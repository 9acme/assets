<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>掘金</title><link>https://juejin.cn/</link><description>代码不止,掘金不停</description><lastBuildDate>Fri, 25 Nov 2022 22:43:29 GMT</lastBuildDate><generator>PyRSS2Gen-1.1.0</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>前端食堂技术周刊第 60 期：TypeScript 4.9、Ant Design 5.0、用 vanilla-extract 编写高性能的 CSS、Node.j</title><link>https://juejin.cn/post/7168433475404922910</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：茉莉乌龙&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly" title="食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript 4.9&lt;/li&gt;
&lt;li&gt;Ant Design 5.0&lt;/li&gt;
&lt;li&gt;用 vanilla-extract 编写高性能的 CSS&lt;/li&gt;
&lt;li&gt;4 个必要的可访问性测试&lt;/li&gt;
&lt;li&gt;Node.js 安全最佳实践&lt;/li&gt;
&lt;li&gt;TypeScript 的类型系统中的汇编解释器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-9/"&gt;TypeScript 4.9&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;自 RC 版本发布以来，TypeScript 4.9 正式版没有作出任何更改。如果之前的每期周刊你都在追更的话，想必对 TypeScript 4.9 的新特性早已经烂熟于心了，satisfies 真香。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://mp.weixin.qq.com/s/qL7UMdHicrk-4b1vYVSIWQ"&gt;Ant Design 5.0&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;设计升级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;增加了 4 类新组件和 4+ 变体组件；&lt;/li&gt;
&lt;li&gt;组件默认样式全面升级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;全新 Design Token 模型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;改造所有 Token，使其基于 Seed + Algorithm 可以派生出所有的 Design Token；&lt;/li&gt;
&lt;li&gt;支持多算法 Pipeline。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;CSS-in-JS 动态主题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为了降低维护成本，选择了 CSS-in-JS 方案，此方案不需要维护中间变量，但是有更多的运行时消耗。但是为了不损害用户体验，研发了针对组件级别的 CSS-in-JS 库 @ant-design/cssinjs，通过牺牲动态性来获取更高的缓存效率，从而减少运行时的性能损耗；&lt;/li&gt;
&lt;li&gt;新的 CSS-in-JS 方案原生支持 Tree Shaking，在 v5 你不在需要使用 babel-plugin-import 摘除未使用到的样式。新的方案将自动按需加载样式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;兼容性调整&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Ant Design v5 兼容性调整从 IE 11 提升至 Edge，其余现代浏览器不变；&lt;/li&gt;
&lt;li&gt;默认 Day.js 代替 Moment.js；&lt;/li&gt;
&lt;li&gt;API 非 Break 调整、组件移除(移除 Comment、PageHeader，BackTop 将会成为 FloatButton 子组件)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于升级指南、未来规划等其他详细内容请移步发布公告阅读。&lt;/p&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://www.lekoarts.de/javascript/writing-performant-css-with-vanilla-extract"&gt;用 vanilla-extract 编写高性能的 CSS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一篇 vanilla-extract 入门指南的长文。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://thinkdobecreate.com/articles/4-required-tests-before-shipping-new-features/"&gt;4 个必要的可访问性测试&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;文章中提出的测试包括颜色对比度、互动元素颜色对比、键盘互动以及焦点的可访问性。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://nodejs.org/en/docs/guides/security/"&gt;Node.js 安全最佳实践&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Node.js 官方团队发布的一篇关于安全最佳实践的博文。&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://judehunter.dev/blog/assembly-interpreter-in-typescripts-type-system"&gt;TypeScript 的类型系统中的汇编解释器&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;继续整活儿，TypeScript 的类型系统是“万能的”。&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://deno.com/blog/v1.28"&gt;Deno 1.28&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nuxt.com/v3"&gt;Nuxt 3.0 stable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zhuanlan.zhihu.com/p/584551696"&gt;dumi 2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nodejs.org/en/blog/release/v19.1.0/"&gt;Node v19.1.0 (Current) &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://mp.weixin.qq.com/s/rl6QrHFnR9CCTKSZiMghVA"&gt;基于 Sentry 高效治理前端异常 &lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://mp.weixin.qq.com/s/ADx8PuNvg4xVVLBeh265kw"&gt;React 中的重新渲染&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 21 Nov 2022 03:43:25 GMT</pubDate></item><item><title>前端食堂技术周刊第 59 期：GitHub Universe 2022、Rome v10、Parcel v2.8.0、可扩展的 CSS 演变</title><link>https://juejin.cn/post/7166108391536869383</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：草莓拿铁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly" title="食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;周刊仓库 923 个 Star 了，有时间的兄弟们帮忙冲一波 1000 Star。&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;GitHub Universe 2022&lt;/li&gt;
&lt;li&gt;Rome v10&lt;/li&gt;
&lt;li&gt;Parcel v2.8.0&lt;/li&gt;
&lt;li&gt;50 个有用的 Vim 命令&lt;/li&gt;
&lt;li&gt;TanStack Router&lt;/li&gt;
&lt;li&gt;如何使用 CSS 创建高级动画&lt;/li&gt;
&lt;li&gt;可扩展的 CSS 演变&lt;/li&gt;
&lt;li&gt;Solid Start Beta&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://github.blog/2022-11-09-everything-new-from-github-universe-2022/"&gt;GitHub Universe 2022&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;看看我们 “程序员的朋友圈” GitHub 今年有哪些大动作：&lt;/p&gt;
&lt;p&gt;(省流版)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub Copilot 企业版、支持语音交互；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/features/codespaces"&gt;GitHub Codespaces：个人开发者每月免费 60 小时&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;全新的代码搜索和代码视图体验；&lt;/li&gt;
&lt;li&gt;GitHub Projects 提供给你更多可视化视图的 Roadmap 以及 &lt;a href="https://docs.github.com/cn/issues/tracking-your-work-with-issues/about-tasklists"&gt;由 Markdown 生成的任务列表对 Issues 进行管理&lt;/a&gt;、GitHub Mobile 新增功能(跑 GitHub Action、编辑文件、PR 等)；&lt;/li&gt;
&lt;li&gt;GitHub 企业版：GitHub Enterprise Cloud 即时体验新功能、&lt;a href="https://github.com/features/actions-importer/signup"&gt;GitHub Actions Importer 帮助你迁移 CI/CD&lt;/a&gt;、更细粒度的访问令牌、&lt;a href="https://github.blog/2022-11-02-github-partners-with-arm-to-revolutionize-internet-of-things-software-development-with-github-actions/"&gt;彻底改变物联网 (IoT) 软件开发&lt;/a&gt;（Arm 开发工具在 GitHub Actions 中原生可用）、&lt;a href="https://github.blog/2022-11-08-github-enterprise-server-3-7-is-now-generally-available/"&gt;GitHub Enterprise Server 3.7&lt;/a&gt; 新增 70 个新特性；&lt;/li&gt;
&lt;li&gt;安全提升：接收来自社区的私有漏洞报告、CodeQL 支持 Ruby、安全概览对企业用户提供更大范围的视图支持；&lt;/li&gt;
&lt;li&gt;投资社区：开源两款可变字体 Mona Sans 和 Hubot Sans、&lt;a href="https://octoverse.github.com/"&gt;Octoverse 10 周年报告&lt;/a&gt;、GitHub Accelerator 将为 20 名维护人员和团队提供津贴和指导，以开展全职开源职业、&lt;a href="https://github.blog/2022-11-09-an-open-source-economy-built-by-developers-for-developers/"&gt;与 M12 合作设立 1000 万美元的开源基金&lt;/a&gt;、GitHub Sponsors 支持批量赞助。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b6ac60410204dfc822cfc1a9ec365b7~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://rome.tools/blog/2022/11/08/rome-10/"&gt;Rome v10&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;此次发布包括 linter 校验器和 formatter 格式化器，它们具有最小化的配置，漂亮的描述性诊断，并内置对 JavaScript 和 TypeScript 的支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;formatter 受 Prettier 启发，允许大多数用户以最小甚至零的改动来进行迁移；&lt;/li&gt;
&lt;li&gt;linter 建立在一个遵循社区标准的推荐规则集上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来的一年里 Rome 团队会进行 compilation 编译、 bundling 打包、 testing 测试等工作。&lt;/p&gt;
&lt;p&gt;Rome 用 Rust 重写后的第一个稳定版本终于等来了，让我们再等等。毕竟我们都知道，罗马不是一天建成的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de5279fb18be4f64855d94e60c08577e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://parceljs.org/blog/v2-8-0/"&gt;Parcel v2.8.0&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;听说最近流行比谁家的 HMR 更快？不好意思，Parcel 赢麻了。&lt;/p&gt;
&lt;p&gt;Parcel v2.8.0 的热更新比 Turbopack 快 68%(根组件)，比 Vite 快 74%(叶组件)。同时此版本带来了全新的打包算法、改进了自动代码拆分、提升了大型项目的构建性能，以及优化 Tree Shaking 使包体积减少 50%。&lt;/p&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://vimtricks.com/p/50-useful-vim-commands/"&gt;50 个有用的 Vim 命令&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;帮你早点下班回家陪老婆的 50 个 Vim 命令。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://tanstack.com/router/v1"&gt;TanStack Router&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;嘿，我是框架无关的路由器 TanStack Router，之前叫 React Location，现在改个名字从 v0.0.1 重新开始，&lt;a href="https://tanstack.com/"&gt;我还有一些兄弟姐妹&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://www.smashingmagazine.com/2022/10/advanced-animations-css/"&gt;如何使用 CSS 创建高级动画&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;来吧，搞清楚三次贝塞尔曲线、二次贝塞尔曲线和堆叠动画，一起玩次过山车。&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://frontendmastery.com/posts/the-evolution-of-scalable-css/"&gt;可扩展的 CSS 演变&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;为什么传统 CSS 在大型项目中难以管理？&lt;/p&gt;
&lt;p&gt;难点有四：全局命名空间，代码互相影响 (新出的 CSS Cascade Layers 申请出战解决）、命名难、重构难、调试难。&lt;/p&gt;
&lt;p&gt;历史破解之法：OOCSS、SMACSS、BEM、ITCSS、Cube CSS。&lt;/p&gt;
&lt;p&gt;今日破解之法：CSS in JS、CSS Modules、原子化 CSS。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e69ff8d097843fca3833d2eb462b55a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;6.&lt;a href="https://www.solidjs.com/blog/introducing-solidstart"&gt;Solid Start Beta&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Solid Start 进入 Beta 阶段，官方公告让我想到了 GALI 的 《70%》，喜欢听黑怕的你一定听过。(开个玩笑)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建基于 &lt;a href="https://vitejs.dev/"&gt;Vite&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;平台无关的 Sessions 借鉴 &lt;a href="https://remix.run/"&gt;Remix&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;嵌套文件路由借鉴 &lt;a href="https://nuxtjs.org/docs/features/file-system-routing/#nested-routes"&gt;NuxtJS&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;FileSystem /&amp;gt;&lt;/code&gt; 组件借鉴 &lt;a href="https://shopify.dev/api/hydrogen/components/framework/fileroutes"&gt;Hydrogen&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;API 路由借鉴 &lt;a href="https://kit.svelte.dev/docs/routing#server"&gt;SvelteKit&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;RouteData 和 RouteActions 借鉴 &lt;a href="https://remix.run/"&gt;Remix&lt;/a&gt; 和 &lt;a href="https://tanstack.com/query/v4/docs/adapters/solid-query"&gt;TanStack Query&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/this-is-learning/client-side-routing-without-the-javascript-3k1i"&gt;新的实验性功能：Partial Hydration 部分水合、hybrid nested routing 混合嵌套路由&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://zhuanlan.zhihu.com/p/581977751"&gt;重新理解 Web&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://blog.maximeheckel.com/posts/the-magical-world-of-particles-with-react-three-fiber-and-shaders/"&gt;用 React Three Fiber 和着色器创造粒子的神奇世界&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 14 Nov 2022 21:22:10 GMT</pubDate></item><item><title>前端食堂技术周刊第 58 期：TypeScript 4.9 RC、10 月登陆浏览器的新功能、Turbopack 真的比 Vite 快 10 倍吗？</title><link>https://juejin.cn/post/7163235734361473055</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：青柑大红袍&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly" title="食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript 4.9 RC&lt;/li&gt;
&lt;li&gt;10 月登陆浏览器的新功能&lt;/li&gt;
&lt;li&gt;Turbopack 真的比 Vite 快 10 倍吗？&lt;/li&gt;
&lt;li&gt;在 VS Code 中使用 Git&lt;/li&gt;
&lt;li&gt;100 天 Modern CSS 挑战&lt;/li&gt;
&lt;li&gt;Node.js 18 的新功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-9-rc/"&gt;TypeScript 4.9 RC&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;自 4.9 Beta 以来的新东西：&lt;/p&gt;
&lt;p&gt;以下内容并没有在 Beta 版本的博文中提及：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-9-rc/#auto-accessors-in-classes"&gt;Class 中的自动访问器 (accessor 关键字)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-9-rc/#performance-improvements"&gt;性能提升&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及与 VS Code 配套的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-9-rc/#sort-remove-import-commands"&gt;移除未使用的导入、导入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-9-rc/#go-to-def-return-keyword"&gt;return 关键字跳转到定义 (Go-to-Definition)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://web.dev/web-platform-10-2022/"&gt;10 月登陆浏览器的新功能&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Firefox 106、Chrome 107 和 Safari 16.1 发布稳定版，Chrome 108、Firefox 107 和 Safari 16.2 发布 Beta 测试版。&lt;/p&gt;
&lt;p&gt;以下是各浏览器稳定版本中新增的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://web.dev/web-platform-10-2022/#animation-of-grid-tracks"&gt;更平滑的 CSS Grid 动画&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.dev/web-platform-10-2022/#additions-to-getdisplaymedia"&gt;getDisplayMedia() 新增功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.dev/web-platform-10-2022/#testing-for-support-of-font-technology-and-features-from-css"&gt;@supports 查询添加 font-tech() 和 font-format()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.dev/web-platform-10-2022/#scroll-to-text-fragment"&gt;滚动到文本片段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.dev/web-platform-10-2022/#avif-support"&gt;支持 AVIF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.dev/web-platform-10-2022/#web-push-for-safari"&gt;支持 Web Push&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.&lt;a href="https://github.com/yyx990803/vite-vs-next-turbo-hmr/discussions/8"&gt;Turbopack 真的比 Vite 快 10 倍吗？&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;6 倍，不要四舍五入。🍉&lt;/p&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://www.gitkraken.com/blog/vs-code-git"&gt;在 VS Code 中使用 Git&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在 VS Code 中使用 Git 的完整指南。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4065095c70a54bedb329db18ddff048e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://www.matuzo.at/blog/2022/100-days-of-more-or-less-modern-css/"&gt;100 天 Modern CSS 挑战&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;某种程度上来说，CSS 的发展要比 JS 快太多了。这篇博客的作者发起了对现代 CSS 的 100 天学习计划，目前已经进行到第 31 天，跟上节奏一起进化～&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://nodesource.com/blog/11-features-nodeJS-18-to-try"&gt;Node.js 18 的新功能&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;内置 Fetch API&lt;/li&gt;
&lt;li&gt;🧪&lt;code&gt;--watch&lt;/code&gt; 支持&lt;/li&gt;
&lt;li&gt;🧪OpenSSL 3 支持&lt;/li&gt;
&lt;li&gt;🧪&lt;code&gt;node:test module&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node:&lt;/code&gt;前缀核心模块&lt;/li&gt;
&lt;li&gt;🧪Web Streams API&lt;/li&gt;
&lt;li&gt;全局 API：Blob、BrodcastChannel&lt;/li&gt;
&lt;li&gt;V8 升级到 10.1&lt;/li&gt;
&lt;li&gt;升级工具链和编译器&lt;/li&gt;
&lt;li&gt;HTTP 超时时间变更&lt;/li&gt;
&lt;li&gt;Undici 官方库&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/evanw/esbuild/releases"&gt;esbuild v0.15.13&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://code.visualstudio.com/updates/v1_73"&gt;VS Code October 2022 (version 1.73)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://answer.dev/"&gt;思否开源的问答社区 Answer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vuetifyjs/vuetify/releases/tag/v3.0.0"&gt;Vuetify v3.0.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/cNr0r3H3mnt9z_D1HLlgKg"&gt;哈啰 Quark Design 正式开源&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://mp.weixin.qq.com/s/cFwqrnpww-kNL7-JRoydBA"&gt;压缩 70% 下载流量 - 记一次店铺优化专项&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://mp.weixin.qq.com/s/VguoRHJJXE90LEunkCY0bQ"&gt;全新的 React 组件设计理念 Headless UI&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 07 Nov 2022 03:33:42 GMT</pubDate></item><item><title>前端食堂技术周刊第 57 期：Turbopack、Next.js13、Chrome107、Vite3.2、图解 TLS 1.3</title><link>https://juejin.cn/post/7160827407203565576</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：荔枝红茶&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly" title="食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Turbopack&lt;/li&gt;
&lt;li&gt;Next.js 13&lt;/li&gt;
&lt;li&gt;Chrome 107&lt;/li&gt;
&lt;li&gt;Vite 3.2&lt;/li&gt;
&lt;li&gt;Babel v7.20.0&lt;/li&gt;
&lt;li&gt;图解 TLS 1.3 连接&lt;/li&gt;
&lt;li&gt;全网最佳暗黑模式鉴赏&lt;/li&gt;
&lt;li&gt;组件画廊&lt;/li&gt;
&lt;li&gt;命令行的艺术&lt;/li&gt;
&lt;li&gt;WebAPI 检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://turbo.build/pack"&gt;Turbopack&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Vercel 发布 Turbopack，目前处于 alpha 阶段。Turbopack 由 Webpack 作者 &lt;a href="https://twitter.com/wSokra"&gt;Tobias Koppers&lt;/a&gt; 亲自操刀，用 Rust 编写，作者的愿景是替代 Webpack 95% 的功能和扩展性。&lt;/p&gt;
&lt;p&gt;其特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;吸取 Webpack 十年来的经验教训，结合 Turborepo 和 Google 的 Bazel 在增量计算方面的创新，创建了一个准备支持未来几十年计算的架构；&lt;/li&gt;
&lt;li&gt;官方声称热更新比 Vite 快 10 倍，比 Webpack 快 700 倍；&lt;/li&gt;
&lt;li&gt;内置增量计算引擎，可以达到单个函数级别的缓存；&lt;/li&gt;
&lt;li&gt;基于请求级别的按需编译；&lt;/li&gt;
&lt;li&gt;生态方面支持 JavaScript、TypeScript、CSS、CSS Modules、插件系统会计划支持 SCSS、LESS、Babel 等，流行的前端框架 Svelte、React、Vue.js  等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尤雨溪近日也亲自对 Vite 和 Turbopack 的热更新性能进行对比，并公开 &lt;a href="https://github.com/yyx990803/vite-vs-next-turbo-hmr"&gt;代码仓库&lt;/a&gt;，得出的结论是热更新性能差不多，远远没有上面声称的 10 倍差距。&lt;/p&gt;
&lt;p&gt;营销归营销，一切还是等 Turbopack 的插件架构造出来再下定论吧，一个好的架构远远比用什么语言更重要，而且还要考虑到对已有生态系统的支持，前方的路还很长。&lt;/p&gt;
&lt;p&gt;Turbopack 中 JavaScript 和 TypeScript 的打包是基于 SWC，随着 Turbopack 的发布，SWC 的作者 kdy1 宣布将他 &lt;a href="https://kdy1.dev/posts/2022/10/open-sourcing-stc"&gt;新的 TypeScript 类型检查器开源，并且最终决定使用 Rust 编写&lt;/a&gt;。这个故事有点长，不清楚故事线的同学可以去链接里读。&lt;/p&gt;
&lt;p&gt;这个新的 TypeScript 类型检查器叫 stc，要不要改个名字，叫 Turbocheck？🤣&lt;/p&gt;
&lt;p&gt;坐等 Turbopack 官方公开下面数据的测试代码。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39d1626e86224ed5a2ecfd80b768b764~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://nextjs.org/blog/next-13"&gt;Next.js 13&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Next.js 13 主要特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;app/ Directory (beta)：改进文件系统路由，包括对布局、服务器组件、流数据和数据获取的支持；&lt;/li&gt;
&lt;li&gt;新的 next/image 组件；&lt;/li&gt;
&lt;li&gt;全新的字体系统 next/font；&lt;/li&gt;
&lt;li&gt;OG 社交卡片图像生成；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;附赠 &lt;a href="https://twitter.com/shadcn/status/1584971527820541953?s=20&amp;amp;t=2fOMSS5-gx94UZd5hNXO2Q"&gt;迁移指南&lt;/a&gt; 和 &lt;a href="https://nextjs.org/conf"&gt;Next.js Conf 回放&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://developer.chrome.com/en/blog/new-in-chrome-107/"&gt;Chrome 107&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chrome 107 主要特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加 Screen Capture API 属性，改善屏幕共享体验；&lt;/li&gt;
&lt;li&gt;Performance API 增加 renderBlockingStatus 属性，可以精确识别页面上的资源是否有渲染阻塞；&lt;/li&gt;
&lt;li&gt;声明式 PendingBeacon API 向后端服务器发送数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4.&lt;a href="https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md"&gt;Vite 3.2&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Vite 3.2 发布，主要特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Library 模式下支持多个打包入口；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cn.vitejs.dev/config/build-options.html#build-modulepreload"&gt;build.modulePreload 构建选项&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;坐等 Vite 4，&lt;a href="https://github.com/vitejs/vite/discussions/10570"&gt;Vite 4 RoadMap&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://babeljs.io/blog/2022/10/27/7.20.0.html"&gt;Babel v7.20.0&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持 TypeScript 4.9；&lt;/li&gt;
&lt;li&gt;支持 Stage 2 阶段的 &lt;a href="https://github.com/tc39/proposal-import-reflection/"&gt;Import Reflection&lt;/a&gt;、&lt;a href="https://github.com/tc39/proposal-explicit-resource-management/"&gt;Explicit Resource Management&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;支持编译给 Deno 使用；&lt;/li&gt;
&lt;li&gt;发布 Babel-loader 9.0，放弃对 webpack &amp;lt; 5 、Babel &amp;lt; 7.12 、Node.js &amp;lt; 14.15 LTS 的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://tls13.xargs.org/"&gt;图解 TLS 1.3 连接&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如题。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a48e479be836406ab8de51e11fcc1834~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://darkmodes.com/"&gt;全网最佳暗黑模式鉴赏&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个站点收集了全网支持 Dark Mode 的漂亮网站。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/902cf346e071408080ae79db47c77f90~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://component.gallery/"&gt;组件画廊&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;组件画廊收集了很多设计系统，并提供了搜索功能，当你输入一个组件名称，它会帮你找到拥有这个组件的组件库和设计系统。&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md"&gt;命令行的艺术&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;无论你是新手还是老手，这个仓库都能帮助你提升使用命令行的效率。&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://webapicheck.com/"&gt;WebAPI 检查&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个项目可以帮助你检查你的设备上有哪些 WebAPI 可用，在你想检查的设备上打开这个页面即可，项目目前正在施工中。&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://nodejs.org/en/blog/release/v18.12.0/"&gt;Node v18.12.0 (LTS)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://eslint.org/blog/2022/10/eslint-v8.26.0-released/"&gt;ESLint v8.26.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://storybook.js.org/blog/new-website-for-storybook/"&gt;Storybook 的新网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/hua1995116/awesome-ai-painting"&gt;AI 绘画资料合集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docusaurus.io/blog/releases/2.2"&gt;Docusaurus 2.2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://vercel.com/blog/building-an-interactive-webgl-experience-in-next-js"&gt;在 Next.js 中构建一个交互式的 WebGL 体验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://zhuanlan.zhihu.com/p/541082191"&gt;8K HDR!｜为 Chromium 实现 HEVC 硬解 - 原理/实测指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 31 Oct 2022 15:49:01 GMT</pubDate></item><item><title>前端食堂技术周刊第 56 期：Solid v1.6.0、2022 State of GraphQL、ViteConf 回放、Lerna v6、SEO 入门指南</title><link>https://juejin.cn/post/7157942637201195038</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：青柑大红袍&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly" title="食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Solid v1.6.0&lt;/li&gt;
&lt;li&gt;首届 2022 State of GraphQL&lt;/li&gt;
&lt;li&gt;ViteConf 回放&lt;/li&gt;
&lt;li&gt;Lerna v6&lt;/li&gt;
&lt;li&gt;SEO 入门指南&lt;/li&gt;
&lt;li&gt;创建自己的 JavaScript 运行时&lt;/li&gt;
&lt;li&gt;为什么和 CSS-in-JS 说拜拜&lt;/li&gt;
&lt;li&gt;Chromium 渲染流水线——字节码到像素的一生&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://github.com/solidjs/solid/releases/tag/v1.6.0"&gt;Solid v1.6.0&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Solid 发布 v1.6.0，代号 “Castle in the Sky” 天空之城。这个代号让我想起了初中暑假学吉他时弹过的曲子。&lt;/p&gt;
&lt;p&gt;Solid 团队在过去的几个月里一直专注于他们的元框架 &lt;a href="https://start.solidjs.com/getting-started/what-is-solidstart"&gt;SolidStart&lt;/a&gt; 的研发，在 islands、 partial hydration、hybrid routing 等方面进行了大量探索，并将这些功能与 Solid 的核心部分进一步整合，以更好的打造出他们心目中的“天空之城”。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://2022.stateofgraphql.com/en-US/"&gt;首届 2022 State of GraphQL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://2022.stateofgraphql.com/en-US/conclusion/"&gt;调查结果总结&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://viteconf.org/2022/replay/ecosystem"&gt;ViteConf 回放&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ViteConf 官方回放终于来了，这届 ViteConf 光看嘉宾阵容就足以称之为 2022 年度前端联欢晚会，共计 12h 的回放，慢慢看吧。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e96ac4bdabf7451bb13250f3c8633c90~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;同时，&lt;a href="https://github.com/stackblitz/viteconf"&gt;ViteConf 的官网&lt;/a&gt; 也开源了。&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://blog.nrwl.io/lerna-reborn-whats-new-in-v6-10aec6e9091c"&gt;Lerna v6&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Lerna 被 Nrwl(Nx 背后的公司) 接管后，推出了全新的&lt;a href="https://lerna.js.org/"&gt;官网&lt;/a&gt;，并 &lt;a href="https://dev.to/nx/lerna-used-to-walk-now-it-can-fly-3661"&gt;提速了 10 倍&lt;/a&gt;，最近发布的 v6 版本又带来了一系列新特性，越来越像一个正经的 Monorepo 工具了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认缓存&lt;/li&gt;
&lt;li&gt;远程缓存、分布式任务执行&lt;/li&gt;
&lt;li&gt;任务编排&lt;/li&gt;
&lt;li&gt;pnpm 支持&lt;/li&gt;
&lt;li&gt;动态终端输出&lt;/li&gt;
&lt;li&gt;VS Code 插件&lt;/li&gt;
&lt;li&gt;lerna repair 自动修复&lt;/li&gt;
&lt;li&gt;lerna version 更新文件自动 Prettier 格式化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df3a80a0eca6496784557daad873f0fe~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://ahrefs.com/zh/seo"&gt;SEO 入门指南&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一份很全面的 SEO 入门指南，共计 7 个章节，同时还提供了大量的扩展资料。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://github.com/ErickWendel/myownnode"&gt;创建自己的 JavaScript 运行时&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使用 V8、Libuv 等创建你自己的 JavaScript 运行时，&lt;a href="https://www.youtube.com/watch?v=ynNDmp7hBdo"&gt;配套视频&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://dev.to/srmagura/why-were-breaking-up-wiht-css-in-js-4g9b"&gt;为什么和 CSS-in-JS 说拜拜&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文的作者 Sam 是 Emotion 的第 2 大贡献者，深入探讨了关于 CSS-in-JS 最初吸引他们团队的原因，以及为什么决定放弃它。&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://zhuanlan.zhihu.com/p/574069391"&gt;Chromium 渲染流水线——字节码到像素的一生&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;长文预警，对应关键事件的源码都给你找好了，非常详细。&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/gatsbyjs/gatsby/discussions/36609"&gt;Gatsby 5 Umbrella Discussion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/oven-sh/bun/releases/tag/bun-v0.2.1"&gt;Bun v0.2.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nodejs.org/en/blog/release/v19.0.0/"&gt;Node v19.0.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://rollupjs.org/guide/en/#migration"&gt;Migrating to Rollup 3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://www.zhangxinxu.com/wordpress/2022/10/2022-new-form-property/"&gt;2022 年新出了哪些 form 表单新特性？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://2ality.com/2022/10/javascript-decorators.html"&gt;用 2022-03 decorators API 进行 JavaScript 元编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Sun, 23 Oct 2022 21:14:33 GMT</pubDate></item><item><title>前端食堂技术周刊第 55 期：Rollup v3.0.0、Volar 1.0 Nika、TypeScript 十年、2022 Web 网络年鉴</title><link>https://juejin.cn/post/7155435611619328036</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：桂花秋梨&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Rollup v3.0.0&lt;/li&gt;
&lt;li&gt;Volar 1.0 Nika&lt;/li&gt;
&lt;li&gt;TypeScript 十年，不忘初心&lt;/li&gt;
&lt;li&gt;2022 Web 网络年鉴&lt;/li&gt;
&lt;li&gt;Resumable vs. Hydration&lt;/li&gt;
&lt;li&gt;JavaScript 框架的新浪潮&lt;/li&gt;
&lt;li&gt;用 Sandpack 打造世界级 Playground&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://github.com/rollup/rollup/releases/tag/v3.0.0"&gt;Rollup v3.0.0&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Rollup 发布 v3.0.0，带来了大量更新。其中 Breaking Change 包括最低支持 Node 14.18.0、浏览器构建拆成单独的包 @rollup/browse、Node 构建使用 &lt;code&gt;node:&lt;/code&gt; 前缀导入内置模块、移除一些以前被废弃的功能，使用时提示警告等。还有包括 Options 配置、插件 API、以及一系列的新特性。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://blog.vuejs.org/posts/volar-1.0.html"&gt;Volar 1.0 Nika&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Volar 发布 1.0，代号 Nika，此次更新主要改进了 UX/DX、性能、包体积、Plugin API v1，将核心代码重构使其与框架无关。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://devblogs.microsoft.com/typescript/ten-years-of-typescript/"&gt;TypeScript 十年，不忘初心&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;祝 TypeScript 10 周年生日快乐 🎂。&lt;/p&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://almanac.httparchive.org/en/2022/"&gt;2022 Web 网络年鉴&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2022 Web 网络年鉴，共计 23 个小章节，包含页面内容、用户体验、内容发布和内容分发等方面，从这些调研数据中可以窥探出各个技术的真实现状。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0b215758bb14610805de8ab1f28692c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://qwik.builder.io/docs/concepts/resumable/"&gt;Resumable vs. Hydration&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文介绍了 Qwik 框架可恢复性的实现原理以及与常规补水相比具有的优势。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://frontendmastery.com/posts/the-new-wave-of-javascript-web-frameworks/"&gt;JavaScript 框架的新浪潮&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;新浪潮这个词今年特别流行，又是一篇“新浪潮”的好文，本文把从古至今各个时代 JavaScript 的典型框架和遇到的痛点问题进行梳理，从而还原出一篇极简的 JavaScript 框架演进史。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc467ce0117f40829e3e4a55f9256e3b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://www.joshwcomeau.com/react/next-level-playground/"&gt;用 Sandpack 打造世界级 Playground&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;CodeSandbox 开源了 Sandpack，本文教你使用 Sandpack 打造出一个功能齐全的 Playground。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85005a156a694f71a132cf67eff0ec3a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/oven-sh/bun/releases/tag/bun-v0.2.0"&gt;Bun v0.2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://storybook.js.org/blog/first-class-vite-support-in-storybook/"&gt;Storybook 7.0 中 Vite 成为内置选项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://astro.build/blog/astro-150/"&gt;Astro 1.5.0 Release&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deno.com/blog/v1.26"&gt;Deno 1.26 Release&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zhuanlan.zhihu.com/p/569763868"&gt;Ant Design 5.0 Alpha&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/lerna/lerna/releases/tag/v6.0.0"&gt;Lerna v6.0.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vitejs/vite/blob/v3.1.8/packages/vite/CHANGELOG.md"&gt;Vite 3.1.8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://mp.weixin.qq.com/s/kibQedZ09TCU2nxJG_v4pQ"&gt;（可能是）最硬核的色彩系统总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://supercodepower.com/fontend-target"&gt;前端版本兼容问题的探索&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 17 Oct 2022 03:05:48 GMT</pubDate></item><item><title>前端食堂技术周刊第 54 期：TS 4.9 Beta、Monorepo Handbook、第 92 次 TC39 会议、将 StoryBook Stories</title><link>https://juejin.cn/post/7147660762519961631</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：芒芒生打椰&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript 4.9 Beta&lt;/li&gt;
&lt;li&gt;Monorepo Handbook 新鲜出炉&lt;/li&gt;
&lt;li&gt;第 92 次 TC39 会议&lt;/li&gt;
&lt;li&gt;将 StoryBook Stories 转换为 Figma 组件&lt;/li&gt;
&lt;li&gt;Playwright 组件测试入门&lt;/li&gt;
&lt;li&gt;垃圾代码书写准则&lt;/li&gt;
&lt;li&gt;React 我爱你，但是你让我失望了&lt;/li&gt;
&lt;li&gt;希望能早点知道的 Chrome Devtools 调试技巧&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-9-beta/"&gt;TypeScript 4.9 Beta&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;TypeScript 4.9 Beta 带着新的 satisfies 操作符来了，主要特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新的 satisfies 操作符；&lt;/li&gt;
&lt;li&gt;增强 in 操作符；&lt;/li&gt;
&lt;li&gt;更严格的 NaN 检查；&lt;/li&gt;
&lt;li&gt;优化 File-Watching，使用文件系统事件，减少轮询；&lt;/li&gt;
&lt;li&gt;为 Promise.resolve 提供更好的类型；&lt;/li&gt;
&lt;li&gt;保留 JS 文件中的导入；&lt;/li&gt;
&lt;li&gt;修正 Exports 和 typeVersions 的优先级；&lt;/li&gt;
&lt;li&gt;优化 Substitution 类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://turborepo.org/docs/handbook/what-is-a-monorepo"&gt;Monorepo Handbook 新鲜出炉&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;TurboRepo 团队近日发布了 Monorepo 手册，包含关于 Monorepo 你需要知道的一切，并提供了详尽的配置示例，内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是 Monorepo？&lt;/li&gt;
&lt;li&gt;安装包 (npm、pnpm、Yarn 1、Yarn &amp;gt;=2)&lt;/li&gt;
&lt;li&gt;Workspaces 工作区&lt;/li&gt;
&lt;li&gt;迁移到 Monorepo&lt;/li&gt;
&lt;li&gt;任务编排&lt;/li&gt;
&lt;li&gt;构建&lt;/li&gt;
&lt;li&gt;Docker 部署&lt;/li&gt;
&lt;li&gt;共享代码&lt;/li&gt;
&lt;li&gt;Lint&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;发布 (Changesets)&lt;/li&gt;
&lt;li&gt;@manypkg/cli 处理包版本依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4cdb1abbba547cd9767a064a0b5ef01~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://dev.to/hemanth/updates-from-the-92nd-tc39-meeting-5fi6"&gt;第 92 次 TC39 会议&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;此次会议进展如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stage3：&lt;a href="https://github.com/tc39/proposal-array-from-async"&gt;Array.fromAsync&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Stage2：&lt;a href="https://github.com/tc39/proposal-is-usv-string"&gt;Well-Formed Unicode Strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;State1：&lt;a href="https://github.com/tc39/proposal-extractors"&gt;Extractors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://divriots.com/blog/story-to-design-is-open/"&gt;将 StoryBook Stories 转换为 Figma 组件&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;‹div›RIOTS&lt;/code&gt; 团队开发的 &lt;code&gt;story.to.design&lt;/code&gt; Figma 插件可以将 StoryBook 的 Strories 转换为 Figma 中的组件。他们同时发布了博文 &lt;a href="https://story.to.design/blog/reasons-every-design-team-needs-story-to-design"&gt;每个设计团队都需要 story.to.design 的 5 个理由&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少代码和设计之间的差异；&lt;/li&gt;
&lt;li&gt;在设计中使用与生产中完全一样的组件；&lt;/li&gt;
&lt;li&gt;设计和原型制作提速；&lt;/li&gt;
&lt;li&gt;跨工具的设计系统更新起来更加便捷；&lt;/li&gt;
&lt;li&gt;与开发人员说同样的（组件）语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc5b7ebb8993427eacea7bef41dcadaa~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://blog.logrocket.com/getting-started-playwright-component-testing/"&gt;Playwright 组件测试入门&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Playwright 现在实验性支持组件测试，本文提供了有关 React、Vue、Svelte 框架组件测试的示例。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://github.com/trekhleb/state-of-the-art-shitcode"&gt;垃圾代码书写准则&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;请把这个仓库转发给写出令你头疼代码的同事，并告诉他：&lt;code&gt;你写的每一行代码都是你的名片。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果他看懂了，他会真诚的谢谢你，并请你吃个饭。&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://marmelab.com/blog/2022/09/20/react-i-love-you.html"&gt;React 我爱你，但是你让我失望了&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Marmelab 的 CEO François Zaninotto 发布了这篇长文，提出了 React 框架现存的一些痛点问题，并坦言 React 社区和生态系统的质量盖过了 React 本身。&lt;/p&gt;
&lt;p&gt;React 团队成员 &lt;a href="https://twitter.com/dan_abramov/status/1572592813363306496"&gt;Dan 随后做出了回应&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb074afbfd0e4100be478022971b9b8a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://javascript.plainenglish.io/11-cool-chrome-devtools-tips-and-tricks-i-wish-i-knew-already-a9e2e078f78"&gt;希望能早点知道的 Chrome Devtools 调试技巧&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加条件断点；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;$i('name')&lt;/code&gt; 在控制台安装 npm 包；&lt;/li&gt;
&lt;li&gt;重新发送 XHR 请求；&lt;/li&gt;
&lt;li&gt;快速切换主题颜色；&lt;/li&gt;
&lt;li&gt;在控制台中快速发送请求；&lt;/li&gt;
&lt;li&gt;复制 JavaScript 变量；&lt;/li&gt;
&lt;li&gt;在控制台中获取选定的 DOM 元素；&lt;/li&gt;
&lt;li&gt;捕获全尺寸的屏幕截图；&lt;/li&gt;
&lt;li&gt;展开所有子节点；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;$&lt;/code&gt; 来获取上一次执行的结果；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;$&lt;/code&gt; 和 &lt;code&gt;$$&lt;/code&gt; 来快速选择 DOM 元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/denoland/deno/releases/tag/v1.25.4"&gt;Deno v1.25.4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html"&gt;Rust 1.64.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.mozilla.org/en-US/firefox/105.0/releasenotes/"&gt;Firefox 105.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.chrome.com/en/blog/new-in-devtools-107/"&gt;What's New In DevTools (Chrome 107)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/parcel-bundler/lightningcss"&gt;Lightning CSS v1.16.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://mp.weixin.qq.com/s/Xur4s28bmqGsxV7f4d2GZQ"&gt;Remesh 介绍：用以开发大型复杂 Web App 的 DDD 框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://mp.weixin.qq.com/s/KKU_V5nRHuMeFjBXwbDReQ"&gt;从 0 到 1000 万：哔哩哔哩直播架构演进史&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 26 Sep 2022 04:16:18 GMT</pubDate></item><item><title>前端食堂技术周刊第 53 期：React Router 6.4、VS Code August 2022、2022 Google 谷歌开发者大会、Meta 开源</title><link>https://juejin.cn/post/7145061375994724389</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：劲浓芝士薯片&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;React Router 6.4&lt;/li&gt;
&lt;li&gt;VS Code August 2022&lt;/li&gt;
&lt;li&gt;2022 Google 谷歌开发者大会&lt;/li&gt;
&lt;li&gt;Meta 开源 MemLab&lt;/li&gt;
&lt;li&gt;WAI-ARIA 指南&lt;/li&gt;
&lt;li&gt;《Vue.js 技术内幕》&lt;/li&gt;
&lt;li&gt;Remix 基础知识&lt;/li&gt;
&lt;li&gt;创建现代 npm 包的最佳实践&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://remix.run/blog/react-router-v6.4"&gt;React Router 6.4&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;随着 React Router 6.4 正式发布，React Router 也加入到了远程状态管理的阵营，开发团队将 Remix 中的功能带入到 React Router 中。&lt;/p&gt;
&lt;p&gt;特性总览可以移步 &lt;a href="https://beta.reactrouter.com/en/main/start/overview"&gt;What's New in 6.4?&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://code.visualstudio.com/updates/v1_71"&gt;VS Code August 2022&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;VS Code 近期发布 2022 年 8 月的版本，下面摘出来一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合并编辑器优化(改为手动打开，可以和旧版合并编辑器同时使用、实验性开启优化的 diff 算法)&lt;/li&gt;
&lt;li&gt;FFmpeg 编解码器支持(支持更多格式)&lt;/li&gt;
&lt;li&gt;资源管理器重命名选择改进(F2 快捷键选择文件名、扩展名和全部)&lt;/li&gt;
&lt;li&gt;全部按钮添加圆角 (看来谁也逃不过圆角。。)&lt;/li&gt;
&lt;li&gt;粘性滚动正式发布&lt;/li&gt;
&lt;li&gt;终端优化(平滑滚动、优化渲染)&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.&lt;a href="https://mp.weixin.qq.com/s/K5V91yZojijWiR801fNkRg"&gt;2022 Google 谷歌开发者大会&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;错过直播的同学可以在这里看亮点回顾啦～&lt;/p&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://engineering.fb.com/2022/09/12/open-source/memlab/"&gt;Meta 开源 MemLab&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;MemLab 是一个自动检测内存泄漏的 JavaScript 内存测试工具。工作原理是通过在预定义的测试场景中运行无头浏览器并对 JavaScript 堆快照进行差异分析来发现内存泄漏。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://www.smashingmagazine.com/2022/09/wai-aria-guide/"&gt;WAI-ARIA 指南&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一篇关于无障碍综合指南的博文，总结了一些常见的错误场景，教你用正确的姿势使用它。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://book.douban.com/subject/36092368/"&gt;《Vue.js技术内幕》&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;黄轶老师的新书，厚实的 474 页，昨天刚收到还没读，先领读个目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：Vue.js 的整体设计&lt;/li&gt;
&lt;li&gt;第二部分：组件&lt;/li&gt;
&lt;li&gt;第三部分：响应式原理&lt;/li&gt;
&lt;li&gt;第四部分：编译和优化&lt;/li&gt;
&lt;li&gt;第五部分：实用特性&lt;/li&gt;
&lt;li&gt;第六部分：内置组件&lt;/li&gt;
&lt;li&gt;第七部分：官方生态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a46ee85ae184e018bda09436bda709b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://css-tricks.com/the-basics-of-remix/"&gt;Remix 基础知识&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一篇关于 Remix 基础知识的入门博客。&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://snyk.io/blog/best-practices-create-modern-npm-package/"&gt;创建现代 npm 包的最佳实践&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Snyk 团队的一篇博文，包括如下方面：初始化项目、创建 npm 账户、发布 npm 包、支持 TypeScript、CJS 和 ESM 的打包配置、单元测试及 Pipeline 配置、本地调试、使用 GitHub Actions 和 Snyk 进行安全检查、自动化版本管理和发布，使用 Snyk 进行持续安全监控。&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/preactjs/preact/releases/tag/10.11.0"&gt;Preact v10.11.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/npm/cli/releases/tag/v9.0.0-pre.0"&gt;npm v9.0.0-pre.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://webkit.org/blog/13152/webkit-features-in-safari-16-0/"&gt;WebKit Features in Safari 16.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.iviewui.com/resource"&gt;View Design 设计资源免费上线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/oven-sh/bun/releases"&gt;Bun v0.1.12&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://www.smashingmagazine.com/2022/09/javascript-api-guide/"&gt;你不知道的 JavaScript API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://olivernguyen.io/s/js2022/"&gt;2022 年最新的 JavaScript 功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 19 Sep 2022 04:07:43 GMT</pubDate></item><item><title>前端食堂技术周刊第 52 期：Babel 7.19.0、Fresh 1.1、React Native 0.70、新的 Web 性能指标 INP</title><link>https://juejin.cn/post/7143094170108821540</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：西瓜挖球冰&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Babel 7.19.0&lt;/li&gt;
&lt;li&gt;Fresh 1.1&lt;/li&gt;
&lt;li&gt;React Native 0.70&lt;/li&gt;
&lt;li&gt;Node.js 工作原理解析&lt;/li&gt;
&lt;li&gt;JSON Crack&lt;/li&gt;
&lt;li&gt;新的 Web 性能指标 INP&lt;/li&gt;
&lt;li&gt;React 为什么重新渲染&lt;/li&gt;
&lt;li&gt;JavaScript 历史的时间轴&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://babeljs.io/blog/2022/09/05/7.19.0"&gt;Babel 7.19.0&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;该版本包括对如下内容的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/tc39/proposal-decorators"&gt;decorators proposal&lt;/a&gt;  5 年了，终于要定下来了，不过功能砍了很多；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tc39/proposal-duplicate-named-capturing-groups"&gt;Duplicate named capturing groups&lt;/a&gt; 正则支持重复命名捕获。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://deno.com/blog/fresh-1.1"&gt;Fresh 1.1&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Fresh 1.1 近期发布，更新了好多特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认支持 JSX；&lt;/li&gt;
&lt;li&gt;支持插件，提供官方 twind 插件；&lt;/li&gt;
&lt;li&gt;支持 &lt;a href="https://preactjs.com/blog/introducing-signals/"&gt;Preact Signals&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;支持 Preact DevTools；&lt;/li&gt;
&lt;li&gt;ctx.renderNotFound() 渲染 404 页面；&lt;/li&gt;
&lt;li&gt;支持多个中间件；&lt;/li&gt;
&lt;li&gt;实验性支持 Deno.serve；&lt;/li&gt;
&lt;li&gt;Showcase 展示区和 Made with Fresh 徽章。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.&lt;a href="https://reactnative.dev/blog/2022/09/05/version-070"&gt;React Native 0.70&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React Native 0.70 主要更新如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文档更新“新的架构“部分；&lt;/li&gt;
&lt;li&gt;使用 Hermes 作为默认引擎；&lt;/li&gt;
&lt;li&gt;统一配置 iOS 和 Android 的 Codegen Config；&lt;/li&gt;
&lt;li&gt;在新架构下 Android 支持库的 Auto-linking ；&lt;/li&gt;
&lt;li&gt;Android 构建时支持 CMake；&lt;/li&gt;
&lt;li&gt;等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://2ality.com/2022/09/nodejs-overview.html#the-node.js-platform"&gt;Node.js 工作原理解析&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Axel Rauschmayer 博士的这篇博文概述了 Node.js 的工作原理，包含如下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;架构；&lt;/li&gt;
&lt;li&gt;API；&lt;/li&gt;
&lt;li&gt;全局变量和内置模块的亮点；&lt;/li&gt;
&lt;li&gt;事件循环；&lt;/li&gt;
&lt;li&gt;并发方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;年底前，他将发布新书&lt;a href="https://buttondown.email/rauschma"&gt;《Shell scripting with Node.js》&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://jsoncrack.com/"&gt;JSON Crack&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JSON 可视化工具。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b354acaca295439e984cee415704787a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://web.dev/inp/"&gt;新的 Web 性能指标 INP&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;INP 通过测量用户与页面的所有交互事件的延迟，来得出代表页面整体响应能力的实验性指标。INP 测量的范围包括鼠标/触摸屏点击事件、键盘事件，不包括悬停和滚动事件。当用户离开页面时计算，结果是一个单一的值，越低越好。&lt;/p&gt;
&lt;p&gt;与 FID 的区别：INP 综合考虑了页面的所有交互，得出更全面的指标，而 FID 只是首次。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92e523ee11a84ce1b87d83bfee7b64c6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://blog.skk.moe/post/react-re-renders-101/"&gt;React 为什么重新渲染&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;你认为 React 组件更新有几个原因？&lt;/p&gt;
&lt;p&gt;是因为它的 prop 发生了改变吗？还是 Context.Provider 的 value 发生了更新？当一个状态发生改变时，整棵 React 树都会更新吗？&lt;/p&gt;
&lt;p&gt;上面的问题如果你不能保证你能完全回答正确，那就去这篇博文一探究竟吧～&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ba82534668e4ad4886cbe3f64427a00~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://blog.risingstack.com/history-of-javascript-on-a-timeline/"&gt;JavaScript 历史的时间轴&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个站点整理了 JavaScript 历史上的关键事件节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1994-1998: 网景时代；&lt;/li&gt;
&lt;li&gt;1999-2007: IE 大战 Firefox；&lt;/li&gt;
&lt;li&gt;2008-2012: 网景终结，Chrome 诞生；&lt;/li&gt;
&lt;li&gt;2013-2014: 从 ASM.js 到 WebAssembly；&lt;/li&gt;
&lt;li&gt;2015-2020: Node.js 崛起；&lt;/li&gt;
&lt;li&gt;2020-2022年：Deno 诞生，IE 退休。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b8ce032ceb42c79820a87bff8db529~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/nuxt-modules/icon"&gt;Nuxt Icon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nextjs.org/blog/next-12-3"&gt;Next.js 12.3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/TypeScript/issues/50457"&gt;TypeScript 4.9 Iteration Plan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://w3cplus.medium.com/%E5%88%9B%E6%84%8F%E6%80%A7%E7%9A%84css%E5%B8%83%E5%B1%80%E5%92%8C%E7%81%B5%E6%B4%BBweb-eb7e83e99575"&gt;创意性的 CSS 布局和灵活 Web&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://meticulous.ai/blog/react-error-boundaries-complete-guide/"&gt;React Error Boundary 指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Tue, 13 Sep 2022 20:54:16 GMT</pubDate></item><item><title>前端食堂技术周刊第 51 期：pnpm v7.10.0、8 月登陆网络平台的新内容、重新思考流行的 Node.js 模式和工具、打包 JavaScript 库的</title><link>https://juejin.cn/post/7140216695834017822</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：青提好椰拿铁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;pnpm v7.10.0&lt;/li&gt;
&lt;li&gt;8 月登陆网络平台的新内容&lt;/li&gt;
&lt;li&gt;重新思考流行的 Node.js 模式和工具&lt;/li&gt;
&lt;li&gt;打包 JavaScript 库的现代化指南&lt;/li&gt;
&lt;li&gt;Chrome DevTools 中的现代 Web 调试&lt;/li&gt;
&lt;li&gt;当 React Query 遇见 React Router&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://github.com/pnpm/pnpm/releases/tag/v7.10.0"&gt;pnpm v7.10.0&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;Time-based 依赖解析模式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;直接依赖将安装其最低版本，比如 foo@^1.1.0，将会安装 1.1.0。&lt;/li&gt;
&lt;li&gt;间接依赖只会安装被选中的直接依赖在其发布时间点之前的版本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;据作者说，这种模式是为了减少供应链攻击导致项目“噶”的风险，因为它能保证间接依赖不会比直接依赖更加新。这样如果间接依赖被攻击，也不会安装被攻击的版本。不过这种解析模式需要拿到 npm 的完整元数据，所以速度会很慢。解法是自建 Verdaccio，并将 registry-supports-time-field 设置为 true。&lt;/p&gt;
&lt;p&gt;能减少供应链攻击的风险是好事，但是感觉这种模式本身存在很多问题，比如不遵守 semver 语义，虽然社区里很多项目都没有好好遵守 :)、或者当旧的间接依赖修复了某个 bug，但是有 bug 的版本还是会被安装。&lt;/p&gt;
&lt;p&gt;啊，我要这铁棒(功能)有何用？&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://web.dev/web-platform-08-2022/"&gt;8 月登陆网络平台的新内容&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/104"&gt;Firefox 104&lt;/a&gt;、&lt;a href="https://developer.chrome.com/blog/new-in-chrome-104/"&gt;Chrome 104&lt;/a&gt;、&lt;a href="https://developer.chrome.com/blog/new-in-chrome-105/"&gt;Chrome 105&lt;/a&gt; 发布稳定版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Chrome 104 新增 &lt;a href="https://web.dev/css-individual-transform-properties/"&gt;CSS transform 属性单独定义&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;Chrome 104 新增 &lt;a href="https://developer.chrome.com/blog/media-query-range-syntax/"&gt;媒体查询的新语法&lt;/a&gt;，支持比较运算符，更加符合人体工程学；&lt;/li&gt;
&lt;li&gt;Chrome 105 新增 &lt;a href="https://developer.chrome.com/blog/has-with-cq-m105/"&gt;容器查询和 :has()&lt;/a&gt;，响应式的最佳拍档；&lt;/li&gt;
&lt;li&gt;Chrome 105 新增 &lt;a href="https://developer.chrome.com/blog/new-in-chrome-105/#sanitizer-api"&gt;Sanitizer API&lt;/a&gt;，防止 XSS 攻击的灭菌武器；&lt;/li&gt;
&lt;li&gt;Chrome 105 新增 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:modal"&gt;:modal 伪类&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;Firefox 104 支持 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:modal"&gt;The findLast() 和 findLastIndex() &lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://practica.dev/blog/popular-nodejs-pattern-and-tools-to-reconsider/"&gt;重新思考流行的 Node.js 模式和工具&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;你习以为常的工具不一定是最佳选择。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/goldbergyoni/nodebestpractices"&gt;Node.js 最佳实践&lt;/a&gt;、&lt;a href="https://github.com/goldbergyoni/javascript-testing-best-practices"&gt;JavaScript 和 Node.js 测试最佳实践&lt;/a&gt; 的作者 Yoni Goldberg 对 Node.js 中的流行工具发出了灵魂拷问，并给出了他的思考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/mozilla/node-convict"&gt;Node-convict&lt;/a&gt; 比 &lt;a href="https://github.com/motdotla/dotenv"&gt;Dotenv&lt;/a&gt; 更好；&lt;/li&gt;
&lt;li&gt;从 Controller 调用 Service 时，要尽量抽象 Service 的内容(多用心封装封装)，尽可能屏蔽掉技术细节和复杂性，让看你代码的同学赏心悦目一些；&lt;/li&gt;
&lt;li&gt;Nest.js 中万物皆可依赖注入，但简单点也许世界会更美好；&lt;/li&gt;
&lt;li&gt;不一定要用 &lt;a href="https://github.com/jaredhanson/passport"&gt;Passport.js&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.npmjs.com/package/supertest"&gt;SuperTest&lt;/a&gt; 的三合一语法有时候并没有那么好用；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/fastify/fastify"&gt;Fastify&lt;/a&gt; 装饰器错误姿势&lt;/li&gt;
&lt;li&gt;catch 子句的正确姿势；&lt;/li&gt;
&lt;li&gt;避免重复使用日志工具 &lt;a href="https://www.npmjs.com/package/morgan"&gt;Morgan&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;减少使用 process.env.NODE_ENV 当作判断条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://github.com/frehner/modern-guide-to-packaging-js-library/blob/main/README-zh_CN.md"&gt;打包 JavaScript 库的现代化指南&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个仓库记录了一些通用的现代化 JavaScript 打包指南，该指南不局限于某一个特定的打包工具，而且包含很多扩展资料，适合入门学习。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://developer.chrome.com/blog/devtools-modern-web-debugging/"&gt;Chrome DevTools 中的现代 Web 调试&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chrome DevTools 团队与 Angular 团队合作，对 Chrome DevTools 中的调试体验进行了改进。&lt;/p&gt;
&lt;p&gt;真正做到给开发者看他们最想看的东西，调试体验终于要起飞了？&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://tkdodo.eu/blog/react-query-meets-react-router"&gt;当 React Query 遇见 React Router&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://beta.reactrouter.com/en/dev"&gt;React Router 6.4&lt;/a&gt; 即将正式发布，React Router 也加入了远程状态管理的数据获取游戏。本文将带你了解 React Router 和现有的远程状态管理库(如：React Query)之间的竞争和关联，作者认为他们是天造地设的一对。&lt;/p&gt;
&lt;p&gt;隔壁家 Vue Router 的数据获取相关提案 &lt;a href="https://github.com/vuejs/rfcs/discussions/460"&gt;Vue Router Data Loaders&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://nextjs.org/conf"&gt;Next.js Conf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#310-beta2-2022-09-02"&gt;Vite v3.1.0-beta.2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://heroicons.com/"&gt;Heroicons v2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vitest-dev/vitest/releases/tag/v0.23.0"&gt;Vitest v0.23.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ant-design/ant-design/releases/tag/4.23.0"&gt;Ant Design v4.23.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://webkit.org/blog/13140/webkit-on-github/"&gt;WebKit on GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://mp.weixin.qq.com/s/d0N1BFtVn0uWVqj-lf0FOA"&gt;玉伯的产品思考：技术人如何做产品&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://www.joshwcomeau.com/react/usememo-and-usecallback/"&gt;深入理解 useMemo 和 useCallback&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Tue, 06 Sep 2022 02:51:52 GMT</pubDate></item><item><title>「程序人生」在腾讯工作是怎么样的体验</title><link>https://juejin.cn/post/6976896524198346760</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: condensed-night-purple&lt;/h2&gt;
&lt;h2&gt;在腾讯工作是怎么样的体验&lt;/h2&gt;
&lt;p&gt;大家好，我是&lt;strong&gt;TianTian&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最近有读者私信我说，腾讯工作体验如何，有幸是一名腾讯人，借此回答一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首发文章，&lt;a href="https://mp.weixin.qq.com/s/ouZcSyZfIMMyGnG8A7yGRA"&gt;点这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;我是21届毕业的，4月拿到腾讯offer，提前来实习了。对我之前的经历感兴趣的话，推荐大家阅读这篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6945625394154307592"&gt;&amp;lt;阿里腾讯面试梳理&amp;amp;个人成长经历分享&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过也有人问我，&lt;strong&gt;怎么进的腾讯？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嗯，我只能说&lt;strong&gt;更多是运气，现在的我，肯定进不了腾讯了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;20年下半年还在&lt;strong&gt;网易实习&lt;/strong&gt;，那个时候盯着巨大的压力。你可以想象很多同龄人都斩获满意offer，而我刚刚入门。&lt;/p&gt;
&lt;p&gt;在网易的半年，下班会去补知识，周末去公司静下心来做总结，写博客。好在一直危机感蛮强的，特别是在网易这样的大环境中。 我蛮感激那会的自己，因为热爱，努力希望进更好的公司。&lt;/p&gt;
&lt;p&gt;努力的意义何在，共勉：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;拼着一切代价，奔你的前程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;从哪里说起&lt;/h2&gt;
&lt;p&gt;前段时间腾讯上了一波微博热搜，相信大家都看到了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="热搜" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/190c7df6effe46d6805a8575dc8f2092~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那我们从加班开始说起吧，正好也是大家关心的点。&lt;/p&gt;
&lt;p&gt;从网上流出的加班管理机制表上看，&lt;strong&gt;“双休”确实是双休，但“不加班”却不是通常理解的不加班。只有周三是6点下班，其他工作日则是最晚9点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很多人存在质疑，其他部门我不敢保证，但是在我们组，&lt;strong&gt;已经落实了！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每周双休，一日六点。&lt;/p&gt;
&lt;p&gt;其实很爽了，很多外人觉得不已为然，那我们来看看其他大厂加班情况。&lt;/p&gt;
&lt;p&gt;还是拿数据来说话吧，去年的这统计数据，腾讯连前十都进不去。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SpringBoot+Prometheus+Grafana实现应用监控和报警&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="互联网加班排名-1" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0fc96fe62a348d0ba374977f01b4fbb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;再看看另外的一份互联网大厂的加班排名：&lt;/p&gt;
&lt;p&gt;&lt;img alt="互联网加班排名-2" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47c216e0ba5a4a8abd9e984c3a8f8030~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;也许有人说，这个事情不值得称赞，他们做了本应该的事情。不可否认从某种意义上来说，确实是这样子。但是在当下的互联网趋势下，其实真的不多，毕竟对比其他大厂后，大家都明白xxxxx&lt;/p&gt;
&lt;p&gt;&lt;img alt="你懂吧" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d823a287c5b465680dc1dd71e20da90~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;说到这里，提一句，可以来我们组看看机会，投了简历，我会随时跟进&lt;strong&gt;面试反馈&lt;/strong&gt;以及后续结果的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于团队：&lt;a href="http://www.alloyteam.com/"&gt;AlloyTeam 腾讯文档前端团队&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;一天是如何度过的&lt;/h2&gt;
&lt;p&gt;最近开始养成一个习惯，做好每天规划，类似于：&lt;/p&gt;
&lt;p&gt;&lt;img alt="每日ToDo" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a88af111230a4bd1a6d81970d7ba3536~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;会按照每日清单，做好时间上的规划，尽可能执行，晚上做好复盘。可能这是提高效率的一种途径吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;上午&lt;/h3&gt;
&lt;p&gt;基本上8点起床，有时候睡个懒觉，出门的时间会在9点左右。&lt;/p&gt;
&lt;p&gt;去公司的路上，基本上需要50分钟，一般会&lt;strong&gt;听课&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="最近听得课" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b406b0608e7e4d278c2ee0b2badad53e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;一般我会听类似于这样子课程，&lt;strong&gt;理论知识多一些&lt;/strong&gt;。要是状态不好的话，会选择听歌，看会儿知乎。&lt;/p&gt;
&lt;p&gt;基本上深圳9点以后的一号线，应该人很多的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="赶地铁的同志" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81d37bf0f2f048dfbb216ee06803b0b3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="9.jpeg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77fbd39475e042a2a76b456273dd681d~tplv-k3u1fbpfcp-watermark.image" /&gt;
偷拍无礼，还望原谅。&lt;/p&gt;
&lt;p&gt;可能今天下雨的缘故，人不多。公司早些时候发了邮件，可以居家办公（&lt;strong&gt;挺人性化&lt;/strong&gt;），估计大家都在家工作吧。&lt;/p&gt;
&lt;p&gt;到公司第一件事情，&lt;strong&gt;干饭&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;腾讯的食堂很不错，好吃又便宜。早餐是免费自助，很多种类什么都有，热干面，虎皮鸡爪，肠粉，等等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="早餐" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/029440db85ef4a6e9a2120b2ec7990a7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;吃完早餐，到工位的话，基本上都10：30。&lt;/p&gt;
&lt;p&gt;打开电脑，开始计划今天的任务。&lt;/p&gt;
&lt;p&gt;&lt;img alt="工位" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5b76c1a8f6f4babbd4c460d61c49748~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;当时没有申请iMac，期待正式入职的&lt;strong&gt;iMac办公&lt;/strong&gt;。不过我感觉现在办公设备还不错，要是能再有一个4k显示屏，那体验更加棒。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;中午&lt;/h3&gt;
&lt;p&gt;上午的任务完成后，接下来就是午饭时间啦～&lt;/p&gt;
&lt;p&gt;一般选择在公司食堂吃，偶尔跟同事出去吃顿好的。个人感觉，口味还是挺多的，暂时还没有忌口的，都还吃的习惯，就放张留在相册里面的照片吧：&lt;/p&gt;
&lt;p&gt;&lt;img alt="牛肉蛋包饭" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76508f3ed4054a0c920d677dece8fe06~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;吃完饭后，偶尔散下步，回到工位基本上12:50，这个时候会&lt;strong&gt;写写文章&lt;/strong&gt;，看看公众号文章，准备明天的推文。&lt;/p&gt;
&lt;p&gt;不过计划也会变，有时候会跟&lt;strong&gt;同事开黑&lt;/strong&gt;，打两把游戏，当午休的一个环节。&lt;/p&gt;
&lt;p&gt;打完后，接下来会午休，有行军床，睡起来很爽，比趴着桌子上舒服很多。&lt;/p&gt;
&lt;p&gt;一般我们组午休的时间，都会在14:10左右结束。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;下午&lt;/h3&gt;
&lt;p&gt;主要工作就是跟进技术需求，把今天任务完成。有些时候会被会议突然打断。&lt;/p&gt;
&lt;p&gt;下午个人觉得效率是很高的时间段，基本上会充分利用好，尽量不被打扰。&lt;/p&gt;
&lt;p&gt;当然啦，与同事讨论问题，是一个互相学习一起进步的过程。&lt;/p&gt;
&lt;p&gt;&lt;img alt="debug" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbc1bc2ead5a45bab5efc5c39217a0a1~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;旁边来了位实习生，是个女孩子，挺厉害的。&lt;/p&gt;
&lt;p&gt;有时候，会一起讨论下遇到的bug，讨论下一些技术问题，还是挺愉快的，可以互相交流学习下。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;晚上&lt;/h3&gt;
&lt;p&gt;晚上有夜宵卷，基本上吃饭不花钱或者你也可以拿着夜宵卷去麦当劳。&lt;/p&gt;
&lt;p&gt;吃完饭，会出去散步，绕公司走一圈。不同人可能选择是不一样的，有些人会选择去健身。&lt;/p&gt;
&lt;p&gt;腾讯还是会提供健身的地方的，滨海大厦就有不错的场所。不过我基本上还没有健身的习惯：&lt;/p&gt;
&lt;p&gt;&lt;img alt="滨海大厦健身房" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5fec26224cc4d20a38dec06572975ae~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;有些人，会选择去打球。比如我们提供对应的&lt;strong&gt;打球场地&lt;/strong&gt;。（虽然我还没有去过）&lt;/p&gt;
&lt;p&gt;我基本上回工位，继续把今日任务完成。&lt;/p&gt;
&lt;p&gt;晚上10点后打滴滴回家公司报销，体验过几次10点回去，基本上整层楼，数得过来为数不多的人，主要我不是卷，我是想在公司搞完任务，回去可以写自己的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不是卷！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深圳的夜晚怎么样？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候，觉得很璀璨，有时间觉得到一丝丝的艰难。&lt;/p&gt;
&lt;p&gt;&lt;img alt="滨海大厦" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e0b3a8777e4d429ec96314b48d56d6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;一切取决于你，是否选择&lt;strong&gt;躺平划水&lt;/strong&gt;，还是奋勇前进。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;感受&lt;/h2&gt;
&lt;p&gt;平淡的描述我大致一天的做的事情，可能你会觉得真的忙，无聊。&lt;/p&gt;
&lt;p&gt;其实我想说，不是这样子的，腾讯的福利也很多，有很多游戏福利，包括XXXXX，很爽。&lt;/p&gt;
&lt;p&gt;小组里或者整个团队还会不定时组织团建，而且大多都是工作日去团建哈哈哈。&lt;/p&gt;
&lt;p&gt;上次整个大组一起去团建滑雪了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="朋友拍的" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/399cac86dc5c459f869e36ce65354bd5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;不仅玩的好，吃得好，住的也是挺不错的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="朋友拍的" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01b81e59827f4a23aaa8a0f9a9c80098~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;是啊，我们的生活并不只有&lt;strong&gt;coding&lt;/strong&gt;。这么有意思的一个团队，不值得你加入吗！！！&lt;/p&gt;
&lt;p&gt;静下心来思考，在腾讯上班，可以用几个点来表达：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、太拼命了，自己要多主动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是我的第一印象，大家都很努力。&lt;/p&gt;
&lt;p&gt;第一天入职，想着稍微表现下，等大家一起，后来发现有些同事会很晚走。&lt;/p&gt;
&lt;p&gt;为了和大家步伐一致，需要自己多主动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、自豪感。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这点是有切身体会的，跟亲戚朋友说你在腾讯工作，还挺有面的。他们第一反应，可能是“哇，腾讯啊，大公司”。&lt;/p&gt;
&lt;p&gt;前女友知道我去腾讯了，后续也找过我好几次。&lt;/p&gt;
&lt;p&gt;隔三差五的小福利让你在朋友圈&lt;strong&gt;赚足虚荣心&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、福利待遇好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这点对比国内互联网大厂来说，综合性价比来说，还是挺好的。无息贷款90W，各种其他的福利，这里保密了。&lt;/p&gt;
&lt;p&gt;如果你部门是很得力的，比如游戏部门。年终奖还真的很可观，10个月以上的还是有的。&lt;/p&gt;
&lt;p&gt;再加上可以搞点期权的话，挺有有盼头的，毕竟这些年腾讯股票已经涨了若干若干倍了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、身边人越来越优秀。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;竞争还是蛮激烈的，不管是校招生，还是社招，进来的牛人大把，都是高智商，竞争和比拼的压力还是蛮大的。&lt;/p&gt;
&lt;p&gt;同事们的做事能力，抗压能力，管理能力以及与人沟通能力，都是让我挺欣赏的。&lt;/p&gt;
&lt;p&gt;学习氛围好，组内技术沉淀氛围好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;让我深刻体会到了，越是优秀的人，越努力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、环境越来越好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;办公环境越来越好，听说每年会有各种&lt;strong&gt;兴趣协会&lt;/strong&gt;、&lt;strong&gt;运动培训班&lt;/strong&gt;、&lt;strong&gt;嘉年华活动&lt;/strong&gt;，走到哪里都有的班车，各种便利的OA等等。&lt;/p&gt;
&lt;p&gt;腾讯的HR、行政一直以“&lt;strong&gt;用户体验&lt;/strong&gt;”作为目标提升工作。&lt;/p&gt;
&lt;p&gt;腾讯的食堂很不错，好吃又便宜。这些都让我觉得，外界条件在往越来越好的地方发展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、上下级，同事之间都很平等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里没有很强烈的上下级概念，都是喊昵称或者xxx哥。&lt;/p&gt;
&lt;p&gt;交流问题的时候，给我感觉，大家都是平等的，一视同仁。&lt;/p&gt;
&lt;p&gt;对于我这个新人来说，初期让我负责一个项目，大家会相信我，放心让我去做。&lt;/p&gt;
&lt;p&gt;这点我觉得挺舒服的！！！&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果你是应届生，&lt;strong&gt;腾讯是值得来的&lt;/strong&gt;。优秀的同事以及完善的新人培养机制会在职业生涯的初期让你&lt;strong&gt;更快成长&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总之，不去诋毁腾讯，也不是希望你盲目乐观的看待腾讯的工作，里面有快乐也有不快乐，&lt;strong&gt;兼听则明&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于团队：&lt;a href="http://www.alloyteam.com/"&gt;AlloyTeam 腾讯文档前端团队&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果喜欢，双击点赞~~&lt;/strong&gt;&lt;/p&gt;</description><author>TianTianUp</author><pubDate>Wed, 23 Jun 2021 00:02:50 GMT</pubDate></item><item><title>「前端性能」避免回流和重绘的必要性</title><link>https://juejin.cn/post/6953029989306466317</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: condensed-night-purple&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本文会介绍浏览器中帧（Frame）的概念，它的流程是怎么样的。&lt;/p&gt;
&lt;p&gt;至于写这个文章的出发点在于，我好奇浏览器中像素工作流程是怎么样的，什么时候开始的，最后的结果是什么。&lt;/p&gt;
&lt;p&gt;基于这些好奇，查阅了些外文资料，本文提供了些参考，参考链接在文末。&lt;/p&gt;
&lt;p&gt;最近搞了性能优化思维导图，还在持续输出中，&lt;a href="https://docs.qq.com/mind/DWnljWm52eEVjWWNE"&gt;点击这里&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;缘由&lt;/h2&gt;
&lt;p&gt;在讲帧的概念前，我们得从背景开始看起，也就是渲染页面的这个过程，有哪些关键性的路径呢。&lt;/p&gt;
&lt;h3&gt;五大关键渲染路径&lt;/h3&gt;
&lt;p&gt;像素输出到页面，肯定经历了很多的过程，那我们作为前端工程师，工作中需要注意的点是哪些呢，这里给出参考:&lt;/p&gt;
&lt;p&gt;&lt;img alt="渲染关键路径" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b04e38ce457a4940af9446daf6fcb6fd~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这五个主要的部分，应该是我们值得去关注的，因为我们拥有最大控制权的部分。至于每一个过程具体是怎么样的呢，不清楚的可以参考下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="详细的工作" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e25e5314ce947e8859820a36680f59c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;所以在这么一个像素的管道里，每部分都有可能造成卡顿，所以我们需要额外的关注这些，毕竟那一部分不当，都会开了不必要的性能开销。&lt;/p&gt;
&lt;h3&gt;三种输出方式&lt;/h3&gt;
&lt;p&gt;当时我的疑问是: 难道每一帧都总是会经过管道每个部分的处理嘛，其实不是这样子的，从视觉的角度来说，管道针对指定帧的运行通常有三种方式:&lt;/p&gt;
&lt;p&gt;&lt;img alt="指定帧的运行通常有三种方式" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03fd70517789475c9d2e4ed50af7736c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果我们以第三种方式来更新视图，也就是更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。&lt;/p&gt;
&lt;h3&gt;跑个demo&lt;/h3&gt;
&lt;p&gt;为了更加具体的验证上述的过程，可以动手跑一个demo，来验证一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;demo地址:https://googlechrome.github.io/devtools-samples/jank/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="主线程-火焰图" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53d192456b80423cb765fad3b12c2df0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们添加多个dom元素进行动画，效果更佳明显，接着我们打开Performance，Record这个过程，我们需要关注的是Main选项卡，也就是主线程，我们在放大里面的Task，就有了下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="主线程-火焰图-2" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5862ea6557704d998ef91f358b3e845d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;经历的过程，也是很清楚看到，Update Layer Tree --&amp;gt;&amp;gt; Layout --&amp;gt;&amp;gt; Paint --&amp;gt;&amp;gt; Composite Layers。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你不是很清楚Performance中名称的含义,可以参考下面这篇文章，&lt;a href="https://mp.weixin.qq.com/s/iodsGPWgYc97yWLb09Xk6A"&gt;点这里&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;https://mp.weixin.qq.com/s/iodsGPWgYc97yWLb09Xk6A&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着，我们按下，Optimize按钮，按照之前的流程走，Record后，发现不对劲，还是这样子步骤，难道是哪里存在问题嘛，好奇的我，打开了Sources面板，然后就发现了:&lt;/p&gt;
&lt;p&gt;&lt;img alt="优化后的动画" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acc257718a5f4c109dc783f6408a3165~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;它的源码优化动画，使用的是rAF,了解过的人一定不会陌生，你可以简单的理解就是:按帧对网页进行重绘。这里就引出了帧的概念，后续会说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rAF的详细介绍，后续会对它进行梳理，可以持续关注。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;如何避免回流与重绘&lt;/h3&gt;
&lt;p&gt;回到前面我们设想的点，我们如何才能保证直接跳到合成过程，避免Layout以及Paint呢，当然有，我们需要对app.js中的uppdate函数进行改造，使用&lt;strong&gt;transform: translateX(0px);&lt;/strong&gt;  做动画，做完update函数的处理逻辑后，我们再次Record一下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="优化后的动画" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73cb710cdf1347a3b4ea52be86664535~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从Task子任务中，我们可以发现，&lt;strong&gt;Layout --&amp;gt;&amp;gt; Paint&lt;/strong&gt;, 布局和绘制的过程跳过了。这也是为什么我们常说的需要避免回流与重绘。从主线程上来看，能够完全的避免这些过程，避免了很多的运算开销。&lt;/p&gt;
&lt;p&gt;这也是为什么经常可以看到这样子的建议:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;坚持使用 transform 和 opacity 属性更改来实现动画。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;will-change&lt;/code&gt; 或 &lt;code&gt;translateZ&lt;/code&gt; 提升移动的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至于使用will-change和translatez来提升图层，这又是另外知识点了，这里就不张开了。&lt;/p&gt;
&lt;p&gt;介绍到这里，我们已经清楚的明白，避免回流和重绘的意义，那么我们提到的&lt;strong&gt;帧&lt;/strong&gt;和&lt;strong&gt;rAF&lt;/strong&gt; 与 渲染路径有啥关系呢。&lt;/p&gt;
&lt;h2&gt;帧&lt;/h2&gt;
&lt;p&gt;我做的第一件事情就是google，然后维基百科给出如下定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在&lt;a href="https://zh.wikipedia.org/wiki/%E8%A7%86%E9%A2%91"&gt;视频&lt;/a&gt;领域，&lt;a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%BD%B1"&gt;电影&lt;/a&gt;、&lt;a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%A7%86"&gt;电视&lt;/a&gt;、&lt;a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%A7%86%E9%A2%91"&gt;数字视频&lt;/a&gt;等可视为随时间连续变换的许多张画面，其中&lt;strong&gt;帧&lt;/strong&gt;是指每一张画面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，不是很好理解，知道我找到了这张图，才解答了我的困惑:&lt;/p&gt;
&lt;p&gt;&lt;img alt="anatomy-of-a-frame.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5780421fc5144028e6b260b36ccb709~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这就真的是&lt;strong&gt;一图胜千言&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个图，你可以理解成就是像素放到屏幕的完整过程。你肯定对里面的一些关键信息很迷惑，这里作出一些解释。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接下来大部分内容都是翻译的，没有更多的总结，感兴趣可以看看原文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;PROCESSES(进程)&lt;/h3&gt;
&lt;p&gt;映入眼帘的就是进程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Renderer Process&lt;/strong&gt;: 渲染进程。
&lt;ul&gt;
&lt;li&gt;一个标签的周围容器。&lt;/li&gt;
&lt;li&gt;它包含了多个线程，这些线程共同负责让你的页面出现在屏幕上的各个环节。&lt;/li&gt;
&lt;li&gt;这些线程是&lt;strong&gt;合成线程&lt;/strong&gt;（Compositor）、&lt;strong&gt;图块栅格化线程&lt;/strong&gt;（Tile Worker）和主线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPU Process&lt;/strong&gt;:  GPU进程。
&lt;ul&gt;
&lt;li&gt;这是服务于所有标签和周围浏览器进程的单一进程。&lt;/li&gt;
&lt;li&gt;当帧被提交时，GPU进程将上传任何磁贴和其他数据（如四维顶点和矩阵）到GPU，以便实际将像素推送到屏幕上。&lt;/li&gt;
&lt;li&gt;GPU进程包含一个单一的线程，称为GPU线程，实际完成工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;RENDERER PROCESS THREADS（渲染进程中的线程）&lt;/h3&gt;
&lt;p&gt;现在我们来看看Renderer Process中的线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Compositor Thread&lt;/strong&gt;(合成线程):
&lt;ul&gt;
&lt;li&gt;这是第一个被告知vsync事件的线程(这是操作系统告诉浏览器制作新帧的方式)。&lt;/li&gt;
&lt;li&gt;它还将接收任何输入事件。&lt;/li&gt;
&lt;li&gt;如果可以的话，合成器线程将避免进入主线程，并将尝试将输入（比如说--滚动甩动）转换为屏幕上的运动。它将通过更新图层位置并通过GPU线程直接将帧提交给GPU来实现。&lt;/li&gt;
&lt;li&gt;如果因为输入事件处理程序或其他视觉工作而无法做到这一点，那么就需要使用主线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Main Thread&lt;/strong&gt;(&lt;strong&gt;主线程&lt;/strong&gt;)：
&lt;ul&gt;
&lt;li&gt;这是浏览器执行我们都知道和喜欢的任务的地方。JavaScript、样式、布局和绘画。(在未来的&lt;a href="https://surma.link/things/houdini-intro/"&gt;Houdini&lt;/a&gt;中，这种情况会有所改变，我们将能够在Compositor线程中运行一些代码。)&lt;/li&gt;
&lt;li&gt;这个线程赢得了 "最有可能导致jank "的奖项，主要是因为这里有很多东西在运行。(jank值得是&lt;strong&gt;页面抖动&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Compositor Tile Worker(s) (&lt;strong&gt;合成图块栅格化线程&lt;/strong&gt;):
&lt;ul&gt;
&lt;li&gt;由合成线程派生的一个或多个线程，用于处理栅格化任务。我们稍后再讨论。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在很多方面，你应该把Compositor线程视为 "大老板"。虽然它不运行JavaScript、Layout、Paint或其他任何东西，但它是完全负责启动主线程工作的线程，然后将帧运送到屏幕上。如果它不需要等待输入事件处理程序，它就可以在等待主线程完成工作的同时运送帧。&lt;/p&gt;
&lt;p&gt;你也可以想象Service Workers和Web Workers生活在这个过程中，不过我没有把他们包括在内，因为这让事情变得更加复杂。&lt;/p&gt;
&lt;h3&gt;THE FLOW OF THINGS(主线程流程)&lt;/h3&gt;
&lt;p&gt;让我们成主线程开始吧。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a7ef1a216604eb282954c9673a1e5e9~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;让我们一步步走过这个流程，从vsync到像素，并谈谈在事件的 "全胖 "版本中事情是如何进行的。值得记住的是，浏览器不需要执行所有这些步骤，这取决于什么是必要的。例如，如果没有新的HTML要解析，那么解析HTML就不会启动。事实上，很多时候，提高性能的最好方法就是简单地消除部分流程被启动的必要性!&lt;/p&gt;
&lt;p&gt;同样值得注意的是，样式和布局下的红色箭头似乎指向了 &lt;strong&gt;requestAnimationFrame&lt;/strong&gt;。在你的代码中完全有可能意外地触发这两者。这就是所谓的强制同步布局（或样式，视情况而定），它通常对性能不利。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Frame Start&lt;/strong&gt;（&lt;strong&gt;开始新的一帧&lt;/strong&gt;）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;垂直同步信号触发，开始渲染新的一帧图像。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Input event handlers&lt;/strong&gt; （&lt;strong&gt;输入事件的处理&lt;/strong&gt;）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-输入数据从合成器线程传递给主线程上的任何输入事件处理程序。&lt;/li&gt;
&lt;li&gt;所有的输入事件处理程序（触摸移动、滚动、点击）都应该首先启动，每帧一次，但情况不一定如此。&lt;/li&gt;
&lt;li&gt;调度器会做出最大努力的尝试，其成功率在不同的操作系统中有所不同。在用户交互和事件进入主线程处理之间也有一些延迟。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是对屏幕进行视觉更新的理想位置，因为你有新鲜的输入数据，而且这是你要得到的最接近vsync的地方。&lt;/li&gt;
&lt;li&gt;其他的视觉任务，比如样式计算，都是在这个任务之后进行的，所以它的理想位置是突变元素。&lt;/li&gt;
&lt;li&gt;如果你突变--比如说--100个类，这不会导致100个样式计算；它们将被分批处理，并在后面处理。唯一需要注意的是，你不要查询任何计算过的样式或布局属性（比如el.style.backgroundImage或el.style.offsetWidth）。&lt;/li&gt;
&lt;li&gt;如果你这样做，你会把重新计算的样式、布局或两者都向前带，导致强制的同步布局，或者更糟糕的是，布局打乱。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Parse HTML&lt;/strong&gt; (&lt;strong&gt;解析 HTML&lt;/strong&gt;):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任何新添加的HTML都会被处理，并创建DOM元素。&lt;/li&gt;
&lt;li&gt;在页面加载过程中或appendChild等操作后，你可能会看到更多的这种情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Recalc Styles&lt;/strong&gt;（&lt;strong&gt;重新计算样式&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;样式是为任何新添加或突变的东西计算的，这可能是整个树，也可能是范围，这取决于改变了什么。&lt;/li&gt;
&lt;li&gt;这可能是整个树，也可能是范围缩小，这取决于改变了什么。&lt;/li&gt;
&lt;li&gt;例如，改变主体上的类可能影响深远，但值得注意的是，浏览器已经非常聪明地自动限制了样式计算的范围。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Layout&lt;/strong&gt;（绘制）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算每个可见元素的几何信息（每个元素的位置和大小）。它通常对整个文档进行计算，通常使计算成本与DOM大小成正比。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Update Layer Tree&lt;/strong&gt;（&lt;strong&gt;更新图层树&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建叠加上下文和深度排序元素的过程。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Paint&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是两部分过程中的第一部分：绘制是记录任何新元素或视觉上有变化的元素的绘制调用（在这里填充一个矩形，在那里写文字）。&lt;/li&gt;
&lt;li&gt;第二部分是光栅化（见下文），在这里执行绘图调用，并填充纹理。这一部分是对绘制调用的记录，通常比光栅化快得多，但这两部分通常统称为 "绘画"。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Composite&lt;/strong&gt;（&lt;strong&gt;合成&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算出图层和瓷砖的信息，并传回给合成器线程来处理。&lt;/li&gt;
&lt;li&gt;这将会考虑到，除其他事项外，像will-change，重叠元素，以及任何硬件加速的canvases。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Raster Scheduled&lt;/strong&gt; （&lt;strong&gt;栅格化规划&lt;/strong&gt;）and &lt;strong&gt;Rasterize&lt;/strong&gt;（&lt;strong&gt;栅格化&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;现在会执行在Paint任务中记录的绘制调用。这是在Compositor Tile Workers中完成的，其数量取决于平台和设备能力。&lt;/li&gt;
&lt;li&gt;例如，在Android上，你通常会发现一个Worker，在桌面上，你有时可以找到四个。栅格化是以图层为单位进行的，每个图层都是由瓷砖组成的。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Frame End（帧结束）:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当各个图层的磁贴都栅格化后，任何新的磁贴都会和输入数据（可能在事件处理程序中被改变）一起提交给GPU线程。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Frame Ships&lt;/strong&gt;（&lt;strong&gt;发送帧&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最后，但绝不是最不重要的，磁贴由GPU线程上传至GPU。GPU使用四边形和矩阵（所有常见的GL好东西）将磁贴绘制到屏幕上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大致上，整个的过程就是上述。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;requestIdleCallback&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;要说这个的话，我们得拿&lt;strong&gt;requestAnimationFrame&lt;/strong&gt;来类比，requestAnimationFrame是在重新渲染屏幕&lt;strong&gt;之前&lt;/strong&gt;执行的，上面提到的rAF，当时做的就是优化动画，所以很适合做动画。&lt;/p&gt;
&lt;p&gt;requestIdleCallback你通过主线程里面中的Task去查找的话，会发现它是在渲染屏幕&lt;strong&gt;之后&lt;/strong&gt;执行，通过查阅文章发现，一般会看浏览器是否空闲。&lt;/p&gt;
&lt;p&gt;这里篇幅有限，想要了解这个的话，推荐&lt;a href="https://juejin.cn/post/6844904196345430023"&gt;一篇文章&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://juejin.cn/post/6844904165462769678&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;最近查阅外文文献，发现要学的东西太多了，如果这篇文章有写的不对，或者翻译不佳的地方，欢迎小伙伴指出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文首发地址&lt;a href="https://mp.weixin.qq.com/s/nMp8j2VnwllLzS8PVJnecQ"&gt;点这里&lt;/a&gt;,欢迎大家关注公众号「TianTianUp」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我是TianTian，我们下一期见！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;[1] &lt;strong&gt;w3c-longTasks:&lt;/strong&gt; https://github.com/w3c/longtasks&lt;/p&gt;
&lt;p&gt;[2] &lt;strong&gt;chrome-fps-meter:&lt;/strong&gt; https://developer.chrome.com/docs/devtools/evaluate-performance/reference/#fps-meter&lt;/p&gt;
&lt;p&gt;[3] &lt;strong&gt;devtools-samples:&lt;/strong&gt; https://googlechrome.github.io/devtools-samples/jank/&lt;/p&gt;
&lt;p&gt;[4] &lt;strong&gt;Analyze runtime performance:&lt;/strong&gt; https://developer.chrome.com/docs/devtools/evaluate-performance/&lt;/p&gt;
&lt;p&gt;[5] &lt;strong&gt;Timeline Event Reference:&lt;/strong&gt; https://developer.chrome.com/docs/devtools/evaluate-performance/performance-reference/&lt;/p&gt;
&lt;p&gt;[6] &lt;strong&gt;The Anatomy of a Frame:&lt;/strong&gt; https://aerotwist.com/blog/the-anatomy-of-a-frame/&lt;/p&gt;
&lt;p&gt;[7] &lt;strong&gt;performance-rendering:&lt;/strong&gt; https://developers.google.com/web/fundamentals/performance/rendering&lt;/p&gt;
&lt;p&gt;[8] &lt;strong&gt;维基百科:&lt;/strong&gt; https://zh.wikipedia.org/wiki/&lt;/p&gt;</description><author>TianTianUp</author><pubDate>Mon, 19 Apr 2021 16:33:16 GMT</pubDate></item><item><title>如何使用Lighthouse性能检测工具</title><link>https://juejin.cn/post/6950855971379871757</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近做性能检测工具，很多知识点不清楚，打算查缺补漏，补一补。&lt;/p&gt;
&lt;p&gt;接下来从官方提供的性能检测工具Lighthouse(灯塔)开始我们的学习，简单介绍了下Lighthouse的一些点。&lt;/p&gt;
&lt;p&gt;阅读完本文，你可以了解到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lighthouse 是什么。&lt;/li&gt;
&lt;li&gt;如何快速上手Lighthouse (使用入门)。&lt;/li&gt;
&lt;li&gt;Lighthouse中的一些Metrics指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能相关的总结准备搞个思维导图，可以&lt;a href="https://docs.qq.com/mind/DWnljWm52eEVjWWNE"&gt;点这里&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://docs.qq.com/mind/DWnljWm52eEVjWWNE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Lighthouse 是什么&lt;/h2&gt;
&lt;p&gt;官方对它的解读:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/GoogleChrome/lighthouse"&gt;Lighthouse&lt;/a&gt; 是一个开源的自动化工具，用于改进网络应用的质量。 您可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 您为 Lighthouse 提供一个您要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它是如何工作的呢？&lt;/p&gt;
&lt;p&gt;如果你跟我一样，翻过它的代码，看过它的介绍肯定很懵逼，它的代码依赖性如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse内部模块依赖.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134180f910bf46019ceb8e71e57c1c54~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;感兴趣的可以看看它的仓库，参考链接已经给出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://github.com/GoogleChrome/lighthouse&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;使用入门&lt;/h2&gt;
&lt;p&gt;运行 Lighthouse 的方式有两种: 作为 Chrome 扩展程序运行，或作为命令行工具运行。 Chrome 扩展程序提供了一个对用户更友好的界面，方便读取报告。 命令行工具允许您将 Lighthouse 集成到持续集成系统。&lt;/p&gt;
&lt;h3&gt;Chrome 扩展程序&lt;/h3&gt;
&lt;p&gt;下载 Google Chrome 52 或更高版本。&lt;/p&gt;
&lt;p&gt;安装 &lt;a href="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk"&gt;Lighthouse Chrome 扩展程序&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;地址:https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;点击 &lt;strong&gt;Generate report&lt;/strong&gt; 按钮以针对当前打开的页面运行 Lighthouse 测试。&lt;/p&gt;
&lt;h3&gt;命令行工具&lt;/h3&gt;
&lt;p&gt;Node CLI在配置和报告Lighthouse运行情况方面提供了最大的灵活性。如果用户需要更多的高级功能，或者想自动运行Lighthouse，可以使用Node CLI。安装 Lighthouse 作为一个全局节点模块。&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm install -g lighthouse
# or use yarn:
# yarn global add lighthouse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;针对一个页面运行 Lighthouse 审查。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;lighthouse https://www.example.com --view
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传递 &lt;code&gt;--help&lt;/code&gt; 标志以查看可用的输入和输出选项。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;lighthouse --help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于一些options不清楚的，可以点击这个链接:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://github.com/GoogleChrome/lighthouse#cli-options&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设我们审查后，就会有这么一个结果:&lt;/p&gt;
&lt;p&gt;&lt;img alt="light-metrics.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb85726649d34805a36742eeeb88d8d8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到一共6个Metrics，Lighthouse 6.0在报告中引入了三个新指标。其中两个新的指标--最大内容画（LCP）和累积布局偏移（CLS）--是Core Web Vitals的实验室实现。&lt;/p&gt;
&lt;p&gt;那么接下来，我们看看这些Metrics指标的含义。&lt;/p&gt;
&lt;h2&gt;几个Metrics指标&lt;/h2&gt;
&lt;h3&gt;First Contentful Paint (FCP)&lt;/h3&gt;
&lt;p&gt;第一次内容丰富的绘画(FCP)指标衡量了从页面开始加载到页面内容的任何部分呈现在屏幕上的时间。对于该指标，"内容 "指的是文本、图像（包括背景图像）、&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;元素或非白色&lt;canvas&gt;元素。&lt;/canvas&gt;&lt;/svg&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse-fcp.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8401aa9ee484d7186f5de6ea3308f57~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在上面的负载时间线中，FCP发生在第二帧中，就像呈现给屏幕的第一文本和图像元素时一样。&lt;/p&gt;
&lt;p&gt;你会注意到，虽然部分内容已经呈现，但并非所有内容都已呈现。这是First Contentful Paint (FCP)和Largest Contentful Paint (LCP)之间的一个重要区别--LCP的目的是衡量页面的主要内容何时完成加载。&lt;/p&gt;
&lt;p&gt;知道了概念，如何衡量FCP呢，我们可以接触的有&lt;strong&gt;Field tools&lt;/strong&gt;和&lt;strong&gt;Lab tools&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要在JavaScript中测量FCP，你可以使用Paint Timing API。下面的例子展示了如何创建一个PerformanceObserver，该PerformanceObserver监听名称为first-contentful-paint的油漆条目，并将其记录到控制台。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;new PerformanceObserver((entryList) =&amp;gt; {
  for (const entry of entryList.getEntriesByName('first-contentful-paint')) {
    console.log('FCP candidate:', entry.startTime, entry);
  }
}).observe({type: 'paint', buffered: true});

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Speed Index&lt;/h3&gt;
&lt;p&gt;速度指数是Lighthouse报告中性能部分跟踪的六个指标之一。每项指标都能反映出页面加载速度的某些方面。&lt;/p&gt;
&lt;p&gt;那么它是如何检测的呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;速度指数衡量的是内容在页面加载过程中的视觉显示速度。Lighthouse首先会在浏览器中捕获一段页面加载的视频，并计算出各帧之间的视觉进度。然后，Lighthouse使用Speedline Node.js模块来生成速度指数得分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于具体的计算，可以参考GitHub里面的代码，这里就不展开了。&lt;/p&gt;
&lt;p&gt;那么我们有机会提升它的性能吗？&lt;/p&gt;
&lt;p&gt;利用Lighthouse报告中的 "&lt;strong&gt;Opportunities&lt;/strong&gt; "部分来确定哪些改进对你的页面最有价值。机会越重要，对性能评分的影响就越大。例如，下面的Lighthouse截图显示，消除渲染阻塞资源将带来最大的改善。&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse-speedindex.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5279e1bb4643f9aec3b9e13f6605bb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;Largest Contentful Paint (LCP)&lt;/h3&gt;
&lt;p&gt;最大内容画（LCP）指标报告了在视口中可见的最大图像或文本块的渲染时间，相对于页面首次开始加载的时间。&lt;/p&gt;
&lt;p&gt;&lt;img alt="light-lcp.svg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fe34160f7344500b6527912c2d5723b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从图上也能看出来，为了提供良好的用户体验，网站应该努力使最大内容画幅达到2.5秒或更少。&lt;/p&gt;
&lt;p&gt;更多信息，请观看Paul Irish对LCP的深度剖析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://www.youtube.com/watch?v=diAc65p15ag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Cumulative Layout Shift (CLS)&lt;/h3&gt;
&lt;p&gt;官方对它的解释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cumulative Layout Shift (CLS)是一种视觉稳定性的测量方法，它量化了页面内容在视觉上的移动程度。它量化了一个页面的内容在视觉上移动的程度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单理解就是:&lt;/p&gt;
&lt;p&gt;CLS测量的是整个页面生命周期内发生的每一次意外布局转变的所有单个布局转变得分的总和。&lt;/p&gt;
&lt;p&gt;布局偏移发生在可见元素从一个渲染帧到下一个渲染帧改变其位置的任何时候。关于如何计算单个布局偏移分数，请参见下文）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://web.dev/cls/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="lighthouse-cls.svg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f428f403b344e69baabcef5434adb18~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从上面的图来看，CLS得分低是给开发者的一个信号，表明他们的用户没有经历不必要的内容移动；CLS得分低于0.10被认为是 "好"。&lt;/p&gt;
&lt;h3&gt;Total Blocking Time (TBT)&lt;/h3&gt;
&lt;p&gt;我们看看官方对它的解读：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总阻塞时间（Total Blocking Time，TBT）量化了负载响应能力，测量了主线程被阻塞的时间长到足以阻止输入响应的总时间。TBT衡量的是第一次有内容的绘画（FCP）和交互时间（TTI）之间的总时间。它是TTI的配套指标，它为量化主线程活动带来了更多的细微差别，这些活动阻碍了用户与您的页面进行交互的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，TBT与核心网络生命力的现场指标First Input Delay（FID）有很好的相关性。&lt;/p&gt;
&lt;p&gt;需要更多的了解，可以参考链接:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://web.dev/tbt/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;最新评分标准&lt;/h3&gt;
&lt;p&gt;Lighthouse中的性能得分是由多个指标加权混合计算出来的，总结出一个页面的速度。6.0的性能得分公式如下。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;Phase&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;Metric Name&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;Metric Weight&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Early (15%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;First Contentful Paint (FCP)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;15%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Mid (40%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Speed Index (SI)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;15%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Largest Contentful Paint (LCP)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;25%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Late (15%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Time To Interactive (TTI)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;15%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Main Thread (25%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Total Blocking Time (TBT)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;25%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Predictability (5%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Cumulative Layout Shift (CLS)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;5%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;那么你是不是会跟我一样，有疑问，我们不能修改这个权重嘛，当然可以试一试:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://googlechrome.github.io/lighthouse/scorecalc/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;点击上面的链接，会展示这个一个画面:&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse-Scoring-calculator.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5272b1ec14c44293ba2537b660c23e0f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这个网站发布了一个评分计算器，帮助你了解性能评分。同时，该计算器还能为你提供Lighthouse 5版和6版的评分比较。当你使用Lighthouse 6.0版本进行审计时，报告中会有一个链接，链接到计算工具，并将结果填入其中。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;到这里，其实Lighthouse如何使用，以及一些关键的指标也做了说明，你一定会有疑问:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我如何通过计算他们具体的值呢，有对应的JavaScript API？&lt;/li&gt;
&lt;li&gt;既然可以通过Lighthouse来衡量性能并找到加快页面加载的机会，那么我们如何优化呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;想必看到这里，你遇到的疑惑跟之前一样，那么如何解决呢。&lt;/p&gt;
&lt;p&gt;嗯，上面说的部分并没有详细的展开，剩下的部分，尝试去翻一翻官方文档，查一查资料，收获一定很大。&lt;/p&gt;
&lt;p&gt;使用入门，很简单，没有难度，后续会继续梳理，思维导图在&lt;a href="https://docs.qq.com/mind/DWnljWm52eEVjWWNE"&gt;这里&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://docs.qq.com/mind/DWnljWm52eEVjWWNE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我是TianTianUp，我们下一期见！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;[1] &lt;strong&gt;Lighthouse performance scoring&lt;/strong&gt;: https://web.dev/performance-scoring/&lt;/p&gt;
&lt;p&gt;[2] &lt;strong&gt;GoogleChrome-lighthouse&lt;/strong&gt;: https://github.com/GoogleChrome/lighthouse&lt;/p&gt;
&lt;p&gt;[3] &lt;strong&gt;What's New in Lighthouse 6.0&lt;/strong&gt;: https://web.dev/lighthouse-whats-new-6.0/&lt;/p&gt;
&lt;p&gt;[4] &lt;strong&gt;Measure:&lt;/strong&gt; https://web.dev/measure/&lt;/p&gt;
&lt;p&gt;[5] &lt;strong&gt;How does Lighthouse work?&lt;/strong&gt;: https://github.com/GoogleChrome/lighthouse/blob/master/docs/architecture.md&lt;/p&gt;
&lt;p&gt;[6] &lt;strong&gt;Largest Contentful Paint (LCP)&lt;/strong&gt;: https://web.dev/lcp/&lt;/p&gt;
&lt;p&gt;[7] &lt;strong&gt;Total Blocking Time (TBT):&lt;/strong&gt; https://web.dev/tbt/&lt;/p&gt;
&lt;p&gt;[8] &lt;strong&gt;Cumulative Layout Shift (CLS):&lt;/strong&gt; https://web.dev/cls/&lt;/p&gt;
&lt;p&gt;[9] &lt;strong&gt;First Contentful Paint (FCP):&lt;/strong&gt; https://web.dev/fcp/&lt;/p&gt;
&lt;p&gt;[10] &lt;strong&gt;Speed Index:&lt;/strong&gt; https://web.dev/speed-index/&lt;/p&gt;</description><author>TianTianUp</author><pubDate>Tue, 13 Apr 2021 19:51:39 GMT</pubDate></item><item><title>阿里腾讯面试梳理&amp;个人成长经历分享</title><link>https://juejin.cn/post/6945625394154307592</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: condensed-night-purple&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;好久没有更新了，最近忙着面试，写毕业设计和论文。&lt;/p&gt;
&lt;p&gt;不过不想停下记笔记的习惯，所以偷偷的发面经，然后"惊艳"老铁们。&lt;/p&gt;
&lt;p&gt;校招面经，面试难度中等，看官老爷们看个热闹就行。&lt;/p&gt;
&lt;p&gt;历经一个月战线，投了阿里和腾讯，具体部门这里不展开了，都是核心部门，提供的舞台很大，至于最后选择去哪一家公司，可以关注文末。&lt;/p&gt;
&lt;p&gt;接下来复盘一下这一个月来的面试感受吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文不会泄题，只是根据我的简历，来展开谈一谈，可能会被问到的题目。&lt;/p&gt;
&lt;p&gt;最后以下都是个人观点，个人能力有限，&lt;strong&gt;如果有错误，希望能纠正我。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;简单介绍&lt;/h2&gt;
&lt;p&gt;2021届毕业生，掘金里面的TianTianUp，双非本科院校(江西师大)，没有听错，那个彩礼“天价”的省份。&lt;/p&gt;
&lt;p&gt;21届里面，应该算起步比较晚的了。2020年暑假7月份，才开始认认真真“复习”前端，当时连js作用域，闭包，浏览器缓存都不清楚。因为起步晚，所以后续错过了秋招。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在我才深刻意识到，视野的重要性。&lt;/p&gt;
&lt;p&gt;当时大三学了点vue，做了点看起来牛逼的东西，就觉得很牛了，于是春招投了阿里，结果惨不忍睹。&lt;/p&gt;
&lt;p&gt;重点当时没有放心上，还是继续玩，继续打游戏。&lt;/p&gt;
&lt;p&gt;还好之后觉悟过来，才有了后面网易的故事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，也导致后续很多环节跟不上其他同届大佬。&lt;/p&gt;
&lt;p&gt;秋招的时候，jack，三元同学，林不渡，单哥，承和等大佬都是offer收割机，各种腾讯，快手，字节ssp，无不冲击着我这个萌新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;暗自下决心: 我也要去大厂核心部门，去做有意思的事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了规划，接下来就是看技术博客，动手实践，总结梳理，写博客。&lt;/p&gt;
&lt;p&gt;熬了无数的夜，无数个周末在社区徘徊，这个知识点不懂，查文档，看不明白就换一篇文章，争取做到一遍过。&lt;/p&gt;
&lt;p&gt;这么坚持了半年，2021年的春招，结果让我满意，但结果还是有些遗憾的。&lt;/p&gt;
&lt;p&gt;满意的地方: 借面试机会，跟着大佬交流学习了一波。&lt;/p&gt;
&lt;p&gt;遗憾的地方: 其他大厂没有去尝试，没有趁着面试机会去接触其他领域的大佬。我觉得原因可以归咎于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找不到大厂核心部门的内推，希望去核心部门。&lt;/li&gt;
&lt;li&gt;需要笔试，觉得流程很慢，没有人跟进。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以后面提到了面试机会。&lt;/p&gt;
&lt;p&gt;整个春招的过程中，聊一聊心态发生的改变吧，迷茫--紧张--坦然--自信，最后到意向书，到拿到offer。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小tips&lt;/strong&gt;⬇️&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你是在校生，推荐你阅读三元同学博客，干货满满。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;面试机会&lt;/h2&gt;
&lt;p&gt;基本上我是靠内推的，腾讯文档，是一位校招大佬帮忙推的，觉得履历还行，给了个面试机会，才勉强给我通过的。真的是勉强给的机会，因为学校确实跟985比起来，差距很大，还好有网易实习经历buff，加上写了点博客笔记等笔记输出，才有这个面试机会。&lt;/p&gt;
&lt;p&gt;内推，内推，内推，这是最快，最有效的方式，可以第一时间知道面试结果，面评，以及后续的面试流程。&lt;/p&gt;
&lt;p&gt;至于其他的，美团，百度，shopee走的都是官网流程，需要笔试。腾讯这边到四面总监面的时候，我基本上都放弃了。&lt;/p&gt;
&lt;p&gt;最好的方式就是找靠谱的内推吧，比如秋风大佬，字节找ssh（昊神），很靠谱的。&lt;/p&gt;
&lt;p&gt;好的履历也很重要:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学校985，211。&lt;/li&gt;
&lt;li&gt;大厂实习经历，众多offer。&lt;/li&gt;
&lt;li&gt;扎实的基础，读过源码，理解框架设计思想。&lt;/li&gt;
&lt;li&gt;社区有一定影响力，坚持做博客产出。&lt;/li&gt;
&lt;li&gt;开源贡献，开源项目维护者，热爱前端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上，我会把握其中的一两个点，争取做好，才会有后续的面试机会。&lt;/p&gt;
&lt;p&gt;有了面试机会后，剩下的就是如何去做好一场面试的准备工作了。&lt;/p&gt;
&lt;h2&gt;如何准备&lt;/h2&gt;
&lt;p&gt;这个链接里面总结的特别好，我基本上看它复习的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://bitable.feishu.cn/app8Ok6k9qafpMkgyRbfgxeEnet?from=logout&amp;amp;table=tblEnSV2PNAajtWE&amp;amp;view=vewJHSwJVd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过面完，给我感觉，重在平时的积累，基本上都是围绕项目展开的，之前做的项目得好好准备一下，比如项目难点，项目如何做优化的，项目的亮点。&lt;/p&gt;
&lt;p&gt;这里推荐一个链接：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;面试被问项目经验不用慌，按这个步骤回答绝对惊艳&lt;/p&gt;
&lt;p&gt;https://juejin.cn/post/6844904102795706375&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于其他的部分，更多的是向面试官展示自己的优点，闪光点。&lt;/p&gt;
&lt;h2&gt;面经心得&lt;/h2&gt;
&lt;p&gt;基本上都是围绕我的简历来的，有兴趣的话，可以联系我要pdf，可以给你参考下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="简历-技能部分.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e339408f918434e8c76e2c823db257f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简历上技能写的不多，基本上能保证的是我写的都能聊上两句。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从我简历部分来看，主要涉及几个点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React部分，这里面可以问的内容也很多。&lt;/li&gt;
&lt;li&gt;浏览器相关的。&lt;/li&gt;
&lt;li&gt;计算机网络部分。&lt;/li&gt;
&lt;li&gt;算法与数据结构，基本上这算是我的一个杀手锏吧。&lt;/li&gt;
&lt;li&gt;webpack相关的，同时会涉及到babel。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我现在回顾我的面试部分，都是围绕这些点张开的。可能我是应届生校招的原因，很多时候，考察的是我学习能力，理解能力，对前端热爱的程度这些方面。&lt;/p&gt;
&lt;p&gt;基于这几点，展开聊聊我面试过程中会注意的点，以及围绕我写的专业技能，会聊到的一些话题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;自我介绍&lt;/h3&gt;
&lt;p&gt;很重要的一个环节，说不定可以奠定本次面试的节奏，会根据你说的内容，来张开问你，同时也会给&lt;strong&gt;给面试官一个缓冲的时间来重新熟悉你的简历&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;面试自我介绍，要：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遵守极简原则，突出重点，忽略细节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小参考:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我是谁。&lt;/li&gt;
&lt;li&gt;我的亮点，可以描述一下几个点，最近的经历。&lt;/li&gt;
&lt;li&gt;我为什么需要这份工作（其实这个我自我介绍都是忽略的）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;围绕上面的点，我会着重突出，我在大学的经历，主要是算法相关的经历，接着就是我在网易实习期间的收获，以及中间会持续更新博客，写总结。&lt;/p&gt;
&lt;p&gt;基本上，面试官对我的掘金博客，以及大学搞算法的经历感兴趣，进入了自己擅长的领域，就会轻松很多。&lt;/p&gt;
&lt;p&gt;记住一个点，&lt;strong&gt;面试是跟人打交道&lt;/strong&gt;，学会去展示自己，以及及时跟面试官做合理的沟通很重要。&lt;/p&gt;
&lt;p&gt;以上是我会注意的一些点，我也是这么去做的，尽量围绕自己的&lt;strong&gt;亮点&lt;/strong&gt;去展开，当然了，有些面试官有自己的风格，&lt;strong&gt;可能一上来就是问你项目&lt;/strong&gt;，那么我们应该如何把握呢。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;项目相关&lt;/h3&gt;
&lt;p&gt;我觉得项目相关的话题，是个挺难的话题，围绕它展开的话，可以延伸出很多话题，我列举了些有意思的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目难点。（如何发现问题，解决思路，最后结果）&lt;/li&gt;
&lt;li&gt;项目考虑过优化吗，你是如何优化的，思路是什么。&lt;/li&gt;
&lt;li&gt;项目的组织架构，你对它的现有架构的理解，哪些优点值得借鉴，哪些缺点需要改进。&lt;/li&gt;
&lt;li&gt;如果让你从0到1建一个项目，你考虑的点是什么，有哪些流程需要注意的。&lt;/li&gt;
&lt;li&gt;项目中代码规范，你们项目有方案吗，你了解的代码规范有哪些方案。&lt;/li&gt;
&lt;li&gt;说一说项目中你们是如何测试的，有哪些单元测试方案，能不能说一说。&lt;/li&gt;
&lt;li&gt;项目中引入TS的原因，为什么这么做。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过对于&lt;strong&gt;应届生&lt;/strong&gt;来说，问项目都是围绕你简历来问的，比如我当时的项目，我觉得没有好的难点，我就&lt;strong&gt;着重说明&lt;/strong&gt;了下，我对项目是如何优化的，优化了哪些点。&lt;/p&gt;
&lt;p&gt;整个面试下来，都会问，你项目写到的优化的地方，能不能具体聊一聊。&lt;/p&gt;
&lt;p&gt;这个时候，真的要把握机会了，问到你会的点，你得有清晰的思路，可以参考STAR法则。&lt;/p&gt;
&lt;p&gt;重新回顾一下 STAR 法则四要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Situation&lt;/strong&gt;：事情是在什么情况下发生，基于一个怎样的背景；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Task&lt;/strong&gt;：你是如何明确你的任务的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Action&lt;/strong&gt;：针对这样的情况分析，你采用了什么行动方式，具体做了哪些工作内容；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Result&lt;/strong&gt;：结果怎样，带来了什么价值，在整个过程中你学到了什么，有什么新的体会。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有段话，我觉得说的很不错:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;往往大部分同学一上来就直接介绍做了什么以及实现的过程，条理也比较清晰，内容也颇具技术含量。但很多同学很容易忽略了 Situation 和 Result 的部分也就是背景和结果。或者是在面试官进一步了解追问细节的时候容易惊慌失措。这些原因往往都是由于面试前对自己的经历没有将来龙去脉讲清楚以及总结不够全面和深入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上，我对项目这块目前能聊的就是这么多，对了，如果你面&lt;strong&gt;大厂核心部门&lt;/strong&gt;，可能还需要关注的点是，&lt;strong&gt;项目的组织架构理解&lt;/strong&gt;，让你实现一个项目，整个流程需要注意考虑哪些点。&lt;/p&gt;
&lt;p&gt;这块真的可以着重准备一下，以我这次春招经验来谈，是重点。&lt;/p&gt;
&lt;p&gt;聊完项目，接下来就围绕我&lt;strong&gt;简历写到的专业技能&lt;/strong&gt;，依此来梳理一下。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;JS基础&lt;/h3&gt;
&lt;p&gt;考察的是一些基础问题，这里最好过一遍，切记不要丢大分。&lt;/p&gt;
&lt;p&gt;比如我写了对异步编程有理解，所以得看一下，异步编程的解决方案，它的发展过程，每种解决方案的优缺点，得了得，最后我会&lt;strong&gt;拓展一下async方案存在的缺陷&lt;/strong&gt;，对错误的捕获，聊到&lt;strong&gt;babel相关&lt;/strong&gt;的，现有的babel社区是否实现了对async语法做错误捕获处理，以及谈了下，社区里面的这个插件存在的缺陷。&lt;/p&gt;
&lt;p&gt;总结的话，我会围绕&lt;strong&gt;面试官问的基础点展开&lt;/strong&gt;，把相关连的部分描述一下， 面试官有兴趣的话，会顺着你的思路往下问。&lt;/p&gt;
&lt;p&gt;至于面试过程中问到&lt;strong&gt;JS基础&lt;/strong&gt;相关的题，这里就不列举了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;React相关&lt;/h3&gt;
&lt;p&gt;第二部分，简历上写了React相关的，那我总结了些可以会问到内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React框架的原理，聊一聊它是如何执行的。&lt;/li&gt;
&lt;li&gt;React更新流程，主要经历了哪些步骤。&lt;/li&gt;
&lt;li&gt;React中setState的理解，需要注意哪些。&lt;/li&gt;
&lt;li&gt;vue和React区别，如何从项目的选型上区分它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;React框架的理解，vdom，patch，批量更新，渲染的过程，经历了啥。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你对React源码很感兴趣，可以关注一下&lt;strong&gt;卡颂大佬&lt;/strong&gt;，他的&lt;a href="https://ke.sifou.com/course/1650000023864436"&gt;自顶向下学 React 源码&lt;/a&gt;值得推荐学习一下。&lt;/p&gt;
&lt;p&gt;当然了，React真的要问，太多可以问你的啦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如让你手写一个Hoc组件，实现类似怎么样的功能，思路是怎么样的。&lt;/li&gt;
&lt;li&gt;比如Hook你对它的理解，当时面试问到了Hook实现原理，还好看平时喜欢折腾，看了下大致流程。&lt;/li&gt;
&lt;li&gt;React-fiber机制引入，解决了什么问题，具体的流程是怎么样的，数据结构上发生了哪些变化。&lt;/li&gt;
&lt;li&gt;React中的时间切片了解嘛，如何实现的，流程能不能说一说。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这次问到好几个React相关的问题，更关注的点是你对原理的过程，有关注嘛，大致是一个怎么样的过程，最后又从中学到了哪些点。简历上写看过React原理相关的，得慎重啊！！！&lt;/p&gt;
&lt;p&gt;快进到浏览器部分。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;浏览器相关&lt;/h3&gt;
&lt;p&gt;这也是我简历上专业技能写到的一个点，这里也写了几个点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入URL到页面渲染。&lt;/li&gt;
&lt;li&gt;DNS解析的端口号是多少，为什么采用UDP协议。&lt;/li&gt;
&lt;li&gt;你渲染流程知道的这么详细，图层，分层，绘制，栅格化线程池，GPU加速，能不能说一下，对你开发有啥影响呢。(其实这个时候，被无情打脸了，知道这个有什么用，当时反问我)&lt;/li&gt;
&lt;li&gt;浏览器缓存。(可以拓展一下，结合webpack如何命中缓存，然后就到你熟悉的webpack领域了)&lt;/li&gt;
&lt;li&gt;浏览器进程架构历史。&lt;/li&gt;
&lt;li&gt;浏览器内核。（这个可以了解）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浏览器的垃圾回收机制&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经典八股文了，不过其实我感觉也是可以拓展的，问到浏览器缓存的时候，结合webpack谈一谈如何命中缓存的。比如讲到浏览器的渲染流程时，我们都知道里面的一些具体流程，比如分层，绘制，栅格化操作，然后其实可以结合实际去思考一下，有哪些具体的用途呢，这里我们需要借助浏览器中的performance来看看。&lt;/p&gt;
&lt;p&gt;&lt;img alt="浏览器中的performance相关.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0579d17015b145a88dd93992c6447d7d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;里面有很多关键性指标，比如 Long  Task执行的细节，跟面试官交流了下，&lt;strong&gt;排查性能问题&lt;/strong&gt;，我是如何通过这个Performance相关的细节去把握的，当然了，里面的内存使用情况，是否出现&lt;strong&gt;内存泄露&lt;/strong&gt;问题，都可以借助它。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非要我总结的话，我觉得哪怕是八股文，我们也要尽可能的展示出亮点来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近也在学习性能优化相关的部分，发现Performance相关的部分，还是有很多地方可以学习的，&lt;strong&gt;可以持续关注我&lt;/strong&gt;噢～&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;webpack相关&lt;/h3&gt;
&lt;p&gt;基本上，看我简历上写了这部分的，会问到，部分问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;webpack打包原理。&lt;/li&gt;
&lt;li&gt;import最终被webpack编译打包成什么。&lt;/li&gt;
&lt;li&gt;路由懒加载的原理是啥，能不能结合webpack说一说。&lt;/li&gt;
&lt;li&gt;写过webpack loader 或者插件吗。&lt;/li&gt;
&lt;li&gt;webpack 如何做性能优化。&lt;/li&gt;
&lt;li&gt;babel的原理了解吗，babel是用来干嘛的。&lt;/li&gt;
&lt;li&gt;说一说常见的babel库，你有使用过哪些。&lt;/li&gt;
&lt;li&gt;写过 babel 插件吗？用来干啥的？怎么写的 babel 插件&lt;/li&gt;
&lt;li&gt;知道怎么转化成 AST 的吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上考察，你是否实践过，因为自己简历上写了这方面的，可能问的比较多。&lt;/p&gt;
&lt;p&gt;比如问到babel原理可以这么答:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;babel的转译过程分为三个阶段：&lt;strong&gt;parsing、transforming、generating&lt;/strong&gt;，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ES6代码输入&lt;/li&gt;
&lt;li&gt;babylon 进行解析得到 AST&lt;/li&gt;
&lt;li&gt;plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树&lt;/li&gt;
&lt;li&gt;用 babel-generator 通过 AST 树生成 ES5 代码&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上至少得知道它大致的原理，平时如果有积累的话，其实问题不大。&lt;/p&gt;
&lt;p&gt;比如babel的话，推荐可以看看babel是如何处理async错误捕获转换的，这个有点意思，正好借这个机会跟面试官交流一下这块的知识点，个人觉得还是很有意思。&lt;/p&gt;
&lt;p&gt;学的时候，&lt;strong&gt;多折腾一下&lt;/strong&gt;，应该就问题不大了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;算法与数据结构相关&lt;/h3&gt;
&lt;p&gt;其实这块，我希望面试官问我多一些，因为大学期间，更多的精力放在算法。有幸碰到过面试官也是打过ICPC，CCPC等比赛的，曾经都是热血青年，最后因为生活，选择了向生活低头。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;聊得过程还是很愉快的～ 也是第一次，跟面试官聊到了，线段树，主席树，最小费用流，二分图匹配（匈牙利）算法，差分约束，Graham扫描法，有限状态自动机，AC自动机。&lt;/p&gt;
&lt;p&gt;似乎找回了大二的那份对算法对热情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记得退役的时候，在QQ个签上，写过这么一句话:&lt;strong&gt;我永远热爱算法，无论它虐我千百遍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能是真的熬了无数的夜，才会有这样子的感慨吧。有点跑题了，感兴趣的话，后续会更新，我是如何走上算法这条路的，最后给我的成长收获又是哪些。&lt;/p&gt;
&lt;p&gt;回到正题，至于这部分的话，我觉得没有一个很明确的范围吧，毕竟算法太广了，过一遍吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向图判断是否有环。&lt;/li&gt;
&lt;li&gt;给定一个数组，如何拆分，保证两个数组的和接近。(想到的是贪心，正解应该是dp)&lt;/li&gt;
&lt;li&gt;Json.parse()实现。&lt;/li&gt;
&lt;li&gt;常见的数据结构。&lt;/li&gt;
&lt;li&gt;数组和链表区别。&lt;/li&gt;
&lt;li&gt;时间复杂度和空间复杂度计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排序算法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;你是如何看待算法的，给你的收获是什么。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法很重要的，对你未来的发展，我觉得还是很有必要去学习的。至于怎么学，我没有能力回答这个问题，要我给建议的话，&lt;strong&gt;看书是一个选择&lt;/strong&gt;，如果要临时应对面试，刷一刷leetcode来说，只能说短期有效果。&lt;/p&gt;
&lt;p&gt;个人建议：&lt;/p&gt;
&lt;p&gt;可以结合书的内容，分专题去刷，比如动态规划dp专题很难，我记得我当时看完书后，对它的理解就很清晰了，当然做题是另外一回事，通过题目不断巩固你对一个算法知识点的理解，我觉得是没有问题的，但是至于完完全全刷leetcode，应付面试，不从最基础的开始，这样子“超车”，觉得意义不大。&lt;/p&gt;
&lt;p&gt;以上是我个人理解，&lt;strong&gt;能力有限&lt;/strong&gt;，说的不对，您就当看个笑话。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;个人经历&lt;/h3&gt;
&lt;p&gt;问到这部分的话，可能是总监面你的时候会问，也可能是hr会问，到hr环节的话，基本十拿九稳了。不过也不能大意，说不定一不留神，卡你学历啥的，一个月的面试付诸东流，还是要认真对待的，罗列了几个点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整个经历自我介绍，越详细越好，什么时候接触计算机，什么时候接触前端。&lt;/li&gt;
&lt;li&gt;整个经历中，你认为最值得骄傲的事情，最难的事情是什么。&lt;/li&gt;
&lt;li&gt;什么事情让你自豪，什么事情让你有挫败感。&lt;/li&gt;
&lt;li&gt;未来的发展，自己的规划。&lt;/li&gt;
&lt;li&gt;为什么现在才来秋招，不选择秋招。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拿我来说，我&lt;strong&gt;双非本科&lt;/strong&gt;，最担心的就是卡学历。当时hr明确问了我，你对现在的学校满意嘛，师范类的院校，怎么选择走软件工程呀，诸如此类的问题很多，无不困扰着我。&lt;/p&gt;
&lt;p&gt;不过我也不搞虚的。实话实话，为什么高中成绩差，又为什么选择软件工程，争取做到坦诚相待的态度，表达出自己最真实的想法吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;看到这里的话，可能对你来说，没有具体说明白，哪些知识点会考，哪些不会考察。&lt;/p&gt;
&lt;p&gt;我面腾讯和阿里的时候，也没有看到我这个部门具体的面试题。&lt;/p&gt;
&lt;p&gt;我觉得更重要的是，把握好&lt;strong&gt;专业技能和项目经历&lt;/strong&gt;的表达，引导面试官去往你所知道的领域交流问题，最后在这个领域拿出自己的&lt;strong&gt;杀手锏&lt;/strong&gt;，这样子面试官会更有好感，接下来的交流会更加愉快。&lt;/p&gt;
&lt;p&gt;对简历感兴趣的话，可以参考下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="个人简历模版.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/453bf44bb9864947bf318974e997f129~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;需要获取简历模板pdf的话，私信我（文末有联系方式），或者&lt;strong&gt;公众号: TianTianUp&lt;/strong&gt;回复，&lt;strong&gt;个人简历&lt;/strong&gt;，即可获取。&lt;/p&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;作为一个即将毕业的我来说，第一份工作很重要。在我面临选择的时候，慎重考虑以及找前辈交流过后，最后选择了&lt;strong&gt;腾讯&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在即将毕业的最后阶段，我应该算交上了一份满意的答卷，未来的路还很长，让我们拭目以待吧！&lt;/p&gt;
&lt;p&gt;有想交流的问题，欢迎联系我⬇️&lt;/p&gt;
&lt;p&gt;微信:DayDay2021&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后做一个简单，自由，有爱的技术人吧。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>TianTianUp</author><pubDate>Tue, 30 Mar 2021 17:34:05 GMT</pubDate></item><item><title>2020的TianTianUp在掘金| 掘金年度征文</title><link>https://juejin.cn/post/6911095991986814989</link><description>&lt;section id="nice"&gt;&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;2020个人总结，基本上是对今年的絮絮叨叨，不是啥干活，感兴趣可以看看。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020即将结束，简单回顾一下，做了哪些事情，收获了什么，哪些不足的地方，做个小结。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;2020年，我大四，似乎才刚刚开始。&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;2021年，我大四，似乎又快结束了。&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;经常这么鼓励自己➡️  为什么要进大厂呢⬇️&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;年轻时候去大厂的目标，是为了避免，【你得顿悟，是别人的基本功】&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;PS: 挤牙膏一样，还是挤不出啥东西。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;前端之旅&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020这一年，真的是波折的一年吧，一直在&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;考研和工作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;之间徘徊，不知道如何选择，想了好久，综合很多方面，于是就走上前端这条曲折又难走的道路。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我，就读于一所本科院校，没有学历光环，没有任何加分项，作为一个Acmer爱好者，跌跌撞撞的搞了算法，奈何实属菜鸡，没有拿到所谓的荣誉证明，一块icpc的奖牌都不从拥有，似乎我的大学将以失败告终！&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;那个时候是最沮丧的时候，算法组成员，很多都已经捧杯无数，似乎只有我，没有一块奖牌来证明自己。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;那个灰暗的时光，似乎过了好久。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可能是因为累了，疲倦了，大三的时候，选择遗憾的退役了，现在想一想，还是很遗憾。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020这一年春天，在前女友的鼓励下，我尝试向互联网公司投了简历，很显然，前端基础不扎实，阿里直接拒绝。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可能是太压抑了，加上之前的失意，似乎我一直都在逃避，一直到今年6🈷️。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;身边的朋友，开始陆陆续续准备考研，工作，而我，机缘巧合下，与一位学长的沟通，坚定了我的前端之路。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我的直系学长，秋招拿到美图offer，春招拿到Shopee的offer，跟他沟通后，发现很多东西都冲刷了我对前端的认知。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;6月底，开始疯狂补前端基础知识，刷题，写博客，特意翻了翻GitHub的提交记录。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="2020-掘金截图" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad013c9ab50b42018cc6f9cb80086f8e~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;2020-掘金截图&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，持续学习，持续总结，希望能赶上同届的大佬们，三元，Jack，曹佬，甘佬，林佬，现在的人太猛了，抓紧时间吧。&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;掘金&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;简单介绍一下，自己是如何知道掘金社区，并且是如何开始写作的吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020-06-24,我在大学宿舍，注册了掘金账号。百无聊赖的翻了几篇文章后，才发现，这里面有很多的文章特别如何我的胃口，总结梳理的很棒，说实话，当时看得很投入，于是乎，我跟它的故事便悄悄开始了。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;第一篇文章&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;在写这篇文章时，我特意去翻了翻我在掘金的第一篇文章，到底是哪一篇“水文”。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de92cbfc576b407d8baf4a67d172d20a~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;注册的当天，我似乎就下定了决心，希望接下来有个&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;不平凡&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的2020。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;立个flag：希望在2020秋招前完成对前端知识点的回顾总结。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这是我当时的Flag，似乎我已经完成了一些，至于多少，也许最清楚的人就是我了。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我依稀记得那个时候，JavaScript基础乃至前端基础，都十分的薄弱，与其说这么说，还不如说啥都不会，这是对我最中肯的评价了，我确实没有花时间在前端领域。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;持续写作&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;为了夯实基础，看书籍，这里推荐的就是&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;红宝石&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; ⬇️&lt;/p&gt;
&lt;img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e1b5a98123d4f74b828571e8dd61c77~tplv-k3u1fbpfcp-watermark.image" /&gt;
![个人总结-2020-红宝石](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1f168663eb748b8a8e855dc964ba4c3~tplv-k3u1fbpfcp-watermark.image)
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;啃完这本书，我觉得至少大厂的第一轮技术面试，完全是可以过的。对这本书籍的评价，绝对是一本值得你花时间去品味的书籍。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，在这里的话，我除了看书籍外，会结合很多博客，比如&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;若川&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;冴羽&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;等很多前辈的博客，很多点，看完他们对知识点的解读，完全可以get到重点。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;于是，我会把易错的点，通过笔记的方式记录下来，然后发在掘金上，很显然，一开始是没有人阅读的，这个也是我的预期，懂得都明白，我也没有把它放在心上。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;慢慢的，开始有了一些阅读量，一些人关注，给我点赞，当时对我是莫大的肯定，也一直坚定了我坚持记笔记的决心。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6846687590540640263" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「浏览器工作原理」写给女友的秘籍-浏览器组成&amp;amp;网络请求篇（1.2W字)&lt;/a&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当时看了极客的专栏，对于浏览器这块，我前所未有的对它了解的这么清楚，我记得那几天，我彻夜难眠，似乎它真的解开了我很多的心结，让我对前端体系有了更深的理解，于是我准备梳理一遍，也就是这篇文章，让我开始点赞UpUp，关注UpUp。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;很显然，学东西就是模仿，参考，借鉴创新的过程，我也勘误了原作者，还是有很多人来撕逼，其实你可以完全不去搭理他们，知识不就是如此吗，自己加深了理解，对他人有所帮助，这就够了，说明你理解到位了。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;如何坚持写，如何鼓励自己&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;上篇讲到，很多时间，你会受到很多的质疑，我举个例子：&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="Git命令" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c919f55501aa496b9b2c163de630d2d8~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;Git命令&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;就拿这个来说，Git命令很简单，为啥这样子的文章，有1800+👍，4W万阅读呢？&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;如果我现在看来，根本不需要记那么多命令行，直接用SourceTree这个工具托管，不香吗，它真的香！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;这个时间点，我真好刚刚入职网易，当时开发流程上，有很多不清楚地方，每次更同事合并分支的时候，会遇到些问题，当然了，操作了两遍，就会了，难道这么简单的东西，不是实践几遍就会吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;我写这个初衷是因为有些时候，比如版本回退，有些很难记的东西，需要查资料，还不如，我总结出来，做个脑图，方便以后工作需要。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可是工作不久，等我接触了SourceTree时，我觉得我这篇文章，其实没有必要了，太香了，基本上能满足你日常的开发需求。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;很多时候，你会受到质疑，为啥这么简单的内容，你都要做笔记，你应该这么对自己说，不同的阶段，你会遇到不同阶段的事情，可能过不了多久，你就会觉得之前写的东西很傻，但这不影响你成长，这更是一种对自我的对比，知道接下来如何梳理总结出更加满意的内容。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，有点跑题，我希望传达的意思就是：做自己认为对的事情，写作分享是一件有意义的事情，至于内容的好坏，取决于不同读者对它的解读，我们需要的保持初心，坚持写下去。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;算法&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;本着作为半个Acmer出身，虽然退役了，但是依旧热爱算法，所以把算法给梳理了一遍，花了两个月时间吧，写作不易，也比较用心的去梳理一遍，每个点难理解地方，如何利用技巧去解读它，这里就列一下吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6900698814093459463" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」你可能需要的一份前端算法总结&lt;/a&gt;（910+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6888451657504391181" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」Trie树之美&lt;/a&gt;（200+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6885104477297344525" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」分治算法之美&lt;/a&gt;（190+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6882394656148045838" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这是部分链接，当然了，你需要每个专题的题集的话，我这边也有一份不错的leetcode题集PDF，可以来找我领取噢～&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;贵人相助&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;在这最艰难的7，8月内，是最难熬的一段时间了，在掘金这个社区，认识一堆人，我们虽然隔着屏幕，分享着一些囧事，分享着前端领域中遇到的难题，有时候，会在各自坚持不下去的时候，互相鼓励，有时候，你需要的可能就是能倾诉的朋友吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;太多小伙伴了，这里就不提及了，我可能最要感激的一个人，就是&lt;a href="https://juejin.cn/user/764915822103079" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;@阿宝哥&lt;/a&gt; 。有时候，有人给你引导如何去规划，如何做出做得更好，如何规划接下来的路，宝哥就是这么一个人，帮我找工作，帮我安排其他一些事情，教我如何做好一个公众号等等。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;希望下次去厦门的生活，能跟宝哥搓一顿饭。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;小结&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;写的再多，都无法描述，我在2020这一年夏天，7月，8月所发生的事情，可能这两个月，对我的意义非凡吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;希望这份简简单单的描述，对现在的你，有那么一点点帮助的话，也许它就有存在的意义了吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;坚持+运气+拼命，似乎一切都来了。&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;网易&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当时投的公司就三家左右吧，匆匆忙忙的投递，嗯，网易的流程很快，算下来，两天的时间就走完了，基本上就敲定了它。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;面试回顾&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我印象中，可能是四轮技术面吧，应该没有记错的话。&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;一面技术电话面，记得是一个周五的上午，是个声音非常nice的小哥哥。基本上大厂的电话面都属于简历评估环节吧，简单的聊了30分钟，问的都是前端基础，没有问算法。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;二面技术视频面，全程高冷，基本上抛出问题，让我回答，当时很紧张吧，有些地方回答不是很好，手写一些常见api，接着写了两道算法题，感觉写的一般，整体下来，只能说面评一般。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;三面技术，还是视频面。也就是我现在的导师，可能就是她的微笑吧，看我问题答错了，也是通过微笑来缓解，整体来说，问的难度还能接受，目前看来，导师非常nice。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;四面技术面，依旧是视频面，目前团队的leader，全程70分钟，问了三个大的场景题，嗯，还有些课程相关的问题。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;五面+hr面，几分钟结束战斗。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这里是面经，感兴趣可以看看。&lt;/p&gt;
&lt;h6 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 16px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;a href="https://juejin.cn/post/6862855292577644552" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「面经」你可能需要的三轮网易面经&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h6&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;翻了翻朋友圈，当时感觉整个团队偏年轻化，字里行间可以看得出有多高兴～&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/973a117409a645fa9469901df05a2756~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;转眼间，4个月过去了，收获也是巨大的～，这里离不开导师mentor对我的帮助，还是很幸运遇到非常nice的导师。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;从产品提需求，到需求定稿，开会评估工期，跟UI同事沟通好，以及和测试说好提测时间，接着就是bugfix，正常上线。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;看着自己负责的板块，如期上线，原来，我写的东西也被数以万计的用户使用～&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，项目上线后，也会出现bug，嗯，定位bug原因，bugfix，然后提测，一般而言，遇到小bug跟随下一个版本发，重大的bug话，通常采用hotfix热更新办法，嗯，基本上整个流程都走了一遍了吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;还记得当时debug的时候，定位问题，到解决问题的过程⬇️&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="个人总结-2020-bugfix.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30d165f916f64507a70b4a4c3d3d30a1~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;个人总结-2020-bugfix&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那是一个难熬的夜晚，现在想一想，确实很”程序员“。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;谈起网易，很多人都会想到🐷厂伙食，没错，几个月下来，都胖了一圈了。&lt;/p&gt;
&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66b678dee2f249978347cab885ac7161~tplv-k3u1fbpfcp-watermark.image" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;2021新期待&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;希望能合理把生活，工作，学习，公众号，这几方面安排妥当。&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;React源码系列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;前端工程化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;node&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;最后期待粉丝**10000+**吧，能认识更多有趣的人。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，留个联系方式，微信: &lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;DayDay2021&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;, 期待我们能有交流。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;目前我的文章都会发在公众号「&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;前端UpUp&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;」上，感兴趣的朋友可以关注一下&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Sun, 27 Dec 2020 16:22:38 GMT</pubDate></item><item><title>「算法与数据结构」你可能需要的一份前端算法总结</title><link>https://juejin.cn/post/6900698814093459463</link><description>&lt;hr /&gt;
&lt;h1&gt;主题列表：juejin, github, smartblue, cyanosis, channing-cyan, fancy, hydrogen, condensed-night-purple, greenwillow, v-green, vue-pro&lt;/h1&gt;
&lt;h1&gt;贡献主题：https://github.com/xitu/juejin-markdown-themes&lt;/h1&gt;
&lt;h2&gt;theme: juejin
highlight:smartblue&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近好多事情，最近前端分享会也如期而至，有幸这次分享会，正好周末有时间，做个总结吧。&lt;/p&gt;
&lt;p&gt;这次想分享的就是&lt;strong&gt;算法与数据结构&lt;/strong&gt;，刷了一段时间题目，逛了逛LeetCode，看了很多关于这个方面的文章，有所感悟，准备做个记录吧。&lt;/p&gt;
&lt;p&gt;当你想花时间去了解学习一件对你来说，很苦难的事情的时候，我们需要明确目标，学习它的意义，它有什么用，对你有哪方面帮助。&lt;/p&gt;
&lt;p&gt;升职加薪必备，对以后成长有所帮助，嗯，加薪，加薪，加薪。&lt;/p&gt;
&lt;p&gt;那么问题来了，为什么要进大厂呢⬇️&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;年轻时候去大厂的目标，是为了避免，【你得顿悟，是别人的基本功】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，闲聊就止步于此，接下来开始吧～&lt;/p&gt;
&lt;p&gt;站在巨人肩膀上，学起来就很轻松了， 这里我是参考网上的算法刷题路线，可以参考一下～&lt;/p&gt;
&lt;p&gt;公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，回复&lt;strong&gt;算法&lt;/strong&gt;，即可获取脑图，以及文末的题目汇总pdf。&lt;/p&gt;
&lt;p&gt;&lt;img alt="算法与数据结构" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cabe509f34e40a28ea46191b72689ec~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们就根据这个脑图来梳理一遍吧~&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;数据结构&lt;/h2&gt;
&lt;p&gt;数据结构可以说是算法的基石，如果没有扎实的数据结构基础，想要把算法学好甚至融会贯通是非常困难的，而优秀的算法又往往取决于你采用哪种数据结构。学好这个专题也是很有必要的，那么我们可以稍微的做个分类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常用数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组，字符串&lt;/li&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高级数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图&lt;/li&gt;
&lt;li&gt;前缀树&lt;/li&gt;
&lt;li&gt;线段树&lt;/li&gt;
&lt;li&gt;树状数组&lt;/li&gt;
&lt;li&gt;主席树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么显然，最常见的数据结构一定是需要掌握的，对于高级的数据结构而言，如果你有时间，对它有所热爱的话，可以深入了解，比如这个&lt;strong&gt;主席树&lt;/strong&gt;在解决一些问题 的时候，算法复杂度是log级别的，某些场景下很有帮助。&lt;/p&gt;
&lt;p&gt;这里想提及的就是&lt;strong&gt;树&lt;/strong&gt;。它的结构很显然是很直观的，树当然有很多的性质，这里也列举不完，比如面试中常考的树：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于它而言的话，我们需要到哪些程度呢？&lt;/p&gt;
&lt;p&gt;对于常见树的遍历，从树的前序遍历，到中序遍历，后续遍历，以至于层次遍历，掌握好这四种遍历的递归写法和非递归写法是非常重要的，接下来需要懂得分析各种写法的时间复杂度和空间复杂度。&lt;/p&gt;
&lt;p&gt;面试准备阶段，把树这个结构花时间去准备的话，对于你理解递归还是很有帮助的，同时也能帮助你学习一些图论的知识，更加准确的说，树是面试考察的热门考点，尤其是二叉树！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;掌握好这些数据结构是基础，绝大部分的算法面试题都得靠它们来帮忙，因此，一定要花功夫勤练题目来深入理解它们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;排序算法&lt;/h2&gt;
&lt;p&gt;这应该是面试最常考，最核心的算法。如果你能把排序算法理解的很透彻的话，接下来的其他算法也是一样的旁敲侧击。&lt;/p&gt;
&lt;p&gt;当时我梳理得是常见的6个排序算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-1"&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-5"&gt;计数排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-9"&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-13"&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-17"&gt;插入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-21"&gt;选择排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在此之前，我也写过一篇排序算法的文章，个人觉得言简意赅，可以看看&lt;a href="https://juejin.cn/post/6856546833025237006"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有时候，面试官喜欢会问冒泡排序和插入排序，基本上这些都是考察你的基础知识，并且看看你能不能快速地写出没有bug的代码。&lt;/p&gt;
&lt;p&gt;又比如，当面试官问你归并排序、快速排序和拓扑排序等的时候，这个时候考察的是你平时对算法得积累，所以有必要做个总结。&lt;/p&gt;
&lt;p&gt;我们拿&lt;strong&gt;归并排序&lt;/strong&gt;来举例子，我们应该如何表达清楚呢？首先，我们应该把这个它的思路说清楚：&lt;/p&gt;
&lt;p&gt;归并排序的核心思想就是分治，它将一个复杂的问题分成两个或者多个相同或相似的子问题，然后把子问题分成更小的子问题，直到子问题可以简单的直接求解，最原问题的解就是子问题解的合并。&lt;strong&gt;归并排序&lt;/strong&gt;将分治的思想体现得淋漓尽致。&lt;/p&gt;
&lt;p&gt;当你向面试官理清楚这个思路时，面试官心里就有底了，他会想，嘿，这个小伙子不错！那你接下来都有底气了！&lt;/p&gt;
&lt;p&gt;有了思想，那么实现起来就不难了:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一开始先把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，才开始排序。&lt;/p&gt;
&lt;p&gt;排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;贴一份之前的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const merge = (left, right) =&amp;gt; { // 合并数组

    let result = []
    // 使用shift()方法偷个懒,删除第一个元素,并且返回该值
    while (left.length &amp;amp;&amp;amp; right.length) {
        if (left[0] &amp;lt;= right[0]) {
            result.push(left.shift())
        } else {
            result.push(right.shift())
        }
    }
    while (left.length) {
        result.push(left.shift())
    }

    while (right.length) {
        result.push(right.shift())
    }
    return result
}

let mergeSort = function (arr) {
    if (arr.length &amp;lt;= 1)
        return arr
    let mid = Math.floor(arr.length / 2)
    // 拆分数组
    let left = arr.slice(0, mid),
        right = arr.slice(mid);
    let mergeLeftArray = mergeSort(left),
        mergeRightArray = mergeSort(right)
    return merge(mergeLeftArray, mergeRightArray)
}

// let arr = [2, 9, 6, 7, 4, 3, 1, 7, 0, -1, -2]
// console.log(mergeSort(arr))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于这部分的算法而言，可以围绕从&lt;strong&gt;解题思路&lt;/strong&gt;--&amp;gt;&amp;gt;&lt;strong&gt;实现过程&lt;/strong&gt;--&amp;gt;&amp;gt;&lt;strong&gt;代码实现&lt;/strong&gt;。 基本上以这三步来实现的话，掌握常见的排序算法完成是没有问题的。&lt;/p&gt;
&lt;p&gt;那么这部分就暂时梳理到这里吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;动态规划&lt;/h2&gt;
&lt;p&gt;动态规划难，可以说是很多面试者也是我最怕的部分，尤其是面试的时候，怕面试官考这个算法了。遇到没有做过的题目，这个时候，能否写出状态转移方程是十分重要的。接下来我们聊一聊这个专题吧。&lt;/p&gt;
&lt;p&gt;首先，强烈推荐我之前分析这个专题如何准备的： &lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果从点赞角度来看，可以说，是我写算法以来，得到大家肯定最多的一次了，可以看看，不过这里也会涵盖部分。&lt;/p&gt;
&lt;p&gt;如何学动态规划，从哪里入手，应该这么去做，这么去刷题，肯定是很多初学者一开始就会遇到的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;动态规划解决了什么问题&lt;/li&gt;
&lt;li&gt;动态规划解题的步骤&lt;/li&gt;
&lt;li&gt;如何高效率刷dp专题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，你得了解动态规划是什么，它的思想是什么，定义又是啥。这里引入维基百科对它的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Wikipedia 定义：它既是一种数学优化的方法，同时也是编程的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然了，看完这段话，我们肯定对它不了解的，我们可以翻译一下，首先它可以算是一种优化的手段，优化一些重复子问题的操作，将很多重叠子问题通过编程的方式来解决，比如&lt;strong&gt;记忆划搜索&lt;/strong&gt;。 又比如，如果一个原问题，可以拆分成很多子问题，它们之间没有任何后续性，当前的决策对后续没有影响的话，每个子问题的最优解，就可以组合成原问题的最优解了。&lt;/p&gt;
&lt;p&gt;当然了，对于动态规划每个人理解是不同的，对于应用到具体的场景中，需要我们都去用多维度的状态去表述它的含义，这里也就是状态转移方程的含义所在。&lt;/p&gt;
&lt;p&gt;嗯，那么动态规划解决了什么问题呢，很显然，对于重复性问题来说，它可以很好的解决，那么从某个维度上来看，它可以优化一个算法的时间复杂度，也就是通常意义上的，拿空间来换取时间的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态规划解题步骤&lt;/strong&gt;： 这个应该就是实际落地的操作，需要我们去通过大量的题目来完成，具体我们需要怎么做呢？&lt;/p&gt;
&lt;p&gt;解题思路，三大步骤👇&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;状态定义&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列出状态转移方程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;强烈推荐这篇问题，里面讲的很清楚了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何高效率刷dp专题&lt;/strong&gt;：首先，你得找到对应的dp专题，这里的话，我帮你准备好了，接下来我说一下我是怎么刷leetcode上面的题目的。&lt;/p&gt;
&lt;p&gt;一般而言，刷完中等的leetcode上的dp专题，基本上可以满足要求了。那么对于中等的dp题目，很多时候，我是写不吃来的，那我应该如何去做呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，我先看题解，把它的状态转移方程写下来，仔细的品味一下，它这么定义，解决了我之前的什么难点，为啥我是没有想到的。&lt;/li&gt;
&lt;li&gt;然后，看完之后，尝试按照这个题解思路，我自己能不能单独实现呢？&lt;/li&gt;
&lt;li&gt;如果不能的话，就照着它的代码，写一遍，多看看状态转移方程是如何写的，把这个题目收藏起来。&lt;/li&gt;
&lt;li&gt;等到下次，或者是隔天，再来看一遍题目，然后看看能不能单独完成，如果不能，第三天再这么操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有，我个人建议，刷dp的话，最好从易到难，这样子自己也会有信心，也不会再去畏惧它。&lt;/p&gt;
&lt;h3&gt;进阶题目汇总&lt;/h3&gt;
&lt;p&gt;以下是我收集的部分题目，希望对你们有帮助。&lt;/p&gt;
&lt;h4&gt;简单&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/climbing-stairs/"&gt;爬楼梯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/house-robber/"&gt;打家劫舍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/"&gt;使用最小花费爬楼梯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/contiguous-sequence-lcci/"&gt;连续数列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/"&gt;三步问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;中等&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/house-robber-ii/"&gt;打家劫舍 II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/"&gt;最佳买卖股票时机含冷冻期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/house-robber-iii/"&gt;打家劫舍 III&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/unique-paths/"&gt;不同路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/unique-paths-ii/"&gt;不同路径 II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/"&gt;最长上升子序列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;困难&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/"&gt;买卖股票的最佳时机 III&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/"&gt;买卖股票的最佳时机 IV&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/frog-jump/"&gt;青蛙过河&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/word-break-ii/"&gt;单词拆分 II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/max-submatrix-lcci/"&gt;最大子矩阵&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;搜索算法&lt;/h2&gt;
&lt;p&gt;这部分也是尤其重要的，那么重点学习深度优先搜索算法（简称为 DFS）和广度优先搜索算法（简称为 BFS）。&lt;/p&gt;
&lt;p&gt;我翻了翻我的博客，恰好有一篇类似的问题，大家可以看看**「算法与数据结构」DFS和BFS算法之美**。&lt;/p&gt;
&lt;p&gt;不过，我看了一下，我当时写得时候，有点粗糙，很多基本的概念都没有讲明白，所以可能适合一些对这部分有基础的小伙伴。&lt;/p&gt;
&lt;p&gt;在这里推荐一个有趣的题目：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-with-rotations/"&gt;穿过迷宫的最少移动次数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你也遇到过迷宫类似的问题，就可以考虑搜索算法了，从我个人的角度来说，它的思路其实就是模拟人的思路，每次走到一个路口的时候，我可以走哪里，我之前走过的路，怎么确保，接下来是不能走的，这里需要在编程的角度，如何去实现呢？&lt;/p&gt;
&lt;p&gt;这里说一说我的经验，对于刚刚提到的题目而言，我盲猜使用BFS，题目做多了，自然就会有心得，对于BFS和DFS而言，做了两个类似的题目，会发现，原来搜索算法也是有迹可循，也是存在某些套路的。&lt;/p&gt;
&lt;p&gt;给些建议：&lt;/p&gt;
&lt;p&gt;一开始可能做的时候，抓不到头脑，有思路，但是代码很难写清楚，那么如何去做呢？ &lt;strong&gt;看题解&lt;/strong&gt;，了解别人的写法是很不错的，可以多个对比，看看哪一份题解代码是你目前可以理解的，然后抄下来，看一遍。&lt;/p&gt;
&lt;p&gt;最普通的办法就是：先画图，看看思维上跟实际代码需要做哪些改变，如何去优化这个过程。最后结合别人代码，一定不要直接copy，不去思考为什么这么写，不然后期发现，是没有多大效果的，一定要多结合自己的理解。&lt;/p&gt;
&lt;p&gt;嗯，不会就看题解，多思考为什么这么写！！！&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;写到这里的时候，已经凌晨1点了，算法与数据结构这个方向太大了，一篇文章不可能写得完，我更希望这篇文章对你，有那么一点点的帮助，对我，或你都些许有所帮助，那么它得存在就有那么一点点意义。&lt;/p&gt;
&lt;p&gt;以下是我刷的题集，需者自取，公众号：&lt;strong&gt;前端UpUp&lt;/strong&gt;，关注它，找我领pdf文档也可以。&lt;/p&gt;
&lt;h3&gt;进阶题目汇总&lt;/h3&gt;
&lt;p&gt;这个专题想进阶，就刷我下面提供的题目吧👇&lt;/p&gt;
&lt;h3&gt;DFS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/"&gt;二叉树的最大深度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/"&gt;二叉树的最小深度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/friend-circles/"&gt;朋友圈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/find-eventual-safe-states/"&gt;找到最终的安全状态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/"&gt;矩阵中的最长递增路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minesweeper/"&gt;扫雷游戏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/word-ladder/"&gt;单词接龙&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;BFS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/"&gt;N叉树的层序遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/"&gt;二叉树的层序遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-height-trees/"&gt;最小高度树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minesweeper/"&gt;扫雷游戏&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;题目汇总&lt;/h2&gt;
&lt;p&gt;我之前刷题历程是根据这套题来的，我觉得里面题目梯度还是质量都是很不错的。&lt;/p&gt;
&lt;p&gt;拿到这个pdf有段时间了，所以不清楚具体作者是谁，有侵权的话，可删。&lt;/p&gt;
&lt;h3&gt;数组&amp;amp;链表&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/rotate-array/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/merge-two-sorted-lists/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/merge-sorted-array/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/swap-nodes-in-pairs/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/3sum/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Map &amp;amp; Set&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/valid-anagram/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/group-anagrams/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;堆栈&amp;amp;队列&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-outermost-parentheses/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/largest-rectangle-in-histogram/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/trapping-rain-water/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二分查找&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/arranging-coins/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/powx-n/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/dungeon-game/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;递归&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/symmetric-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-paths/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/range-sum-of-bst/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;哈希表&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/two-sum/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/valid-anagram/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/top-k-frequent-words&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/number-of-atoms/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二叉树&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/symmetric-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二叉搜索树&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/validate-binary-search-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/range-sum-of-bst/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/contains-duplicate-iii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;图&lt;/h3&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/number-of-islands/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/course-schedule-ii&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;堆和排序&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/find-median-from-data-stream/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DFS&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/friend-circles/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/find-eventual-safe-states/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minesweeper/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/word-ladder/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;BFS&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/binary-tree-level-order-traversal-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minesweeper/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-height-trees/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Trie树&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/longest-word-in-dictionary/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/implement-trie-prefix-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/word-search-ii/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;分治算法&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/majority-element/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-subarray/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/search-a-2d-matrix-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;回溯算法&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/letter-case-permutation/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/subsets/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/permutations/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/combinations/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/n-queens/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;贪心算法&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/assign-cookies/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;动态规划&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/climbing-stairs/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/house-robber/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/house-robber-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/house-robber-iii/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/unique-paths/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/unique-paths-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;❤️ 感谢大家&lt;/h2&gt;
&lt;p&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/li&gt;
&lt;li&gt;关注公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，联系作者👉 &lt;strong&gt;DayDay2021&lt;/strong&gt; ，我们一起学习一起进步。&lt;/li&gt;
&lt;li&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6888451657504391181"&gt;「算法与数据结构」Trie树之美&lt;/a&gt;（200+👍）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6885104477297344525"&gt;「算法与数据结构」分治算法之美&lt;/a&gt;（190+👍）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6861376131615227912"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6874708801208254478"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6882394656148045838"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description><author>TianTianUp</author><pubDate>Sun, 29 Nov 2020 16:06:46 GMT</pubDate></item><item><title>「算法与数据结构」二叉树之美</title><link>https://juejin.cn/post/6890680584033533960</link><description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这次梳理的内容是数据结构专题中的&lt;strong&gt;树&lt;/strong&gt;，如果你看到&lt;code&gt;树&lt;/code&gt;这类数据结构时，满脑子头疼，觉得它很难理解，如果是这样子的话，那么本文可能对你或许有点帮助。&lt;/p&gt;
&lt;p&gt;俗话说得好，要想掌握理解的话，我们得先了解它的概念，性质等内容。&lt;/p&gt;
&lt;p&gt;围绕以下几个点来展开介绍树👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树的基本概念&lt;/li&gt;
&lt;li&gt;基本术语&lt;/li&gt;
&lt;li&gt;树的种类&lt;/li&gt;
&lt;li&gt;二叉树概念&lt;/li&gt;
&lt;li&gt;二叉树的遍历&lt;/li&gt;
&lt;li&gt;二叉树题目汇总&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，回复&lt;strong&gt;二叉树&lt;/strong&gt;，即可获取脑图。&lt;/p&gt;
&lt;p&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;p&gt;脑图👇&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/345ae35ff7c040cf893fc9b0f06dbb52~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;树的基本概念&lt;/h2&gt;
&lt;p&gt;树是用来模拟具有树状结构性质的数据集合。或者你可以把它认为是一种&lt;strong&gt;抽象数据结构&lt;/strong&gt;或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。&lt;/p&gt;
&lt;p&gt;那么根据维基百科给出的定义，我们似乎可以这么理解：&lt;/p&gt;
&lt;p&gt;它是由n（n&amp;gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;每个节点都只有有限个子节点或无子节点；&lt;/li&gt;
&lt;li&gt;没有父节点的节点称为根节点；&lt;/li&gt;
&lt;li&gt;每一个非根节点有且只有一个父节点；&lt;/li&gt;
&lt;li&gt;除了根节点外，每个子节点可以分为多个不相交的子树；&lt;/li&gt;
&lt;li&gt;树里面没有环路(cycle)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个时候，我们就需要拿出一张图来看👇&lt;/p&gt;
&lt;p&gt;&lt;img alt="树的概念" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a797132557334101a5af5631068d230b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从图中来看，以上的五个特点都可以很好的总结出来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A节点作为根节点，没有父节点，所以是根节点。&lt;/li&gt;
&lt;li&gt;除根节点（A）外，其他的节点都有父节点，并且每个节点只有有限个子节点或无子节点。&lt;/li&gt;
&lt;li&gt;从某个节点开始，可以分为很多个子树，举个例子，从B节点开始，即是如此。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然对树有一定认识后，我们需要了解它的一些术语。&lt;/p&gt;
&lt;h2&gt;基本术语&lt;/h2&gt;
&lt;p&gt;&lt;img alt="树的基本术语" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffe6a7a99096480c8077c53912a1ccc8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为了更加规范的总结，这里给出的描述来自于维基百科：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;节点的度&lt;/strong&gt;：一个节点含有的子树的个数称为该节点的度；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的度&lt;/strong&gt;：一棵树中，最大的节点度称为树的度；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;叶节点&lt;/strong&gt;或&lt;strong&gt;终端节点&lt;/strong&gt;：度为零的节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非终端节点&lt;/strong&gt;或&lt;strong&gt;分支节点&lt;/strong&gt;：度不为零的节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;父亲节点&lt;/strong&gt;或&lt;strong&gt;父节点&lt;/strong&gt;：若一个节点含有子节点，则这个节点称为其子节点的父节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;孩子节点&lt;/strong&gt;或&lt;strong&gt;子节点&lt;/strong&gt;：一个节点含有的子树的根节点称为该节点的子节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兄弟节点&lt;/strong&gt;：具有相同父节点的节点互称为兄弟节点；&lt;/li&gt;
&lt;li&gt;节点的&lt;strong&gt;层次&lt;/strong&gt;：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;深度&lt;/strong&gt;：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高度&lt;/strong&gt;：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堂兄弟节点&lt;/strong&gt;：父节点在同一层的节点互为堂兄弟；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点的祖先&lt;/strong&gt;：从根到该节点所经分支上的所有节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子孙&lt;/strong&gt;：以某节点为根的子树中任一节点都称为该节点的子孙；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;森林&lt;/strong&gt;：由m（m&amp;gt;=0）棵互不相交的树的集合称为森林。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以结合上述的图来理解这些概念，通过两者的结合，你一定会对树有进一步的了解的。&lt;/p&gt;
&lt;p&gt;有以上基本概念，以及一些专业术语的掌握，接下来我们需要对树进行一个分类，看看树有哪些种类。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;树的种类&lt;/h2&gt;
&lt;p&gt;理解了树的概念以及基本术语，接下来，我们需要拓展的内容就是树的种类。&lt;/p&gt;
&lt;p&gt;我们可以根据维基百科的依据来作为分类的标准👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为&lt;a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E6%A0%91"&gt;自由树&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；
&lt;ul&gt;
&lt;li&gt;二叉树：每个节点最多含有两个子树的树称为二叉树；
&lt;ul&gt;
&lt;li&gt;完全二叉树：对于一颗二叉树，假设其深度为d（d&amp;gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"&gt;满二叉树&lt;/a&gt;：所有叶节点都在最底层的完全二叉树；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"&gt;平衡二叉树&lt;/a&gt;（&lt;a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91"&gt;AVL树&lt;/a&gt;）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；&lt;/li&gt;
&lt;li&gt;排序二叉树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91"&gt;霍夫曼树&lt;/a&gt;：&lt;a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84&amp;amp;action=edit&amp;amp;redlink=1"&gt;带权路径&lt;/a&gt;最短的二叉树称为哈夫曼树或最优二叉树；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/B%E6%A0%91"&gt;B树&lt;/a&gt;：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然树的分类有这么多的话，那么我们是不是都需要一一掌握呢，我个人觉得，掌握二叉树这种结构就足够了，它也是树最简单、应用最广泛的种类。&lt;/p&gt;
&lt;p&gt;那么接下来，我们就来介绍一下二叉树吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;二叉树的概念&lt;/h2&gt;
&lt;p&gt;二叉树是一种典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。&lt;/p&gt;
&lt;p&gt;&lt;img alt="二叉树" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928edb599f30491c8f62935da572a0eb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;图片来自网络，具体出处不明。&lt;/p&gt;
&lt;p&gt;从这个图片的内容来看，应该很清楚的展示了二叉树的结构。&lt;/p&gt;
&lt;p&gt;至于二叉树的性质的话，可以参考下图，作为补充知识吧，个人觉得这个不是重点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="二叉树的性质" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a977e2da02a847ad92c68adcbfd05a27~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;重点的话，我们需要掌握的应该是它的遍历方式。&lt;/p&gt;
&lt;h2&gt;二叉树的遍历&lt;/h2&gt;
&lt;p&gt;我们知道对于二叉树的遍历而言，有常见得三种遍历方式，分别是以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历&lt;/li&gt;
&lt;li&gt;中序遍历&lt;/li&gt;
&lt;li&gt;后序遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于任何一种遍历方式而言，我们不仅需要掌握它的非递归版本，同时对于它的递归版本来说，更是考察一个人的算法基本功，那么接下来，我们来看看吧。&lt;/p&gt;
&lt;h3&gt;前序遍历&lt;/h3&gt;
&lt;p&gt;点击这里，练习&lt;a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/"&gt;二叉树的前序遍历&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回它节点值的 &lt;strong&gt;前序&lt;/strong&gt; 遍历。&lt;/p&gt;
&lt;p&gt;假设我们mock一下假数据👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;输入: [1,null,2,3]
   1
    \
     2
    /
   3
输出: [1,3,2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么根据我们对前序遍历的理解，我们可以写出解题伪代码👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;//   TianTianUp
//   * function TreeNode(val, left, right) {
//   *     this.val = (val===undefined ? 0 : val)
//   *     this.left = (left===undefined ? null : left)
//   *     this.right = (right===undefined ? null : right)
//   * }
let preorderTraversal  = (root, arr = []) =&amp;gt; {
    if(root) {
      arr.push(root.val)
      preorderTraversal(root.left, arr)
      preorderTraversal(root.right, arr)
    }
    return arr
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本👇&lt;/p&gt;
&lt;p&gt;对于非递归的话，我们需要借助一个数据结构去存储它的节点，需要使用的就是栈，它的思路可以借鉴👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点为目标节点，开始向它子节点遍历&lt;/li&gt;
&lt;li&gt;1.访问目标节点&lt;/li&gt;
&lt;li&gt;2.左孩子入栈 -&amp;gt; 直至左孩子为空的节点&lt;/li&gt;
&lt;li&gt;3.节点出栈，以右孩子为目标节点，再依次执行1、2、3&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;  let preorderTraversal = (root, arr = []) =&amp;gt; {
    const stack = [], res = []
    let current = root
    while(current || stack.length &amp;gt; 0) {
      while (current) {
        res.push(current.val)
        stack.push(current)
        current = current.left
      }
      current = stack.pop()
      current = current.right
    }
    return res
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;中序遍历&lt;/h3&gt;
&lt;p&gt;给定一个二叉树，返回它的中序 遍历。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [1,null,2,3]
1
&lt;br /&gt;
2
/
3&lt;/p&gt;
&lt;p&gt;输出: [1,3,2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进阶: 递归算法很简单，你可以通过迭代算法完成吗？&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;递归版本👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const inorderTraversal  = (root, arr = []) =&amp;gt; {
  if(root) {
    inorderTraversal(root.left, arr)
    arr.push(root.val)
    inorderTraversal(root.right, arr)
  }
  return arr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本，这里就不解释了，跟前序遍历一样，思路一样，用栈维护节点信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const inorderTraversal = (root, arr = []) =&amp;gt; {
  const stack = [], res = []
  let current = root
  while(current || stack.length &amp;gt; 0) {
    while (current) {
      stack.push(current)
      current = current.left
    }
    current = stack.pop()
    res.push(current.val)
    current = current.right
  }
  return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;后续遍历&lt;/h3&gt;
&lt;p&gt;给定一个二叉树，返回它的 后序 遍历。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [1,null,2,3]&lt;br /&gt;
1
&lt;br /&gt;
2
/
3&lt;/p&gt;
&lt;p&gt;输出: [3,2,1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进阶: 递归算法很简单，你可以通过迭代算法完成吗？&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;递归版本👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const postorderTraversal  = (root, arr = []) =&amp;gt; {
  if(root) {
    postorderTraversal(root.left, arr)
    postorderTraversal(root.right, arr)
    arr.push(root.val)
  }
  return arr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本👇&lt;/p&gt;
&lt;p&gt;其实，嗯，做完前面两个后，会发现都是有套路滴~&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const postorderTraversal = (root, arr = []) =&amp;gt; {
  const stack = [], res = []
  let current = root, last = null  // last指针记录上一个节点
  while(current || stack.length &amp;gt; 0) {
    while (current) {
      stack.push(current)
      current = current.left
    }
    current = stack[stack.length - 1]
    if (!current.right || current.right == last) {
      current = stack.pop()
      res.push(current.val)
      last = current
      current = null              // 继续弹栈
    } else {
      current = current.right
    }
  }
  return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/"&gt;二叉树的层次遍历 ⭐⭐&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/"&gt;二叉树的层序遍历&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给你一个二叉树，请你返回其按 &lt;strong&gt;层序遍历&lt;/strong&gt; 得到的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;p&gt;示例：
二叉树：[3,9,20,null,null,15,7],&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;/ &lt;br /&gt;
9  20
/  &lt;br /&gt;
15   7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回其层次遍历结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[
[3],
[9,20],
[15,7]
]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;递归版本👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const levelOrder = function(root) {
  if(!root) return []
  let res = []
  dfs(root, 0, res)
  return res
}

function dfs(root, step, res){
  if(root){
      if(!res[step]) res[step] = []
      res[step].push(root.val)
      dfs(root.left, step + 1, res)
      dfs(root.right, step + 1, res)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本👇&lt;/p&gt;
&lt;p&gt;这里借助的就是队列这个数据结构，先进先出的机制。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const levelOrder = (root) =&amp;gt; {
  let queue = [], res = []
  if (root) queue.push(root);
  while (queue.length) {
      let next_queue = [],
          now_res = []
      while (queue.length) {
          root = queue.shift()
          now_res.push(root.val)
          root.left &amp;amp;&amp;amp; next_queue.push(root.left)
          root.right &amp;amp;&amp;amp; next_queue.push(root.right)
      }
      queue = next_queue
      res.push(now_res)
  }
  return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;题目汇总&lt;/h2&gt;
&lt;p&gt;还是那句话，题目做不完的，剩下的就靠刷leetcode了，我还准备了一些常见的二叉树题集，题目的质量还是不错的👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/"&gt;二叉树的最小深度⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/"&gt;二叉树的最大深度⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/same-tree/"&gt;相同的树⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/range-sum-of-bst/"&gt;二叉搜索树的范围和⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/symmetric-tree/"&gt; 对称二叉树⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/"&gt;将有序数组转换为二叉搜索树⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/"&gt;二叉树的层次遍历 II⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/"&gt;二叉树的最近公共祖先⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/validate-binary-search-tree/"&gt;验证二叉搜索树⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/path-sum-iii/"&gt;路径总和 III⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/contains-duplicate-iii/"&gt;存在重复元素 III⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/"&gt;计算右侧小于当前元素的个数⭐⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;❤️ 感谢大家&lt;/h2&gt;
&lt;p&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关注公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，联系作者👉 &lt;strong&gt;DayDay2021&lt;/strong&gt; ，我们一起学习一起进步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6888451657504391181"&gt;「算法与数据结构」Trie树之美&lt;/a&gt;（200+👍）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6885104477297344525"&gt;「算法与数据结构」分治算法之美&lt;/a&gt;（190+👍）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6861376131615227912"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6856546833025237006"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6874708801208254478"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6882394656148045838"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6850418120755494925"&gt;「算法与数据结构」链表的9个基本操作(190+👍)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description><author>TianTianUp</author><pubDate>Mon, 02 Nov 2020 16:06:16 GMT</pubDate></item><item><title>「算法与数据结构」Trie树之美</title><link>https://juejin.cn/post/6888451657504391181</link><description>&lt;section id="nice" style="padding: 0 10px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px;"&gt;&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这次分享的Trie字典树，是数据结构专题中的一个分支，认识了解Trie这种树型数据结构，对构建算法与数据结构知识体系有一定的帮助。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;我对Trie树的理解：把字符串都串接起来，消灭不必要的存储，利用的就是字符串的公共前缀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;其实对于它的理解，你理解了这句话即可👇&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高。&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;如果你还不了解什么是Trie数据结构的话，或者知道一些，但是对于它具体是如何实现一个简单Trie树时，那么这篇文章可能适合你阅读。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么围绕以下几个点来展开介绍Trie树👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;基本概念&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;基本性质&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;应用场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;2个例题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;基本概念&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;首先，我们对Trie树得做一些基本的了解。Trie树中文名叫字典树，前缀树等，接下来我就以字典树称呼。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;我们来看下维基百科对它的描述吧⬇️&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;在&lt;a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;计算机科学&lt;/a&gt;中，&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;trie&lt;/strong&gt;，又称&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;前缀树&lt;/strong&gt;或&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;字典树&lt;/strong&gt;，是一种有序&lt;a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;树&lt;/a&gt;，用于保存&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;关联数组&lt;/a&gt;，其中的键通常是&lt;a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;字符串&lt;/a&gt;。与&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;二叉查找树&lt;/a&gt;不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的&lt;a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;前缀&lt;/a&gt;，也就是这个节点对应的字符串，而根节点对应&lt;a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;空字符串&lt;/a&gt;。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;朴实无华的描述，其实我们看一张图就能看明白了~，我在网上找了一张不错的图，具体的出处，这里就不补充了，因为实在找不到原作者~&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="字典树图解1" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80d94807ec494830b8d7945a153883e9~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;字典树图解1&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这里需要说明的内容就是，一般而言，&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;应该是用一个点来表示一个字符&lt;/strong&gt;，这里为了更好的说明，所以我就是&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;用边来描述字符&lt;/strong&gt;。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;可以发现，这棵字典树用边来代表字母，而&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;从根结点到树上某一结点的路径就代表了一个字符串&lt;/strong&gt;。举个例子， 1→2→6表示的就是字符串 &lt;code&gt;aba&lt;/code&gt; 。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;再比如，&lt;code&gt;1→4→8&lt;/code&gt;构成的字符串是&lt;code&gt;ca&lt;/code&gt;，那么如果在往下拓展的话，我们是不是有 &lt;code&gt;caa&lt;/code&gt;,&lt;code&gt;cab&lt;/code&gt;，那么他们都会经过&lt;code&gt;1→4→8&lt;/code&gt;，这些路径，说明他们是有一段公共的前缀，这个前缀的内容就是&lt;code&gt;ca&lt;/code&gt;，说道这里，我们就知道字典树利用的就是字符串的前缀来解决问题。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么具体它有哪些性质的话，我们下文介绍一下~&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;基本性质&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;对于上述概念有了一定的理解后，我们接下来就看下Trie树的基本性质。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;可以根据这个，大体上分成三个点来说👇&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;根节点不包含字符，除根节点外，每个节点只包含一个字符。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;每个节点的所有子节点包含的字符串不相同。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;接下来我们可以稍微分析一下，可以结合一个图来看看👇&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;我们通过拿how,hi,her,hello,so,see这6个字符串构造出来的就是下面图这个样子。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="图解Trie树" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a834aa9e63ff47248f6fe0ec5f03bc4d~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;图解Trie树&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;（图片出处不明，网上引用处太多~）&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;第一个性质：&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;从图中也可以看出，根节点是&lt;code&gt;/&lt;/code&gt;, 代表的内容也就是空，其他的节点比如，根节点下一个层级，有 &lt;code&gt;h&lt;/code&gt;和&lt;code&gt;s&lt;/code&gt;，分别代表的是两个字符。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;第二个性质：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;比如&lt;code&gt;how&lt;/code&gt;表示的就是一个字符串，&lt;code&gt;hi&lt;/code&gt;,也表示的是一个字符串，可是你会不会好奇，&lt;code&gt;he&lt;/code&gt;和&lt;code&gt;hel&lt;/code&gt;为什么不能表示一个字符串呢？&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;当你想到这里的话，说明你已经看得很仔细，马上就要掌握它了，确实，从图中看，我们会发现有些节点颜色不同，这是因为，我们预定好以这个深色的节点代表当前是一个字符串的结尾，想一想，这样子的作用是啥？&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么实际代码中，我们应该如何去约定或者做个标记呢，其实只要设置一个标记位即可。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;比如下面这样子👇&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;const&lt;/span&gt; TrieNode = &lt;span class="hljs-function" style="line-height: 26px;"&gt;&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;function&lt;/span&gt; (&lt;span class="hljs-params" style="line-height: 26px;"&gt;&lt;/span&gt;) &lt;/span&gt;{
&lt;span&gt;  &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;this&lt;/span&gt;.next = &lt;span class="hljs-built_in" style="color: #e6c07b; line-height: 26px;"&gt;Object&lt;/span&gt;.create(&lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;null&lt;/span&gt;)
&lt;span&gt;  &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;this&lt;/span&gt;.isEnd = &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;false&lt;/span&gt;
&lt;span&gt;};
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;当前的isEnd变量就表示当前的节点是不是结束串，当isEnd为True时，表示从根节点开始，到这个字符，所构成的字符串是存在的，是一个完整的字符串。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;第三个性质：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;每个节点的所有子节点包含的字符串不相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;很明显，我们从根节点开始，依次往下走，会发现，每个节点下面的节点是不相同的，所以依次组成的字符串不可能相同。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;应用场景&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;对Trie树，有一定了解后，我们就可以看看它有哪些的实际应用场景了。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这里参考的是网上所提供的几个点👇&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;在搜索引擎中关键词提示，引擎会自动弹出匹配关键词的下拉框，这种应用场景大家应该都很熟悉。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="下拉框" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d770fe23422402bb052c28d083535d7~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;下拉框&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么应该如何利用一种高效的数据结构存储呢，这里就符合字典树的性质，所以可以利用字典树来构造特定的数据，达到一种更加快速检索的效果。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;字符串检索&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率，可以举例子说明情况👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;词频统计&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;给定很长的一个串，统计频数出现次数最多情况，举个例子👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;字符串最长公共前缀&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;到现在，我们应该知道，Trie树利用多个字符串的公共前缀来节省存储空间，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀，所以可以利用这个特点来解决一些前缀问题。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;非要举个例子的话，有个例子👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;应用场景还是有很多的，剩下的可以自行去探索，接下来，我们通过实际的题目来看看，如何构造字典树吧~&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;2个例子&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;接下来，我们通过二个题目作为例子，来看看字典树在实际应用可以解决哪些问题👇&lt;/p&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 16px; font-weight: bold; display: inline-block; margin-left: 8px; color: rgb(60,112,198);"&gt;&lt;a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;词典中最长的单词⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;词典中最长的单词&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;若无答案，则返回空字符串。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;示例 1：&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;输入：
&lt;span&gt;words = [&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"w"&lt;/span&gt;,&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wo"&lt;/span&gt;,&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wor"&lt;/span&gt;,&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"worl"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"world"&lt;/span&gt;]
&lt;span&gt;输出：&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"world"&lt;/span&gt;
&lt;span&gt;解释： 
&lt;span&gt;单词&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"world"&lt;/span&gt;可由&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"w"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wo"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wor"&lt;/span&gt;, 和 &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"worl"&lt;/span&gt;添加一个字母组成。
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;示例 2：&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;输入：
&lt;span&gt;words = [&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"a"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"banana"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"appl"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"ap"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apply"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;]
&lt;span&gt;输出：&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;
&lt;span&gt;解释：
&lt;span&gt;&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apply"&lt;/span&gt;和&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;都能由词典中的单词组成。但是&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;的字典序小于&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apply"&lt;/span&gt;。
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;提示：&lt;/p&gt;
&lt;span class="span-block-equation" style="cursor: pointer;"&gt;&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" class="equation" src="https://juejin.cn/equation?tex=%E6%89%80%E6%9C%89%E8%BE%93%E5%85%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E5%8F%AA%E5%8C%85%E5%90%AB%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E3%80%82words%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E8%8C%83%E5%9B%B4%E4%B8%BA[1,1000]%E3%80%82words[i]%E7%9A%84%E9%95%BF%E5%BA%A6%E8%8C%83%E5%9B%B4%E4%B8%BA[1,30]%E3%80%82" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;/figure&gt;&lt;/span&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-word-in-dictionary
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这题无非就是找到一个最长的单词，可以拆分成words数组中某一部分，最暴力的思路就是去枚举每一项，但是这样子的时间复杂度是巨大的， 这个时候，我们是不是可以思考一下，这个问题有哪些地方是共性的呢？&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;没错，就是前缀是相同的，从这点来看，是不是就可以利用这个前缀树，把它数据存储下来&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;然后遍历一遍这课树，只要这颗树只有一个分支，则表示它有解，如果存在两个分支以上的话，则无答案。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;复杂度分析&lt;/p&gt;
&lt;span class="span-block-equation" style="cursor: pointer;"&gt;&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" class="equation" src="https://juejin.cn/equation?tex=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9AO(\sum%20w_i)%E3%80%82w_i%20%E6%8C%87%E7%9A%84%E6%98%AF%20words[i]%E7%9A%84%E9%95%BF%E5%BA%A6%E3%80%82" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;/figure&gt;&lt;/span&gt;
&lt;span class="span-block-equation" style="cursor: pointer;"&gt;&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" class="equation" src="https://juejin.cn/equation?tex=%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9AO(\sum%20w_i)%EF%BC%8C%E5%89%8D%E7%BC%80%E6%A0%91%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E3%80%82" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;/figure&gt;&lt;/span&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这点应该很好理解，这里就跳过了。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这里的话，我的解法构造字典树，当然了，也有其他的解法，这里就不展开了，可以看下我得代码噢～&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="最长的串" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7376b352a77643f7b988899f6fa070a8~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;最长的串&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/Tire%E6%A0%91/leetcode-%E5%AD%97%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D.js" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;代码点这里&lt;/a&gt;☑️&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;其实你会发现，构造一个Trie树的话，是很消耗空间的，有点空间换时间的意思，所以具体得根据实际的题目来解决问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 16px; font-weight: bold; display: inline-block; margin-left: 8px; color: rgb(60,112,198);"&gt;&lt;a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;实现Trie（前缀树）⭐⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;实现 Trie (前缀树)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;示例:&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;Trie trie = new Trie();
&lt;span&gt;trie.insert(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;);
&lt;span&gt;trie.search(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;);   // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;true&lt;/span&gt;
&lt;span&gt;trie.search(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;);     // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;false&lt;/span&gt;
&lt;span&gt;trie.startsWith(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;); // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;true&lt;/span&gt;
&lt;span&gt;trie.insert(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;);   
&lt;span&gt;trie.search(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;);     // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;true&lt;/span&gt;
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;说明:&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;你可以假设所有的输入都是由小写字母 a-z 构成的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;保证所有输入均为非空字符串。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这个题目就是典型的写Trie树，对于第一次写这个题目的话，如果没有思路的话，可以尝试先看看别人的代码，看看基本的&lt;code&gt;套路&lt;/code&gt;在哪里。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;话不多说，可以参考这份代码，可以看看如何构造一颗字典树👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="leetcode-实现Trie树" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c61a33b0a184bc1984e1452916d0b4d~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;leetcode-实现Trie树&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/Tire%E6%A0%91/leetcode-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AATrie%E6%A0%91.js" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;剩下的删除操作，还有统计字符串出现的频率，可以自己来实现一下，这个基本上不难，画个图，就知道如何实现啦～&lt;/p&gt;
&lt;hr /&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;题目是做不完的，做完这些题目后，希望你能对Trie字典树有所认识，能对它有更加深入的理解~，接下来准备了四道题集，希望对你们有帮助~&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;词典中最长的单词&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;实现 Trie (前缀树)&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/word-search-ii/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;单词搜索 II&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;Loading question&lt;/a&gt;&lt;/p&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;❤️ 感谢大家&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;关注公众号&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;前端UpUp&lt;/strong&gt;，联系作者，遇到问题的话，欢迎打扰我，我们一起探讨一起进步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6885104477297344525" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」回溯算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」分治算法之美(180+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p class="nice-suffix-juejin-container" id="nice-suffix-juejin-container" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;"&gt;本文使用 &lt;a href="https://mdnice.com/?from=juejin" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;mdnice&lt;/a&gt; 排版&lt;/p&gt;&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Tue, 27 Oct 2020 15:53:48 GMT</pubDate></item><item><title>「算法与数据结构」分治算法之美</title><link>https://juejin.cn/post/6885104477297344525</link><description>&lt;section id="nice"&gt;&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这次分享的内容是，经典算法思想-分治，你可以把它称之为一种思想，也可以叫它分治算法，为了更好的区分，接下来我们以&lt;strong style="color: #595959; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;分治法&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;来称呼它。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你还不了解什么是分治法，或者知道一些，但是对于它具体是如何实现&lt;code&gt;回溯&lt;/code&gt;，那么这篇文章可能适合你阅读。&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;我对分治算法的理解：&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;它的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;求出子问题的解，就可得到原问题的解，可以理解成一种分目标完成程序的算法。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;二分法很多时候，就是一种分治的思想。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么围绕以下几个点来展开介绍分治算法👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;基本思路&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;适用情况以及求解哪些经典问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;经典例题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;分治法基本思想&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;一句话，对分治法概括它的话👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;将原问题划分成n个规模较小而结构与原问题相似的子问题，递归去解决这些子问题，然后依次再合并其结果，最后得到原问题的解。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么具体的来说，我们似乎可以分成三个步骤👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;分解：将要解决的问题划分成若干规模较小的同类问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;解决：当子问题划分得足够小时，用较简单的方法解决。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;其实思想还是不变的，将一个难以直接解决的大问题，分割成一些小规模的相同问题，以便各个击破，分而治之。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;分治法适用情况&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;利用分治法求解一个问题，在于我们能否掌握分治法的几个特征：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;把一个问题可以缩小到一定程度，变成更小的问题来解决。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;分解成若干个小问题后，规模更小且是同类问题，这样子的话，该问题应该就是最优子结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;利用该问题分解出来的子问题的解，合并为该问题的解。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;分解出来的各个子问题是相互独立的，即子问题之间不包含公共的子问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那我们来说一说这几个特征吧~&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第一条特征：一个问题的计算复杂性一般是随问题的规模增加而增加的，所以绝大多数问题都满足。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第二条特征：应用分治法的前提是得满足它，你可以理解成它某种程度上反映了递归思想的应用。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第三条特征：这个应该就是分治法的关键了吧，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;了解分治法的特征，我们来看看有哪些经典的问题是利用这个思想来解决问题的👇&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;分治法求解经典问题&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;什么情况下，可以用该思路来求解呢，以下来自网上搜集的内容👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（1）二分搜索&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（2）大整数乘法&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（3）Strassen矩阵乘法&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（4）棋盘覆盖&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（5）合并排序&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（6）快速排序&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（7）线性时间选择&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（8）最接近点对问题&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（9）循环赛日程表&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（10）汉诺塔&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我想提起的是合并（归并）排序，它完成照应分治法的思想，&lt;code&gt;分解大问题，解决各个规模小问题，最后合并&lt;/code&gt;，那我们来看看合并（归并）排序代码👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="归并排序" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05eb4f8501584bb494ac0029249ba9fd~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;归并排序&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于归并排序的思路，是如何实现的，之前的排序一章以及提及过，采用的是分治思路，可以看看是如何实现的，这里就不具体展开了。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;2个例子&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;接下来，我们通过三个题目作为例子，来看看怎么利用分治的思想来解决问题👇&lt;/p&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-subarray/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;最大子序和⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/maximum-subarray/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;最大子序和&lt;/a&gt;&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;示例:&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;进阶:&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先，我们看看能不能以O(n)复杂度解决这个问题，其实仔细想一想的话，我们可以通过一个简单&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;更多得是，我们这题尝试一下用分治法来解决这题。对于一个数组的最大子序和，它对答案的贡献，只能是以下几种情况👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;出现在左半边&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;出现在右半边&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;出现在中间，穿过中间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么我们是不是可以递归处理呢，对于出现在左边和出现在右边的答案，我们可以把它们当作是一种情况，然后递归去处理，当然了递归的出口，很显然，当递归的数组的长度为1时，我们需要递归结束。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于出现在中间答案的情况，我们可以通过计算来算出答案，所以思路理清楚， 接下来，我们看如何写👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="分治法求最大和" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72e2c3430d264166b61cc8f7fa66be8e~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;分治法求最大和&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，这题用动态规划思路更好求解，也更加得好理解👇&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;//dp[i]表示nums中以nums[i]结尾的最大子序和&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;
&lt;p&gt;&lt;img alt="动态规划求连续和" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167f14786b934fbf95201d6d8b8d4f48~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/p&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;动态规划求连续和&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/leetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%82%E8%A7%A3%E8%BF%9E%E7%BB%AD%E6%9C%80%E5%A4%A7%E5%92%8C.js" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;搜索二维矩阵 II⭐⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;搜索二维矩阵 II&lt;/a&gt;&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
示例:&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;现有矩阵 matrix 如下：&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;[
[1,   4,  7, 11, 15],
[2,   5,  8, 12, 19],
[3,   6,  9, 16, 22],
[10, 13, 14, 17, 24],
[18, 21, 23, 26, 30]
]&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定 target = &lt;code&gt;5&lt;/code&gt;，返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定 target = &lt;code&gt;20&lt;/code&gt;，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/search-a-2d-matrix-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这题的题目很清晰👉矩阵的每行从左到右是升序， 每列从上到下也是升序，在矩阵中查找某个数。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，我们有一个简单的思路👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;维护两个指针（row,col),找到目标元素时，我们就放回true&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;当指向当前的元素值小于target时，我们就col++，向上移动一行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;如果当前的值大于当前的target，我们就row--，向左移动一列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;知道col &amp;gt; 矩阵的行，或者row &amp;lt; 0时，我们直接return false，表示不存在。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;时间复杂度：O(n+m)&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;时间复杂度分析的关键是注意到在每次迭代（我们不返回 true）时，行或列都会精确地递减/递增一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;由于行只能减少 m 次，而列只能增加 n次，因此在导致 while 循环终止之前，循环不能运行超过 n+m 次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;因为所有其他的工作都是常数，所以总的时间复杂度在矩阵维数之和中是线性的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;根据以上的伪代码，我们基本上就能解出这个题目👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="二维矩阵求值" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5a9a8aa6a847ddaf57a6faf7e01e94~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;二维矩阵求值&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这样子的解法，简单且容易理解，其实这并不是真正意义上的二分，只是根据数据的特殊性，使用特定的搜索方式完成对矩阵的查找。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;既然一维数组查某个值时，我们可以将复杂度降为&lt;code&gt;log&lt;/code&gt;级别的时间复杂度，那么在二维的情况下，我们是不是也可以这么考虑呢?&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这个思路，可以借鉴一下👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;我们可以迭代矩阵对角线，二分搜索这些行和列，对它们进行切片。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;在对角线上迭代，二分搜索行和列，知道对角线上的迭代元素用完为止（这个时候，就可以放回true或者是false）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;说得更加简单一些，二分查找的思想是沿着对角线，行查找一下，列查找一下。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可以借鉴一下代码，就会明白如何利用矩阵的对角线去分治。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/175cd11798554cf3b23d1b0371430230~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/leetcode-%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%B1%82%E5%80%BC.js" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;理清楚分治法思路，对它的特征有了一定的了解，明白何如利用它解决实际的问题，那或许这就是这篇文章的意义所在吧~&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;题目汇总&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;题目不多，但是对于基本的入门分治法，应该还是不错的选择👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-subarray/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;最大子序和&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://leetcode-cn.com/problems/contiguous-sequence-lcci/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;连续数列&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://leetcode-cn.com/problems/qie-fen-shu-zu/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;切分数组&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;❤️ 感谢大家&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;关注公众号&lt;strong style="color: #595959; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;前端UpUp&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，联系作者👉 &lt;strong style="color: #595959; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;DayDay2021&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; ，我们一起学习一起进步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p class="nice-suffix-juejin-container" id="nice-suffix-juejin-container" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; margin-top: 20px !important;"&gt;本文使用 &lt;a href="https://mdnice.com/?from=juejin" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;mdnice&lt;/a&gt; 排版&lt;/p&gt;&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Sun, 18 Oct 2020 15:24:24 GMT</pubDate></item><item><title>「算法与数据结构」带你看回溯算法之美</title><link>https://juejin.cn/post/6882394656148045838</link><description>&lt;section id="nice"&gt;&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这次梳理的是回溯算法，掌握它的解决问题思路，对很多搜索尝试问题，都会在日后学习工作中有所帮助。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;我对回溯算法有一定理解：回溯算法建立在DFS基础之上的，但不同的是在搜索的过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索，因此我们可以这样子理解，回溯算法与DFS的区别就是有无状态重置。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你还不了解什么是回溯算法，或者知道一些，但是对于它具体是如何实现&lt;code&gt;回溯&lt;/code&gt;，那么这篇文章可能适合你阅读。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么围绕以下几个点来展开介绍回溯算法👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;来源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;基本思路&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;算法框架&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;经典例题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;回溯算法的来源&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先，我们得明白啥叫回溯算法，它的由来是什么。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;根据维基百科给出的定义👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;用回溯算法解决问题的一般步骤：&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;1、 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;2 、确定易于搜索的解空间结构,使得能用&lt;code&gt;回溯法&lt;/code&gt;方便地搜索整个解空间 。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;3 、以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;用更加简单的话术来解释的话👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;回溯法可以理解成为通过选择不同的岔路口，来寻找目的地，一个岔路口一个岔路口的去尝试找到目的地，如果走错了路的话，继续返回到上一个岔路口的另外一条路，直到找到目的地。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;基本思路&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先，我们得明确这个回溯算法的思路是什么，有了思路，我们才可以根据这个思路写出伪代码，有了伪代码之后，根据实际的问题，写出相应的解决方案。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我们可以把这类回溯问题，看成是解决一个决策树的遍历过程，这样子也方便我们接下来的解释👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;基本思路：&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;从决策树的一条路开始走，能进则进，不能进则退回来，换一条路试一试。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;举个例子来说，还是拿八皇后问题来解释：&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;第一步按照顺利，也就是在第一行，我们放置第一个皇后。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;第二步，我们需要在第二行放置一个皇后，我们需要遍历，将符合要求的位置放置皇后。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;第三步，也就是在第三行，我们需要去遍历，找到符合的位置，如果都没有符合要求，我们就需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销第二步操作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，那么需要改变第二个皇后位置，重新放置第二个皇后位置，直到满足第三个皇后放置的位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;当你改变第二个皇后位置后，都无法满足第三个皇后位置的时候，我们就需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销第一步操作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，重新去放置第一个皇后位置，然后按照顺序完成后续操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我们可以通过另外一个例子来看，也就是回溯在迷宫搜索中也很常见，简单来说，就是这条路走不通的话，我们就需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销上个操作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，返回前一个路口，继续下一条路。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;似乎你已经发现了，回溯说到底就是&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;穷举法&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，但是如果你只是单纯的穷举的话，不剪枝的话，时间复杂度是巨大的，那么如何剪枝呢？&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我们将回溯优化的方法可以称之为剪枝，或者是剪枝函数，通过这个函数，我们可以减去一些状态，剪去一些不可能到达（&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;最终状态&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;），这里说的最终状态，可以认为是答案状态，这样子的话，就减少了部分空间树节点的生成，具体如何剪枝的话，可以根据做题经验多加练习，这里就不张开了。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;算法框架&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;其实刷了一定的题量，你会发现，对于这种回溯思路而言，都是有一定的套路的，那么接下来就给出伪代码👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;接下来是自己的一点理解，觉得按照这个步骤来的话，也好理解一些👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可以按照3个步骤来思考这类的问题：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;路径&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：记录做出的选择。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;选择列表&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：通常而言，用数组存储可以选择的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;结束条件&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：一般而言，就是递归的结束点，也就是搜索的结束点。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;result = []
&lt;span&gt;
&lt;span&gt;&lt;span class="hljs-function" style="line-height: 26px;"&gt;&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;function&lt;/span&gt; &lt;span class="hljs-title" style="color: #61aeee; line-height: 26px;"&gt;backtrack&lt;/span&gt;(&lt;span class="hljs-params" style="line-height: 26px;"&gt;路径, 选择列表&lt;/span&gt;) &lt;/span&gt;{
&lt;span&gt;    &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;if&lt;/span&gt;(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;'满足结束条件'&lt;/span&gt;) {
&lt;span&gt;        &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 这里就是对答案做更新,依据实际题目出发&lt;/span&gt;
&lt;span&gt;        result.push(路径)
&lt;span&gt;        &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;return&lt;/span&gt;
&lt;span&gt;    } &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;else&lt;/span&gt; {
&lt;span&gt;        &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;for&lt;/span&gt;(&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;let&lt;/span&gt; i = &lt;span class="hljs-number" style="color: #d19a66; line-height: 26px;"&gt;0&lt;/span&gt;; i &amp;lt; 选择列表.length; i++) {
&lt;span&gt;            &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 对一个选择列表做相应的选择&lt;/span&gt;
&lt;span&gt;            
&lt;span&gt;            做选择
&lt;span&gt;            
&lt;span&gt;            backtrack(路径, 选择列表)
&lt;span&gt;            
&lt;span&gt;            &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 既然是回溯算法,那么在一次分岔路做完选择后&lt;/span&gt;
&lt;span&gt;            &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 需要回退我们之前做的操作&lt;/span&gt;
&lt;span&gt;            
&lt;span&gt;            撤销选择
&lt;span&gt;        }
&lt;span&gt;    }
&lt;span&gt;}
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;做过类似的题目都知道，核心的处理就是for循环里面的递归操作，每次在递归之前，&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;做选择&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，在这种方案结束后，我们需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销选择&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，这样子的话，就不会影响同一层决策树的其他选择。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;举个例子，在走迷宫这类题型中，我们需要不断的去搜索，去试探答案，这个过程就是一个回溯算法的过程，每次要走下一个格子的时候，我们需要先将这个格子&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;做个标记&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，代表这个格子已经走过，然后在往后继续搜索...&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当这个方案不合理的时候，我们是不是需要将之前标记的格子清除标记呢？仔细想一想的话，这样子是非常合理的，在当前方案行不通的时候，我们要将这个&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;步骤撤销掉&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于以上的基础知识，有了一定了解，接下来我们就通过这么基础知识来解决问题。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;怎么样写回溯&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;做一些题目后，对回溯算法有初步认识后，我觉得可以参考下面的步骤来刻意练习👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;首先画出递归树，找到状态变量（这里可以理解成回溯函数参数）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;确定递归出口，一般根据具体题目条件而言。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;找准选择列表（一般而言与函数参数有关）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;剪枝，对于一些情况而言，可以适当剪枝。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;做出选择，递归调用，进入下一层。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;撤销选择。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我觉得这个对回溯算法的总结，是挺不错的，可以借鉴下。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;2个例子&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;接下来，我们通过三个题目作为例子，来看看怎么根据我们之前提及的&lt;code&gt;算法框架&lt;/code&gt;来解决问题👇&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;&lt;a href="https://leetcode-cn.com/problems/letter-case-permutation/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字母大小写全排列⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/letter-case-permutation/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字母大小写全排列&lt;/a&gt;&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;示例：&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入：S = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入：S = "3z4"
输出：["3z4", "3Z4"]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入：S = "12345"
输出：["12345"]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;提示：&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;S 的长度不超过12。
S 仅由数字和字母组成。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/letter-case-permutation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，这题的话，可以通过画图举个例子来说，我这里就借鉴网上的图了👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="字母全排列" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93b6631eb83447609f909fea94d63c9f~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;字母全排列&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于数字而言的话，我们直接跳过，字母的话，无非就是两种状态，大小写字母，那么我们就有接下来的思路👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;遇到数字的话，不会涉及新的分支，我们就直接往后搜，这样子的话，对于数字就只需要搜索一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;对于单个字母而言，我们需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;搜索2次&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，小写字母搜索一次，大写字母搜索一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;我们可以去维护一个index，遇到数字的话，index+1，继续递归，遇到字母的话，需要递归两次，假设当字母是小写时，我们递归一次(index+1),然后回溯时将字母转为大写，又去递归一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;递归尽头：即搜索完整个字符串为止，我们前面维护的index，这个时候就可以作为条件判断。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;按照这个思路走的话，我们就可以写出完整的解题代码&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;代码👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="回溯算法代码-1" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05057b7c673b46ae9956fddcf4b0e900~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;回溯算法代码-1&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-%E5%AD%97%E6%AF%8D%E5%85%A8%E6%8E%92%E5%88%97.js" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;&lt;a href="https://leetcode-cn.com/problems/subsets/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集🐍⭐⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/subsets/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集&lt;/a&gt;&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;说明：解集不能包含重复的子集。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;示例:&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入: nums = [1,2,3]
输出:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/subsets
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;做这类题目的时候，不太懂的话，可以先画图，从上面的题来看，我们可以画类似一个树的结构，然后看看如何去遍历这个决策树，看看能不能剪枝，直接借鉴一下网上的图👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="子集的递归树" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5f58298bf1f4f8d859b368d39fdcf60~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;子集的递归树&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;其实把这个图画出来，你应该就成功一半了，从这个图来看，我们似乎又可以去遍历这颗树。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先我们得把我们思路整理一下👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;这题肯定是求树的所有节点！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;对这颗树而言，我们可以遍历它的分支，选择其中一个分支，然后继续向下操作，不选这个分支的话，选择另外一个分支又是另外一个情况，所以每次枚举下一个数字的时候,也就是两种选择：选或不选。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;可以考虑使用一个index指针来记录&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;节点&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的状态,即当前递归考察的数字&lt;code&gt;nums[index]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;递归结束的条件： index === nums.length, 这个时候代表考察完所有的数字，把当前的子集加入题解，结束当前递归分支。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;每次结束一个分支，即结束递归，需要撤销当前的选择，（从list中删除），回到选择前的状态，做另外一个选择，即不选择当前的数字，往下递归，继续生成子集。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;根据以上的伪代码，我们基本上就能解出这个题目👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="回溯算法题解-2" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6a5cbcfe7eb465a802faccea3ef20ab~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;回溯算法题解-2&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-%E5%AD%90%E9%9B%86.js" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;题目是做不完的，做完这些题目后，希望你能找出回溯算法的规律，能对它有更加深入的理解~，接下来准备了些题集，希望对你们有帮助~&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;进阶题目汇总&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;以下是我在网上看到一套不错的回溯算法题集，如果你还在刻意找的话，可以看看这里。&lt;/p&gt;
&lt;section class="table-container"&gt;&lt;table style="display: table; text-align: left;"&gt;
&lt;thead&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"&gt;
&lt;th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; color: #595959;"&gt;类型&lt;/th&gt;
&lt;th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; color: #595959;"&gt;题目链接&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody style="border: 0;"&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;子集，组合&lt;/td&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/subsets/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/subsets-ii/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集 II&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/combinations/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;组合&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/combination-sum/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;组合总和&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/combination-sum-ii/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;组合总和 II&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;"&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;全排列&lt;/td&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/permutations/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;全排列&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/permutations-ii/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;全排列 II&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字符串的全排列&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/letter-case-permutation/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字母大小写全排列&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;搜索&lt;/td&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/sudoku-solver/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;解数独&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/word-search/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;单词搜索&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/eight-queens-lcci/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;N皇后&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/palindrome-partitioning/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;分割回文串&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/binary-watch/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;二进制手表&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/section&gt;&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;❤️ 感谢大家&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;关注公众号&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;前端UpUp&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，联系作者，我们一起学习一起进步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p class="nice-suffix-juejin-container" id="nice-suffix-juejin-container" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; margin-top: 20px !important;"&gt;本文使用 &lt;a href="https://mdnice.com/?from=juejin" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;mdnice&lt;/a&gt; 排版&lt;/p&gt;&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Sun, 11 Oct 2020 08:11:57 GMT</pubDate></item><item><title>Rollup 与 Webpack 的 Tree-shaking</title><link>https://juejin.cn/post/7169004126469914654</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="清音.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dea02686df0430ab66fd4e7091549a5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 166 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="http://zoo.zhengcaiyun.cn/blog/article/tree-shaking"&gt;Rollup 与 Webpack 的 Tree-shaking&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Rollup 和 Webpack 是目前项目中使用较为广泛的两种打包工具，去年发布的 Vite 中打包所依赖的也是 Rollup；在对界面加载效率要求越来越高的今天，打包工具最终产出的包体积也影响着开发人员对工具的选择，所以对 Tree-shaking 的支持程度和配置的便捷性、有效性就尤为重要了。本文就来简单分析下两者 Tree-shaking 的流程和效果差异。&lt;/p&gt;
&lt;h4&gt;Tree-shaking 的目的&lt;/h4&gt;
&lt;p&gt;Tree-shaking 的目标只有一个，去除无用代码，缩小最终的包体积，至于什么算是无用代码呢？主要分为三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码不会被执行，不可到达&lt;/li&gt;
&lt;li&gt;代码执行的结果不会被用到&lt;/li&gt;
&lt;li&gt;代码只会影响死变量（只写不读）
Tree-shaking 的目的就是将这三类代码在最终包中剔除，做到按需引入。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;为什么 Tree-shaking 需要依赖 ES6 module&lt;/h4&gt;
&lt;p&gt;ES6 module 特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能作为模块顶层的语句出现&lt;/li&gt;
&lt;li&gt;import 的模块名只能是字符串常量&lt;/li&gt;
&lt;li&gt;import 之后是不可修改的
例如，在使用 CommonJS 时，&lt;em&gt;必须导入完整的工具 (tool) 或库 (library) 对象&lt;/em&gt;，且可带有条件判断来决定是否导入。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-plain"&gt;// 使用 CommonJS 导入完整的 utils 对象
if (hasRequest) {
 &amp;nbsp;const utils = require( 'utils' );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是在使用 ES6 模块时，无需导入整个 &lt;code&gt;utils&lt;/code&gt; 对象，我们可以只导入我们所需使用的 &lt;code&gt;request&lt;/code&gt; 函数，但此处的 import 是不能在任何条件语句下进行的，否则就会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plain"&gt;// 使用 ES6 import 语句导入 request 函数
import { request } from 'utils';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ES6 模块依赖关系是确定的，和运行时的状态无关，因此可以进行可靠的静态分析，这就是 Tree-shaking 的基础。&lt;/p&gt;
&lt;p&gt;静态分析就是不执行代码，直接对代码进行分析；在 ES6 之前的模块化，比如上面提到的 CommonJS ，我们可以动态 require 一个模块，只有执行后才知道引用的什么模块，这就使得我们不能直接静态的进行分析。&lt;/p&gt;
&lt;h3&gt;Wepack5.x Tree-shaking 机制&lt;/h3&gt;
&lt;p&gt;Webpack 2 正式版本内置支持 ES2015 模块（也叫做 &lt;em&gt;harmony modules&lt;/em&gt;）和未使用模块检测能力。Webpack 4 正式版本扩展了此检测能力，通过 &lt;code&gt;package.json&lt;/code&gt; 的  &lt;code&gt;"sideEffects"&lt;/code&gt;  属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 "pure (纯正 ES2015 模块)"，由此可以安全地删除文件中未使用的部分。Webpack 5 中内置了 terser-webpack-plugin 插件用于 JS 代码压缩，相较于 Webpack 4 来说，无需再额外下载安装，但如果开发者需要增加自定义配置项，那还是需要安装。&lt;/p&gt;
&lt;p&gt;Wepack 自身在编译过程中，会根据模块的 &lt;code&gt;import&lt;/code&gt; 与 &lt;code&gt;export&lt;/code&gt; 依赖分析对代码块进行打标。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;/**
   * @param {Context} context context
   * @returns {string|Source} the source code that will be included as initialization code
   */
  getContent({ runtimeTemplate, runtimeRequirements }) {
    runtimeRequirements.add(RuntimeGlobals.exports);
    runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
​    // 未使用的模块, 在代码块前增加 unused harmony exports 注释标记
    const unusedPart =
      this.unusedExports.size &amp;gt; 1
        ? `/* unused harmony exports ${joinIterableWithComma(
            this.unusedExports
          )} */\n`
        : this.unusedExports.size &amp;gt; 0
        ? `/* unused harmony export ${first(this.unusedExports)} */\n`
        : "";
    const definitions = [];
    const orderedExportMap = Array.from(this.exportMap).sort(([a], [b]) =&amp;gt;
      a &amp;lt; b ? -1 : 1
    );
    // 对 harmony export 进行打标
    for (const [key, value] of orderedExportMap) {
      definitions.push(
        `\n/* harmony export */ &amp;nbsp; ${JSON.stringify(
          key
        )}: ${runtimeTemplate.returningFunction(value)}`
      );
    }
    
    // 对 harmony export 进行打标
    const definePart =
      this.exportMap.size &amp;gt; 0
        ? `/* harmony export */ ${RuntimeGlobals.definePropertyGetters}(${
            this.exportsArgument
         &amp;nbsp;}, {${definitions.join(",")}\n/* harmony export */ });\n`
        : "";
    return `${definePart}${unusedPart}`;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面是从 Webpack 中截取的打标代码，可以看到主要会有两类标记，&lt;code&gt;harmony export&lt;/code&gt; 和 &lt;code&gt;unused harmony export&lt;/code&gt; 分别代表了有用与无用。标记完成后打包时 Teser 会将无用的模块去除。&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.rollupjs.com/guide/introduction#tree-shaking"&gt;Rollup Tree-shaking &lt;/a&gt;机制&lt;/h3&gt;
&lt;p&gt;以下是 &lt;code&gt;rollup 2.77.2&lt;/code&gt; 版本的 package.json 文件，我们可以看下它的主要依赖；&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plain"&gt;{
 &amp;nbsp;"name": "rollup",
 &amp;nbsp;"version": "2.77.2",
 &amp;nbsp;"description": "Next-generation ES module bundler",
 &amp;nbsp;"main": "dist/rollup.js",
 &amp;nbsp;"module": "dist/es/rollup.js",
 &amp;nbsp;"typings": "dist/rollup.d.ts",
 &amp;nbsp;"bin": {
 &amp;nbsp; &amp;nbsp;"rollup": "dist/bin/rollup"
  },
 &amp;nbsp;"devDependencies": {
 &amp;nbsp; &amp;nbsp;"@rollup/plugin-alias": "^3.1.9",
 &amp;nbsp; &amp;nbsp;"@rollup/plugin-buble": "^0.21.3",
 &amp;nbsp; &amp;nbsp;"@rollup/plugin-commonjs": "^22.0.1",
 &amp;nbsp; &amp;nbsp;"@rollup/plugin-json": "^4.1.0",
 &amp;nbsp; &amp;nbsp;"@rollup/plugin-node-resolve": "^13.3.0",
 &amp;nbsp; &amp;nbsp;"@rollup/plugin-replace": "^4.0.0",
 &amp;nbsp; &amp;nbsp;"@rollup/plugin-typescript": "^8.3.3",
 &amp;nbsp; &amp;nbsp;"@rollup/pluginutils": "^4.2.1",
 &amp;nbsp; &amp;nbsp;"acorn": "^8.7.1", // 生成 AST 语法树
 &amp;nbsp; &amp;nbsp;"acorn-jsx": "^5.3.2", // 针对 jsx 语法分析
 &amp;nbsp; &amp;nbsp;"acorn-walk": "^8.2.0", // 递归生成对象
 &amp;nbsp; &amp;nbsp;"magic-string": "^0.26.2", // 语句的替换
 &amp;nbsp; &amp;nbsp;......,
  },
......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想要详细了解Acorn：A tiny, fast JavaScript parser, written completely in JavaScript.可&lt;a href="https://github.com/acornjs/acorn"&gt;查看&lt;/a&gt;，Magic-string，可&lt;a href="https://github.com/rich-harris/magic-string#readme"&gt;查看&lt;/a&gt; 。rollup源码中各个模块的执行顺序大致如下图，这也基本表明了它的分析流程。
&lt;img alt="image (5).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9325286cf1c54ae38210ebfadd39192d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;与 Webpack 不同的是，Rollup 不仅仅针对模块进行依赖分析，它的分析流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从入口文件开始，组织依赖关系，并按文件生成 Module&lt;/li&gt;
&lt;li&gt;生成抽象语法树（Acorn），建立语句间的关联关系&lt;/li&gt;
&lt;li&gt;为每个节点打标，标记是否被使用&lt;/li&gt;
&lt;li&gt;生成代码（MagicString+ position）去除无用代码&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Rollup 的优势&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;它支持导出 ES 模块的包。&lt;/li&gt;
&lt;li&gt;它支持程序流分析，能更加正确的判断项目本身的代码是否有副作用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;两个 Case&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;案例 1：
Import  但未调用，不可消除&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-plain"&gt;import pkgjson from '../package.json';

export function getMeta (version: string) {
 &amp;nbsp;return {
 &amp;nbsp; &amp;nbsp;lver: version || pkgjson.version,
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译后整个 package.json 都被打了进来，代码块如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;var name = "@zcy/xxxxx-sdk";
var version$1 = "0.0.1-beta";
var description = "";
var main = "lib/index.es.js";
var module$1 = "lib/index.cjs.js";
var browser = "lib/index.umd.js";
var types = "lib/index.d.ts";
var scripts = {
  test: "jest --color  --coverage=true",
  doc: "rm -rf doc &amp;amp;&amp;amp; typedoc --out doc ./src",
  .....
};
var repository = {
  type: "git",
  url: "......"
};
var author = "";
var license = "ISC";
var devDependencies = {
  "@babel/core": "^7.15.5",
  "@babel/preset-env": "^7.15.4",
  "@babel/runtime-corejs3": "^7.11.2",
  "@types/jest": "^24.9.1",
  "@typescript-eslint/eslint-plugin": "^2.34.0",
  "@typescript-eslint/parser": "^2.34.0",
  "babel-loader": "^8.2.2",
  eslint: "^6.8.0",
  "eslint-config-alloy": "^3.7.2",
  jest: "^24.9.0",
  "lodash.camelcase": "^4.3.0",
  path: "^0.12.7",
  prettier: "^1.19.1",
  rollup: "^1.32.1",
  ...
.  
};
var dependencies = {
  "@babel/plugin-transform-runtime": "^7.10.5",
  "@rollup/plugin-json": "^4.1.0",
  "core-js": "^3.6.5"
};
var sideEffects = false;
var pkgjson = {
  name: name,
  version: version$1,
  description: description,
  main: main,
  module: module$1,
  browser: browser,
  types: types,
  scripts: scripts,
  repository: repository,
  author: author,
  license: license,
  devDependencies: devDependencies,
  dependencies: dependencies,
  sideEffects: sideEffects,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;未 import 的部分可消除&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plain"&gt;import { version } from '../package.json';
​
export function getMeta (ver: string) {
 &amp;nbsp;return {
 &amp;nbsp; &amp;nbsp;lver: ver || version,
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译后可以发现，version 作为一个常量被单独打包进来；代码块如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;var version$1 = "0.0.1-beta";
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="2"&gt;
&lt;li&gt;案例 2：
&lt;strong&gt;变量影响了全局变量&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-plain"&gt;window.utm = 'a.b.c';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即使 &lt;code&gt;utm&lt;/code&gt; 没有任何地方被使用到，在编译打包的过程中，上述代码也不能被去除。
因此我们可以得出结论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 import 三方工具库、组件库时不要全量 import。&lt;/li&gt;
&lt;li&gt;设置或改动全局变量需谨慎。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Vue3 针对 Tree-shaking 所做的优化&lt;/h4&gt;
&lt;p&gt;在 Vue2.x 中，你一定见过以下引入方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;import Vue from 'vue'
​
Vue.nextTick(() =&amp;gt; {
 &amp;nbsp;// 一些和 DOM 有关的东西
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很可惜的是，像 &lt;code&gt;Vue.nextTick()&lt;/code&gt; 这样的全局 API 是不支持 Tree-shaking 的，因为它并没有被单独 &lt;code&gt;export&lt;/code&gt;；无论 &lt;code&gt;nextTick&lt;/code&gt; 方法是否被实际调用，都会被包含在最终的打包产物中。
但在 Vue3，针对全局和内部 API 进行了改造。如果你想更详细的了解 Vue3.x 全局 API Tree-shaking 带来的改动，可以查看&lt;a href="https://v3.cn.vuejs.org/guide/migration/global-api-treeshaking.html"&gt;这里&lt;/a&gt;，里面详细列出了不再兼容的 API，以及在内部帮助器及插件中的使用变化。&lt;/p&gt;
&lt;p&gt;有了这些能力之后，我们可以不再过于关注框架总体的体积了，因为按需打包使得我们只需要关注那些我们已经使用到的功能和代码。&lt;/p&gt;
&lt;h4&gt;最终效果对比&lt;/h4&gt;
&lt;p&gt;先分别来看下两种打包工具的配置；&lt;/p&gt;
&lt;p&gt;webpack.config.js :&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;const webpack = require('webpack');
const path = require('path');
// 删除 const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
​
module.exports = {
 &amp;nbsp;entry: path.join(__dirname, 'src/index.ts'),
 &amp;nbsp;output: {filename: 'webpack.bundle.js'},
 &amp;nbsp;module: {
 &amp;nbsp; &amp;nbsp;rules: [
 &amp;nbsp; &amp;nbsp;  {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;test: /\.(js|ts|tsx)$/,
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;exclude: /(node_modules|bower_components|lib)/,
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;use: {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;loader: 'babel-loader',
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;options: {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;presets: ['@babel/preset-env']
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  }
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  }
 &amp;nbsp; &amp;nbsp;  },
 &amp;nbsp; &amp;nbsp;  {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;test: /\.tsx?$/,
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;use: 'ts-loader',
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;exclude: /(node_modules|lib)/,
 &amp;nbsp; &amp;nbsp;  },
 &amp;nbsp;  ]
  },
 &amp;nbsp;resolve: {
 &amp;nbsp; &amp;nbsp;extensions: ['.tsx', '.ts', '.js'],
  },
 &amp;nbsp;optimization: { // tree-shaking 优化配置
 &amp;nbsp; &amp;nbsp;usedExports: true,
  },
 &amp;nbsp;plugins: [
 &amp;nbsp; &amp;nbsp;new webpack.optimize.ModuleConcatenationPlugin()
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;rollup.config.js :&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;import resolve from "rollup-plugin-node-resolve";
import commonjs from "rollup-plugin-commonjs";
import typescript from "rollup-plugin-typescript2";
import babel from "rollup-plugin-babel";
import json from "rollup-plugin-json";
import { uglify } from 'rollup-plugin-uglify'
​
export default {
 &amp;nbsp;input: "src/index.ts",
 &amp;nbsp;output: [
 &amp;nbsp;  { file: "lib/index.cjs.js", format: "cjs" },
  ],
 &amp;nbsp;treeshake: true, // treeshake 开关
 &amp;nbsp;plugins: [
 &amp;nbsp; &amp;nbsp;json(),
 &amp;nbsp; &amp;nbsp;typescript(),
 &amp;nbsp; &amp;nbsp;resolve(),
 &amp;nbsp; &amp;nbsp;commonjs(),
 &amp;nbsp; &amp;nbsp;babel(
 &amp;nbsp; &amp;nbsp;  {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;exclude: "node_modules/**",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;runtimeHelpers: true,
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;sourceMap: true,
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;extensions: [".js", ".jsx", ".es6", ".es", ".mjs", ".ts", ".json"],
 &amp;nbsp; &amp;nbsp;  }
 &amp;nbsp;  ),
 &amp;nbsp; &amp;nbsp;uglify(),
  ],
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后来看下打包结果的对比。结果发现，本项目在配置  &lt;code&gt;sideEffects：false&lt;/code&gt;  前后时长和体积没有明显变化。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;对比&lt;/th&gt;
&lt;th style="text-align: left;"&gt;Tree-Shaking 前体积&lt;/th&gt;
&lt;th style="text-align: left;"&gt;Tree-Shaking 后体积&lt;/th&gt;
&lt;th style="text-align: left;"&gt;打包时长&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;webpack（5.52.0）&lt;/td&gt;
&lt;td style="text-align: left;"&gt;46kb&lt;/td&gt;
&lt;td style="text-align: left;"&gt;44kb&lt;/td&gt;
&lt;td style="text-align: left;"&gt;4.8s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;rollup（1.32.1）&lt;/td&gt;
&lt;td style="text-align: left;"&gt;24kb&lt;/td&gt;
&lt;td style="text-align: left;"&gt;18kb&lt;/td&gt;
&lt;td style="text-align: left;"&gt;3.7s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;另，上述打包效果中的项目是 sdk 工具包。&lt;/p&gt;
&lt;h3&gt;结束语&lt;/h3&gt;
&lt;p&gt;你如果想了解 Rollup 会打包更快的原因，可以查看我之前发布的文章（&lt;a href="https://www.zoo.team/article/about-vite"&gt;《Vite 特性和部分源码解析》&lt;/a&gt;）。关于 Tree-shaking 的问题也欢迎你在下面留言讨论。&lt;/p&gt;
&lt;h3&gt;推荐阅读&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7021115814870810660"&gt;《Rollup源码解析》&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7166416369943068679"&gt;Git 是如何工作的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7163801933612843016"&gt;大数据前端团队生存指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7153410606673395725"&gt;所见即所得 —— HTML转图片组件开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7145604963593355277"&gt;探索组件在线预览和调试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7143025612267978760"&gt;规范升级 NPM 包&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="http://zoo.zhengcaiyun.cn/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 22 Nov 2022 16:38:06 GMT</pubDate></item><item><title>Git 是如何工作的</title><link>https://juejin.cn/post/7166416369943068679</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="三秋.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8ba0b56767e416da4d685edf403f8c7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 165 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="http://zoo.zhengcaiyun.cn/blog/article/git-work"&gt;# Git 是如何工作的&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;Git 是一个分布式的版本控制系统，这意味着它使用多个本地存储库，包括一个集中式存储库和服务器，它在从前端工作中抽象出底层机制方面做得非常出色。虽然 Git 已经演变成一个成熟的版本控制管理系统，但这并不是作者最初的意图，但并不影响它成为最为世界上最为出色、优雅的工具之一。Git 的好处在于，你可以在整个职业生涯中都不知道 Git 内部是如何工作的，但你依然可以和它相处得很好。但当你了解了 Git 如何管理您的存储库将有助于打开你的思维方式，并让您更深入地了解 Git 。&lt;/p&gt;
&lt;h1&gt;git的特性&lt;/h1&gt;
&lt;h3&gt;区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SVN 是集中式版本控制系统，它的版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，只有一台服务器来维护和控制代码，所以首先要从中央服务器那里得到最新的版本，干完活后需要把自己做完的活推送到中央服务器。&lt;/li&gt;
&lt;li&gt;Git 是分布式版本控制系统，它没有中央服务器，每一台主机都当成一台服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;优势&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则关心文件内容的具体差异。&lt;/li&gt;
&lt;li&gt;Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件做快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而是直接引用上次保存的快照链接。&lt;/li&gt;
&lt;li&gt;Git 近乎所有操作都是本地执行，它的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用CVCS （集中式版本控制系统）的话，差不多所有操作都需要连接网络。且因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;git实际上是如何工作的&lt;/h1&gt;
&lt;p&gt;当我们要去探究 Git 是如何工作的时候我们该从何处下手呢？因为上文说过 Git 近乎所有操作都是本地执行的，在本地的文件中我们能找到他执行的记录，这就需要我们聚焦 本地文件的 Git 文件 —— .git 文件，那么接下来就来看看 Git 的本地文件都有些什么。&lt;/p&gt;
&lt;h2&gt;git对象&lt;/h2&gt;
&lt;p&gt;.git 文件作为一个隐藏文件并不经常出现在我们的目录中，现在我们打开一个从代码仓库拉取的项目，打开终端程序并导航到存储库的主目录，再导航到存储库的 &lt;strong&gt;.git&lt;/strong&gt; 目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd .git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拉出 &lt;strong&gt;.git&lt;/strong&gt; 的目录列表，那么你至少能看到以下几个目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FETCH_HEAD/             
HEAD/
config/
objects/
refs/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现阶段我们需要聚焦的是&lt;code&gt;objects&lt;/code&gt;目录，在objects中，我们最常见的对象是以下三种（具体的下文会详细说明这三者）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Commits&lt;/code&gt;&lt;/strong&gt;: 这将树对象链接在一起以形成历史，保存有关您的提交的元数据的结构，以及指向父提交和下面文件的指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Tree&lt;/code&gt;&lt;/strong&gt;: 这相当于一个目录，记录着目录树内容及其中各个文件对应 blob 对象索引。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Blobs&lt;/code&gt;&lt;/strong&gt;: 这是文件的内容，用于表示文件快照内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Commits对象&lt;/h3&gt;
&lt;p&gt;直接进入object对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd objects
ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;控制台展示：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;// 每个人的项目都不同，文件自然也不同，此处以笔者的一个项目为例
0c      57      85      b3       
1b      60      94      c4      
2a      67      98      cb      
2c      6c      9a      info      
3c      73      a9      pack      
49      82      af      
52      83      b1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;小朋友你是否有很多问号？在第一眼看到这么多两位字符的文件夹名时完全不知道这些是啥。那么我们就需要转头来解释一下 &lt;strong&gt;Git 的数据存储结构&lt;/strong&gt; 了。&lt;/p&gt;
&lt;p&gt;当 Git 存储对象（也就是我们提交的记录）时，它不会将它们全部转储到一个目录中，因为这样会使得目录在不断的迭代提交后变得笨拙，所以它会将它们整齐地构造成一棵树—— &lt;strong&gt;Git 将对象哈希的前 2 个字符用作目录名称，然后将剩余的 38 个字符用作对象标识符&lt;/strong&gt;。当我们将以上的二位字符命名的文件夹展开时，我们就会得到这样一个树形结构的目录：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;objects
├── 0c
│   ├── 8867d7e175f46d4bcd66698ac13f4ca00cf592
│   └── c8002da0403724dfaa6792885eaa97faa71bcf
├── 1b
│   └── 716fafdd3aeb3636222a0026d1d4971078db05
├── 2a
│   └── 14f7db6a6748cc98862960ff5d0e9b1d4a2f17
├── 2c
│   ├── 14f7db6a6748cc98862960ff5d0e9b1d4a2f17
├── 3c
│   ├── 121291ffc25ce6792f9350883b77cea2633048
.
.
.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了验证上述 Git 存储对象的结构，我们可以查看当前最新的4次提交，并取第一条记录去提交记录的结构树中匹配：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;command: git log -4 --oneline

9a5bf36 (HEAD -&amp;gt; master) feat: third commit
2c5331f feat: second commit
60814e1 feat: first commit
49942f3 Initial commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们能看到最近的4次提交，并且每次提交都会有一个 7 位长的哈希值以及提交时的描述。以 &lt;code&gt;9a5bf36&lt;/code&gt;  这次提交为例，我们可能会有个疑问：这只有 7 位似乎跟我们说的不太一样呀。别急！我们需要转换一下，将他转换成完整的长哈希值，因为在树结构中是以长哈希值构建生成的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rev-parse 9a5bf36
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git 以等效的长哈希值响应：&lt;code&gt;9a5bf367f10390c64a3f7b3e738b78bd78a3d781&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;将其分解为目录名称和对象标识符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;目录&lt;/strong&gt;：&lt;code&gt;9a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象标识符&lt;/strong&gt;：&lt;code&gt;5bf367f10390c64a3f7b3e738b78bd78a3d781&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们很容易就能看到找到：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;objects
├── 0c
│   ├── 8867d7e175f46d4bcd66698ac13f4ca00cf592
│   └── c8002da0403724dfaa6792885eaa97faa71bcf
├── 1b
│   └── 716fafdd3aeb3636222a0026d1d4971078db05
.
.
.
├── 98
│   ├── ed6b3f02409778bc864d8897bc230c90cae445
├── 9a
│   ├── 5bf367f10390c64a3f7b3e738b78bd78a3d781   //====&amp;gt;在这
.
.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;既然我们知道了它的存储结构，那么我们自然就应该打开这个文件查看文件的内容，但是我们不能直接查看此对象，因为 Git 中的对象是经过压缩的。如果您尝试使用&lt;code&gt;cat 5bf367f10390c64a3f7b3e738b78bd78a3d781&lt;/code&gt;或类似方式查看它，您可能会看到一堆像这样的乱码，以及计算机尝试从二进制对象读取控制字符时发出的咔呲声：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;6?$?(?E9?z??nUmV?Em]?p??3?`??????q?Ţqjw????VR?O? q?.r???e|lN?p??Gq?)?????#???85V?W6?????
)|Wc*??8?1a?b?=?f*??pSvx3??;??3??^??O?S}??Z4?/?%J?
xu?Ko?0??̯?51??Ԯ
yB
    ??f?y?cBɯo?{ݝ?|ҌFL?:?@??_?0Td5?D2Br?D$??f?B??b?5W?HÁ?H*?&amp;amp;??(fbꒉdC!DV%?????D@?(???u0??8{?w
    ????0?IULC1????@(&amp;lt;?s '
mO????????ƶe?S????&amp;gt;?K8                  89_vxm(#?jxOs?u?b?5m????=w\l?
%?O??[V?t]?^??????G6.n?Mu?%
                           ?̉?X??֖X
                          v??x?EX???:sys???G2?y??={X?Ռe?X?4u???????4o'G??^"qݠ???$?Ccu?ml???vB_)?I?
`??*ގF?of??O
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以使用命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git cat-file -p 9a5bf36
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;sanqius-MacBook-Pro:3c zcy$ git cat-file -p 9a5bf36
tree 85b9416a23f8fb018181f96e5c01ba4bd923b965
parent 2c5331fd7046e561aad8fdde3e3f21375a17549c
author 三秋 &amp;lt;sanqiu@***.com&amp;gt; 1665729807 +0800
committer 三秋 &amp;lt;sanqiu@***.com&amp;gt; 1665729807 +0800

feat: third commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到的这个文件内部的这些内容其实就是一个对象，一个包含了 tree、parent、author... 等数据的对象，这个对象就是 &lt;code&gt;Commits&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;Commits 对象是以键值对的形式展示的，这个 Commits 指向一个 Hash 值为 &lt;em&gt;2c5331fd7046e561aad8fdde3e3f21375a17549c&lt;/em&gt;  的 parent ，其实这个&lt;strong&gt;parent同样是一个 Commits 对象&lt;/strong&gt;，这很好理解。但是这个 Commits 还有一个 Hash 值为 &lt;em&gt;85b9416a23f8fb018181f96e5c01ba4bd923b965&lt;/em&gt;  的 tree 属性，也就是我们上面所说的第二个常用对象 &lt;code&gt;Tree&lt;/code&gt; 。接下来我们需要聚焦的是 Commits 对象中的 Tree。&lt;/p&gt;
&lt;h3&gt;Tree对象&lt;/h3&gt;
&lt;p&gt;这个提交的文章目录里面有什么？我们使用相同的命令打开这个哈希值指向的文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git cat-file -p 85b9416a23f8fb018181f96e5c01ba4bd923b965
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;100644 blob 0cc8002da0403724dfaa6792885eaa97faa71bcf    README.md
040000 tree 3c121291ffc25ce6792f9350883b77cea2633048    src
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们发现这个 Tree 对象下有两个，一个是 Blob 类型的 README.md 文件和 Tree 类型的 src 的文件夹，可以看出 Tree 是可以嵌套的，并且这个结构似乎有点眼熟，没错这就是我们项目的目录结构，这也就能解释为什么说 &lt;strong&gt;Commits 对象下的 Tree 就是对应着这个代码版本的文件快照了&lt;/strong&gt;。（100644 代表它是一个普通的文件，100755 表示一个可执行文件，120000 仅仅是一符号链接）&lt;/p&gt;
&lt;h3&gt;Blobs对象&lt;/h3&gt;
&lt;p&gt;接上文，现在这个 Tree 文件类型已经出现我们的第三类对象 &lt;code&gt;Blob&lt;/code&gt; 了，打破砂锅问到底，继续看看这个Blob 是啥：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git cat-file -p 0cc8002da0403724dfaa6792885eaa97faa71bcf
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;MIT License

Copyright (c) 2019

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell...
&amp;lt;snip&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到其实这就是我们在这个代码版本下的文件内容，&lt;strong&gt;这也就意味着&lt;/strong&gt; &lt;strong&gt;Blob&lt;/strong&gt; &lt;strong&gt;其实就是存放文件的内容&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;放一张图用来总结一下 Commits、Tree、Blob 三者之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20221028114950203.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c75f83c22b34887b5316787317f6c70~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;分支创建与合并&lt;/h2&gt;
&lt;p&gt;在上文中，我们不难知道每一次提交记录其实就是向代码仓库提交一次 Commits 对象，还记得 Commits 对象中的 Parent 属性吗， Parent 属性指向的是当前基变的原型版本。那么当有多个 Commits 提交后，我们能得到这样一个结构的 Commits 流：&lt;/p&gt;
&lt;img alt="image-20221028114926447.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c912e6c961645b49b283ea83ef12ea3~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;p&gt;用过图形化 Git 工具的同学有没有觉得这个很眼熟，没错，图形化工具就是将Commits 关系视图化，就得到我们常用的 SourceTree 、GitKraken 这些常用的图像化 Git 工具。&lt;/p&gt;
&lt;p&gt;现在来谈分支，Git 中的分支，其实本质上仅仅是个指向 Commit 对象的可变指针。Git 会使用 Master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 Master 分支，它在每次提交的时候都会自动向前移动。&lt;/p&gt;
&lt;img alt="image-20221028114904826.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4ce723d7c034731a1061994d01bb452~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;p&gt;当我们创建一个新的分支时，其实就是在当前 Commit 对象上新建一个分支指针。这也就是为什么当我们新建一个分支的时候会如此迅速。&lt;/p&gt;
&lt;img alt="image-20221028114837528.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c2d398c48a24a8ba3d134743a91ad32~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;p&gt;那么Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 &lt;code&gt;HEAD&lt;/code&gt; 的特别指针。在 Git 中，它是一个指向你正在工作中的本地分支的指针。所以当我们切换分支的时候就是切换 HEAD 指针的指向，这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，花费的时间也会有很大的差别，快则几秒，慢则数分钟。而  Git 的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。&lt;/p&gt;
&lt;img alt="image-20221028113328326.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5934175ab0341adad10a37bea81ada7~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;p&gt;当我们分别在 Master、testing 分支分别进行了一些修改，并将代码提交，那么我们就会得到这样结构的分支关系，当前 Master、testing 分支最新的代码的父级记录指向的都是同一个。&lt;/p&gt;
&lt;img alt="image-20221028114802324.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a14333738c945de8bb9fd9389eb064a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;p&gt;读到这我们可以总结出分支的本质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当我们切换到一个命名分支，其实只是切换一个引用提交哈希的标签。&lt;/li&gt;
&lt;li&gt;Git 是通过哈希值来找到该提交对象，然后从提交对象中获取树哈希。&lt;/li&gt;
&lt;li&gt;然后 Git 沿树对象递归，找到哈希对应的快照文件对象，然后解压缩文件对象。&lt;/li&gt;
&lt;li&gt;您的工作目录现在代表该分支的状态，因为它存储在存储库中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;代码合并与冲突&lt;/h2&gt;
&lt;p&gt;当我们继续在 testing 分支进行开发，且 Master 与 testing 分支的开发是在两个不同文件中，那么当我们要将 testing 分支合并到 Master 分支中去时，Git实际上会将两个分支的末端（A5 和 A7）以及它们的共同祖先（A3）进行一次简单的三方合并计算。&lt;/p&gt;
&lt;img alt="image-20221028095708236.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ba27077bbfd4acf8aa504818bde9e01~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;p&gt;这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（ A8 ）。这个提交对象比较特殊，它有两个祖先（ A5 和 A7 ）。&lt;/p&gt;
&lt;img alt="image-20221028095733911.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d476c00fca7429190c37b8cd950706f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;p&gt;此时我们知道了代码的合并是如何进行的，但当我们在两个分支都同时修改了同一处代码时，那么当你合并代码的时候碰到这样的提示时，就意味着我们在进行代码合并时出现了代码冲突。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 代码合并冲突提示
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们打开冲突的文件，你会看到类似于这种&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
&amp;lt;div id="footer"&amp;gt;contact : email.support@github.com&amp;lt;/div&amp;gt;
=======
&amp;lt;div id="footer"&amp;gt;
  please contact us at support@github.com
&amp;lt;/div&amp;gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; iss53
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到 &lt;code&gt;=======&lt;/code&gt; 隔开的上半部分，是 HEAD（即 Master 分支，在运行 Merge 命令时所切换到的分支）中的内容，下半部分是在 testing 分支中的内容。解决冲突的办法无非是二者选其一或者由你手动整合到一起。但是 Git 是如何进行 Diff 的呢？&lt;/p&gt;
&lt;h2&gt;代码合并算法（Myers）&lt;/h2&gt;
&lt;p&gt;Git 的 Diff 是基于 Myers 算法进行的，那么先来了解一下 Myers 算法。&lt;strong&gt;Myers算法&lt;/strong&gt;由 Eugene W.Myers 在 1986 年发表的一篇论文中提出，是一个能在大部分情况产生”最短的直观的“diff的一个算法。&lt;/p&gt;
&lt;h3&gt;differ&lt;/h3&gt;
&lt;p&gt;Diff 就是寻找目标文本和源文本之间的区别，也就是将源文本变成目标文本所需要的操作。举一个 Myers 算法中最常用的例子，A1 = &lt;strong&gt;ABCABBA&lt;/strong&gt;，A2 = &lt;strong&gt;CBABAC&lt;/strong&gt;，那么通过怎样的操作才能使得由 A1 转变成 A2 呢。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：
1.  - A       2.  - A       3.  + C
    - B           + C           - A
      C             B             B
    - A           - C           - C
      B             A             A
    + A             B             B
      B           - B           - B
      A             A             A
    + C           + C           + C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这三种都是有效的变动方式，其实这种转化过程有很多种，那么那种转换过程才是最高效的呢？我们在变动时有这么一个共识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除后新增，比新增后删除要好&lt;/li&gt;
&lt;li&gt;当修改一块代码时，整块的删除然后新增，比删除新增交叉在一起要好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面对这个问题我们可以将这个问题抽象成一个数学问题，生成“直观”的 Diff 算法。抽象的结果是：&lt;strong&gt;寻找 Diff 的过程可以被表示为图搜索&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;图搜索&lt;/h3&gt;
&lt;p&gt;还是以两个字符串，A1 = &lt;strong&gt;ABCABBA&lt;/strong&gt; ，A2 = &lt;strong&gt;CBABAC&lt;/strong&gt;  为例，根据这两个字符串我们可以构造下面一张图，横轴是 A1 内容，纵轴是 A2 内容，要想从 A1 变换成为 A2抽象的数学问题就是求一条从左上角到右下角的路径。图中每一条从左上角到右下角的路径，都表示一个 Diff。向右表示“删除”，向下表示”新增“，对角线则表示“原内容保持不动“。&lt;/p&gt;
&lt;img alt="image-20221028102938469.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccc61e5d2bb24e52907ed9064890f88e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;p&gt;将上述的共识再次进行数学抽象化就对应为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径长度最短（对角线不算长度）&lt;/li&gt;
&lt;li&gt;先向右，再向下（先删除，后新增）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就像走迷宫一样，我们就可以摸索得到这么一条路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;①.  (0, 0) -&amp;gt; (1, 0) -&amp;gt; (2, 0) 
②.  (2, 0) -&amp;gt; (3, 1)
③.  (3, 1) -&amp;gt; (3, 2)
④.  (3, 2) -&amp;gt; (4, 3) -&amp;gt; (5, 4)
⑤.  (5, 4) -&amp;gt; (6, 4)
⑥.  (6, 4) -&amp;gt; (7, 5)
⑦.  (7, 5) -&amp;gt; (7, 6)
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt="image-20221028104037267.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa3ec57dcf8d40ad86e536940385f4e0~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;p&gt;这条路径代表的 diff 的操作为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- A
- B
  C
+ B
  A
  B
- B
  A
+ C
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;代码diff&lt;/h3&gt;
&lt;p&gt;我们以上文中的几次提交中的任意两次 &lt;code&gt;2c5331f&lt;/code&gt; 和  &lt;code&gt; 60814e1&lt;/code&gt; 提交进行 diff：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;command: git diff 2c5331f 60814e1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;2c5331f&lt;/em&gt; 和  &lt;em&gt;60814e1&lt;/em&gt; 表示两个文件的 &lt;code&gt;Hash&lt;/code&gt;，相当于它们的 HashID，这个 HashID 就代表了一个文件对象的特定版本，最后的一串数字代表了一个文件的模式。&lt;/p&gt;
&lt;p align="left"&gt;&lt;img alt="image-20221028112120563" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a313e1fe8b644e98aa193bc7d36a211~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;Git 会告诉你哪些行存在差异，它们被显示在两个 “@@” 符号之前，以上图示例中所表示的含义为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来自文件 a （标记为 “-”），从第 1 行开始之后的 15 行代码。&lt;/li&gt;
&lt;li&gt;来自文件 b （标记为 “+”），从第 1 行开始之后的 15 行代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;@@ -1,15 +1,5 @@
-console.log('watch')
-
-const add = (a,c) =&amp;gt; {
-  return a+c
-}
-const reduce=(a)=&amp;gt;{
-  if (a&amp;lt;0){
-    return  "第一位不能为负数"
-  }else {
-    return a-b
-  }
+const add = (a,b) =&amp;gt; {
+  return a+b
 }
 add(4,8)
-console.log(reduce(-2,-9))
-console.log(new Date().getDate(),'第二次提交')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而”@@”后面的紧跟着的部分就是其上下文信息，在每一个被改动过的代码行之前都会前置一个 “+” 或是 “-” 符号。这些符号可以帮助你准确了解版本 a 和版本 b ，例如前置了 “-” 符号的行就代表来自版本 a ，反之带有符号 “+” 的行就代表来自于版本 b 。&lt;/p&gt;
&lt;h1&gt;结尾&lt;/h1&gt;
&lt;h1&gt;结尾&lt;/h1&gt;
&lt;p&gt;上述已经粗浅的为大家介绍了 Git 的一些简单原理，但这只是 Git 的冰山一角，如果大家还有兴趣可以继续深入学习，相信大家能够为自己开拓出一块新的知识领域。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/"&gt;&lt;strong&gt;The Myers diff algorithm: part 1&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7163801933612843016"&gt;大数据前端团队生存指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7153410606673395725"&gt;所见即所得 —— HTML转图片组件开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7145604963593355277"&gt;探索组件在线预览和调试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7143025612267978760"&gt;规范升级 NPM 包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7140422304920109092"&gt;你想知道的前后端协作规范都在这了&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="http://zoo.zhengcaiyun.cn/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 15 Nov 2022 17:15:51 GMT</pubDate></item><item><title>大数据前端团队生存指南</title><link>https://juejin.cn/post/7163801933612843016</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="一帧.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61643608183f4c7d9f8b66ddd73716fe~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 164 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="http://zoo.zhengcaiyun.cn/blog/article/big-data"&gt;大数据前端团队生存指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文会简单介绍大数据、大数据前端团队以及可落地的演进方向。 ps.针对数据前端团队10人及以内的中小厂。&lt;/p&gt;
&lt;p&gt;开始前问几个问题：&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;你了解大数据技术吗？&lt;/li&gt;
&lt;li&gt;为什么需要大数据前端团队（和大数据有什么关联）？&lt;/li&gt;
&lt;li&gt;大数据前端团队在前端团队中的定位？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;浅入浅出大数据&lt;/h2&gt;
&lt;h3&gt;为什么需要大数据&lt;/h3&gt;
&lt;p&gt;咱们年终述职汇报的时候，是不是有个标准套路：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用xx工具替换了xx工具，并落地xx个团队的xx个项目，覆盖率x%，整体体积减少了x%，加载速度从x缩短到x。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么完成上面这条简短而有力的阐述需要那几个步骤？&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;我需要哪些数据，从哪来？寻源与采集&lt;/li&gt;
&lt;li&gt;收集的数据很多要怎么管理？聚合与统计&lt;/li&gt;
&lt;li&gt;如何整理出可读和有用的结果？建模与分析&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;大数据技术在做什么&lt;/h3&gt;
&lt;p&gt;数据本身的价值——疫情防控啊，通过数据精准发现密接和次密接 数据增值的价值——电商行业根据用户消费情况做商品推荐、我的抖音里每次都是跳舞小姐姐&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单来说可以分为提供数据服务和提供数据分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大数据开发分了几个方向： 1.底层的基础平台开发 2.面向用户的数据产品开发 3.数据仓库开发 4.大数据分析 5.算法，数据挖掘&lt;/p&gt;
&lt;p&gt;简化一下运作流程：&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;确定需求：要做什么&lt;/li&gt;
&lt;li&gt;需求分析：沉淀需要的指标（通常是数据分析师和运营）&lt;/li&gt;
&lt;li&gt;分析数据来源：埋点？业务数据库&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据域划分、指标&amp;amp;模型：原子指标的统计口径、计算逻辑（核心）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;跑数据&amp;amp;结果验证&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;数仓平台&lt;/h3&gt;
&lt;p&gt;采用阿里的数据体系分层架构分表为：数据引入层（ODS，Operation Data Store）、数据公共层（CDM，Common Data Model）和数据应用层（ADS，Application Data Service）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分层&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ODS 贴源层&lt;/td&gt;
&lt;td&gt;实际业务产生的未经处理的原始数据数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DWD 明细数据表&lt;/td&gt;
&lt;td&gt;以业务过程明细数据进行宽表化处理，形成明细逻辑表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DWS 汇总数据层&lt;/td&gt;
&lt;td&gt;面向可复用模型公共建模，汇总成口径统一指标，完成数据加工与整合。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ADS 数据应用层&lt;/td&gt;
&lt;td&gt;基于指标的个性化数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;作为底层能力，数仓同学会根据产品诉求做抽象和分层，并建立一些内部业务的通用模型。&lt;/p&gt;
&lt;h3&gt;数据平台&lt;/h3&gt;
&lt;p&gt;除了配合分层之外，还有跑批、作业、数据集成、抽取 、回流等，这些都是 &lt;strong&gt;数据平台&lt;/strong&gt; 的工作，目的是管理数据，是一个较为独立且闭环的技术产品，也是支撑数仓的能力平台。 通过平台化和gui的能力释放数仓同学的工作压力，同时更合理合规的透出到业务线。&lt;/p&gt;
&lt;h3&gt;数据应用&lt;/h3&gt;
&lt;p&gt;通常是前端的主战场，配合各种端的业务，与数据平台联调，使用一些可视化的方案完成用户诉求。&lt;/p&gt;
&lt;p&gt;在初步介绍了大数据团队工作以后，我们回到前端。&lt;/p&gt;
&lt;h2&gt;团队成长&lt;/h2&gt;
&lt;h3&gt;团队现状&lt;/h3&gt;
&lt;p&gt;内部出现的一些问题：&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;不了解公司业务、与核心业务交流少&lt;/li&gt;
&lt;li&gt;与前端基建的关联性很少，导致在大前端里出头脱s节&lt;/li&gt;
&lt;li&gt;交付效率不够，其中占比最重的来自于数据分析，业务消化不完&lt;/li&gt;
&lt;li&gt;内部数据处理的业务都搞不清楚（业务知识壁垒高）&lt;/li&gt;
&lt;li&gt;.......&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结：人少活急、业务壁垒、交流不畅&lt;/p&gt;
&lt;h3&gt;结合行业分析&lt;/h3&gt;
&lt;p&gt;业界比较出名的数据可视化（排名不分先后）团队有很多，&lt;strong&gt;百度 Echarts 团队、阿里云 DataV 团队 、蚂蚁金服 AntV 团队&lt;/strong&gt; 、&lt;strong&gt;360 企业安全集团可视化团队等&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些团队Paas化（参考 DataV、网易数帆等）有更复杂的场景和更高的可视化要求，也能诞生很多可视化垂直赛道的专家机会。&lt;/strong&gt; 然而大部分公司想做数字化转型，都没金力培养一个支“可视化”的前端团队 ；要么直接外采，要么成立一个数据团队，前端只要简单场景的分析展示（数据处理后台、BI、大屏、驾驶舱）。&lt;/p&gt;
&lt;p&gt;目前公司的规模和节奏卡在两者之间，有商业化的规划但是上升期业务交付压力很大，晒一条数据—— 6 月计划需要前端的需求为 27 个，实际排入14个，其中 42% 精力投入大屏、看板的项目交付。&lt;/p&gt;
&lt;p&gt;经过一系列梳理，决定提升人效问题并借助大数据分析能力帮助其他团队建流程、做分析，我们明确了 3 点方向：&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;做深、做宽底层能力，并使其通用化&lt;/li&gt;
&lt;li&gt;提升可视化业务的交付效率&lt;/li&gt;
&lt;li&gt;与个别业务进行深度合作，提供数字化运营解决方案&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;能力清单&lt;/h2&gt;
&lt;h3&gt;底层能力-可视化物料体系&lt;/h3&gt;
&lt;p&gt;数据前端团队内部的底层能力，同时也可以成为公司的规范来保证数据展示的交付效率。 首先需要建立一套通用视化规范，然后形成可插拔的物料体系落地到业务侧。&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;基础图表组件库&lt;/li&gt;
&lt;li&gt;业务视图：一些额外的自定义组件&lt;/li&gt;
&lt;li&gt;3D能力（d3、three）&lt;/li&gt;
&lt;li&gt;拖拽交互、流程编排（g6）&lt;/li&gt;
&lt;li&gt;与搭建场景的结合，物料管理等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;难点&lt;/strong&gt;&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;可视化规范的约束与视觉创意的 balance，既要克制又要个性。&lt;/li&gt;
&lt;li&gt;可视化组件库不像传统组件库，配置的复杂度容易牵一发动全身，抽象能力很重要。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;方案&lt;/strong&gt;&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;定义一套标准化方案（包含可变和约束项）结合主题来满足不同的调性；视觉负责新增的组件以及场景设计&lt;/li&gt;
&lt;li&gt;充分的分类：素材、信息、控件、地图、图表、表格、业务等，其中素材、控件和业务是需要迭代的工作量&lt;/li&gt;
&lt;li&gt;配套物料体系需要固定的开发脚手架、模板和物料管理 &lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36893b5c8ea54c7080df860caf48cb7c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;【鲁班数据源管理方案】&lt;/a&gt; &lt;a href="https://juejin.cn/post/7127440050937151525"&gt;【低代码平台远程组件加载方案】&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;通用服务-可视化搭建平台&lt;/h2&gt;
&lt;p&gt;可视化搭建采用 NoCode，只有个别数据源处理需要前端做数据规则转换，基于物料沉淀和视觉规范做快速搭建；工作转移和共建流程放在了下面方案中。&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;大屏&lt;/li&gt;
&lt;li&gt;BI 驾驶舱：相比大屏的展示更重交互有可能会嵌在管理系统里&lt;/li&gt;
&lt;li&gt;报表：excel&lt;/li&gt;
&lt;li&gt;ppt&lt;/li&gt;
&lt;li&gt;pdf&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;难点&lt;/strong&gt;&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;搭建系统本身的复杂度，可视化的配置项会比普通搭建多。&lt;/li&gt;
&lt;li&gt;搭建与物料之间的规范抽象，完善的物料体系，标准的共建规则。&lt;/li&gt;
&lt;li&gt;搭建的受益群体。搭建由谁来完成？如何配合共工作职责？谁是买单方？&lt;/li&gt;
&lt;li&gt;搭建产品演进与日常研发的边界，哪些功能从业务中抽象，哪些功能不应该做。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;方案&lt;/strong&gt;&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;
&lt;p&gt;物料管理与搭建的关系、渲染加载拖拽能力、图表的数据转换统一规范&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前面已经说过了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将前端搭建的流程提前提供一些搭建出来的行业解决方案模板给业务方挑选，视觉负责个性化组件和场景的设计。&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;前端需要对业务方、对应的产品、视觉进行培训&lt;/li&gt;
&lt;li&gt;完全支持的场景，搭建人由业务方或视觉出，边界是是否需要视觉把控质量&lt;/li&gt;
&lt;li&gt;视觉与前端的搭建人，边界在于是否可以避免视觉出设计稿以及是否有额外的全局事件代码和新组件&lt;/li&gt;
&lt;li&gt;数据源的搭建人边界，是否需要前端对数据做大量转换，应尽量避免。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如版本、草稿、回退、收藏，交互处理（下钻、刷新、tab等），view之外的逻辑由业务方承接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了支持业务+内部基建，需要搭建产物的多样性，支持 npm、html、url 等方式交付。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="image的副本.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23a281270f144cf6b3141c1d87dbef83~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;【低代码平台远程组件加载方案】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7145604963593355277"&gt;【探索组件在线预览和调试】&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;数字化能力-埋点分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;难点&lt;/strong&gt;&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;建立一套规范的产研埋点流程，从需求到前端&lt;/li&gt;
&lt;li&gt;了解数据流转的流程，区分诉求是前端埋点还是后端埋点，实时还是 T+1&lt;/li&gt;
&lt;li&gt;如何推动产品用起来（数据意识不够）&lt;/li&gt;
&lt;li&gt;埋点标准化、可视化、无痕化、工程化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结：横向能力 &amp;gt; 技术难度 &lt;strong&gt;方案&lt;/strong&gt; &lt;img alt="image的副本2.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0acbc0f1bde34403b8eaa82cc744b787~tplv-k3u1fbpfcp-zoom-1.image" /&gt; 当然路径图（桑基）、转化率（漏斗）等高定制组件应该是在“可视化物料体系”里面的，相比之下抛开技术本身，埋点更适合有产品思维，横向和数据意识强的同学。 细节我们也沉淀了不少 &lt;a href="https://juejin.cn/post/7114450860335169543"&gt;【埋点能力分享】&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;数据中台抓手-数字化运营&lt;/h3&gt;
&lt;p&gt;使用大数据已沉淀的能力，连接业务与产研，让产研找到业务侧的技术发力点。 为什么大数据前端团队可以做数据能力的运用和推动落地？&lt;/p&gt;
&lt;ol start="0"&gt;
&lt;li&gt;埋点需要产品、运营和技术充分讨论，而前端是唯一的执行者&lt;/li&gt;
&lt;li&gt;产研数据分析必定需要可视化平台承载&lt;/li&gt;
&lt;li&gt;数据分析之后需要提供解决方案，前端可以从体验方向作为切入点，也可有依据的" battle需求"&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数字化运营的通用方案还在路上，感兴趣的关注我，等下一篇《数字化运营在客满业务线的落地》&lt;/p&gt;
&lt;p&gt;大数据前端是一个特殊的团队，可大可小，如何打破技术边界，渗透到业务内部还需要不断修炼。 最后，如果你正好也在这个团队，同时有些个人建议，欢迎在评论区分享。&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7153410606673395725"&gt;所见即所得 —— HTML转图片组件开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7145604963593355277"&gt;探索组件在线预览和调试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7143025612267978760"&gt;规范升级 NPM 包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7140422304920109092"&gt;你想知道的前后端协作规范都在这了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7158607083699437605"&gt;IntersectionObserver 实现虚拟列表初探&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="http://zoo.zhengcaiyun.cn/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 08 Nov 2022 16:12:06 GMT</pubDate></item><item><title>小而美的 css 的原子化</title><link>https://juejin.cn/post/7161211941652791304</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="大海.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de6a33a26c24275a1b59e7592ac0e41~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 163 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="http://zoo.zhengcaiyun.cn/blog/article/css"&gt;小而美的 css 的原子化&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;什么是 CSS 原子化&lt;/h2&gt;
&lt;p&gt;引用 &lt;a href="https://css-tricks.com/lets-define-exactly-atomic-css/"&gt;文章 Let’s Define Exactly What Atomic CSS is&lt;/a&gt; 中定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Atomic CSS is the approach to CSS architecture that favors small, single-purpose classes with names based on visual function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;译文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原子化 CSS 是一种 CSS 的架构方式，它倾向于小巧且用途单一的 class，并且会以视觉效果进行命名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;.bg-blue { background-color: #357edd; } 
.f1 { font-size: 3rem; }
.m0 { margin: 0; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;通常情况下我们是怎么写 CSS 的&lt;/h2&gt;
&lt;p&gt;原子化 CSS 是一个 CSS 框架， 在没有对应的 CSS 框架的项目中，是如何写 CSS 的。我们引用 &lt;a href="https://www.smashingmagazine.com/2013/10/challenging-css-best-practices-atomic-approach/"&gt;Challenging CSS Best Practices&lt;/a&gt; 文中例子来看看。&lt;/p&gt;
&lt;p&gt;如图所示：我们要实现一个类似访问记录组件，右边是访问人的头像，左侧是访问的描述。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20220920162400" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7b7800f0369469cb9ee1d8fab5708b0~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;对应代码.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class="media"&amp;gt;
 &amp;nbsp;&amp;lt;a href="https://www.zcygov.cn/" class="img"&amp;gt;
 &amp;nbsp; &amp;nbsp;&amp;lt;img width="40" src="logo.png" alt="zcy" /&amp;gt;
 &amp;nbsp;&amp;lt;/a&amp;gt;
 &amp;nbsp;&amp;lt;div class="bd"&amp;gt;@小明 14 分钟之前&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
.media {
 &amp;nbsp;margin: 10px;
}
.media,
.bd {
 &amp;nbsp;overflow: hidden;
 &amp;nbsp;_overflow: visible;
 &amp;nbsp;zoom: 1;
}
.media .img {
 &amp;nbsp;float: left;
 &amp;nbsp;margin-right: 10px;
}
.media .img img {
 &amp;nbsp;display: block;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新增一个设计，需要把头像放在右侧，描述在左侧，如图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="20220920162310" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a546703cc514317a87339852168c28c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们通过新增一个类名 imgExt，右浮动&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class="media"&amp;gt;
  &amp;lt;a href="https://www.zcygov.cn/" class="imgExt"&amp;gt;
 &amp;nbsp;  &amp;lt;img width="40" src="https://sitecdn.zcycdn.com/f2e-assets/b37c37db-ce59-4bfe-a889-5c8615d008c8.png" alt="zcy" /&amp;gt;
  &amp;lt;/a&amp;gt;
  &amp;lt;div class="bd"&amp;gt;@小明 14 分钟之前&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
  ...
/* 图片在右侧 */
.media .imgExt {
  float: right;
  margin-left: 10px;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时候有来一个新设计，要求组件在页面右侧栏中时候，字体变小&lt;/p&gt;
&lt;p&gt;&lt;img alt="20220920162709" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5ecb12c580a4e948eb814e81739ae0c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id="rightRail"&amp;gt;
&amp;lt;div class="media"&amp;gt;
 &amp;nbsp;&amp;lt;a href="https://www.zcygov.cn/" class="imgExt"&amp;gt;
 &amp;nbsp; &amp;nbsp;&amp;lt;img width="40" src="https://sitecdn.zcycdn.com/f2e-assets/b37c37db-ce59-4bfe-a889-5c8615d008c8.png" alt="zcy" /&amp;gt;
 &amp;nbsp;&amp;lt;/a&amp;gt;
 &amp;nbsp;&amp;lt;div class="bd"&amp;gt;@小明 14 分钟之前&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
  ...
/* 页面右侧容器中时，字体变小 */
#rightRail .bd {
 &amp;nbsp; &amp;nbsp;font-size: smaller;
}
&amp;lt;/style&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上诉的代码是在2013年发布的文章中引用的，CSS编码和命名的抽象是在组件层上，这样的抽象和命名存以下问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个简单的样式修改，都需要有新增一条样式规则。面向业务组件内CSS的抽象，复用的颗粒度是到组件的，比如例子中访问记录组件，是按照组件复用。组件中单个规则是很难单独抽离复用。&lt;/li&gt;
&lt;li&gt;在例子中的6个样式规则中，4个是基于上下文的&lt;/li&gt;
&lt;li&gt;新的需求与原有规则冲突，需要修改一个其中一个样式，是通过新增一个嵌套类覆盖原有的样式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;9年过去了，前端技术飞速发展，但是看一眼现有项目中的CSS，相似的问题还是存在的。因为CSS组件化的思路没有变，还是按照组件维度去写。说明这些问题不是简单从CSS改用LESS就能解决的。而且随着业务复杂度变高，相关构建工具升级会引入更多的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相同功能在不同组件内部需要重新命名：比如字符过长省略的样式，CSS规则是一致的，比如一个订单详情字符缩略和发票信息的字符缩略都会各自独立实现，而不会相互引用，因为没人会在订单中使用发票的CSS类，CSS复用度问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;.order-overflow-dot {
 &amp;nbsp;text-overflow: ellipsis;
 &amp;nbsp;white-space: nowrap;
 &amp;nbsp;overflow: hidden;
}
...
 &amp;nbsp;.title-number {
 &amp;nbsp; &amp;nbsp;text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
  }
... &amp;nbsp;
.invoice-overflow-content {
 &amp;nbsp; &amp;nbsp;div {
 &amp;nbsp; &amp;nbsp; text-overflow: ellipsis;
     white-space: nowrap;
     overflow: hidden;
 &amp;nbsp;  }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;类命名困难：缺失命名规范，不同人不同的风格，没有什么可读性，给类取名字一个十分痛苦的事情，大多数时候类名不伦不类，难以读懂。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;.time-tip {
 &amp;nbsp;i {
 &amp;nbsp; &amp;nbsp;margin-left: 10px;
 &amp;nbsp; &amp;nbsp;cursor: pointer;
  }
}
​
#service-charge-Bill {
 &amp;nbsp;.zcy-search-panel .ant-form-item-label {
 &amp;nbsp; &amp;nbsp;min-width: 80px;
  }
}
​
.invoice-tpl-container {
 &amp;nbsp;max-height: 360px;
 &amp;nbsp;overflow-y: scroll;
}
​
.add-invoice-tpl-item {
 &amp;nbsp;border: 1px dashed rgb(209, 215, 232);
 &amp;nbsp;text-align: center;
 &amp;nbsp;height: 160px;
 &amp;nbsp;line-height: 160px;
 &amp;nbsp;margin: 10px;
}
​
.invoice-tpl-item {
 &amp;nbsp;border: 1px solid rgb(209, 215, 232);
 &amp;nbsp;margin: 10px;
 &amp;nbsp;height: 160px;
 &amp;nbsp;position: relative;
​
 &amp;nbsp;.invoice-content {
 &amp;nbsp; &amp;nbsp;overflow: hidden;
 &amp;nbsp; &amp;nbsp;padding: 20px;
 &amp;nbsp; &amp;nbsp;height: 119px;
​
 &amp;nbsp; &amp;nbsp;div {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;overflow: hidden;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;text-overflow: ellipsis;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;white-space: nowrap;
 &amp;nbsp;  }
​
 &amp;nbsp; &amp;nbsp;.invoice-type-mark {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;display: inline-block;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;width: 20px;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;height: 20px;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;line-height: 20px;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;text-align: center;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;color: white;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;background-color: #3177fd;
 &amp;nbsp;  }
  }
​
 &amp;nbsp;.operate {
 &amp;nbsp; &amp;nbsp;position: absolute;
 &amp;nbsp; &amp;nbsp;bottom: 0;
 &amp;nbsp; &amp;nbsp;width: 100%;
 &amp;nbsp; &amp;nbsp;border-top: 1px solid rgb(209, 215, 232);
 &amp;nbsp; &amp;nbsp;height: 40px;
 &amp;nbsp; &amp;nbsp;line-height: 40px;
 &amp;nbsp; &amp;nbsp;text-align: center;
  }
}
​
.invoice-tpl-item.active {
 &amp;nbsp;border-color: #3177fd;
}
​
.default-mark {
 &amp;nbsp;position: absolute;
 &amp;nbsp;right: 0;
 &amp;nbsp;top: 0;
 &amp;nbsp;background-color: #bbb;
 &amp;nbsp;color: white;
 &amp;nbsp;padding: 0 5px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;重复的 CSS 文件：现有项目大家都习惯将 CSS 文件创建在业务的目录中，我的项目是用 webpack 构建的，开发阶段 CSS 文件是按需加载的。这样就存在一个问题，如果一个页面也需要用另外页面的样式，开发同学第一反应是复制粘贴。很少发现同学用@import 的方式，导致大量重复的 CSS 文件。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20220901103410149" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd2188d2d7144902a9375e9b107bea41~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无意义的嵌套和使用&amp;amp;符号：无法搜索定位样式，且可读性极差&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;.catalogue {
  &amp;amp;-title {
 &amp;nbsp; &amp;nbsp;display: flex;
 &amp;nbsp;  &amp;amp;-btns {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;flex-grow: 1;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;align-items: center;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;text-align: right;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;.ant-btn {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;margin: 0 5px;
 &amp;nbsp; &amp;nbsp;  }
 &amp;nbsp;  }
  }
  &amp;amp;-content {
 &amp;nbsp; &amp;nbsp;height: calc(100% - 60px);
 &amp;nbsp; &amp;nbsp;overflow: auto;
 &amp;nbsp; &amp;nbsp;padding: 18px;
 &amp;nbsp; &amp;nbsp;.cy-tree {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;width: 80%;
 &amp;nbsp;  }
 &amp;nbsp; &amp;nbsp;.ant-tree {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;overflow: auto;
 &amp;nbsp;  }
  }
  &amp;amp;-tree {
 &amp;nbsp; &amp;nbsp;height: calc(100% - 22px);
 &amp;nbsp; &amp;nbsp;.ant-input {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;width: 100%;
 &amp;nbsp; &amp;nbsp;  &amp;amp;-search {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;width: 80%;
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;flex-grow: 1;
 &amp;nbsp; &amp;nbsp;  }
 &amp;nbsp;  }
  }
}
​
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我所负责的项目都是后台管理的项目，团队也有成熟的组件库。这类的项目CSS的工作量是比较少的，所以项目开始之处，没有指定对应CSS规范和架构。大家都是按照组件的抽象思维，没有规范命名规程，日积月累，导致现有项目CSS代码状况较差，维护起来让人十分头大。如何解决这些问题呢？就需要我们改变现有CSS编码思路，改变现在业务组件抽象维度，制定适合命名规范。这些内容就是我们平时所说的CSS的架构，我们这边调研几个比较流行的CSS框架，以下是几个框架简要介绍。&lt;/p&gt;
&lt;h2&gt;CSS框架介绍&lt;/h2&gt;
&lt;h3&gt;原子化 CSS&lt;/h3&gt;
&lt;h4&gt;定义&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;原子化 CSS 是一种 CSS 的架构方式，它倾向于小巧且用途单一的 class。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;原则&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;class 的命名按照功能&lt;/li&gt;
&lt;li&gt;class 的功能单一&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4&gt;相关资料&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://css-tricks.com/lets-define-exactly-atomic-css/"&gt;https://css-tricks.com/lets-define-exactly-atomic-css/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;OOCSS (Object-Oriented CSS 面向对象 CSS)&lt;/h3&gt;
&lt;h4&gt;定义&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;OOCSS (Object-Oriented CSS 面向对象 CSS ) 是组织 CSS 的领先的模块化或基于组件的系统。它是 Nicole Sullivan 在 2008 年在 Web Directions North 大会上首次提出的，核心就是&lt;strong&gt;编写可复用和可维护的样式&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;原则&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;分离结构（structure）和皮肤（skin）。 您应该在基础对象中保留结构和位置，并在扩展类中保留视觉特征（如 &lt;code&gt;background&lt;/code&gt; 或 &lt;code&gt;border&lt;/code&gt;）。这样您就不必覆盖视觉属性。&lt;/li&gt;
&lt;li&gt;分离容器（container）和内容（&lt;em&gt;content&lt;/em&gt;）。 永远不要在 CSS 中模仿 HTML 的结构。换句话说，不要在样式表中引用标签或 ID。相反，尝试创建和应用描述相关标签使用的类。并将嵌套类保持在最低限度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4&gt;相关资料&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://oocss.org/"&gt;http://oocss.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;SMACSS (Scalable and Modular Architecture for CSS)&lt;/h3&gt;
&lt;h4&gt;定义&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;SMACSS（Scalable and Modular Architecture for CSS）编写模块化、结构化和可扩展的 CSS。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;原则:SMACSS 认为 CSS 有 5 个类别，我们通过这 5 种类别来拼凑出完整的 class&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Base 基础样式&lt;/li&gt;
&lt;li&gt;Layout 布局样式&lt;/li&gt;
&lt;li&gt;Module 模块样式&lt;/li&gt;
&lt;li&gt;State 状态样式&lt;/li&gt;
&lt;li&gt;Theme 主题样式&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4&gt;相关资料&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://smacss.com/"&gt;http://smacss.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;BEM（ &lt;strong&gt;block, element, modifier&lt;/strong&gt;）&lt;/h3&gt;
&lt;h4&gt;定义&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;首先 BEM 是一个分层系统，它把我们的网站分为三层，这三层正好对应着 BEM 三个英文单词的简写 &lt;strong&gt;block, element, modifier&lt;/strong&gt;，分为为 &lt;strong&gt;块层、元素层、修饰符层&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;原则&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;__&lt;/code&gt;两个下划线将块名称与元素名称分开&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;--&lt;/code&gt;两个破折号分隔元素名称及其修饰符&lt;/li&gt;
&lt;li&gt;一切样式都是一个类，不能嵌套&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4&gt;相关资料&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://getbem.com/"&gt;https://getbem.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;ITCSS&lt;/h3&gt;
&lt;h4&gt;定义&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;理智、可扩展、可管理CSS架构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;原则:类似 SMACSS 对 CSS 元素进行了分层&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Settings – 与预处理器一起使用，包含颜色、字体等定义&lt;/li&gt;
&lt;li&gt;Tools – 工具与方法，比如 mixins，Settings 与 Tools 都不会产生任何 CSS 代码，仅仅是辅助函数与变量&lt;/li&gt;
&lt;li&gt;Generic – 通用层，比如 reset &lt;code&gt;html&lt;/code&gt;、&lt;code&gt;body&lt;/code&gt; 的样式&lt;/li&gt;
&lt;li&gt;Elements – 对通用元素的样式重置，比如 　&lt;code&gt;a&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;div&lt;/code&gt; 等元素的样式重置 Objects – 类似 OOCSS 中的对象，描述一些常用的基础状态&lt;/li&gt;
&lt;li&gt;Components – 对组件样式的定义，一个 UI 元素基本由 Objects 与 Components 组成&lt;/li&gt;
&lt;li&gt;Utilities – 工具类，比如 &lt;code&gt;.hidden&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4&gt;相关资料&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://getbem.com/"&gt;https://getbem.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考虑到我们自身项目项目是一个后台管理类的项目，有成熟组件库。日常 CSS 开发工作量和复杂度都不高。我们也希望有一个快速可以落地的框架方案，且实现的成本较低。我们对比几个框架后，选择 CSS 原子化作为我们的 CSS 的架构方案。CSS 原子化提供现成的解决方案，几乎就是拿就用（ &lt;a href="https://github.com/tailwindlabs/tailwindcss"&gt;tailwindcss&lt;/a&gt; ，&lt;a href="https://github.com/windicss/windicss"&gt;windicss&lt;/a&gt; ）。而且成体接入和改造成本也是最低的，不用自己再制定命名规则和使用规范。&lt;/p&gt;
&lt;h2&gt;CSS 原子化是如何解决这些问题的&lt;/h2&gt;
&lt;p&gt;首先我们看看前文中提到组件使用 CSS 原子化是如何实现的，项目中已引入 winidicss。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20220920162709" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d8d80ff4d1d4438a877fdc989dc86e3~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class="overflow-hidden mr-1"&amp;gt;
  &amp;lt;a href="https://www.zcygov.cn/" class="float-left mr-1"&amp;gt;
 &amp;nbsp;  &amp;lt;img
 &amp;nbsp; &amp;nbsp;  width="30"
 &amp;nbsp; &amp;nbsp;  src="logo.png"
 &amp;nbsp; &amp;nbsp;  alt="zcy"
 &amp;nbsp;  /&amp;gt;
  &amp;lt;/a&amp;gt;
  &amp;lt;div class="overflow-hidden text-sm"&amp;gt;@小明 14 分钟之前&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这边如果需要 头像在右侧的，只需要将 float-left 替换成 float-right 即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有了命名的烦恼，按照功能命名&lt;/li&gt;
&lt;li&gt;没有相关嵌套，整体可读性加强&lt;/li&gt;
&lt;li&gt;没有重复 CSS 类， 一个功能对应一个类名，一个类名一个功能。没有重复&lt;/li&gt;
&lt;li&gt;没有新增 CSS 文件了。所有类名都是有工具库提供，项目中无需新增类了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上解决了项目现有的 CSS 问题，而且 CSS 的维护性有了很大的提高，CSS 编码的成本相对于以前有明显的降低。&lt;/p&gt;
&lt;h2&gt;使用体验&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接入简单：只选简单几步就能直接使用。参考官网的接入说明：&lt;a href="https://windicss.org/integrations/webpack.html"&gt;https://windicss.org/integrations/webpack.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;良好的编码提示：建议安装自动补全插件( &lt;a href="https://marketplace.visualstudio.com/items?itemName=voorjaar.windicss-intellisense"&gt;https://marketplace.visualstudio.com/items?itemName=voorjaar.windicss-intellisense&lt;/a&gt; )，对于日常使用有很大的帮助，用起来的体验也很好。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20221024195725661" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcd1101d7d9446c28aa97b7444aed6b6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速的功能和类目的映射：刚开始的时候对应功能的类名不熟悉，需要使用官网( &lt;a href="https://windicss.org/guide/"&gt;https://windicss.org/guide/&lt;/a&gt; )查询。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20221024195823993" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958ac8f1e4104a949dbbb3d7021cacef~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;design token 的设计规范约束：winidicss 工具提供了 design token 的设计规范实现，再推广 CSS 的原子化之前和设计师统一好此类的规范，形成工具配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { defineConfig } from 'windicss/helpers';
import colors from 'windicss/colors';

export default defineConfig({
  theme: {
    extend: {
      transitionProperty: {
        width: 'width',
      },
      screens: {
        sm: '640px',
        md: '768px',
        lg: '1024px',
        xl: '1280px',
      },
      colors: {
        gray: colors.coolGray,
        blue: colors.sky,
        red: colors.rose,
        pink: colors.fuchsia,
      },
      fontSize: {
        xs: '.75rem',
        sm: '.875rem',
        tiny: '.875rem',
        base: '14px',
        lg: '1.125rem',
        xl: '1.25rem',
        '2xl': '1.5rem',
        '3xl': '1.875rem',
        '4xl': '2.25rem',
        '5xl': '3rem',
        '6xl': '4rem',
        '7xl': '5rem',
      },
    },
  },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用过程中的问题&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;功能类优先的 原子化 CSS 框架，带来便利的同时，也是存在一些问题的。最突出的问题就是 html 上类过多，如果要实现一个相同功能，需要复制一个很长的字符串。这个情况下的可读性和复用性是比较差的。&lt;/p&gt;
&lt;p&gt;比如一个简单按钮的例子：涉及到背景，字体，边距，边框的设置，类就很多&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button
className="bg-blue-400 text-sm text-white font-mono font-light py-2 px-4 border-2 border-rounded border-blue-200"
&amp;gt;
  Button
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且相同样式复用需要整块的复制。虽然windicss提供属性化（&lt;a href="https://windicss.org/features/attributify.html"&gt;https://windicss.org/features/attributify.html&lt;/a&gt;）的模式，Shortcuts（&lt;a href="https://windicss.org/features/shortcuts.html"&gt;https://windicss.org/features/shortcuts.html&lt;/a&gt;）和指令（&lt;a href="https://cn.windicss.org/features/directives.html"&gt;https://cn.windicss.org/features/directives.html&lt;/a&gt;）来解决相同功能类集合过长，过多的问题。但是从他的实现思路上看，已经不在是原子化的范畴了。&lt;/p&gt;
&lt;p&gt;当然你也可以通过设计变量的方式来解决这个问题，但这种做法和抽象成一个组件的CSS类没有什么区别了。我们发现，原子化框架自身是无法解决这些问题的。但是我们使用CSS框架初衷是为了使CSS的维护性和复用性变高，而不是墨守成规，不变通。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const myButtonClass = "bg-blue-400 text-sm text-white font-mono font-light py-2 px-4 border-2 border-rounded border-blue-200"

&amp;lt;button
className={myButtonClass}
&amp;gt;
  Button
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;在选定一个 CSS 框架作为项目的 CSS 规范的时候，需要考虑自身项目的现状，如果项目本身 CSS 复杂度较高，相对是偏向CSS工作量较多，原子化的 CSS 是不太适合的，建议去参考像ITCSS，其实ITCSS中的 Utilities – 工具类和原子化就很类似，但是他的分层更加的复杂。随着&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@layer"&gt;CSS的级联层&lt;/a&gt;浏览器支持程度越来越好，类似ITCSS分层框架会慢慢流行起来。&lt;/p&gt;
&lt;p&gt;原子化的 CSS 可以帮助我们的项目解决 CSS 命名，代码重复，不断膨胀的问题，但它也不是一劳永逸的，实际使用中还是会有问题，关键在与开发者自身的取舍，权衡利弊。不要一个规则用到底，遇到问题也不变通。工具和思想发明其实也是为了解决你实际的问题。你会发现 &lt;a href="https://cn.windicss.org/posts/v30-utilities.html"&gt;windicss&lt;/a&gt; 这类工具优先的css框架，也是添加蛮多额外的功能来弥补原子化 CSS 框架的缺陷，提升自身使用体验。&lt;/p&gt;
&lt;h2&gt;参考连接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.smashingmagazine.com/2013/10/challenging-css-best-practices-atomic-approach/"&gt;Challenging CSS Best Practices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://css-tricks.com/lets-define-exactly-atomic-css/"&gt;Let’s Define Exactly What Atomic CSS is&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/windicss/windicss"&gt;windicss&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7153410606673395725"&gt;所见即所得 —— HTML转图片组件开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7145604963593355277"&gt;探索组件在线预览和调试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7143025612267978760"&gt;规范升级 NPM 包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7140422304920109092"&gt;你想知道的前后端协作规范都在这了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7158607083699437605"&gt;IntersectionObserver 实现虚拟列表初探&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="http://zoo.zhengcaiyun.cn/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 01 Nov 2022 16:41:42 GMT</pubDate></item><item><title>IntersectionObserver 实现虚拟列表初探</title><link>https://juejin.cn/post/7158607083699437605</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="陈皮.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdb140efc78b4c28a84a70654794b122~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 162 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="http://zoo.zhengcaiyun.cn/blog/article/intersectionobserver"&gt;IntersectionObserver 实现虚拟列表初探&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;前端开发中经常会遇到大数据量列表展示的性能问题，即大数据量一次性展示时前端渲染大量 Dom，触发渲染性能问题，造成初始加载白屏，交互卡顿等。解决这类问题的方案也有很多，使用虚拟列表展示是一个比较常见的解决方案。今天我们来介绍如何使用 IntersectionObserver 这个API来自定义实现虚拟列表。&lt;/p&gt;
&lt;h2&gt;传统列表&lt;/h2&gt;
&lt;p&gt;在未使用虚拟列表之前，传统列表很难处理大量数据的渲染问题，常出现以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表数据渲染时间长甚至出现白屏&lt;/li&gt;
&lt;li&gt;列表交互卡顿&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决该类问题，我们可以选用虚拟列表来承载大量数据的渲染，增强用户体验，&lt;code&gt;IntersectionObserver API&lt;/code&gt; 作为浏览器原生的API可以做到“观察”所需元素是否需要在页面上显示，以此来对大量数据的渲染进行优化。&lt;/p&gt;
&lt;h2&gt;虚拟列表&lt;/h2&gt;
&lt;p&gt;在介绍 IntersectionObserver 之前，我们先简单介绍下虚拟列表概念。前面已经提到，页面的性能问题是由于太多数据渲染展示引起的。但一个页面总共就那么大，人一屏能浏览的内容就这么多，如果我们可以只渲染展示当前可见区域内的内容，当内容已出可见区域外时只作简单渲染，这样不就可以大大提高页面性能了吗？虚拟列表就是这个思路的实现&lt;/p&gt;
&lt;p&gt;&lt;img alt="pic.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b32d6a17d9af4c6292518288cf2ea51b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;传统的实现方案&lt;/h2&gt;
&lt;p&gt;根据刚才的介绍我们知道，关键是要计算出哪些 dom 出现在可视区域需要实际渲染，哪些在视野外只需简单渲染。传统方法一般是监听 scroll, 在回调方案中 手动计算偏移量然后计算定位，由于 scroll 事件密集发生，计算量很大，容易造成性能问题。另外如果行行高不固定（实际业务中往往需要这样）, 那计算将会更加复杂。&lt;/p&gt;
&lt;p&gt;自己观察不难发现，所有的这些计算都是为了判断一个 dom 是否在可视范围内，如果存在一个方法可以方便地让我们知道这点，那实现虚拟列表方案将大大简化。幸运的是目前大部分浏览器已经提供了这个 api——IntersectionObserver&lt;/p&gt;
&lt;h2&gt;IntersectionObserver介绍&lt;/h2&gt;
&lt;p&gt;IntersectionObserver 接口 (从属于 Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗 (viewport) 交叉状态的方法。祖先元素与视窗 (viewport) 被称为根 (root)。&lt;/p&gt;
&lt;p&gt;当一个 IntersectionObserver 对象被创建时，其被配置为监听根中一段给定比例的可见区域。一旦 IntersectionObserver 被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值；然而，你可以在同一个观察者对象中配置监听多个目标元素。&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var intersectionObserver = new IntersectionObserver(function(entries) {
  // If intersectionRatio is 0, the target is out of view
  // and we do not need to do anything.
  if (entries[0].intersectionRatio &amp;lt;= 0) return;

  loadItems(10);
  console.log('Loaded new items');
});
// start observing
intersectionObserver.observe(document.querySelector('.scrollerFooter'));

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到用法很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先new IntersectionObserver 构造函数，这个函数接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）, 然后就得到一个观察器实例&lt;/li&gt;
&lt;li&gt;调用实例的 observe 方法对目标 dom 元素进行监听&lt;/li&gt;
&lt;li&gt;在回调函数 callback 中拿到 entries， entries是一个数组，里面每个成员都是一个IntersectionObserverEntry对象，监听了几个元素， entries就包含了几个成员。IntersectionObserverEntry对象描述了目标对象与容器之前的相交信息。其中 intersectionRatio 目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0。在这里我们取 entries[0].intersectionRatio 来判断目标元素是否在视野中, 大于0代表在视野中，小于0表示已移出视野。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;使用 IntersectionObserver 实现虚拟列表方案&lt;/h2&gt;
&lt;h4&gt;基本思路&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;实例化配置一个观察器，在这里除了传入回调函数外我们还会传入配置项：
config = {
root: document.querySelector('.main'),
}
这样我们就设置了 class 为 main 的 dom 元素为容器&lt;/li&gt;
&lt;li&gt;监听列表的每一行元素&lt;/li&gt;
&lt;li&gt;在回调函数中拿到每一个行元素的 intersectionRatio，一次判断是否在可是区域内。如果进入视野则给这一行附上实际的数据进行渲染，如果移出视野则将这一行的数据置为空。此外为了定位准确，我们在元素移出视野时给一个实际渲染时的高度。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简化示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt; &amp;lt;div class="main"&amp;gt;
     &amp;lt;div v-for="(row, index0) in uiPeriodList" :key="index0"&amp;gt;
         &amp;lt;div class="period" :style="periodStyle"&amp;gt;
            &amp;lt;div
              v-for="(column, index1) in row.columnList"
              :key="column.id"
            &amp;gt;
                /* 详细展示元素 */
            &amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;update() {
    let rolwList = document.querySelectorAll('.period')
    let _this = this
    let config = {
        root: document.querySelector('.main'),
    }
    let intersectionObserver = new IntersectionObserver(function(entries) {
        entries.forEach((row)=&amp;gt; {
            if (row.intersectionRatio &amp;lt;= 0) {
                if (!_this.isFirst) {
                    row.target.style.height = `${row.target.clientHeight}px`
                }
                _this.uiPeriodList[index].coordList = []
            } else {
                row.target.className = 'period'
                row.target.style.height = ''
                _this.uiPeriodList[index].columnList = _this.periodList[index].columnList // 附上实际元素
            }
        })
    }, config)
    if (this.isFirst) {
        rowList.forEach((row, index) =&amp;gt; {
            intersectionObserver.observe(row)
    })
        this.isFirst = false
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;没有效果&lt;/h4&gt;
&lt;p&gt;当按照上面实现后，实际测试却发现并没有达到预想效果，初始加载时仍然非常缓慢，出现长时间白屏。
这是为什么呢？打印发现，初始时每一行的元素都进入了视野中，触发了附上实际数据的动作从而引发渲染。
怀疑是初始加载元素时没有实际内容，导致大量的行元素没有高度而一下子直接进入了视野区，进而触发大数据量渲染。 为了解决这个问题，我们在初始时给行元素设置一个非常大的行高，使得在视野中只存在一行，然后对这一行附上实际数据，去除行高样式，使行的高度由实际内容决定。这样可以使各个行依次进入视野，逐个渲染直到实际的高度的行元素撑满视野&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;created() {
    this.periodStyle = {
        'grid-template-columns': `52px repeat(${this.headList.length}, 1fr)`,
        height: '2000px',
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;let intersectionObserver = new IntersectionObserver(function(entries) {
    entries.forEach((row)=&amp;gt;{
        if (row.intersectionRatio &amp;lt;= 0) {
            if (!_this.isFirst) {
                row.target.style.height = `${row.target.clientHeight}px`
            }
            _this.uiPeriodList[index].coordList = []
        } else {
            row.target.style.height = ''
            _this.uiPeriodList[index].columnList = _this.periodList[index].columnList // 附上实际元素
       }
   })
}, config)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再试一下，问题解决&lt;/p&gt;
&lt;h4&gt;快速下拉出现空白行&lt;/h4&gt;
&lt;p&gt;解决了上面的问题，我们的虚拟列表方案已基本实现，但还有瑕疵。当我们快速滚动列表时有可能出现空白区域，原因是监听回调是异步触发，不随着目标元素的滚动而触发，这样性能消耗很低，但也会导致回调函数没有执行，导致出现在视野中的元素但没有附上实际数据。&lt;/p&gt;
&lt;p&gt;自然地我们想到增加冗余量来解决这个问题，在行元素还没出现在视野当中时就附上实际数据进行渲染。查看发现在初始化 IntersectionObserver 可以传入配置项 rootMargin,  rootMargin 定义根元素的 margin，用来扩展或缩小 rootBounds 这个矩形的大小，从而影响 intersectionRect 交叉区域的大小。这样就变相地达成在视野单位外就进行数据实际渲染的目的&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;let config = {
    root: document.querySelector('.main'),
    rootMargin: '100px 0px',
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再试，问题基本解决&lt;/p&gt;
&lt;h2&gt;方案对比&lt;/h2&gt;
&lt;p&gt;由下图我们能看到，目前主流浏览器新版本基本都支持了这个 API， 但老版本及IE不支持
&lt;img alt="caniuse.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a00bb2493557401aa5f05b260b80aea1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;传统的监听 scroll 方案性能消耗大，交汇计算复杂，但浏览器兼容性高。
而 IntersectionObserver 异步特性降低了提高了性能且实现简便，但相应的兼容性较差些。&lt;/p&gt;
&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;虚拟列表是解决大数据量列表渲染的有效方案。对于实际业务中对老版本浏览器兼容性要求不高的场景，大家可以考虑使用 IntersectionObserver，可以方便地实现自定义的虚拟列表。&lt;/p&gt;
&lt;h5&gt;参考资料&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API"&gt;MDN: IntersectionObserver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html"&gt;阮一峰博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7153410606673395725"&gt;所见即所得 —— HTML转图片组件开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7145604963593355277"&gt;探索组件在线预览和调试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7143025612267978760"&gt;规范升级 NPM 包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7140422304920109092"&gt;你想知道的前后端协作规范都在这了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7135217402983235592"&gt;带你了解 Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 25 Oct 2022 16:12:45 GMT</pubDate></item><item><title>所见即所得 —— HTML转图片组件开发</title><link>https://juejin.cn/post/7153410606673395725</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="伟豪.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6546c8b2768040829a7667de22ff7830~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 161 篇不掺水的原创，想获取更多原创好文，请搜索公众号【政采云前端团队】关注我们吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在我们日常开发中一定会遇到&lt;code&gt;"所见即所得"&lt;/code&gt;的需求，如导出查询表格中的内容为Excel表格——&lt;a href="https://juejin.cn/post/7030291455243452429"&gt;《前端导出Excel，让后端刮目相看》&lt;/a&gt;、通过后台网页配置实现配置预览页与实际页面展示的统一——&lt;a href="https://juejin.cn/post/6937257727106220040"&gt;《从零开发一款可视化大屏制作平台》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;今天我们也来实现一个"所见即所得"的需求：将用户所见网页提取为图片。&lt;/p&gt;
&lt;p&gt;&lt;img alt="2C0714D1-BBEB-4810-8C64-F66963489F9D.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/946b0753eb2c4e87ad73f3fbeafa1034~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;方案1：最短步骤实现结果&lt;/h2&gt;
&lt;p&gt;第一个想到的方案就是通过浏览器自带的网页另存为图片去实现。&lt;/p&gt;
&lt;p&gt;&lt;img alt="68630441-5C95-4594-AFB1-CDE4C6F1B348.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c060bfc087148f397b0db5013012234~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;但这种方法显然是不可行的。第一需要提示用户操作进行繁琐的操作，第二无法达到局部提取为图片的效果。&lt;/p&gt;
&lt;h2&gt;方案2：达成初步可行方案&lt;/h2&gt;
&lt;p&gt;通过调研发现，可以使用 &lt;a href="http://html2canvas.hertzen.com/"&gt;html2canvas&lt;/a&gt; 将网页先转换为 &lt;code&gt;canvas&lt;/code&gt;数据。再将其转换为图片的方法，最终实现我们想要的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20221011134318.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a77d7bf291740349a16c0cca4e30ade~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;引入html2canvas&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cnpm install --save html2canvas
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;div class="box"&amp;gt;
    &amp;lt;!-- 将可保存为图片的内容 通过一个 标签 框起来 --&amp;gt;
    &amp;lt;div id="screenshot-box"&amp;gt;
      &amp;lt;!-- 内容可以随意 --&amp;gt;
      &amp;lt;p&amp;gt;名称：&amp;lt;a-input v-model="formState.name" /&amp;gt;&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;年龄：&amp;lt;a-input v-model="formState.age" /&amp;gt;&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        班级：
        &amp;lt;a-radio-group v-model="formState.class"&amp;gt;
          &amp;lt;a-radio value="1"&amp;gt;班级1&amp;lt;/a-radio&amp;gt;
          &amp;lt;a-radio value="2"&amp;gt;班级2&amp;lt;/a-radio&amp;gt;
        &amp;lt;/a-radio-group&amp;gt;
      &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;a-button  @click="onSaveCanvas"&amp;gt;保存为图片&amp;lt;/a-button&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 点击保存为Canvas
    onSaveCanvas(){
       // 这里的类名要与点击事件里的一样
        const canvas = document.querySelector('#screenshot-box');
        let that = this;
        html2canvas(canvas,{scale:2,logging:false,useCORS:true}).then(function(canvas) {
          const type = 'png';
          let imgData = canvas.toDataURL(type);
          // 图片格式处理
          let _fixType = function(type) {
          type = type.toLowerCase().replace(/jpg/i, 'jpeg');
          let r = type.match(/png|jpeg|bmp|gif/)[0];
          return 'image/' + r;
        };
            imgData = imgData.replace(_fixType(type),'image/octet-stream');
            let filename = "htmlImg" + '.' + type;
            // 保存为文件
            //  以bolb文件下载
 that.downFileToLocal(filename,that.convertBase64ToBlob(imgData))
        });
    },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此我们便实现了初步的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="1.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dec5e02062c74cba8d889df06ca8c900~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;当然，我们也可以设置一个预览图片来预览我们将要导出的图片。&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;img :src="previewPic" alt="预览图片"&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;this.previewPic = URL.createObjectURL(that.convertBase64ToBlob(imgData));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;展示效果&lt;/p&gt;
&lt;p&gt;&lt;img alt="A9A4712D-B30C-452E-A610-9F5ACF492162.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02bbb33f4bef4f5cbe2929f51b8bbbad~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;将方案进行拓展并升级&lt;/h2&gt;
&lt;p&gt;需求止步于此，但秉承着"将事情做的更好"的我们岂能止步于此。&lt;/p&gt;
&lt;h3&gt;实现HTML导出为Word&lt;/h3&gt;
&lt;p&gt;我们需要通过 html-docx 来实现导出为Word（&lt;strong&gt;导出Word目前只支持原生HTML + CSS&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;引入html-docx&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cnpm install --save html-docx-js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;div id="export-word"&amp;gt;
      &amp;lt;table border &amp;gt;
        &amp;lt;tr&amp;gt;
          &amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;
          &amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
          &amp;lt;td&amp;gt;贾维斯&amp;lt;/td&amp;gt;
          &amp;lt;td&amp;gt;2&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
      &amp;lt;/table&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;a-button  @click="onWordExport"&amp;gt;导出为word&amp;lt;/a-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;onWordExport(){
        var contentHtml = document.getElementById("export-word").innerHTML;
        const cssHTML = `table {
                          width: 200px;
                          border: 1px solid #ccc;
                          color:red;
                        }`
        var content = `&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;
            &amp;lt;head&amp;gt;
                &amp;lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&amp;gt;
                &amp;lt;style&amp;gt;
                    ${cssHTML}
                &amp;lt;/style&amp;gt;
            &amp;lt;/head&amp;gt;
            &amp;lt;body&amp;gt;
                ${contentHtml}
            &amp;lt;/body&amp;gt;
            &amp;lt;/html&amp;gt;`
        var converted = htmlDocx.asBlob(content,{orientation:"landscape"});
        this.downFileToLocal('word文件名.docx',converted)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;展示效果&lt;/p&gt;
&lt;p&gt;&lt;img alt="2.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c25207348094464b8aed24cfdb0cbd05~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;如此我们便实现了导出 HTML 为 Word。&lt;/p&gt;
&lt;h3&gt;实现HTML导出为PDF&lt;/h3&gt;
&lt;p&gt;目前市面上 HTML 导出 PDF 的实现方式有多种，如&lt;a href="https://github.com/parallax/jsPDF"&gt;jsPDF&lt;/a&gt;、&lt;a href="https://blog.csdn.net/weixin_43897590/article/details/124729389"&gt;iText&lt;/a&gt;、&lt;a href="https://github.com/wkhtmltopdf/wkhtmltopdf"&gt;wkhtmltopdf&lt;/a&gt;等。在不同情况下我们应该使用不同的解决方案：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方案&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;th&gt;分页&lt;/th&gt;
&lt;th&gt;图片&lt;/th&gt;
&lt;th&gt;表格&lt;/th&gt;
&lt;th&gt;链接&lt;/th&gt;
&lt;th&gt;中文&lt;/th&gt;
&lt;th&gt;特殊字符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;jsPDF&lt;/td&gt;
&lt;td&gt;1、整个过程在客户端执行(不需要服务器参与)，调用简单&lt;/td&gt;
&lt;td&gt;1、生成的pdf为图片形式，且内容失真&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iText&lt;/td&gt;
&lt;td&gt;1、功能基本可以实现，比较灵活 2、生成pdf质量较高&lt;/td&gt;
&lt;td&gt;1、对html标签严格，少一个结束标签就会报错；2、后端实现复杂，服务器需要安装字体；3、图片渲染比较复杂&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wkhtmltopdf&lt;/td&gt;
&lt;td&gt;1、调用方式简单；2、生成pdf质量较高&lt;/td&gt;
&lt;td&gt;1、服务器需要安装wkhtmltopdf环境；2、根据网址生成pdf，对于有权限控制的页面需要在拦截器进行处理&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;今天我们使用在&lt;strong&gt;客户端执行&lt;/strong&gt;(不需要服务器参与)的方式——jsPDF。&lt;/p&gt;
&lt;p&gt;导入jsPDF&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install --save jspdf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt; &amp;lt;a-button  @click="onPDFExport"&amp;gt;导出为PDF&amp;lt;/a-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 导出为PDF
    onPDFExport(){
      const canvas = document.querySelector('#screenshot-box');
      html2canvas(canvas).then(function(canvas) {
        let contentWidth = canvas.width;
            let contentHeight = canvas.height;
            //一页pdf显示html页面生成的canvas高度;
            let pageHeight = contentWidth / 592.28 * 841.89;
            //未生成pdf的html页面高度
            let leftHeight = contentHeight;
            //页面偏移
            let position = 0;
            //a4纸的尺寸[595.28,841.89]，html页面生成的canvas在pdf中图片的宽高
            let imgWidth = 595.28;
            let imgHeight = 592.28/contentWidth * contentHeight;

            let pageData = canvas.toDataURL('image/jpeg', 1.0);

            let pdf = new jsPDF('', 'pt', 'a4');

            //有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)
            //当内容未超过pdf一页显示的范围，无需分页
            if (leftHeight &amp;lt; pageHeight) {
              pdf.addImage(pageData, 'JPEG', 0, 0, imgWidth, imgHeight );
            } else {
              while(leftHeight &amp;gt; 0) {
                  pdf.addImage(pageData, 'JPEG', 0, position, imgWidth, imgHeight)
                  leftHeight -= pageHeight;
                  position -= 841.89;
                  //避免添加空白页
                  if(leftHeight &amp;gt; 0) {
                    pdf.addPage();
                  }
              }
            }
            pdf.save('content.pdf');
      })
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;展示效果&lt;/p&gt;
&lt;p&gt;&lt;img alt="3.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77defcda66bd45269560301574d7fde8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;如此我们便实现了导出 HTML 为 PDF。&lt;/p&gt;
&lt;h2&gt;将功能封装为组件&lt;/h2&gt;
&lt;p&gt;实现一次HTML导出图片需要写的代码太多，很多参数也需要按需定制。是否能够将其封装成组件呢？&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;a href="https://v2.cn.vuejs.org/v2/api/#v-slot"&gt;Vue的插槽&lt;/a&gt;将我们导出的内容进行插入&lt;/p&gt;
&lt;h3&gt;完整组件&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-HTML"&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class="box"&amp;gt;
    &amp;lt;!-- 将可保存为图片的内容 通过一个 标签 框起来 --&amp;gt;
    &amp;lt;div :id="id"&amp;gt;
        &amp;lt;!-- 需要导出的内容 --&amp;gt;
        &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
//引入html2canvas
import html2canvas from 'html2canvas';
export default {
  name: "Html2Image",
  props: {
    id: { // id
      type: String,
      default: 'export-box',
    },
    filename: { // 导出文件名称
      type: String,
      default: 'htmlPic',
    },
    outType:{ // 导出类型
      type: String,
      default: 'png',
      validator(value) {
        return ['png', 'jpg', 'bmp','jpeg','gif'].includes(value)
      }
    },
    isFile: { // 是否为导出文件
      type: Boolean,
      default: false,
    },
    
  },
  methods: {
    //点击保存为Canvas
    onSaveCanvas(){
       // 这里的类名要与点击事件里的一样
        const canvas = document.querySelector(`#${this.id}`);
        let that = this;
        html2canvas(canvas,{scale:2,logging:false,useCORS:true}).then(function(canvas) {
          const type = that.outType;
          let imgData = canvas.toDataURL(type);
          
          // 图片格式处理
          let _fixType = function(type) {
            type = type.toLowerCase().replace(/jpg/i, 'jpeg');
            let r = type.match(/png|jpeg|bmp|gif/)[0];
            return 'image/' + r;
          };
          imgData = imgData.replace(_fixType(type),'image/octet-stream');
          if(!that.isFile){
              const retn = URL.createObjectURL(that.convertBase64ToBlob(imgData))
              that.$emit('onExport',retn)
              return retn
          }
          //  以bolb文件下载
          that.downFileToLocal(that.filename + '.' + type,that.convertBase64ToBlob(imgData))
        });
    },
    // base64转化为Blob对象
    convertBase64ToBlob(imageEditorBase64) {
      let base64Arr = imageEditorBase64.split(",");
      let imgtype = "";
      let base64String = "";
      if (base64Arr.length &amp;gt; 1) {
        //如果是图片base64，去掉头信息
        base64String = base64Arr[1];
        imgtype = base64Arr[0].substring(
          base64Arr[0].indexOf(":") + 1,
          base64Arr[0].indexOf(";")
        );
      }
      // 将base64解码
      let bytes = atob(base64String);
      //let bytes = base64;
      let bytesCode = new ArrayBuffer(bytes.length);
      // 转换为类型化数组
      let byteArray = new Uint8Array(bytesCode);
 
      // 将base64转换为ascii码
      for (let i = 0; i &amp;lt; bytes.length; i++) {
        byteArray[i] = bytes.charCodeAt(i);
      }
      // 生成Blob对象（文件对象）
      return new Blob([bytesCode], { type: imgtype });
    },
    // 下载Blob流文件
    downFileToLocal(fileName, blob) {
      // 创建用于下载文件的a标签
      const d = document.createElement("a");
      // 设置下载内容
      d.href = URL.createObjectURL(blob);
      // 设置下载文件的名字
      d.download = fileName;
      // 界面上隐藏该按钮
      d.style.display = "none";
      // 放到页面上
      document.body.appendChild(d);
      // 点击下载文件
      d.click();
      // 从页面移除掉
      document.body.removeChild(d);
      // 释放 URL.createObjectURL() 创建的 URL 对象
      window.URL.revokeObjectURL(d.href);
    },
  },
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Attributes&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;唯一ID，盒子内容将作为导出内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;filename&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;导出的文件名称（不带文件类型后缀）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;outType&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;导出文件类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isFile&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;是否导出为文件，true将下载文件，false返回bolb路径&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Methods&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;onSaveCanvas&lt;/td&gt;
&lt;td&gt;执行导出或保存方法&lt;/td&gt;
&lt;td&gt;若isFile为true则保存文件，若isFile为false则返回bolb路径&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Events&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;onExport&lt;/td&gt;
&lt;td&gt;导出方法&lt;/td&gt;
&lt;td&gt;当触发导出/下载时会触发该方法输出 Bolb路径 类型String&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;使用组件&lt;/h3&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;Html2Image ref="html2Image" @onExport="exportPic" &amp;gt;
      &amp;lt;div class="export-content" style="border: 1px solid #F0F;width:200px"&amp;gt;
        &amp;lt;div&amp;gt;1&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;2&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;3&amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/Html2Image&amp;gt;
&amp;lt;a-button  @click="onExportImgByComponent"&amp;gt;组件导出为图片&amp;lt;/a-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 引入组件
import Html2Image from '@/components/Html2Image/Html2Image.vue'
// 使用组件
components: { 
    Html2Image
},

// methods
onExportImgByComponent(){
      this.previewPicComponent =this.$refs.html2Image.onSaveCanvas()
    },
exportPic(baseUrl){
       // 赋值导出图片的blob路径
      this.previewPicComponent = baseUrl;
    },  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Q&amp;amp;A&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Q.为什么外网图片展示不出?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="7BFD5507-2620-4EEB-A4AF-144F63441CD8.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36068e8ea46442fca4e0527ca3fa42f6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A: 设置 html2canvas 方法中 useCORS 为 true 即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="AC53AB9C-170A-4CF8-8F1B-2C7724EDC3F6.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8296ccb966454ebfb835e28d46404673~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;最后要说的&lt;/h2&gt;
&lt;p&gt;项目地址: &lt;a href="https://github.com/FireSmallPanda/vuexDemo.git"&gt;https://github.com/FireSmallPanda/vuexDemo.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTML导出为图片组件地址:&lt;a href="https://github.com/FireSmallPanda/vuexDemo/tree/master/src/components/ImageUpload"&gt;HTML导出为图片组件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据需求目前只封装了HTML导出为图片，相信大家可以依葫芦画瓢将导出Word和PDF也一并封装为组件。&lt;/p&gt;
&lt;h2&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/liuzemtx/article/details/109307540"&gt;《前端实现将页面保存成图片功能》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/xiao970615/article/details/126305092"&gt;《base64字串转Blob文件流，Blob文件流再下载到本地》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gitcode.net/mirrors/linwalker/render-html-to-pdf?utm_source=csdn_github_accelerator"&gt;《render-html-to-pdf》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/lisheng19870305/article/details/124158191"&gt;《HTML页面导出为PDF》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://landscape.tuchong.com/"&gt;外网图片来源——《风光摄影精选》&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7145604963593355277"&gt;探索组件在线预览和调试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7143025612267978760"&gt;规范升级 NPM 包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7140422304920109092"&gt;你想知道的前后端协作规范都在这了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7135217402983235592"&gt;带你了解 Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7132628898453880840"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 11 Oct 2022 16:07:23 GMT</pubDate></item><item><title>探索组件在线预览和调试</title><link>https://juejin.cn/post/7145604963593355277</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="梓安.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0f54a21fcf14baa85523b4ccbba2a52~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 160 篇不掺水的原创，想获取更多原创好文，请搜索公众号【政采云前端团队】关注我们吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;前端人员在开发过程中，如何快速&lt;strong&gt;感知&lt;/strong&gt;到组件的功能和属性？现状是通过阅读组件相关文档，好在基础组件库的文档相对完整和清晰，手动补全示例。业务组件相关文档目前只能在内部 NPM 私库上查看，静态的 API 文档，没有组件的 Demo。对于非前端人员，如何预览和调试组件呢？比如：某一天，产品想提前调研其它业务线的业务组件功能能否满足业务诉求；业务组件开发完成，测试和设计可以介入组件相关功能的验证；运营人员可以在低代码搭建平台，预览和调试相关组件等。&lt;/p&gt;
&lt;p&gt;基于以上痛点问题，我们从需求点出发，逐步探索实现方案。&lt;/p&gt;
&lt;h2&gt;需求&lt;/h2&gt;
&lt;h3&gt;场景分析&lt;/h3&gt;
&lt;h4&gt;功能&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;组件预览&lt;/li&gt;
&lt;li&gt;组件调试 面向不同的用户群体，组件功能调试的交互分为两种，一种是&lt;strong&gt;代码调试&lt;/strong&gt;，即通过代码编辑器修改示例代码，另一种是组件 &lt;strong&gt;schema 调试&lt;/strong&gt;，通过 schema JSON 数据来描述组件的属性，然后 通过 schema 渲染器渲染成组件属性面板，这样非研发人员也可以方便的调试组件功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;分类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基础组件&lt;/li&gt;
&lt;li&gt;业务组件&lt;/li&gt;
&lt;li&gt;低代码组件 大致整理了下：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="组件预览和调试-组件分类-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08984f1dad7d4d50b3ab0a58ccfa16ac~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;这里的&lt;strong&gt;低代码组件&lt;/strong&gt;是指提供给低代码搭建平台使用的自定义组件，目前公司的低代码搭建平台主要有“鲁班”，对此感兴趣的小伙伴可以翻一下往期关于 &lt;strong&gt;“鲁班”&lt;/strong&gt; 的文章。&lt;/p&gt;
&lt;p&gt;针对组件&lt;strong&gt;schema 调试&lt;/strong&gt;，低代码组件本身自带 schema 文件，如：“鲁班”自定义组件会有一份 schema.json 文件，需要开发者去编写和维护这份文件。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
 &amp;nbsp;"props": {
 &amp;nbsp; &amp;nbsp;"linkList": {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;"group": "链接配置",
 &amp;nbsp; &amp;nbsp; &amp;nbsp;"title": "链接列表",
 &amp;nbsp; &amp;nbsp; &amp;nbsp;"type": "array",
 &amp;nbsp; &amp;nbsp; &amp;nbsp;"fields": [
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"name": "imageAddress",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"title": "图链接图片地址",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"type": "string"
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  },
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"name": "imageLink",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"title": "链接跳转地址",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"type": "string"
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  } &amp;nbsp; 
 &amp;nbsp; &amp;nbsp;  ]
 &amp;nbsp;  }
  },
 &amp;nbsp;"models": {
 &amp;nbsp; &amp;nbsp;"linkList": [
 &amp;nbsp; &amp;nbsp;  {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"imageAddress": "",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"imageLink": ""
 &amp;nbsp; &amp;nbsp;  },
 &amp;nbsp; &amp;nbsp;  {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"imageAddress": "",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"imageLink": ""
 &amp;nbsp; &amp;nbsp; &amp;nbsp; }
 &amp;nbsp;  ]
  } &amp;nbsp; 
}
​
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，业务组件也需要同一份 schema 协议的 JSON 文件，这样就可以动态调试组件的属性。但是，不会让开发组件的同学去手动编写。&lt;/p&gt;
&lt;p&gt;自动生成 schema 文件大致思路：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件在线预览和调试-自动生成 schema 文件-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44db4b0c13c34831872c27bf7ea8b22c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;应用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基础组件的示例在线预览和调试&lt;/li&gt;
&lt;li&gt;业务组件的 Demo 在线预览和调试&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;面向人群&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;研发&lt;/li&gt;
&lt;li&gt;非研发：产品、测试、运营 研发主要用到组件的调试功能，而像运营和产品这样非研发人员，他们的诉求简单快捷，就是直接预览该组件，并且可以通过修改组件的 props 看到实时效果，那么问题来了，如何修改组件当前的 props 属性？玩过低代码的同学应该很清楚，有个组件&lt;strong&gt;属性面板&lt;/strong&gt;。基于以上，我们可能需要代码编辑面板、组件属性面板以及组件功能模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大致画了下页面的结构图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件在线预览和调试-界面图-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd38c6f6cf1449d7a3787312587e0124~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;调研&lt;/h2&gt;
&lt;h3&gt;市面上成熟的产品&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Stackblitz 一款非常优秀的在线 IDE，移植了很多 VS Code 的功能和特性。目前支持了很多框架模版，如：React、Angular、Vue3、Next.js、Nuxt3 及自定义模版等，其中， StackBlitz 提供的 WebContainers 可以在浏览器端运行 Node.js 环境。&lt;/li&gt;
&lt;li&gt;CodeSandbox 为 Web 应用程序而开发而构建的在线编辑器，同样也提供了多种模版方便开发者使用。大部分核心代码也开源了，网上也有相关的原理解析和搭建在线 IDE 方案的资料，有兴趣的同学可以去看看。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;需求和应用场景已经很明确了，考虑到不同的用户群体，交互方式也有差别，重点是组件调试功能的差异性，对于研发人员可通过代码编辑器去修改代码达到调试效果，非研发人员则通过修改属性面板的组件属性值。而市面上的成熟产品会提供一些设计思路，具体实现方案下面会细讲。&lt;/p&gt;
&lt;h2&gt;方案&lt;/h2&gt;
&lt;p&gt;从页面结构图，我们先聊下代码编辑器、组件属性面板、工具栏、预览区的设计方案。&lt;/p&gt;
&lt;h4&gt;代码编辑器&lt;/h4&gt;
&lt;p&gt;目前主流的有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MonacoEditor&lt;/li&gt;
&lt;li&gt;Codemirror MonacoEditor 相对来说功能强大，集成度高，但随之带来的是比较重，而 Codemirror 轻量小巧，核心文件压缩后仅 70+ KB 左右，根据所需要支持的语言按需打包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种代码编辑器都能满足我们的需求，在线修改一些组件 Demo 的部分代码，其实 Codemirror 够用了。&lt;/p&gt;
&lt;h4&gt;组件属性面板&lt;/h4&gt;
&lt;p&gt;了解低代码搭建平台的朋友应该很熟悉了，其实就是通过表单去动态修改组件的属性参数，因此，需要一份通用的 schema 协议，来描述组件的自定义属性。可以由&lt;strong&gt;鲁班&lt;/strong&gt;和大数据搭建平台那边提供 schema 数据，我们负责渲染即可。&lt;/p&gt;
&lt;p&gt;大致列了下组件属性的类型和操作表单类型的对应关系：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件预览和调试-属性面板-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30bc75c06daa4ec1a76c4c17c4617fc2~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;工具栏&lt;/h4&gt;
&lt;p&gt;工具栏包含的主要功能有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;账号登陆&lt;/li&gt;
&lt;li&gt;接口代理 业务组件和低代码组件需要被调试时，比如测试人员需要介入测试组件功能，需要用到&lt;strong&gt;账号登陆&lt;/strong&gt;和&lt;strong&gt;接口代理功能&lt;/strong&gt;。组件内涉及到业务接口的请求头需要携带当前登陆用户的 token 信息，先通过请求 oauth 接口拿到对应的 token，然后塞到请求头的 Authorization 字段上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面实现的前提是需要一个代理服务，在本地开发环境我们可以用 &lt;strong&gt;http-proxy&lt;/strong&gt;插件创建本地代理服务，那么问题来了，在浏览器端如何做代理服务？&lt;/p&gt;
&lt;p&gt;目前主流的方案都是通过 Chrome 插件形式，需要用户手动填写代理接口等信息。在我们的场景下，这个方案对用户体验显然不够友好。还有个方案可以利用浏览器的黑科技 —— &lt;strong&gt;Service Worker&lt;/strong&gt;，它可以拦截网页发出的请求，并能自定义返回内容，相当于在浏览器内部实现了一个反向代理。&lt;/p&gt;
&lt;h4&gt;预览区&lt;/h4&gt;
&lt;p&gt;核心会涉及到两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器&lt;/li&gt;
&lt;li&gt;通信 容器是指页面容器，业界通用做法都是通过 iframe，将编译好的组件代码挂载到 iframe 里一个 root 节点上，主要有环境隔离和动态生成预览页面的访问链接作用。编辑器、核心包、预览区之间的通信可以用 postMessage。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通信时序图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件预览和调试-通信.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d3c6df9ec5e494ebc6559c25d467036~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;核心包&lt;/h4&gt;
&lt;p&gt;设计思路，主要参考了 CodeSandbox 的核心源码，主要涉及到代码转译和代码执行。核心模块有 Manger、Transpiler、Preset、Transpiled-module、Runtime。&lt;/p&gt;
&lt;p&gt;架构图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件预览和调试架构图-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c1842b6b80e446dbe3d62debd4e314a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;大致流程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件在线预览和调试-核心包流程图-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4de5229d7f9747138764c3d681c04d13~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;Manger 模块&lt;/h4&gt;
&lt;p&gt;顾名思义“管理者“，即管理其它核心模块，主要负责代码转译和执行的一系列过程。&lt;/p&gt;
&lt;p&gt;核心方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addTranspiledModule&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resolveTranspiledModuleSync&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resolveTranspiledModuleAsync&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;evaluateTranspiledModule&lt;/code&gt; 首先将转译后的模块缓存起来放到 &lt;code&gt;transpiledModules&lt;/code&gt; 对象 ，需要的话可以从缓存里同步或异步加载转译后的模块，如果需要执行转译的模块，可以调用 &lt;code&gt;evaluateTranspiledModule&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;transpiledModules&lt;/code&gt; 的类型定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type IModule = {
 &amp;nbsp;path: string;
 &amp;nbsp;url?: any;
 &amp;nbsp;code: string;
 &amp;nbsp;requires?: Array&amp;lt;string&amp;gt;;
 &amp;nbsp;parent?: Module;
};
​
interface ITranspiledModules {
 &amp;nbsp;  [path: string]: {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;module: IModule;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;tModules: {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  [query: string]: ITranspiledModule; // ITranspiledModule 类型定义放在 Transpiled-module 模块
 &amp;nbsp; &amp;nbsp;  };
 &amp;nbsp;  };
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Transpiler 模块&lt;/h4&gt;
&lt;p&gt;类比 Webpack 的 loader，对指定类型的文件进行编译，如：Babel、Typescript、vue、tsx、jsx 等。&lt;/p&gt;
&lt;p&gt;介绍下部分内置的 Transpiler 模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;babelTranspiler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stylesTranspiler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rawTranspiler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noopTranspiler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vueTranspiler&lt;/code&gt; &lt;code&gt;rawTranspiler&lt;/code&gt; 跟 Webpack 的 raw-loader 作用一样，将模块的内容作为字符串导入，从而实现静态资源内联。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现原理也很简单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = JSON.stringify(sourceCode)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;babelTranspiler&lt;/code&gt; 这里实现了简化版，script 标签引入 bable-standalone.js，拿到全局对象 Babel。&lt;/p&gt;
&lt;p&gt;部分核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import babelPluginRenameImports from './plugins/babel-plugin-rename-imports';
​
const transpiledCode = window.Babel.transform(code, {
 &amp;nbsp;plugins: [babelPluginRenameImports],
 &amp;nbsp;presets: ['es2015', 'es2016', 'es2017'],
}).code;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vueTranspiler&lt;/code&gt; ，这里默认是 vue2.0 版本，核心依赖了 &lt;code&gt;vue-template-compiler&lt;/code&gt;、&lt;code&gt;vue-template-es2015-compiler&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;将 vue 单文件组件转换为 SFC 对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as compiler from 'vue-template-compiler';
import type {SFCDescriptor} from 'vue-template-compiler';
​
const sfc:SFCDescriptor = compiler.parseComponent(content, { pad: 'line' });
​
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析 Vue template 部分核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as compiler from 'vue-template-compiler';
import transpile from 'vue-template-es2015-compiler'; &amp;nbsp; 
 &amp;nbsp;
function vueTemplateCompiler(html, options) {
 &amp;nbsp;const bubleOptions = options.buble;
 &amp;nbsp;const vueOptions = options.vueOptions || {};
 &amp;nbsp;const userModules = vueOptions.compilerModules || options.compilerModules;
 &amp;nbsp;const stripWith = bubleOptions.transforms.stripWith !== false;
 &amp;nbsp;const { stripWithFunctional } = bubleOptions.transforms;
 &amp;nbsp;const staticRenderFns = compiled.staticRenderFns.map((fn) =&amp;gt; 
 &amp;nbsp; &amp;nbsp; toFunction(fn, stripWithFunctional)
  ); // 静态渲染函数放到数组中
 &amp;nbsp;const compilerOptions: compiler.CompilerOptionsWithSourceRange = {
 &amp;nbsp; &amp;nbsp;preserveWhitespace: options.preserveWhitespace, // 是否保留HTML标记之间的所有空白字符
 &amp;nbsp; &amp;nbsp;modules: defaultModules.concat(userModules || []), // 自定义编译模版 
 &amp;nbsp; &amp;nbsp;directives: vueOptions.compilerDirectives || options.compilerDirectives || {}, // 自定义指令 
 &amp;nbsp; &amp;nbsp;comments: options.hasComment, // 是否保留注释
 &amp;nbsp; &amp;nbsp;scopeId: options.hasScoped ? options.id : null, / 
  };
  const compiled = compiler.compile(html, compilerOptions);
  
 &amp;nbsp;// 生成渲染函数和静态子树
  let code = transpile(
 &amp;nbsp;  'var render = ' +
 &amp;nbsp;    toFunction(compiled.render, stripWithFunctional) +
 &amp;nbsp; &amp;nbsp;'\n' +
 &amp;nbsp; &amp;nbsp;'var staticRenderFns = [' + 
      staticRenderFns.join(',') +
 &amp;nbsp; &amp;nbsp; ']') + '\n';
 &amp;nbsp; &amp;nbsp;// mark with stripped (this enables Vue to use correct runtime proxy detection)
 &amp;nbsp; &amp;nbsp;if (stripWith) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;code += `render._withStripped = true\n`;
 &amp;nbsp;  }
​
 &amp;nbsp; &amp;nbsp;const exports = `{ render: render, staticRenderFns: staticRenderFns }`;
 &amp;nbsp; &amp;nbsp;code += `module.exports = ${exports}`;
 &amp;nbsp;
    return code;
}
​
function toFunction(code, stripWithFunctional) {
 &amp;nbsp;return 'function (' + (stripWithFunctional ? '_h,_vm' : '') + ') {' + code + '}';
}
​
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vue 在渲染阶段将模板编译为 AST，然后根据 AST 生成 render 函数，底层通过调用 render 函数会生成 VNode 创建虚拟 DOM。&lt;/p&gt;
&lt;h4&gt;Preset 模块&lt;/h4&gt;
&lt;p&gt;组件预设构建模版，针对不同组件的框架类型，如：Vue2、React 等，预设默认该类型组件所需的 &lt;code&gt;Transpiler&lt;/code&gt; 模块。类似于 vue-cli、create-react-app。&lt;/p&gt;
&lt;p&gt;核心方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;registerTranspiler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getTranspilers&lt;/code&gt; &lt;code&gt;registerTranspiler&lt;/code&gt; 作用是注册 Transpiler 模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;部分伪代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vuePreset.registerTranspiler(
  (module) =&amp;gt; /.(m|c)?jsx?$/.test(module.path),
  [{ transpiler: babelTranspiler }]
);
vuePreset.registerTranspiler(
  (module) =&amp;gt; /.vue$/.test(module.path),
  [{ transpiler: vueTranspiler }]
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Transpiled-module 模块&lt;/h4&gt;
&lt;p&gt;即转译后的模块，维护转译的结果、代码执行的结果、依赖的模块信息，负责驱动具体模块的转译(调用 Transpiler)和执行。&lt;/p&gt;
&lt;h4&gt;Runtime 模块&lt;/h4&gt;
&lt;p&gt;执行转译后的模块入口，使用 eval 执行入口文件，若遇到 require 函数，加载转译后的依赖模块然后使用 eval 执行执行。&lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export default function (
 &amp;nbsp;code: string,
 &amp;nbsp;require: Function,
 &amp;nbsp;module: { exports: any },
 &amp;nbsp;env: Object = {},
 &amp;nbsp;globals: Object = {},
  { asUMD = false }: { asUMD?: boolean } = {}
) {
 &amp;nbsp;const { exports } = module;
  
 &amp;nbsp;const g = typeof window === 'undefined' ? self : window;
 &amp;nbsp;const global = g;
 &amp;nbsp;g.global = global;
  
 &amp;nbsp;// 兼容 Node.js 环境，列举了一部分
 &amp;nbsp;const process = {
 &amp;nbsp; &amp;nbsp;env: { NODE_ENV: 'development', ...env },
 &amp;nbsp; &amp;nbsp;cwd: () =&amp;gt; { return '/' },
 &amp;nbsp; &amp;nbsp;umask: () =&amp;gt; { return 0 }
  };
 &amp;nbsp;
 &amp;nbsp;// 全局变量
 &amp;nbsp;const allGlobals: { [key: string]: any } = {
 &amp;nbsp; &amp;nbsp;require, // require 函数
 &amp;nbsp; &amp;nbsp;module,
 &amp;nbsp; &amp;nbsp;exports,
 &amp;nbsp; &amp;nbsp;process,
 &amp;nbsp; &amp;nbsp;global,
 &amp;nbsp; &amp;nbsp;...globals,
  };
​
 &amp;nbsp;// 是否 UMD 模块
 &amp;nbsp;if (asUMD) {
 &amp;nbsp; &amp;nbsp;delete allGlobals.module;
 &amp;nbsp; &amp;nbsp;delete allGlobals.exports;
 &amp;nbsp; &amp;nbsp;delete allGlobals.global;
  }
 &amp;nbsp;
 &amp;nbsp;const allGlobalKeys = Object.keys(allGlobals);
 &amp;nbsp;const globalsCode = allGlobalKeys.length ? allGlobalKeys.join(', ') : '';
 &amp;nbsp;const globalsValues = allGlobalKeys.map((k) =&amp;gt; allGlobals[k]);
 &amp;nbsp;
 &amp;nbsp;const newCode = `(function $csb$eval(` + globalsCode + `) {` + code + `\n})`;
  (0, eval)(newCode).apply(allGlobals.global, globalsValues);
​
}
​
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;从页面功能模块到组件的构建核心包设计，相信各位看官已经有了初步的了解。有两点没有提到，在这里简单补充下。&lt;/p&gt;
&lt;p&gt;第一点是依赖包的数据源问题，简单粗暴点就是创建 manifest 文件，事先预存一份底层通用的依赖包数据，如：Babel 插件相关等，如果需要动态添加依赖包，可以使用 import-maps 特性。&lt;/p&gt;
&lt;p&gt;第二点在 Transpiler 模块没有提到针对 react 组件的构建方案，添加相关 Babel 插件就好了，如：&lt;code&gt;transform-runtime&lt;/code&gt; 、&lt;code&gt;@babel/plugin-transform-react-jsx-source&lt;/code&gt; 等。&lt;/p&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;背景、需求、调研、方案这四个层面，其中背景和需求更多是从产品的角度去思考和设计，这样做出来的东西才更符合用户需求和提升用户体验。我们技术人员不仅仅只关心技术层面的设计，更多时候还要从产品的角度去思考。&lt;/p&gt;
&lt;p&gt;组件作为项目开发不可分割的一部分，从基础组件到业务组件，我们前端开发人员每天都在跟组件打交道。围绕着组件我们可以有很多专题，如何打造高质量组件？如何提升组件的复用率？如何提升组件的感知度？等等，贯穿组件的整个生命周期，那么如何治理好组件，需要我们共同努力和思考。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/codesandbox/codesandbox-client/tree/master/packages/sandpack-core"&gt;CodeSandbox 核心源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.yuque.com/wangxiangzhong/aob8up/nb1gp2"&gt;CodeSandbox浏览器端的webpack是如何工作的？&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7143025612267978760"&gt;规范升级 NPM 包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7140422304920109092"&gt;你想知道的前后端协作规范都在这了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7135217402983235592"&gt;带你了解 Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7132628898453880840"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 20 Sep 2022 15:18:36 GMT</pubDate></item><item><title>规范升级 NPM 包</title><link>https://juejin.cn/post/7143025612267978760</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="刘静.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a8a543e7ad456eb573501b05ff9796~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 159 篇不掺水的原创，想获取更多原创好文，请搜索公众号【政采云前端团队】关注我们吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在日常工作中，当组件跨项目使用时，我们往往会选择把组件抽成 npm 包。那么在 npm 开发以及发布的过程中有什么需要注意的事项吗？本文将从我自己的角度，来为大家介绍一下我认为的一些需要大家注意的点。&lt;/p&gt;
&lt;h2&gt;版本号规则&lt;/h2&gt;
&lt;p&gt;从日常的开发中我们可以看到，npm 包的版本号的格式都是 X.Y.Z。那么大家发布的 npm 包为什么都在遵循这个格式呢？这个格式其实是由 Gravatars 创办者兼 GitHub 共同创办者 &lt;a href="http://tom.preston-werner.com/"&gt;Tom Preston-Werner&lt;/a&gt; 所建立。由 GitHub 起草的统一的版本号表示规则，称为 Semantic Versioning(语义化版本表示)。这些规范具体包含的内容大家可以参考&lt;a href="https://semver.org/lang/zh-CN/"&gt;语义化版本 2.0.0&lt;/a&gt;。本文只针对我们开发中容易忽略的地方做一些详述。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;X 代表主版本号，也叫做大版本号&lt;/p&gt;
&lt;p&gt;升级大版本时意味着这个包可能做了颠覆性的改动，和低版本的包已经&lt;strong&gt;无法兼容&lt;/strong&gt;。每当主版本号递增时，次版本号和修订号必须归零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Y 代表次版本号，也叫做小版本号&lt;/p&gt;
&lt;p&gt;当做了&lt;strong&gt;向下兼容&lt;/strong&gt;的功能性新增时，升级小版本号。每当次版本号递增时，修订号必须归零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Z 代表修订号&lt;/p&gt;
&lt;p&gt;当做了&lt;strong&gt;向下兼容&lt;/strong&gt;的问题修正（bugfix）时， 升级修订号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;常见版本格式/引用方式&lt;/h2&gt;
&lt;table&gt;
   &lt;tbody&gt;&lt;tr&gt;
      &lt;td style="width: 130px;"&gt;版本引用方式&lt;/td&gt;
      &lt;td style="width: 90px;"&gt;版本号&lt;/td&gt;
      &lt;td&gt;匹配版本&lt;/td&gt;
      &lt;td&gt;解释&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;直接使用版本号&lt;/td&gt;
      &lt;td&gt;2.3.1&lt;/td&gt;
      &lt;td&gt;2.3.1&lt;/td&gt;
      &lt;td&gt;只可以匹配 2.3.1 这个版本，如果是比较重要的项目，建议用这种方式固定版本。&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td rowspan="3"&gt;^:不能修改版本号最左侧非零数字&lt;/td&gt;
      &lt;td&gt;^2.3.1&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 2.3.1 &amp;amp;&amp;amp; &amp;lt; 3.0.0&lt;/td&gt;
      &lt;td&gt;最左侧非零数字是 2&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;^0.3.1&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 0.3.1 &amp;amp;&amp;amp; &amp;lt; 0.4.0&lt;/td&gt;
      &lt;td&gt;最左侧非零数字是 3&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;^0.0.1&lt;/td&gt;
      &lt;td&gt; &amp;gt;= 0.01 &amp;amp;&amp;amp; &amp;lt; 0.02，即 0.01&lt;/td&gt;
      &lt;td&gt;最左侧非零数字是 1&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td rowspan="2"&gt;~:版本号列出 Y 时兼容 Z 的修改。列出 X 时兼容 Y、Z&lt;/td&gt;
      &lt;td&gt;~2.3.1&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 2.3.1 &amp;amp;&amp;amp; &amp;lt; 2.4.0&lt;/td&gt;
      &lt;td&gt;Y 为 3。～2.3 同理&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;～2&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 2.0.0 &amp;amp;&amp;amp; &amp;lt; 3.0.0&lt;/td&gt;
      &lt;td&gt;X 为 2&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td rowspan="3"&gt;*、X、x，空：表示可以匹配任何版本&lt;/td&gt;
      &lt;td&gt;"2.3.X"、"2.3.x"、"2.3*"、"2.3"&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 2.3.0 &amp;amp;&amp;amp; &amp;lt; 2.4.0&lt;/td&gt;
      &lt;td&gt;Z 可以为任意值&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;"2.X"、"2.x"、"2.*"、"2"&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 2.0.0 &amp;amp;&amp;amp; &amp;lt; 3.0.0&lt;/td&gt;
      &lt;td&gt;Y、Z 为任意值&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;*、X、x，空&lt;/td&gt;
      &lt;td&gt;任意版本&lt;/td&gt;
      &lt;td&gt;任意版本指的是最新的正式版&lt;/td&gt;
   &lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;关于 npm 的版本格式还有许多，此处不再赘述。&lt;/p&gt;
&lt;p&gt;从上边的常用格式介绍可以看出来，在精确版本号的情况下，版本号是完全固定的，在项目发布时不会出现一些实际安装的包和 package.json 中版本号不一致的问题。或者如果使用方有用到 package-lock.json 文件来固定包的版本，也可以避免包的版本号导致的问题。&lt;/p&gt;
&lt;p&gt;但是在实际开发中，我们并不知道我们包的使用方是否使用的固定版本号或者 package-lock.json 文件，我们怎么做才能让使用方不受影响呢？&lt;/p&gt;
&lt;p&gt;这时候就要用到先行版本号了，下面我将为大家具体介绍。&lt;/p&gt;
&lt;h2&gt;先行版本&lt;/h2&gt;
&lt;p&gt;npm 的先行版本号，放到 X.Y.Z 的后边，作为延伸。被标上先行版本号则表示这个版本&lt;strong&gt;并非稳定&lt;/strong&gt;而且&lt;strong&gt;可能无法满足预期&lt;/strong&gt;的兼容性需求。例如：1.0.0-alpha.1，2.0.0-beta.1 等。一般常用的关键词有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;alpha：预览版，或者叫内部测试版；一般不向外部发布，会有很多bug（会不太稳定）；一般只有测试人员使用。&lt;/li&gt;
&lt;li&gt;beta：测试版，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在alpha版之后推出。&lt;/li&gt;
&lt;li&gt;rc(release candidate)：最终测试版本；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;先行版本升级规则&lt;/h4&gt;
&lt;p&gt;我们使用 &lt;code&gt;npm dist-tag ls @zcy/zcy-region-detail-back&lt;/code&gt; 查看 @zcy/zcy-region-detail-back 的 tag，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb7df6aa7692494a8c31d5044c76f1e1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到这个包有一个 beta 版，一个 latest 版。&lt;/p&gt;
&lt;p&gt;对比两个版本的名字可以发现，beta 版本是在 latest 版本的 Z 上加了 1 且添加了一个 beta 作为延伸。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果包只是对现有的问题进行修复，那么只需要对 Z 进行加 1，然后添加延伸。&lt;/li&gt;
&lt;li&gt;如果包本次是做&lt;strong&gt;向下兼容&lt;/strong&gt;的功能性新增，那么需要对 Y 进行加 1，Z 清零，然后添加延伸。&lt;/li&gt;
&lt;li&gt;如果包本次的升级是&lt;strong&gt;无法向下兼容&lt;/strong&gt;的，那么就需要对 X 进行加 1，Y、Z 清零，然后添加延伸。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在加了延伸的版本上需要进行 bugfix 时，只需要将我们延伸的版本继续增加即可。当 bugfix 结束，需要发布正式版本时，只需要去掉延伸版本，发布版本即可。&lt;/p&gt;
&lt;h4&gt;什么时候需要使用先行版本&lt;/h4&gt;
&lt;p&gt;假设 P 项目中引用了 @zcy/zcy-region-detail-back 包，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c620677fe4b2487281a4698d3693f74f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;A 需求改动了项目 P，发布时间为 6.30。&lt;/p&gt;
&lt;p&gt;B 需求改动了 @zcy/zcy-region-detail-back 包，改动的时间是 6.29。&lt;/p&gt;
&lt;p&gt;B 需求的改动没有使用先行版本且包中的 bug 在 6.30 项目 P 发布时没有修改。此时就会导致项目 P 发布时，下载到了有 bug 的 @zcy/zcy-region-detail-back 包，就会导致线上问题。&lt;/p&gt;
&lt;p&gt;这是因为我们在 P 项目中执行 &lt;code&gt;npm i @zcy/zcy-region-detail-back&lt;/code&gt; 后，下载出来的 &lt;code&gt;@zcy/zcy-region-detail-back&lt;/code&gt;  的版本号为 1.0.0。因为在执行 &lt;code&gt;npm i @zcy/zcy-region-detail-back&lt;/code&gt; 时会默认下载 tag 为 latest 下的最新包。相当于执行了 &lt;code&gt;npm i @zcy/zcy-region-detail-back@latest&lt;/code&gt;。&lt;strong&gt;注&lt;/strong&gt;：这里的 tag 指的是 npm 中的 tag。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43e162b9ea54b90849d9f5b6cdce364~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;所以 npm 的 tag 到底有什么用呢？其实 tag 就相当于是 git 的分支管理中的标签，不同的 tag 之间的包互不影响。可以使我们发布先行版本时不影响正式版本。&lt;/p&gt;
&lt;p&gt;一般常用的有三种类型的 tag：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;latest：最后的稳定版，npm install 时就是下载的这个&lt;/li&gt;
&lt;li&gt;beta：测试版本，需要指定版本或者使用 &lt;code&gt;npm install packageName@beta&lt;/code&gt;  来下载。例如：1.0.0-beta.0&lt;/li&gt;
&lt;li&gt;next：先行版本，使用 &lt;code&gt;npm install packageName@next&lt;/code&gt; 安装&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;版本发布&lt;/h2&gt;
&lt;p&gt;那么我们如何发布先行版本的包呢？首先需要升级 A 包的版本号，此处介绍两种升级方式&lt;/p&gt;
&lt;p&gt;方式一：简单粗暴，手动修改 package.json 中的 version：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20220313200823440" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bd766dbef3647f2bbe02428b8399165~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;这种方式需要我们自己手动执行 &lt;code&gt;git commit -am 'XXXX'&lt;/code&gt; 提交代码，如果需要在此版本的 git 仓库打上 tag 时，需要我们自己手动触发&lt;code&gt;git tag v2.3.2-beta.1&lt;/code&gt; ，&lt;code&gt;git push origin v2.3.2-beta.1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;方式二：借助 &lt;code&gt;npm version&lt;/code&gt; 命令&lt;/p&gt;
&lt;p&gt;A 包中所有的改动都 commit 后，可以根据以下命令更新版本&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm version [&amp;lt;newversion&amp;gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]
// newversion：指定更新的版本号
// major：大版本并且不向下兼容时，使用 major
// minor：有新功能且向下兼容时，使用 minor
// patch：修复一些问题、优化等，使用 patch
// 以 A：2.3.1 为例
npm version premajor // 版本号会成为 3.0.0-0，即 3.0.0 的预发版本
npm version preminor // 版本号为成为 2.4.0-0，即 2.4.0 的预发版本
npm version prepatch // 版本号成为 2.3.2-0，即 2.3.2 的预发版本
/**
* 版本号会成为 2.3.2-0。
* 执行此命令时，如果没有预发布版本号，则增加 Z，增加预发布号为 0
* 如果有预发步号，增加预发步号
*/
npm version prerelease
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据上边的 API 可以看到我们能通过 &lt;code&gt;npm version 2.3.2-beta.1&lt;/code&gt; 将 A 的版本升为 2.3.2-beta.1 的形式，除此之外，在 &lt;code&gt;npm 6.4.0&lt;/code&gt; 之后，我们也可以使用 &lt;code&gt;--preid&lt;/code&gt; 参数来添加前缀：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm version prerelease --preid=beta
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此种方式需要注意，必须要 commit 本地的修改之后才可以执行。&lt;code&gt;npm version&lt;/code&gt; 修改版本号，会默认执行 &lt;code&gt;git add&lt;/code&gt; -&amp;gt; &lt;code&gt;git commit&lt;/code&gt; -&amp;gt; &lt;code&gt;git tag&lt;/code&gt; 操作，此时的版本号看起来有 beta，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20220703204725616" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0adbc7e25294507bc20cf51b92ae97a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;但是这个 beta 是 git 仓库的 tag，并不是 npm 的 tag。如果不想默认给 git 添加 tag 的话，可以使用以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm --no-git-tag-version version xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么 &lt;code&gt;npm version &lt;/code&gt; 执行时具体发生了什么呢？简要流程图如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1079bc8d179d49c8ae78feae23bca45e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;执行完 &lt;code&gt;npm version 2.3.2-beta.1&lt;/code&gt; 之后，如果直接使用 &lt;code&gt;npm publish&lt;/code&gt; 来发布的话，发布出来的包的 tag 是 latest，但是我们其实是想发布一个测试包。如果其他人 &lt;code&gt;npm i&lt;/code&gt; 下载时就会下载 version 为 2.3.2-beta.1 的包。只有使用 &lt;code&gt;npm publish --tag XXX&lt;/code&gt; 才是给 npm 包上打了 tag 标签。&lt;/p&gt;
&lt;p&gt;执行以下命令就可以生成一个 tag 为 beta 的包：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm run build // 打包
npm publish --tag beta // 发布 beta 包
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b99153d765a4a7ba2621049c0042273~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果不小心直接使用 &lt;code&gt;npm publish&lt;/code&gt; 发错了也没有关系，可以使用以下命令来添加 tag：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm dist-tag add &amp;lt;pkg&amp;gt;@2.3.2-beta.1 &amp;lt;tag&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当需要删除多余的 tag 时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm dist-tag rm &amp;lt;pkg&amp;gt; &amp;lt;tag&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给大家提供一条指令完成 beta 版本的发布：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;"scripts": {
    "publish:beta": npm version prerelease --preid=beta &amp;amp;&amp;amp; npm run build &amp;amp;&amp;amp; npm publish --tag=beta"
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码开发完毕，提交之后，只需要 &lt;code&gt;npm run publish:beta&lt;/code&gt; 就可以发布一个测试版本啦～&lt;/p&gt;
&lt;p&gt;以上就是我本次分享的所有内容啦，如果有不足的地方，还望指正。&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://semver.org/lang/zh-CN/spec/v2.0.0.html"&gt;语义化版本 2.0.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6844903870578032647"&gt;前端工程化（5）：你所需要的npm知识储备都在这了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.npmjs.com/cli/v6/commands/npm-version"&gt;npm version&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7140422304920109092"&gt;你想知道的前后端协作规范都在这了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7135217402983235592"&gt;带你了解 Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7132628898453880840"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 13 Sep 2022 16:28:07 GMT</pubDate></item><item><title>你想知道的前后端协作规范都在这了</title><link>https://juejin.cn/post/7140422304920109092</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="商陆.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19edac65d0f24d80b2d945ceb06a339a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 158 篇不掺水的原创，想获取更多原创好文，请搜索公众号【政采云前端团队】关注我们吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;一. 前言&lt;/h4&gt;
&lt;p&gt;你是否在为如何制定前后端协作规范而发愁？干货来啦，一文带你了解我们团队内部沉淀并践行已久的前后端协作规范，读完本文，回去大胆拒绝你后端的不合理设计！&lt;/p&gt;
&lt;h4&gt;二. 为什么需要协作规范？&lt;/h4&gt;
&lt;p&gt;假如你要在团队内部推一套规范，那么首先你得知道为什么需要制定协作规范呢？有规范会带来什么好处呢？&lt;/p&gt;
&lt;p&gt;随着前后端分离开发模式大行其道，前端和后端已经在两个方向上渐行渐远，各自深耕细作、术业专攻。前端更加关注交互视觉体验，而后端对高并发、高性能、高扩展上要求更高。这就导致大部分的前端和后端之间会存在所谓的"代沟"，我不知道你的数据如何存储，你不知道我的页面如何渲染。&lt;/p&gt;
&lt;p&gt;因此，很有必要制定前后端开发上的规范来抹平代沟，有了协作规范，便有了前后端开发默契，也因此达到了提高开发效率、降低沟通成本的作用。&lt;/p&gt;
&lt;h4&gt;三. 协作流程规范&lt;/h4&gt;
&lt;p&gt;首先是协作的流程规范，相信每个团队在前后端协作中都有各自的开发模式和开发流程来保障效率和质量，我们团队的前后端协作大致流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20220825230352601.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/204e6803eaf44d7aac2267fc6f351f72~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需求导入、交互视觉导入分析 ：对产品导出的需求，参会各方包括产品、前端、后端、测试、UED，在对需求的认知上要达成一致，这是开发的第一步。&lt;/li&gt;
&lt;li&gt;接口设计、前后端对接接口：后端给出接口，前后端要在接口字段设计上达成大致方向上的一致。&lt;/li&gt;
&lt;li&gt;技术方案评审 ：在开发之前进行技术方案评审，再次确保各方在需求的认知上统一，并且双方就接口字段可行性上再次确认。&lt;/li&gt;
&lt;li&gt;并行开发 、前后端自测：前后端并行开发，在此阶段前端可以 mock 数据进行页面渲染。&lt;/li&gt;
&lt;li&gt;开发环境联调：前后端自测完成之后在开发环境上完成接口联调。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;四. 如何做接口规范？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;前置约定：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;后端接口定义 URL、出入参之前，&lt;strong&gt;前后端需达成一致&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;文档规范：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接口注释需要写清楚：模块、枚举、必填/非必填、出参是否可能为 null&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口需要向下兼容，如果不兼容需要评估并且通知相应的业务方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口文档上面有变更需及时同步前端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后端需保证文档上定义的参数，可以正常请求接口且功能正常稳定&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="3"&gt;
&lt;li&gt;计量单位约定：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;时间：统一使用 13 位时间戳&lt;/li&gt;
&lt;li&gt;金额：统一为分，可根据业务情况选择&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="4"&gt;
&lt;li&gt;请求接口 URL &amp;amp; 请求方式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Post 接口不允许使用 Get 传参方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Post 接口必须使用 &lt;code&gt;application/json&lt;/code&gt; 模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口命名应尽量符合语义，接口命名不要过于相似，难区分，易混淆&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="5"&gt;
&lt;li&gt;入参&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;保证同一应用领域内，相同含义的字段，命名保持一致&lt;/li&gt;
&lt;li&gt;业务编号 / ID 必须为&lt;strong&gt;字符串类型&lt;/strong&gt;，JS 对最大数字有限制&lt;/li&gt;
&lt;li&gt;同一个页面不同 Tab，接口尽量保证一致&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="6"&gt;
&lt;li&gt;出参&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;接口出参格式要统一&lt;/li&gt;
&lt;li&gt;接口不要返回类似 "服务器内部异常"、"网络异常" 这种无法理解的错误信息，非线上环境可以返回错误堆栈，方便排查问题&lt;/li&gt;
&lt;li&gt;前后端数据列表相关的接口，如果返回为空，则返回空数组 &lt;code&gt;[]&lt;/code&gt; 或空集合 &lt;code&gt;{}&lt;/code&gt;，有利于数据层面上的协作更加高效，减少前端很多琐碎的 null 值判断，特殊情况特殊分析&lt;/li&gt;
&lt;li&gt;接口出参根据页面需求返回有效字段，避免吐出过多无用字段&lt;/li&gt;
&lt;li&gt;枚举值尽量返回中文和英文描述&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;五. 协作中的Bad Case&lt;/h4&gt;
&lt;p&gt;以下总结了我们团队内部在协作中遇到的比较典型的 Bad Case 以及解决方案，我相信大家在开发过程中也遇到过类似的痛点经历：&lt;/p&gt;
&lt;h5&gt;类型 1：前端过多的条件逻辑判断&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按钮、组件显示与否，前端要通过大量的字段进行条件逻辑判断；同一页面不同场景前端调用的接口不一样&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 按钮文案、显示逻辑
{((record.state === 'RESULT_CONFIRM' &amp;amp;&amp;amp; isCurrentUserCreate) ||(record.state === 'RESULT_CHECK' &amp;amp;&amp;amp; isCurrentUserCreate &amp;amp;&amp;amp; currentUserCanCheck )) &amp;amp;&amp;amp; &amp;lt;Button&amp;gt;确认&amp;lt;/Button&amp;gt;}

 {['DREFT', 'AUDIT_FAILD', 'REVOKE'].includes(record.state) &amp;amp;&amp;amp; isCurrentUserCreate &amp;amp;&amp;amp; &amp;lt;Button&amp;gt;修改&amp;lt;/Button&amp;gt;}
 
// A 场景调用接口 1，B 场景调用接口 2，C 场景调用接口 3 和 4
if (id) {
  this.operation = '修改';
  const res = await this.fetchInfo(id);
  ...
} else if (source) {
  const res = await this.fetchSourceInfo(id: source);
  ...
} else {
  const res = await this.fetchBasicInfo();
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="image-20220823234007383.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3451fc4eb7b443fc8d62e63fcbf71588~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;控制前端显示逻辑判定都放在后端去做处理，前端尽可能减少字段判定。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注：如果功能简单，前端也可以做判断&lt;/strong&gt;，如何鉴定是否简单？从代码层面比如 If 判断中超过 2 个条件，按钮显示超过 2 个条件，可视作复杂逻辑，逻辑移到后端处理。建议一开始就视作复杂去处理，这样后期就不用再调整。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// 按钮展示
前后端约定好 按钮的显示返回一个数组，数组具体返回哪些逻辑写在后端。
[
  { name:'确认'，type:'resultConfirm'},
  { name:'修改'，type:'edit' },
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【好处】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将逻辑收敛到后端，&lt;strong&gt;出现问题或者更改逻辑时只需一方排查或修改&lt;/strong&gt;。即能一端完成的，绝不让两个端干， 两个就可能会出现不一致的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 2：前端二次数据加工过多&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;页面上同一个表格展示的数据是两个接口拼接而成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="image-20220824174620804.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ecfd5abd9a4f80931504fc2e322b5c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;接口数据返回格式不符合前端渲染逻辑，需要二次加工&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;p&gt;1、后端做好数据的整合，避免数据在前端的重组。&lt;/p&gt;
&lt;p&gt;2、Tree 数据展示的场景，如果数据不大后端全量返回，如果数据量过大异步返回，但异步返回存在后续的回显和搜索展示方面问题。&lt;/p&gt;
&lt;p&gt;3、同一个业务功能，一个接口搞定，不要分接口进行，后端业务考虑复用可包装新接口或原接口加参数兼容。&lt;/p&gt;
&lt;p&gt;【好处】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少前后端数据处理的成本，提高性能和用户体验&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 3：枚举值、下拉框数据由前端维护&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;列表页单据状态由前端维护枚举值，如果新增枚举都需要前后端更改，可能导致最终显示状态不统一&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 状态值映射
const getStatusName = (status) =&amp;gt; {
  switch(status) {
    case 0:
      return '草稿'；
    case 1:
      return '待部门审批';
    case 2: 
      return '待财务审核';
    case 3: 
      return '待单位审核';
    case 4: 
      return '审核中';
    ...
    default:
      break;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;确保状态可扩展，后端已经做了枚举的情况下，前端不需维护状态值，以后端提供接口为准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果是状态定死的情况下譬如：选项为【是、否】可无需后端返回。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 由后端接口返回下拉框选项
{
  result: [{
    code: string
    name: string
  }]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【好处】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;枚举值变动时，只需后端更新，也避免了迭代过程中出现的前后端不一致的情况&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 4：PC 端数据结构不适用 App 端&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;App 端的布局样式 是较 PC 端略复杂的，如果 App 端一味采用 PC 端的接口数据，是需要前端做特殊处理的。比如，同一时间的单据 App 端放在同一张卡片内，卡片内部的标题、内容、按钮展示也做了情况区分。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断前端处理工作量，后端需新增接口实现 App 不同的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【好处】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少前端处理逻辑的成本，提高 App 上的用户体验&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 5：同一业务领域同一含义的接口字段命名不统一&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关于返回结果： &lt;code&gt;response.data&lt;/code&gt;、 &lt;code&gt;response.result&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关于时间：&lt;code&gt;createAt&lt;/code&gt;、&lt;code&gt;queryEffectStartingBeginTime&lt;/code&gt;、&lt;code&gt;penaltyBeginTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关于名称：&lt;code&gt;punishedInstitutionName&lt;/code&gt;、&lt;code&gt;responderName&lt;/code&gt;、&lt;code&gt;penaltyObjectName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关于 Id: &lt;code&gt;punishedOrganizationId&lt;/code&gt;，&lt;code&gt;penaltyObjectId&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前后端共同维护一份字段词典，保持同一业务领域下命名一致，避免不必要的字段转换。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 6：金额计算结果由前端提交给后端并入库&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前端页面中，输入支付金额并除以总额，然后计算出支付比例，最后点击保存按钮将数据提交给后端接口；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于金额的计算：以是否入库为界限，非入库纯展示可前端计算，&lt;strong&gt;入库的统一由后端计算&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 7：前端维护业务配置类型的代码&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由多个表单项（下拉框、输入框、单选框等）的值作为条件判断某一表单项（附件、单选框、输入框等）是否必填、显示或隐藏。因此，前端需要写很多动态校验逻辑，并且涉及到每个区划的动态校验逻辑还不一样，有的校验条件还是写死的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置校验规则的页面可根据区划配置后生成标识码，然后后端可提供一个通用的校验接口，前端把值传给后端，然后返回校验结果是否通过。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 入参：
{
  code: '99900', // 区划代码
  identity: '11111', // 标识码
  datas:[ // 数据
   {
     key: 'catalog',
     value: 'A07',
   },
   {
     key: 'assetApproval',
     value: 0,
   }
 ]
}

// 返回值：
{
  result: true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 8：前端直接调用其它业务线后端的接口&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;业务线 A 列表&lt;/strong&gt;页面，点击新建按钮，弹框调用**业务线 B **那边的接口。&lt;/p&gt;
&lt;p&gt;由于 A 和 B 是不同业务线后端，接口对接以及后期的沟通维护成本会比较高。例如该接口发生改动，需要跨业务线通知到对应的前端（该后端还不一定知道前端是哪位）；并且接口返回的大量字段前端都用不到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;后台业务耦合的情况下需要自己业务线后端整合数据；如果只是为了展示非自己业务的数据后端不处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 9：后端分页接口的数据返回格式不统一&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;目前分页接口的数据返回格式不统一，已有如下几种形式：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 形式一：
{
  result: {
    data: [],
      total: 0,
  }
}
// 形式二：
{
  result: {
    data: [],
    pagination: {
      total: 0,
      pageSize: 10,
      pageNo: 1
    }，
  }
}
// 形式三：
{
  result: {
    data: [],
    total: 0,
    pageSize: 10,
    pageNo: 1
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建议后端接口统一格式如形式三。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 10：后端一个接口拆分多个&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个表单页，在提交之前调用三个不同的校验接口。三个校验接口入参也不一样，前端需要组装各种类型的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个校验接口和提交接口合并成一个提交接口。&lt;/li&gt;
&lt;li&gt;校验不通过时，接口返回值里区分阻塞式和提醒式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阻塞式：弹框告警，用户只能关闭弹框&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提醒式：弹框询问，在用户点击"继续提交"后，继续调用提交接口，此时增加入参标识跳过此步校验&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;六. 效果&lt;/h4&gt;
&lt;p&gt;基于一套合理可行的协作规范，前后端从开发到上线的各个阶段都能够看到诸多成效：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低沟通成本，减少不必要的扯皮， 加快开发进度；&lt;/li&gt;
&lt;li&gt;缩短联调时间，减少联调阶段的代码调整，保证了开发效率；&lt;/li&gt;
&lt;li&gt;减少测试阶段的排查问题归属，加快测试进度，保证质量；&lt;/li&gt;
&lt;li&gt;方便线上问题排查及修复。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;七. 总结&lt;/h4&gt;
&lt;p&gt;一言以蔽之：如果你发现前端在处理大量的逻辑，那么就是协作规范存在问题啦！前端更多的是关注交互、渲染上的逻辑，应尽量避免复杂的业务逻辑处理。万事开头难！推一套规范是需要时间去沉淀的，前端和后端同学都应多些耐心，多些理解。&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7135217402983235592"&gt;带你了解 Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7132628898453880840"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7124839474575441934"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 06 Sep 2022 16:07:23 GMT</pubDate></item><item><title>带你了解 Tree Shaking</title><link>https://juejin.cn/post/7135217402983235592</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="佳民.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4bcf3e8f8294db798dd11c54b597805~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 156 篇不掺水的原创，想获取更多原创好文，请搜索公众号【政采云前端团队】关注我们吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;JavaScript 绝大多数情况需要通过网络进行加载再执行，加载的文件越小，整体执行时间更短，所以就有了 Tree Shaking 去除无用代码，从而减小文件体积。&lt;/p&gt;
&lt;h3&gt;什么是 Tree Shaking&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Tree-shaking&lt;/strong&gt; (摇树) 是一个术语，通常指通过打包工具"摇"我们的代码，将未引用代码 (Dead Code) "摇" 掉。在 Webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝，虽然依赖了某些模块，但其实只使用其中的某些方法，通过 Tree Shaking ，将没有使用的方法摇掉，这样来达到删除无用代码的目的。&lt;/p&gt;
&lt;h3&gt;Tree Shaking 具体做了什么&lt;/h3&gt;
&lt;p&gt;我们通过例子来详细了解一下 Webpack 中 Tree Shaking 到底做了什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未使用的函数消除&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// utils.js
export function sum(x, y) {
  return x + y;
}

export function sub(x, y) {
  return x - y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// index.js
import { sum } from "./utils";
// import * as math from "./utils";

console.log(sum(1, 2));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在 utils 中定义了 sum 与 sub 两个方法， 仅使用了 sum 方法，而 sub 方法并没有被使用。我们一起看一下打包后的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;(()=&amp;gt;{"use strict";console.log(3)})();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;未使用的 JSON 数据消除&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;// main.json
{
  "a": "a",
  "b": "b"
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// index.js
import main from "./main.json";

console.log(main.a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到仅使用了 JSON 中的 a 。我们一起看一下打包后的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;(()=&amp;gt;{"use strict";console.log("a")})();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Tree Shaking 的原理&lt;/h3&gt;
&lt;p&gt;Tree Shaking 在去除代码冗余的过程中，程序会从入口文件出发，扫描所有的模块依赖，以及模块的子依赖，然后将它们链接起来形成一个 “抽象语法树” (AST)。随后，运行所有代码，查看哪些代码是用到过的，做好标记。最后，再将“抽象语法树”中没有用到的代码“摇落”。经历这样一个过程后，就去除了没有用到的代码。
&lt;img alt="image-20200729195132323" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bed23d8877d4ddf8ffc249f7cbbf276~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;前提是模块必须采用 ES6 Module 语法，因为 Tree Shaking 依赖 ES6 的静态语法：import 和 export。不同于 ES6 Module，CommonJS 支持动态加载模块，在加载前是无法确定模块是否有被调用，所以并不支持 Tree Shaking 。如果项目中使用了 babel 的话， &lt;code&gt;@babel/preset-env&lt;/code&gt; 默认将模块转换成 CommonJs 语法，因此需要设置 &lt;code&gt;module：false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;CommonJS 与 ES6 Module 模块的依赖的区别在于，CommonJS 是&lt;strong&gt;动态的&lt;/strong&gt;，ES6 Module 是&lt;strong&gt;静态的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CommonJS 导入时，&lt;code&gt;require&lt;/code&gt; 的路径参数是支持表达式的，路径在代码执行时是可以动态改变的，所以如果在代码编译阶段就建立各个模块的依赖关系，那么一定是不准确的，只有在代码运行了以后，才可以真正确认模块的依赖关系，因此说CommonJS 是动态的。&lt;/p&gt;
&lt;p&gt;ES6 模块不是对象，它的对外接口只是一种静态定义，在代码编译，静态解析阶段就会生成，这样我们就可以使用各种工具对JS模块进行依赖分析，优化代码。&lt;/p&gt;
&lt;h4&gt;Development 模式下&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// webpack.config.js

module.exports = {
  // mode: "production",
  mode: "development",
  devtool: false,
  optimization: {
    usedExports: true, // 目的使未被使用的export被标记出来
  },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打包后的 bundle.js&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sum": () =&amp;gt; (/* binding */ sum)
/* harmony export */ });
/* unused harmony export sub */
function sum(x, y) {
  return x + y;
}

function sub(x, y) {
  return x - y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1、可以看到未被使用的 sub 会被标记为 &lt;code&gt;/* unused harmony export sub */&lt;/code&gt;，不会被 &lt;code&gt;__webpack_require__.d&lt;/code&gt; 进行 exports 绑定；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于 &lt;code&gt;__webpack_require__.d&lt;/code&gt; 的含义，可参考 &lt;a href="https://segmentfault.com/a/1190000024457777"&gt;深入了解 webpack 模块加载原理&lt;/a&gt; 一文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、经过压缩工具（UglifyJSPlugin）压缩后，未使用的接口代码会被删除。原理显而易见，未被 &lt;code&gt;__webpack_require__.d&lt;/code&gt; 引用，所以压缩工具可以将其安全移除。&lt;/p&gt;
&lt;h4&gt;Production 模式下&lt;/h4&gt;
&lt;p&gt;由前面的例子可以看出 &lt;code&gt;dist/bundle.js&lt;/code&gt; 中整个 bundle 都已经被 压缩工具 压缩和混淆破坏，但是如果仔细观察，则不会看到引 &lt;code&gt;sub&lt;/code&gt; 函数，但能看到 &lt;code&gt;sum&lt;/code&gt; 函数的混淆破坏版本（&lt;code&gt;function r(e){return e*e*e}n.a=r&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;再看一下两次打包的文件体积会发现，bundle 的体积明显减少了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20220721071044241" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c7005dcdb934685a2ee94629944f464~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;Tree Shaking 和 sideEffects&lt;/h3&gt;
&lt;p&gt;提到 Tree Shaking 就要聊一下 sideEffects。什么是 sideEffects ？sideEffects 又是与 Tree Shaking 如何搭配使用的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sideEffect&lt;/strong&gt;(副作用) 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。&lt;/p&gt;
&lt;p&gt;webpack v4 开始新增了一个 &lt;code&gt;sideEffects&lt;/code&gt; 特性，通过给 &lt;code&gt;package.json&lt;/code&gt; 加入 &lt;code&gt;sideEffects: false&lt;/code&gt; 声明该包模块是否包含副作用，从而可以为 Tree Shaking 提供更大的优化空间。&lt;/p&gt;
&lt;p&gt;举例说明&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// a.js
// 无副作用，仅仅是单纯的 export
function a () {
  console.log('a')
}
export default {
  a
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// b.js
function b () {
  console.log('b')
}

// 执行了特殊行为
Array.prototype.fun = () =&amp;gt; {}

export default {
  b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 a 在 import 后未使用，Tree Shaking 完全可以将其优化掉；但是 b 在 import 后未使用，但因为存在他还执行了为数组原型添加了方法，副作用还是会被保留下来。这时就需要使用  &lt;code&gt;sideEffects: false&lt;/code&gt; ，可以强制标识该包模块不存在副作用，那么不管它是否真的有副作用，只要它没有被引用到，整个 模块/包 都会被完整的移除。&lt;/p&gt;
&lt;p&gt;如果你的项目中存在一些副作用代码 b 需要被保留下来，比如 polyfill、css、scss、less 等，可以按下面方法一样配置；保证必要的代码不被 Tree Shaking&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;// package.json
{
  "name": "your-project",
  "sideEffects": ["./src/b.js", "*.css"]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;通过以上讲解，使 Webpack 更精确地检测无效代码，完成 Tree Shaking 操作，需要符合以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 ES6 Module 语法（即 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;确保没有 &lt;code&gt;@babel/preset-env&lt;/code&gt;等工具将 ES6Module 语法转换为 CommonJS 模块。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optimization: { minimize: true, usedExports: true }&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用支持 Tree Shaking 的包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://segmentfault.com/a/1190000040037144"&gt;Tree shaking原理及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://webpack.docschina.org/guides/tree-shaking/"&gt;Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7132628898453880840"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7124839474575441934"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 23 Aug 2022 15:28:44 GMT</pubDate></item><item><title>如何使用CSS创建高级动画，这个函数必须掌握</title><link>https://juejin.cn/post/7169375268321116196</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们每天都在网上摸鱼，作为前端开发人员，网站上微妙的细节变化通过比别人会更关注。我一直注意到的一件事是网站上的动画的流畅性。动画对于用户体验来说是非常好的，有时我们可以一些有趣的动画来留住用户。&lt;/p&gt;
&lt;p&gt;创建高级动画听起来是一个很难的话题，但好消息是，在CSS中，可以将多个简单的动画相互叠加，以创建一个更复杂的动画&lt;/p&gt;
&lt;p&gt;在这节课中，我们会学习如下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是贝塞尔曲线，以及如何用一行CSS来创建一个 "复杂"的动画&lt;/li&gt;
&lt;li&gt;如何将动画相互叠加以创建一个高级动画&lt;/li&gt;
&lt;li&gt;如何通过应用上面学到的两点来创建一个过山车动画&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;什么是贝塞尔曲线&lt;/h2&gt;
&lt;p&gt;CSS中的 cubic-bezier 函数是一个缓动函数，可以让我们完全控制动画在时间上的表现。下面是官方的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;贝塞尔缓动函数是一种由四个实数定义的缓和函数，指定了贝塞尔曲线的两个控制点&lt;code&gt;P1&lt;/code&gt;和&lt;code&gt;P2&lt;/code&gt;，其端点&lt;code&gt;P0&lt;/code&gt;和&lt;code&gt;P3&lt;/code&gt;分别固定在&lt;code&gt;（0, 0&lt;/code&gt;）和&lt;code&gt;（1, 1）&lt;/code&gt;。&lt;code&gt;P1&lt;/code&gt;和&lt;code&gt;P2&lt;/code&gt;的&lt;code&gt;x&lt;/code&gt;坐标被限制在&lt;code&gt;[0, 1]&lt;/code&gt;范围内。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea1cb4a1b12b44b5b4c8eb7a3a2a5a1b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;什么是缓动函数？&lt;/h3&gt;
&lt;h4&gt;线性曲线&lt;/h4&gt;
&lt;p&gt;想象两个点&lt;code&gt;P0&lt;/code&gt;和&lt;code&gt;P1&lt;/code&gt;，其中&lt;code&gt;P0&lt;/code&gt;是动画的起点，&lt;code&gt;P1&lt;/code&gt;是结束点。现在想象另一个点在两点之间线性移动，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="001.gif" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab2988deff4d4d9db0bf0e9a2b7f7875~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这就是所谓的线性曲线，也是最简单的动画。&lt;/p&gt;
&lt;h4&gt;二次贝塞尔曲线&lt;/h4&gt;
&lt;p&gt;如下图所示，有三个点。P0、P1和P2。我们想让动画从&lt;code&gt;P0&lt;/code&gt;移动到&lt;code&gt;P2&lt;/code&gt;。在这种情况下，&lt;code&gt;P1&lt;/code&gt;是一个控制点，控制动画的曲线。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41f82ed640a44d45a6bf578d05c2842f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;二次方贝塞尔概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在P0和P1之间以及P1和P2之间（用灰线表示）连接虚线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点Q0沿着P0和P1之间的直线移动。同时，点Q1沿着P1和P2之间的直线移动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Q0和Q1之间连接一条虚线（用绿线表示）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Q0和Q1开始移动的同时，点B开始沿着绿线移动，B点所走的路径就是动画路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="002.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eff9d7a551841548c90c1b2db10d51d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;请注意，Q0、Q1和B不以相同的速度移动。它们都必须在同一时间开始，并在同一时间完成它们的路径。因此，每一个点都是根据它所移动的线长以适当的速度移动的。&lt;/p&gt;
&lt;h4&gt;三次贝塞尔曲线&lt;/h4&gt;
&lt;p&gt;三次贝塞尔曲线由4个点组成。P0, P1, P2和P3。动画开始于P0，结束于P3。P1和P2是我们的控制点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d993b060fe44c89c407254ff6ce703~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;三次贝赛尔的工作原理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在（P0, P1）、（P1, P2）和（P2, P3）之间连接虚线，由灰线表示&lt;/li&gt;
&lt;li&gt;点Q0、Q1和Q2分别沿直线（P0，P1）、（P1，P2）和（P2，P3）移动&lt;/li&gt;
&lt;li&gt;在（Q0, Q1）和（Q1, Q2）之间连接虚线，它们由绿线表示。&lt;/li&gt;
&lt;li&gt;点R0和R1分别沿直线（Q0, Q1）和（Q1, Q2）移动&lt;/li&gt;
&lt;li&gt;连接R0和R1之间的线（用蓝线表示）&lt;/li&gt;
&lt;li&gt;最后，B点沿着R0和R1之间的连接线移动，B点所走的路径就是动画路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="003.gif" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c43855c899e4eb78c21f89e82dceea4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你想更好地了解三次体贝塞尔的工作原理，建议你看看这个&lt;a href="https://www.desmos.com/calculator/7arefxmgfb?lang=zh-CN"&gt;desmos链接&lt;/a&gt;。玩玩控制点，看看动画如何随时间变化。(注意，链接中的动画是由黑线表示的）。&lt;/p&gt;
&lt;h2&gt;叠加动画&lt;/h2&gt;
&lt;p&gt;有很多步骤的大动画可以被分解成多个小动画。在 css 中，通过添加&lt;code&gt;animation-delay&lt;/code&gt;属性来实现这一点。计算延迟很简单，把你要计算动画延迟的那个动画之前的所有动画的时间加起来。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation: movePointLeft 4s linear forwards, movePointDown 3s linear forwards;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，我们有两个动画，&lt;code&gt;movePointLeft&lt;/code&gt;和&lt;code&gt;movePointDown&lt;/code&gt;。&lt;code&gt;movePointLeft&lt;/code&gt;的动画延迟是零，因为它是我们想先运行的动画。&lt;code&gt;movePointDown&lt;/code&gt;的动画延迟是&lt;code&gt;4&lt;/code&gt;秒，因为&lt;code&gt;movePointLeft&lt;/code&gt;将在这段时间后完成。&lt;/p&gt;
&lt;p&gt;因此，&lt;code&gt;animation-delay&lt;/code&gt;属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation-delay: 0s, 4s;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，如果有两个或更多的动画同时开始，它们的动画延迟将是一样的。此外，当你计算即将开始的动画的延迟时，把它们视为一个动。例如 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation: x 4s linear forwards, y 4s linear forwards, jump 2s linear forwards;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;同时开始。在这种情况下，&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;的动画延迟都将为零，而 &lt;code&gt;jump&lt;/code&gt; 动画的延迟将为4秒（而不是&lt;code&gt;8&lt;/code&gt;秒！）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation-delay: 0s, 0s, 4s;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;创建过山车&lt;/h2&gt;
&lt;p&gt;掌握了上面的知识，是时候应用一下了。&lt;/p&gt;
&lt;h4&gt;了解动画&lt;/h4&gt;
&lt;p&gt;过山车路径由三部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑动部分&lt;/li&gt;
&lt;li&gt;循环部分&lt;/li&gt;
&lt;li&gt;还会有一些动画，在上面的两个动画之间创造水平空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de549ce62d97434fbe54de2199ff8c5a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们将首先创建一个简单的球，作为我们过山车的 "车"。&lt;/p&gt;
&lt;p&gt;hmtl 部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id="the-cart" class="cart"&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;css 部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.cart {
  background-color: rgb(100, 210, 128);
  height: 50px;
  width: 50px;
  border: 1px solid black;
  border-radius: 50px;
  position: absolute;
  left: 10vw;
  top: 30vh;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;滑动部分&lt;/h4&gt;
&lt;p&gt;创建小球滑动的部分可以用&lt;code&gt;cubic-bezier&lt;/code&gt;函数来完成! 这个动画是由2个动画组成的，一个是沿&lt;code&gt;x&lt;/code&gt;轴的动画，另一个是沿&lt;code&gt;y&lt;/code&gt;轴的动画。&lt;code&gt;X&lt;/code&gt;轴动画是一个沿&lt;code&gt;X&lt;/code&gt;轴的普通线性动画。它的关键帧如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@keyframes x {
  to {
    left: 40vw;
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将其添加到球路径的 &lt;code&gt;animation&lt;/code&gt; 属性中，如下所示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation: x 4s linear forwards

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;y轴动画是我们将使用cubic-bezier函数的部分。首先定义动画的关键帧。我们希望起始点和结束点之间的差异很小，以至于球达到的高度几乎相同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@keyframes y {
  to {
    top: 29.99vh;
  }
}}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在让我们来思考一下cubic-bezier函数。我们希望我们的路径先向右缓慢移动，然后当它滑动时，它应该走得更快。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fd213c24a7e4bb4865c001639a605d4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;向右缓慢移动意味着&lt;code&gt;$P1$&lt;/code&gt;将沿&lt;code&gt;x&lt;/code&gt;轴移动。所以，我们知道它是在（V，0）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们需要选择一个合适的V，使我们的动画缓慢地向右移动，但又不能太多，以免占用整个空间。在这种情况下，我发现&lt;code&gt;0.55&lt;/code&gt;最适合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了达到滑动效果，我们需要将&lt;code&gt;P2&lt;/code&gt;向&lt;code&gt;Y&lt;/code&gt;轴下移（负值），所以&lt;code&gt;P2=（X，-Y）&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Y应该是一个大值。在这种情况下，我选择 &lt;code&gt;Y=5000&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;为了得到&lt;code&gt;X&lt;/code&gt;，我们知道我们的动画速度在滑动时应该更快，在再次上升时应该更慢。所以，X越接近于零，动画在滑动时就越陡峭。在这种情况下，让&lt;code&gt;X = 0.8&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，我们得到了一个cubic-bezier函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cubic-bezier(0.55, 0, 0.2, -800).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为动画属性添加关键帧:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation: x 4s linear forwards,
    y 4s cubic-bezier(0.55, 0, 0.2, -5000) forwards;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是我们动画的第一部分，所以动画延迟为零。我们应该添加一个&lt;code&gt;animation-delay&lt;/code&gt;属性，因为从下面的动画开始，动画的开始时间将与第一个动画不同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation-delay: 0s, 0s;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;地址：https://codepen.io/smashingmag/pen/VwxXBQb&lt;/p&gt;
&lt;p&gt;&lt;img alt="004.gif" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf44b894eebe47ddad3736bb11e309f1~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h4&gt;添加水平空间&lt;/h4&gt;
&lt;p&gt;在做循环之前，球应该沿着&lt;code&gt;X&lt;/code&gt;轴移动一小会儿，所以两个动画之间有空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义关键帧&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@keyframes x2 {
  to {
    left: 50vw;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把它添加到 &lt;code&gt;animation&lt;/code&gt;  属性中:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation: x 4s linear forwards,
    y 4s cubic-bezier(0.55, 0, 0.2, -5000) forwards, x2 0.5s linear forwards;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个动画应该在滑动动画之后开始，而滑动动画需要4秒，因此，动画延迟将是4秒。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation-delay: 0s, 0s, 4s;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;地址：https://codepen.io/smashingmag/pen/dyemExY&lt;/p&gt;
&lt;p&gt;&lt;img alt="005.gif" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b91e1772f342420cad7ebffc9f88eeec~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h4&gt;循环部分&lt;/h4&gt;
&lt;p&gt;要在CSS中创建一个圆（循环），我们需要把圆移到循环的中心，然后从那里开始做动画。圆的半径是&lt;code&gt;100px&lt;/code&gt;，所以我们把圆的位置改为&lt;code&gt;top: 20vh&lt;/code&gt;（&lt;code&gt;30&lt;/code&gt;是期望的半径（这里是&lt;code&gt;10vh&lt;/code&gt;））。然而，这需要在滑动动画完成后发生，所以我们将创建另一个持续时间为&lt;code&gt;0秒&lt;/code&gt;的动画，并添加一个合适的动画延迟。&lt;/p&gt;
&lt;p&gt;关键帧:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@keyframes pointOfCircle {
  to {
    top: 20vh;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加到 animation 动画中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation: x 4s linear forwards,
    y 4s cubic-bezier(0.55, 0, 0.2, -5000) forwards, x2 0.5s linear forwards,
    pointOfCircle 0s linear forwards;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加动画延迟, &lt;code&gt;4.5s&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation-delay: 0s, 0s, 4s, 4.5s;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;循环本身&lt;/h4&gt;
&lt;p&gt;创建一个循环动画:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个关键帧，将球移回原来的位置，然后旋转球。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;@keyframes loop {
  from {
    transform: rotate(0deg) translateY(10vh) rotate(0deg);
  }
  to {
    transform: rotate(-360deg) translateY(10vh) rotate(360deg);
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加到 animation 中:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation: x 4s linear forwards,
    y 4s cubic-bezier(0.55, 0, 0.2, -5000) forwards, x2 0.5s linear forwards,
    pointOfCircle 0s linear forwards, loop 3s linear forwards;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加动画延迟，这里是&lt;code&gt;4.5s&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation-delay: 0s, 0s, 4s, 4.5s, 4.5s;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;地址：https://codepen.io/smashingmag/pen/mdLxZdR&lt;/p&gt;
&lt;p&gt;&lt;img alt="006.gif" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6268ffc20504262b9b2d303886a47ba~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h4&gt;添加水平空间&lt;/h4&gt;
&lt;p&gt;快完成了，最后 只需要在动画之后沿着&lt;code&gt;x&lt;/code&gt;轴移动球，这样球就不会像上图中那样在循环之后完全停止。&lt;/p&gt;
&lt;p&gt;关键帧:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@keyframes x3 {
  to {
    left: 70vw;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加到 animation 中:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation: x 4s linear forwards,
    y 4s cubic-bezier(0.55, 0, 0.2, -800) forwards, x2 0.5s linear forwards,
    pointOfCircle 0s linear forwards, loop 3s linear forwards,
    x3 2s linear forwards;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加上适当的延迟，这里是&lt;code&gt;7.5s&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation-delay: 0s, 0s, 4s, 4.5s, 4.5s, 7.5s;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;地址：https://codepen.io/smashingmag/pen/wvjmLKp&lt;/p&gt;
&lt;p&gt;&lt;img alt="007.gif" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d776e57c9c1469bbb22f32e6e7e224a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;在本节中，我们介绍了如何结合多个关键帧来创建一个复杂的动画路径。我们还介绍了贝塞尔以及如何使用它们来创建你自己的缓动函数。建议大家自己多多动手，才能更好的掌握 css 动画。&lt;/p&gt;
&lt;p&gt;来源：https://www.smashingmagazine.com/2022/10/advanced-animations-css/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编辑中可能存在的bug没法实时知道，事后为了解决这些bug,花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  https://github.com/qq449245884/xiaozhi 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Wed, 23 Nov 2022 16:38:10 GMT</pubDate></item><item><title>我服了，整理了 40 余种图片优化工具，论图片压缩，直接甩给他这个列表</title><link>https://juejin.cn/post/7166777437143957534</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;图像往往是任何特定网页上最大的资源。虽然许多开发者花时间优化网页性能的其他方面，但减少图像的大小对性能的影响比所有其他方面加起来还要大。这篇文章将纯粹关注于可用于减少图片大小的不同工具。&lt;/p&gt;
&lt;h2&gt;WebUtils Bulk Image Compress&lt;/h2&gt;
&lt;p&gt;地址：https://www.webutils.app/image-compress&lt;/p&gt;
&lt;p&gt;WebUtils Bulk Image Compress 支持压缩图片并将其转换为 WebP、JPG、PNG、AVIF和 JXL。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a7d09d270a544e1aa55902f9fd71241~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;Compressor.Io&lt;/h2&gt;
&lt;p&gt;地址：https://compressor.io/&lt;/p&gt;
&lt;p&gt;Compressor.io 支持有损或无损压缩来优化JPEG、PNG、SVG、GIF和WebP，每个文件最大可压缩10MB。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25d1524ec0cf41dfaa5da144677aaa0a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;Imagecompresser.Com&lt;/h2&gt;
&lt;p&gt;地址：https://imagecompresser.com/&lt;/p&gt;
&lt;p&gt;Imagecompresser.com 支持同时上传多达10个文件，支持PNG、JPEG、WebP、JPG和GIF格式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/096fff4d8762429e9623a2d40e734b34~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;AnyWebP&lt;/h2&gt;
&lt;p&gt;地址：https://anywebp.com/&lt;/p&gt;
&lt;p&gt;AnyWebP 是专门用于转换WebP格式的图片，可以输出为JPEG、PNG或ICO，也可以按文件大小或质量进行定制，还可以选择将几乎任何文件格式（TIFF、PSD、BMP等）转换为WebP。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df08356626844f3ba58f26c77314ac3c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;Compressimage.Io&lt;/h2&gt;
&lt;p&gt;地址：https://compressimage.io/&lt;/p&gt;
&lt;p&gt;Compressimage.io 支持离线的图像优化，对文件大小或文件数量没有限制。唯一的限制是只能压缩JPEG和PNG。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/911b0791edaf4493a50a5e114240539f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;JPEG.Rocks&lt;/h2&gt;
&lt;p&gt;地址：https://jpeg.rocks/&lt;/p&gt;
&lt;p&gt;JPEG.rocks，顾名思义，是一个隐私友好的JPEG图像优化器，完全是客户端和开源的。对文件大小或文件数量似乎没有限制，而且可以自定义输出文件的质量。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a93fb6ea572a42ceacfc3a059b680104~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;Compressor.Js&lt;/h2&gt;
&lt;p&gt;地址：https://fengyuanchen.github.io/compressorjs/&lt;/p&gt;
&lt;p&gt;Compressor.js 与本列表中的其他工具完全不同。它包括大约十几种不同的设置，可以自定义图像的质量、大小、MIME类型等等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c5333dd8b284f14a69e71551c7fcbf8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;Squoosh&lt;/h2&gt;
&lt;p&gt;地址：https://squoosh.app/&lt;/p&gt;
&lt;p&gt;Squoosh是由Chrome实验室团队设计的。这个网络应用仅限于一张图片，但它包括几个选项，用于缩小尺寸、调色板、选择压缩方法、压缩质量等级，以及一系列其他高级设置。为这个工具提供动力的引擎也可以作为API或CLI用于批量处理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3f2cc1285974a089b432891c10f8dc5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;SVGOMG&lt;/h2&gt;
&lt;p&gt;地址：https://jakearchibald.github.io/svgomg/&lt;/p&gt;
&lt;p&gt;SVGOMG是专门用于减少SVG图形的大小。它是SVGO的一个GUI，是一个基于Node.js的工具。SVG优化器很有用，因为许多生成SVG的程序在生成图像的SVG代码中包含了多余的和无用的信息&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0ed335d35924c96b96a74b413991a3b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;Optimizilla&lt;/h2&gt;
&lt;p&gt;地址：https://imagecompressor.com/&lt;/p&gt;
&lt;p&gt;Optimizilla 使用有损压缩来减少JPEG、GIF和PNG图像的大小。最多能上传20张图片，可以选择在下载前为每张图片定制压缩级别和质量。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09f02973998d4e11a8826a89e15dfd99~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;Shrink Me&lt;/h2&gt;
&lt;p&gt;地址：https://shrinkme.app/&lt;/p&gt;
&lt;p&gt;Shrink Me 支持批量优化JPEG、PNG、WebP或SVG图像，而且没有明显的质量损失。对文件数量或文件大小没有限制。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/097024e634a64329a90283bef4a252cf~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;JPEG Stripper&lt;/h2&gt;
&lt;p&gt;地址：https://www.toolsley.com/jpegstrip.html&lt;/p&gt;
&lt;p&gt;JPEG Stripper 通过剥离不必要的数据来优化JPEG文件。一次只允许上传一张图片，所以这只对JPEG格式的几张图片有用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bcdc412b9a641ab8a03f79100c82de8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;Shrink Media&lt;/h2&gt;
&lt;p&gt;地址：https://www.shrink.media/&lt;/p&gt;
&lt;p&gt;Shrink Media 支持优化PNG、JPEG和WebP图像，分辨率最高可达&lt;code&gt;5000x5000&lt;/code&gt;，它也可以作为iOS或Android的移动应用程序。使用交互式滑块来改变质量水平和照片尺寸。也可以粘贴图片的URL。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f90becda65e541fe877c90d094fd8df7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;OptimizeImages&lt;/h2&gt;
&lt;p&gt;地址：https://www.optimizeimages.com/&lt;/p&gt;
&lt;p&gt;OptimizeImages 可以减少SVG、PNG、JPEG、WebP、GIF和AVIF的大小，支持转换为WebP或AVIF。最多可以优化30张图片，并选择一个压缩质量选项（推荐、中等或超级）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44904c9ca93b4f8caf5308e8f5c6ad9f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;ImagesTool.Com&lt;/h2&gt;
&lt;p&gt;地址：https://imagestool.com/&lt;/p&gt;
&lt;p&gt;ImagesTool.com 包括许多不同的图像处理工具。可以调整大小，转换，压缩图像，以及更多。支持JPEG、WebP、SVG、GIF和APNG。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0c4b06ffb1f45c0a235c76c2ff133a9~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;AVPress&lt;/h2&gt;
&lt;p&gt;地址：https://avpress.zaps.dev/&lt;/p&gt;
&lt;p&gt;AVPress有点不同，因为它是专门用于优化视频文件和GIF动画的。一次只能处理一个视频或GIF，并包括几个自定义和输出设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92012d9eed6f4496bf311f503ca474ae~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;AVIF Converter&lt;/h2&gt;
&lt;p&gt;地址：https://avif.io/&lt;/p&gt;
&lt;p&gt;AVIF Converter 可以将任何图像格式转换为 AVIF，这是一种下一代文件格式，据称比WebP、JPEG、PNG和GIF有更好的压缩效果。这个应用程序似乎对文件数量或文件大小没有任何限制，但请注意，AVIF格式尚未被所有现代浏览器支持。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3976418712264eff988556cd6a908e3d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;TinyPNG&lt;/h2&gt;
&lt;p&gt;地址：https://tinypng.com/&lt;/p&gt;
&lt;p&gt;TinyPNG是一个较早的工具，可以优化WebP、PNG或JPEG文件。你一次最多可以上传20个，每个大小不超过5MB。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f47c16431f5144c9b20547b448292cfe~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;用于图像优化的构建工具和CLI工具&lt;/h2&gt;
&lt;p&gt;到目前为止，所列举的工具是手动批量处理或一次优化几张图片的好选择。但在一个大型项目的背景下，你会想考虑使用不同的工具，这些工具被设计成持续工作流程或构建过程的一部分。这里有一些你可以考虑的选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/svg/svgo"&gt;SVGO&lt;/a&gt;是流行的SVG优化工具，是前面提到的SVGOMG背后的核心。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/GoogleChromeLabs/squoosh/tree/dev/libsquoosh"&gt;libSquoosh&lt;/a&gt; 是 Squoosh API，支持构建动态优化图像的JavaScript程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/GoogleChromeLabs/squoosh/tree/dev/cli"&gt; Squoosh CLI &lt;/a&gt;是一个命令行工具，用于使用运行 Squoosh 的引擎。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://pngquant.org/"&gt;pngquant&lt;/a&gt;是一个专门用于优化PNG图像的命令行工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/bognarlaszlo/esbuild-squoosh"&gt;esbuild-squoosh&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据所使用的构建工具或任务运行程序的不同，前面提到的imagemin可能是你的所选工具的插件。下面是一些用于不同构建工具的imagemin插件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/malchata/rollup-plugin-imagemin"&gt;rollup-plugin-imagemin&lt;/a&gt;是Rollup的一个插件，它使用imagemin来自动优化Rollup构建中的图片。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/DeMoorJasper/parcel-plugin-imagemin"&gt;parcel-plugin-imagemin&lt;/a&gt;是另一个使用imagemin的插件，这次是为你的Parcel构建的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[grot-contrib-imagemin](https://github.com/gruntjs/grunt-contrib-imagemin)&lt;/code&gt;是另一个imagemin插件，为那些仍然使用Grunt的人提供，Grunt是一个较老的任务运行器工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://webpack.js.org/plugins/image-minimizer-webpack-plugin/"&gt;ImageMinimizerWebpackPlugin&lt;/a&gt;是另一个imagemin插件，这次是与流行的JavaScript捆绑包webpack一起使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/jaredLunde/snowpack-plugin-imagemin"&gt;snowpack-plugin-imagemin&lt;/a&gt;是一个imagemin插件，可与现代前端构建工具Snowpack一起使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;其它工具&lt;/h2&gt;
&lt;h4&gt;&lt;a href="https://qoiformat.org/"&gt;QOI&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;地址：https://qoiformat.org/&lt;/p&gt;
&lt;p&gt;Quite OK 图像格式是一种图像格式，它将图像无损压缩到与PNG相似的大小，同时提供20倍至50倍的编码速度和3倍至4倍的解码速度。&lt;/p&gt;
&lt;h4&gt;JXL&lt;/h4&gt;
&lt;p&gt;地址：https://jpegxl.info/&lt;/p&gt;
&lt;p&gt;不是一个工具，而是一个以JPEG XL图像格式为中心的社区网站。&lt;/p&gt;
&lt;h4&gt;UPNG.js&lt;/h4&gt;
&lt;p&gt;地址：https://github.com/photopea/UPNG.js&lt;/p&gt;
&lt;p&gt;这是流行的Photopea应用程序背后的PNG引擎，一个先进的PNG/APNG解码器和编码器，提供有损和无损优化。&lt;/p&gt;
&lt;h4&gt;Optimus&lt;/h4&gt;
&lt;p&gt;地址：https://github.com/Splode/optimus&lt;/p&gt;
&lt;p&gt;一个本地的桌面应用程序，支持压缩、优化和转换图像，支持JPEG、PNG和WebP格式。&lt;/p&gt;
&lt;h4&gt;ImageOptim&lt;/h4&gt;
&lt;p&gt;地址：https://imageoptim.com/mac&lt;/p&gt;
&lt;p&gt;一个Mac应用程序和Sketch插件，用于减少图像文件大小。&lt;/p&gt;
&lt;h4&gt;pngcrush&lt;/h4&gt;
&lt;p&gt;地址：https://pmt.sourceforge.io/pngcrush/&lt;/p&gt;
&lt;p&gt;一个传统的图像压缩工具，可以通过命令行使用。&lt;/p&gt;
&lt;h4&gt;Trimage&lt;/h4&gt;
&lt;p&gt;地址：https://trimage.org/&lt;/p&gt;
&lt;p&gt;一个原生的跨平台应用程序和命令行界面来优化JPEG和PNG图像。&lt;/p&gt;
&lt;h4&gt;PNGGauntlet&lt;/h4&gt;
&lt;p&gt;地址：https://pnggauntlet.com/&lt;/p&gt;
&lt;p&gt;一个较早的可配置的本地应用程序，适用于Windows、Mac和Linux，可优化PNG并将各种格式转换为PNG。&lt;/p&gt;
&lt;h4&gt;Pngyu&lt;/h4&gt;
&lt;p&gt;地址：https://nukesaq88.github.io/Pngyu/&lt;/p&gt;
&lt;p&gt;另一个使用pngquant进行PNG优化的本地应用程序。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;希望这个工具清单足以提供你所需要的任何东西来满足你的图像优化要求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来源：https://www.smashingmagazine.com/2022/07/powerful-image-optimization-tools/&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Wed, 16 Nov 2022 16:37:08 GMT</pubDate></item><item><title>为什么和 CSS-in-JS 说拜拜</title><link>https://juejin.cn/post/7165878751295700999</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是由 Emotion 的第二大活跃维护者 Sam 分享，本文第一人称都指的是 Sam。&lt;a href="https://emotion.sh/docs/introduction"&gt;Emotion&lt;/a&gt; 是一个广泛流行的 CSS-in-JS 库，用于React。文文章 Sam 会带大家深入探讨 CSS-in-JS 最初吸引人的原因，以及为什么作者（以及Spot团队的其他成员）决定放弃它。&lt;/p&gt;
&lt;h2&gt;什么是 CSS-in-JS？&lt;/h2&gt;
&lt;p&gt;顾名思义，CSS-in-JS 就是在 JS 或 TS 中直接编写 CSS，为 React 组件提供样式，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Object Styles  方式
function ErrorMessage({ children }) {
  return (
    &amp;lt;div
      css={{
        color: 'red',
        fontWeight: 'bold',
      }}
    &amp;gt;
      {children}
    &amp;lt;/div&amp;gt;
  );
}

// String Styles 方式
const ErrorMessage = styled.div`
  color: red;
  font-weight: bold;
`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://styled-components.com/"&gt;styled-components&lt;/a&gt;和&lt;a href="https://emotion.sh/docs/introduction"&gt;Emotion&lt;/a&gt;是React社区中最流行的CSS-in-JS库。虽然我只使用了Emotion，但我相信本文的所有观点也适用于styled-components。&lt;/p&gt;
&lt;p&gt;本文重点介绍&lt;strong&gt;运行时CSS-in-JS&lt;/strong&gt;，这个类别包括 styled-components 和 Emotion。运行时CSS-in-JS 仅仅意味着库在应用程序运行时解释并应用你的样式。我们会在文章的最后简要讨论编译时 CSS-in-JS。&lt;/p&gt;
&lt;h2&gt;CSS-in-JS 的好、坏、丑&lt;/h2&gt;
&lt;p&gt;在讨论 CSS-in-JS 编码模式及其对性能的影响之前，先来看看为什么有的开发者会使用 CSS-in-JS，有的不会使用。&lt;/p&gt;
&lt;h4&gt;好处&lt;/h4&gt;
&lt;p&gt;1.局部作用域的样式。在写普通的CSS时，很容易不小心将样式应用到其它文件中。例如，假设我们正在写一个列表，每一行都应该有一些 &lt;code&gt;padding&lt;/code&gt; 和 &lt;code&gt;border&lt;/code&gt; 。我们可能会这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   .row {
     padding: 0.5rem;
     border: 1px solid #ddd;
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;几个月后，当我们完全忘记了这个列表时，又创建了一个列表。然后也设置了 &lt;code&gt;className="row"&lt;/code&gt;。现在，新组件的行有一个难看的边框，而我们却不知道为什么! 虽然这类问题可以通过使用较长的类名或更具体的选择器来解决，但作为开发者还是要确保没有类名冲突。&lt;/p&gt;
&lt;p&gt;CSS-in-JS 完全解决了这一问题，它使样式默认为本地作用域。如果把上面的样式写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div css={{ padding: '0.5rem', border: '1px solid #ddd' }}&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样 &lt;code&gt;padding&lt;/code&gt; 和  &lt;code&gt;border&lt;/code&gt; 就不可能应用到其它元素了。&lt;/p&gt;
&lt;p&gt;2.托管。如果使用普通的CSS，则可以将所有&lt;code&gt;.css&lt;/code&gt;文件放在 &lt;code&gt;src/styles&lt;/code&gt; 目录中，而所有的React组件都在 &lt;code&gt;src/components&lt;/code&gt; 中。随着应用程序的大小的增长，很难判断每个组件使用哪些样式。很多时候，你的CSS中会出现死代码，因为没有简单的方法可以说出这些样式没有使用。&lt;/p&gt;
&lt;p&gt;一个更好的组织代码的方法是将所有与单个组件相关的东西放在同一个地方。这种做法被称为colocation (托管)。&lt;/p&gt;
&lt;p&gt;问题是，在使用普通的CSS时，很难实现 &lt;strong&gt;colocation&lt;/strong&gt;，因为CSS和JavaScript必须放在单独的文件中，而且无论&lt;code&gt;.css&lt;/code&gt;文件在哪里，你的样式都会全局应用。另一方面，如果使用CSS-in-JS，可以直接在使用它们的React组件中编写样式 如果操作得当，这将极大地提高应用程序的可维护性。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;可以在样式中使用JavaScript变量&lt;/strong&gt;。CSS-in-JS 可以在样式规则中引用JavaScript变量，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// colors.ts
export const colors = {
  primary: '#0d6efd',
  border: '#ddd',
  /* ... */
};

// MyComponent.tsx
function MyComponent({ fontSize }) {
  return (
    &amp;lt;p
      css={{
        color: colors.primary,
        fontSize,
        border: `1px solid ${colors.border}`,
      }}
    &amp;gt;
      ...
    &amp;lt;/p&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如本示例所示，可以在CSS-in-JS样式中同时使用 JS 常量（例如 &lt;code&gt;colors&lt;/code&gt;）和 &lt;code&gt;React Props/state&lt;/code&gt; （例如 &lt;code&gt;fontSize&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;在样式中使用 JS 常量的能力在某些情况下可以降低重复，因为同一个常量不需要同时定义为CSS变量和 JS 常量。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;props&lt;/code&gt; 和 &lt;code&gt;state&lt;/code&gt;  的能力可以创建具有高度可定制的样式的组件，而无需使用内联样式。(当相同的样式应用于许多元素时，内联样式的性能并不理想）。&lt;/p&gt;
&lt;h2&gt;中立&lt;/h2&gt;
&lt;p&gt;这是一项热门的新技术。许多Web开发者，包括我自己，一般会社区中最热门的新趋势。部分原因是这样的，因为在很多情况下，新的库和框架已经被证明比它们的前辈有巨大的改进（想想React比早期的库如jQuery提高了多少生产力就知道了）。&lt;/p&gt;
&lt;p&gt;另一方面，我们对新工具的痴迷是害怕错过下一个大事件，在决定采用一个新的库或框架时，我们可能忽略了真正的缺点。我认为这肯定是CSS-in-JS被广泛采用的一个因素--至少对我来说是这样。&lt;/p&gt;
&lt;h2&gt;不好&lt;/h2&gt;
&lt;p&gt;1.&lt;strong&gt;CSS-in-JS增加了运行时的开销&lt;/strong&gt;。当组件渲染时，CSS-in-JS库必须将样式 "序列化"为可以插入到文档中的普通CSS。很明显，这需要占用额外的CPU周期，但这是否足以对应用程序的性能产生明显的影响？我们在下一节中深入研究这个问题。&lt;/p&gt;
&lt;p&gt;2 &lt;strong&gt;CSS-in-JS增加的包的大小&lt;/strong&gt;。这是一个明显的问题--每个访问你网站的用户都必须下载CSS-in-JS库的JavaScript。Emotion 的最小压缩量是&lt;code&gt;7.9 kB&lt;/code&gt;，styled-components 是&lt;code&gt;12.7 kB&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;CSS-in-JS会打乱React DevTools&lt;/strong&gt;。对于每个使用css prop 的元素，Emotion会渲染&lt;code&gt;&amp;lt;EmotionCssPropInternal&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;Insertion&amp;gt;&lt;/code&gt;组件。如果你在许多元素上使用css prop，Emotion 的内部组件会使React DevTools变得非常混乱，如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6387a6214714899ad40e3d460db0769~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;丑&lt;/h2&gt;
&lt;p&gt;1.&lt;strong&gt;频繁插入CSS规则迫使浏览器做很多额外的工作&lt;/strong&gt;。React核心团队成员、React Hooks的最初设计师Sebastian Markbåge在React 18工作组中写了一篇非常有见地的讨论，内容是关于CSS-in-JS库需要如何改变才能与React 18一起工作，以及总体上关于运行时CSS-in-JS的未来。特别是，他说:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在并发渲染中，React可以在渲染之间向浏览器让步。如果在一个组件中插入一个新的规则，如果React 让步了，那么浏览器就必须看看这些规则是否适用于现有的树。所以它会重新计算样式规则。然后React渲染下一个组件，然后该组件发现了一个新的规则，再次发生。
引用
这有效地导致在React渲染时，每一帧都要针对所有DOM节点重新计算所有CSS规则。这是很慢的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题最糟糕的地方在于，它不是一个可修复的问题（在运行时CSS-in-JS的上下文中）。运行时CSS-in-JS库通过在组件渲染时插入新的样式规则来工作，这在基本层面上不利于性能。&lt;/p&gt;
&lt;p&gt;2.对于CSS-in-JS，可能出错的地方还有很多，尤其是在使用SSR或组件库的时候。在Emotion的GitHub仓库里，我们收到了大量这样的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我正在使用Emotion与服务器端渲染和MUI/Mantine/(另一个Emotion驱动的组件库)，它不能工作，因为...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然每个问题的根本原因各不相同，但有一些共同的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Emotion的多个实例被同时加载。即使多个实例都是同一版本的Emotion，这也会导致问题。&lt;a href="https://github.com/emotion-js/emotion/issues/2639"&gt;(issue&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件库通常不能完全控制插入样式的顺序。(&lt;a href="https://github.com/emotion-js/emotion/issues/2803"&gt;issue&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Emotion的SSR支持在React 17和React 18之间的工作方式不同。为了与React 18的流式SSR兼容，这是必要的。(&lt;a href="https://github.com/emotion-js/emotion/issues/2725"&gt;issue&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些复杂性只是冰山一角。&lt;/p&gt;
&lt;h2&gt;性能&lt;/h2&gt;
&lt;p&gt;运行时 CSS-in-JS既有明显的优点也有明显的缺点。为了理解我们的团队为什么要放弃这项技术，我们需要探索CSS-in-JS的实际性能影响。&lt;/p&gt;
&lt;p&gt;本节重点介绍Emotion 对性能的影响，因为它被用于 Spot 代码库。因此，如果认为下给出的性能数据也适用于你的代码库，那就错了--有很多方法可以使用Emotion，而且每一种方法都有自己的性能特点。&lt;/p&gt;
&lt;h4&gt;渲染内的序列化与渲染外的序列化&lt;/h4&gt;
&lt;p&gt;样式序列化是指Emotion将CSS字符串或对象样式转换为可以插入文档的普通CSS字符串的过程。在序列化过程中，Emotion也会计算出一个普通CSS的哈希值--这个哈希值就是你在生成的类名中看到的，例如&lt;code&gt;css-15nl2r3&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;虽然我没有测量过这一点，但我相信影响Emotion如何执行的最重要因素之一是样式序列化是在React渲染循环内部还是外部执行的。&lt;/p&gt;
&lt;p&gt;Emotion文档中的例子是在&lt;code&gt;render&lt;/code&gt;里面进行序列化的，像这样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function MyComponent() {
  return (
    &amp;lt;div
      css={{
        backgroundColor: 'blue',
        width: 100,
        height: 100,
      }}
    /&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每次&lt;code&gt;MyComponent&lt;/code&gt;渲染的时候，对象的样式都会被再次序列化。如果&lt;code&gt;MyComponent&lt;/code&gt;频繁地渲染（例如每次按键），重复的序列化可能会有很高的性能代价。&lt;/p&gt;
&lt;p&gt;一个更有效的方法是把样式移到组件之外，这样序列化就会在模块加载时一次性发生，而不是在每次渲染时。这可以通过@emotion/react的&lt;code&gt;css&lt;/code&gt;函数来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const myCss = css({
  backgroundColor: 'blue',
  width: 100,
  height: 100,
});

function MyComponent() {
  return &amp;lt;div css={myCss} /&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，这种方式就无法在样式中访问 props，所以错过了CSS-in-JS的主要卖点之一。&lt;/p&gt;
&lt;p&gt;在Spot，我们在&lt;code&gt;render&lt;/code&gt;中进行了样式序列化，所以下面的性能分析将集中于这种情况。&lt;/p&gt;
&lt;h4&gt;对Member Browser 进行基准测试&lt;/h4&gt;
&lt;p&gt;现在通过对Spot的一个真正的组件进行分析来使事情具体化。我们将使用 Member Browser，这是一个相当简单的列表视图，可以显示你的团队中的所有用户。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87037f59de9b4ddcad1e8d72c01b931a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为了测试:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Member Browser 显示20个用户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;React.memo&lt;/code&gt; 周围的列表项目将被删除，并且强制最上面的&lt;code&gt;&amp;lt;BrowseMembers&amp;gt;&lt;/code&gt;组件每秒钟渲染一次，并记录前10次渲染的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;React严格模式是关闭的。(它可以效地让我们在分析器中看到的渲染时间翻倍）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我使用React DevTools对该页面进行了分析，前&lt;code&gt;10&lt;/code&gt;次渲染时间的平均值为&lt;code&gt;54.3ms&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我个人的经验是，一个React组件的渲染时间应该在&lt;code&gt;16&lt;/code&gt;毫秒以内，因为每秒60帧的1帧是&lt;code&gt;16.67&lt;/code&gt;毫秒。Member Browser 目前是这个数字的3倍多，所以它是一个相当重量级的组件。&lt;/p&gt;
&lt;p&gt;这个测试是在M1 Max CPU上进行的，它比普通用户的速度要快很多。我得到的&lt;code&gt;54.3&lt;/code&gt;毫秒的渲染时间在性能较差的机器上可能很容易达到&lt;code&gt;200&lt;/code&gt;毫秒。&lt;/p&gt;
&lt;h2&gt;使用火焰图(FlameGraph)分析程序性能&lt;/h2&gt;
&lt;p&gt;下面是上述测试中单个列表项的火焰图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dbd1324ffd04a4184706bb081199079~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;正如你所看到的，有大量的&lt;code&gt;&amp;lt;Box&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;Flex&amp;gt;&lt;/code&gt;组件被渲染--这些是我们的 "tyle primitives"，使用css prop。虽然每&lt;code&gt;个&amp;lt;Box&amp;gt;&lt;/code&gt;只需要0.1-0.2毫秒的渲染时间，但由于&lt;code&gt;&amp;lt;Box&amp;gt;&lt;/code&gt;组件的总数非常大，所以这就增加了。&lt;/p&gt;
&lt;h4&gt;不使用 Emotion，对 Member Browser 进行测试&lt;/h4&gt;
&lt;p&gt;为了了解这种昂贵的渲染有多少是由&lt;code&gt;Emotion&lt;/code&gt;造成的，我使用Sass Modules而不是Emotion重写了Member Browser 的样式。(Sass模块在构建时被编译成普通的CSS，所以使用它们几乎没有性能损失)。&lt;/p&gt;
&lt;p&gt;我重复了上述同样的测试，前10次渲染的平均时间为&lt;code&gt;27.7ms&lt;/code&gt;。这比原来的时间减少了48%!&lt;/p&gt;
&lt;p&gt;所以，这就是我们与CSS-in-JS 说拜拜的原因：运行时的性能成本实在是太高了。&lt;/p&gt;
&lt;p&gt;重复我上面的免责声明：这个结果只直接适用于Spot代码库和我们使用Emotion的方式。如果你的代码库以一种更有效的方式使用Emotion（例如在render之外的样式序列化），你可能会看到从方程中移除CSS-in-JS后的更小好处。&lt;/p&gt;
&lt;p&gt;下面是一些数据，供那些好奇的人参考：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f967f134a56b467dbcc3c42b3a38ec39~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;我们新的样式系统&lt;/h2&gt;
&lt;p&gt;在我们下定决心不再使用CSS-in-JS之后，一个新的问题就会出现：我们应该用什么来代替？理想情况下，我们希望样式系统的性能与普通CSS类似，同时尽可能多地保留CSS-in-JS的优点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部作用域&lt;/li&gt;
&lt;li&gt;样式与它们所应用的组件放在同个地方&lt;/li&gt;
&lt;li&gt;可以在样式中使用 JS 变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你仔细看了那一节，你会记得我说过，CSS Module 还提供了局部作用域的样式和同位。而且，CSS Module 可以编译成普通的CSS文件，所以使用它们没有运行时的性能成本。&lt;/p&gt;
&lt;p&gt;在我看来，CSS模块的主要缺点是，说到底，它们仍然是普通的CSS--而普通的CSS缺乏改善DX和减少代码重复的功能。虽然嵌套选择器即将出现在CSS中，但它们还没有出现，而这个功能对我们来说是一个巨大开发质量的提升。&lt;/p&gt;
&lt;p&gt;幸运的是，这个问题有一个简单的解决方案--&lt;strong&gt;Sass模块&lt;/strong&gt;，它只是用Sass编写的CSS模块。你可以得到CSS模块的局部范围的样式和Sass强大的构建时间功能，而且基本上没有运行时间成本。这就是为什么Sass模块将成为我们未来的通用样式解决方案。&lt;/p&gt;
&lt;h2&gt;实用类&lt;/h2&gt;
&lt;p&gt;对于从Emotion切换到Sass Modules，团队的一个担心是，应用极其常见的样式，如&lt;code&gt;display: flex&lt;/code&gt;，会不太方便。以前，我们会写。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;FlexH alignItems="center"&amp;gt;...&amp;lt;/FlexH&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了只使用Sass模块做到这一点，我们必须打开.module。SCSS文件并创建一个应用样式display: flex和align-items: center的类。虽然不是世界末日，但确实不那么方便了。&lt;/p&gt;
&lt;p&gt;如果只使用Sass模块，我们不得在新建&lt;code&gt;.module.scss&lt;/code&gt;文件，并创建一个类，应用样式&lt;code&gt;display: flex &lt;/code&gt;和 &lt;code&gt;align-items: center&lt;/code&gt;。这并不是灾难，但肯定不那么方便。&lt;/p&gt;
&lt;p&gt;为了改进DX，我们决定引入一个实用类系统。实用类就是是在元素上设置一个单一的CSS属性的CSS类。通常情况下，结合多个实用类来获得所需的样式。对于上面的例子，可以这样写。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div className="d-flex align-items-center"&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bootstrap和Tailwind是提供实用程序类的最流行的CSS框架。这些库在其实用程序系统中投入了大量的设计工作，所以采用其中一个而不是推出我们自己的实用程序是最有意义的。我已经使用Bootstrap多年了，所以我们选择了Bootstrap。虽然你可以把Bootstrap的实用类作为一个预建的CSS文件，但我们需要定制这些类来适应我们现有的样式系统，所以我把Bootstrap源代码的相关部分复制到我们的项目中。&lt;/p&gt;
&lt;p&gt;我们使用Sass模块和实用类的新组件已经有几个星期了，对它相当满意。DX与Emotion相似，而运行时的性能则大大优于Emotion。&lt;/p&gt;
&lt;h2&gt;关于编译时CSS-in-JS的说明&lt;/h2&gt;
&lt;p&gt;本文主要介绍运行时的CSS-in-JS库，如 Emotion 和s tyled-components。最近，我们看到越来越多的CSS-in-JS库在编译时将样式转换为普通CSS。这些库包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://compiledcssinjs.com/"&gt;Compiled&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://vanilla-extract.style/"&gt;Vanilla Extract&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://linaria.dev/"&gt;Linaria&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些库旨在提供类似于运行时CSS-in-JS的好处，而没有性能成本。&lt;/p&gt;
&lt;p&gt;虽然我自己没有使用过任何编译时的CSS-in-JS库，但我仍然认为它们与Sass模块相比有缺点。以下是我在观察&lt;code&gt;Compiled&lt;/code&gt;时看到的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;样式仍然是在组件第一次挂载时插入的，这迫使浏览器在每个DOM节点上重新计算样式。(这个缺点已经在 "丑"一节中讨论过了）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;像本例中的 color prop 这样的动态样式不能在构建时提取，所以Compiled使用 style prop（又称内联样式）将该值添加为CSS变量。众所周知，当应用许多元素时，内联样式会导致次优的性能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该库仍然将模板组件插入你的React树中，如图所示。这将使React DevTools变得混乱，就像运行时的CSS-in-JS一样。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;任何技术一样，它有其优点和缺点。归根结底，作为一个开发者，你应该评估这些优点和缺点，然后就该技术是否适合你的使用情况做出一个明智的决定。对于我们Spot公司来说，Emotion的运行时性能成本远远超过了DX的好处，特别是当你考虑到Sass模块+实用类的替代方案仍然有一个很好的DX，同时提供巨大的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来源：https://dev.to/srmagura/why-were-breaking-up-wiht-css-in-js-4g9b&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Mon, 14 Nov 2022 06:30:39 GMT</pubDate></item><item><title>开发人员面临的10个最常见的JavaScript问题</title><link>https://juejin.cn/post/7161959592967012366</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天，JavaScript 是几乎所有现代 Web 应用的核心。这就是为什么JavaScript问题，以及找到导致这些问题的错误，是 Web 发者的首要任务。&lt;/p&gt;
&lt;p&gt;用于单页应用程序（SPA）开发、图形和动画以及服务器端JavaScript平台的强大的基于JavaScript的库和框架已不是什么新鲜事。在 Web 应用程序开发的世界里，JavaScript确实已经无处不在，因此是一项越来越重要的技能，需要掌握。&lt;/p&gt;
&lt;p&gt;起初，JavaScript 看起来很简单。事实上，对于任何有经验的前端开发人员来说，在网页中建立基本的JavaScript功能是一项相当简单的任务，即使他们是JavaScript新手。然而，这种语言比人们最初认为的要细致、强大和复杂得多。事实上，JavaScript的许多微妙之处导致了许多常见的问题，这些问题使它无法工作--我们在这里讨论了其中的10个问题--在寻求成为JavaScript开发大师的过程中，这些问题是需要注意和避免的。&lt;/p&gt;
&lt;h2&gt;问题#1：不正确的引用 this&lt;/h2&gt;
&lt;p&gt;随着JavaScript编码技术和设计模式多年来变得越来越复杂，回调和闭包中的自引用作用域也相应增加，这是造成JavaScript问题的 "this/that 混乱 "的一个相当普遍的来源。&lt;/p&gt;
&lt;p&gt;考虑下面代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Game.prototype.restart = function () {
    this.clearLocalStorage();
    this.timer = setTimeout(function() {
    this.clearBoard();    // What is "this"?
    }, 0);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行上述代码会出现以下错误:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Uncaught TypeError: undefined is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述错误的原因是，当调用 &lt;code&gt;setTimeout()&lt;/code&gt;时，实际上是在调用 &lt;code&gt;window.setTimeout()&lt;/code&gt;。因此，传递&lt;code&gt;给setTimeout()&lt;/code&gt;的匿名函数是在&lt;code&gt;window&lt;/code&gt;对象的上下文中定义的，它没有&lt;code&gt;clearBoard()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;传统的、符合老式浏览器的解决方案是将 &lt;code&gt;this&lt;/code&gt; 引用保存在一个变量中，然后可以被闭包继承，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Game.prototype.restart = function () {
    this.clearLocalStorage();
    var self = this;   // Save reference to 'this', while it's still this!
    this.timer = setTimeout(function(){
    self.clearBoard();    // Oh OK, I do know who 'self' is!
    }, 0);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，在较新的浏览器中，可以使用&lt;code&gt;bind()&lt;/code&gt;方法来传入适当的引用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Game.prototype.restart = function () {
    this.clearLocalStorage();
    this.timer = setTimeout(this.reset.bind(this), 0);  // Bind to 'this'
};

Game.prototype.reset = function(){
    this.clearBoard();    // Ahhh, back in the context of the right 'this'!
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;问题2：认为存在块级作用域&lt;/h2&gt;
&lt;p&gt;JavaScript开发者中常见的混乱来源（也是常见的错误来源）是假设JavaScript为每个代码块创建一个新的作用域。尽管这在许多其他语言中是对的，但在JavaScript中却不是。考虑一下下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (var i = 0; i &amp;lt; 10; i++) {
    /* ... */
}
console.log(i);  // 输出什么？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你猜测&lt;code&gt;console.log()&lt;/code&gt;的调用会输出 &lt;code&gt;undefined&lt;/code&gt; 或者抛出一个错误，那你就猜错了。答案是输出&lt;code&gt;10&lt;/code&gt;。为什么呢？&lt;/p&gt;
&lt;p&gt;在大多数其他语言中，上面的代码会导致一个错误，因为变量&lt;code&gt;i&lt;/code&gt;的 "生命"（即使作用域）会被限制在&lt;code&gt;for&lt;/code&gt;块中。但在JavaScript中，情况并非如此，即使在for循环完成后，变量&lt;code&gt;i&lt;/code&gt;仍然在作用域内，在退出循环后仍保留其最后的值。(顺便说一下，这种行为被称为变量提升（variable hoisting）。&lt;/p&gt;
&lt;p&gt;JavaScript中对块级作用域的支持是通过&lt;code&gt;let&lt;/code&gt;关键字实现的。&lt;code&gt;Let&lt;/code&gt;关键字已经被浏览器和Node.js等后端JavaScript引擎广泛支持了多年。&lt;/p&gt;
&lt;h2&gt;问题#3：创建内存泄漏&lt;/h2&gt;
&lt;p&gt;如果没有有意识地编写代码来避免内存泄漏，那么内存泄漏几乎是不可避免的JavaScript问题。它们的发生方式有很多种，所以我们只重点介绍几种比较常见的情况。&lt;/p&gt;
&lt;h4&gt;内存泄漏实例1:对不存在的对象的悬空引用&lt;/h4&gt;
&lt;p&gt;考虑以下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var theThing = null;
var replaceThing = function () {
  var priorThing = theThing; 
  var unused = function () {
     // 'unused'是'priorThing'被引用的唯一地方。
    // 但'unused'从未被调用过
    if (priorThing) {
      console.log("hi");
    }
  };
  theThing = {
    longStr: new Array(1000000).join('*'),  // 创建一个1MB的对象
    someMethod: function () {
      console.log(someMessage);
    }
  };
};
setInterval(replaceThing, 1000);    // 每秒钟调用一次 "replaceThing"。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你运行上述代码并监测内存使用情况，你会发现你有一个明显的内存泄漏，每秒泄漏整整一兆字节！而即使是手动垃圾收集器（GC）也无济于事。因此，看起来我们每次调用 &lt;code&gt;replaceThing&lt;/code&gt; 都会泄漏 &lt;code&gt;longStr&lt;/code&gt;。但是为什么呢？&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;theThing&lt;/code&gt;对象包含它自己的&lt;code&gt;1MB longStr&lt;/code&gt;对象。每一秒钟，当我们调用 &lt;code&gt;replaceThing&lt;/code&gt; 时，它都会在 &lt;code&gt;priorThing&lt;/code&gt; 中保持对先前 &lt;code&gt;theThing&lt;/code&gt; 对象的引用。&lt;/p&gt;
&lt;p&gt;但是我们仍然认为这不会是一个问题，因为每次通过，先前引用的&lt;code&gt;priorThing&lt;/code&gt;将被取消引用（当&lt;code&gt;priorThing&lt;/code&gt;通过&lt;code&gt;priorThing = theThing;&lt;/code&gt;被重置时）。而且，只在 &lt;code&gt;replaceThing&lt;/code&gt; 的主体和&lt;code&gt;unused&lt;/code&gt;的函数中被引用，而事实上，从未被使用。&lt;/p&gt;
&lt;p&gt;因此，我们又一次想知道为什么这里会有内存泄漏。&lt;/p&gt;
&lt;p&gt;为了理解发生了什么，我们需要更好地理解JavaScript的内部工作。实现闭包的典型方式是，每个函数对象都有一个链接到代表其词法作用域的字典式对象。如果在&lt;code&gt;replaceThing&lt;/code&gt;里面定义的两个函数实际上都使用了&lt;code&gt;priorThing，&lt;/code&gt;那么它们都得到了相同的对象就很重要，即使&lt;code&gt;priorThing&lt;/code&gt;被反复赋值，所以两个函数都共享相同的词法环境。但是一旦一个变量被任何闭包使用，它就会在该作用域内所有闭包共享的词法环境中结束。而这个小小的细微差别正是导致这个可怕的内存泄露的原因。&lt;/p&gt;
&lt;h4&gt;内存泄漏实例2：循环引用&lt;/h4&gt;
&lt;p&gt;考虑下面代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function addClickHandler(element) {
    element.click = function onClick(e) {
        alert("Clicked the " + element.nodeName)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，&lt;code&gt;onClick&lt;/code&gt;有一个闭包，保持对&lt;code&gt;element&lt;/code&gt;的引用（通过&lt;code&gt;element.nodeName&lt;/code&gt;）。通过将&lt;code&gt;onClick&lt;/code&gt;分配给&lt;code&gt;element.click&lt;/code&gt;，循环引用被创建；即：&lt;code&gt; element&lt;/code&gt; → &lt;code&gt;onClick&lt;/code&gt; → &lt;code&gt;element&lt;/code&gt; → &lt;code&gt;onClick&lt;/code&gt; → &lt;code&gt;element&lt;/code&gt;...&lt;/p&gt;
&lt;p&gt;有趣的是，即使 &lt;code&gt;element&lt;/code&gt; 被从DOM中移除，上面的循环自引用也会阻止 element 和&lt;code&gt;onClick&lt;/code&gt;被收集，因此会出现内存泄漏。&lt;/p&gt;
&lt;h4&gt;避免内存泄漏:要点&lt;/h4&gt;
&lt;p&gt;JavaScript的内存管理（尤其是垃圾回收）主要是基于对象可达性的概念。&lt;/p&gt;
&lt;p&gt;以下对象被认为是可达的，被称为 "根":&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从当前调用堆栈的任何地方引用的对象（即当前被调用的函数中的所有局部变量和参数，以及闭包作用域内的所有变量）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有全局变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只要对象可以通过引用或引用链从任何一个根部访问，它们就会被保留在内存中。&lt;/p&gt;
&lt;p&gt;浏览器中有一个垃圾收集器，它可以清理被无法到达的对象所占用的内存；换句话说，当且仅当GC认为对象无法到达时，才会将其从内存中删除。不幸的是，很容易出现不再使用的 "僵尸 "对象，但GC仍然认为它们是 "可达的"。&lt;/p&gt;
&lt;h2&gt;问题4：双等号的困惑&lt;/h2&gt;
&lt;p&gt;JavaScript 的一个便利之处在于，它会自动将布尔上下文中引用的任何值强制为布尔值。但在有些情况下，这可能会让人困惑，因为它很方便。例如，下面的一些情况对许多JavaScript开发者来说是很麻烦的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 下面结果都是 'true'
console.log(false == '0');
console.log(null == undefined);
console.log(" \t\r\n" == 0);
console.log('' == 0);

// 下面也都成立
if ({}) // ...
if ([]) // ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于最后两个，尽管是空的（大家可能会觉得他们是 false），&lt;code&gt;{}&lt;/code&gt;和&lt;code&gt;[]&lt;/code&gt;实际上都是对象，任何对象在JavaScript中都会被强制为布尔值 &lt;code&gt;"true"&lt;/code&gt;，这与ECMA-262规范一致。&lt;/p&gt;
&lt;p&gt;正如这些例子所表明的，类型强制的规则有时非常清楚。因此，除非明确需要类型强制，否则最好使用&lt;code&gt;===&lt;/code&gt;和&lt;code&gt;!==&lt;/code&gt;（而不是&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;），以避免强制类型转换的带来非预期的副作用。(&lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 会自动进行类型转换，而 &lt;code&gt;===&lt;/code&gt; 和 &lt;code&gt;!==&lt;/code&gt; 则相反)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外需要注意的是&lt;/strong&gt;：将&lt;code&gt;NaN&lt;/code&gt;与任何东西（甚至是&lt;code&gt;NaN&lt;/code&gt;）进行比较时结果都是 &lt;code&gt;false&lt;/code&gt;。因此，不能使用双等运算符（&lt;code&gt;==&lt;/code&gt;,&lt;code&gt; ==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;!==&lt;/code&gt;）来确定一个值是否是&lt;code&gt;NaN&lt;/code&gt;。如果需要，可以使用内置的全局 &lt;code&gt;isNaN()&lt;/code&gt;函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(NaN == NaN);    // False
console.log(NaN === NaN);   // False
console.log(isNaN(NaN));    // True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;JavaScript问题5：低效的DOM操作&lt;/h2&gt;
&lt;p&gt;使用 JavaScript 操作DOM（即添加、修改和删除元素）是相对容易，但操作效率却不怎么样。&lt;/p&gt;
&lt;p&gt;比如，每次添加一系列DOM元素。添加一个DOM元素是一个昂贵的操作。连续添加多个DOM元素的代码是低效的。&lt;/p&gt;
&lt;p&gt;当需要添加多个DOM元素时，一个有效的替代方法是使用 &lt;code&gt;document fragments&lt;/code&gt;来代替，从而提高效率和性能。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var div = document.getElementsByTagName("my_div");

var fragment = document.createDocumentFragment();

for (var e = 0; e &amp;lt; elems.length; e++) {  // elems previously set to list of elements
    fragment.appendChild(elems[e]);
}
div.appendChild(fragment.cloneNode(true));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了这种方法固有的效率提高外，创建附加的DOM元素是很昂贵的，而在分离的情况下创建和修改它们，然后再将它们附加上，就会产生更好的性能。&lt;/p&gt;
&lt;h2&gt;问题#6：在循环内错误使用函数定义&lt;/h2&gt;
&lt;p&gt;考虑下面代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var elements = document.getElementsByTagName('input');
var n = elements.length;    // Assume we have 10 elements for this example
for (var i = 0; i &amp;lt; n; i++) {
    elements[i].onclick = function() {
        console.log("This is element #" + i);
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据上面的代码，如果有&lt;code&gt;10&lt;/code&gt;个 &lt;code&gt;input&lt;/code&gt; 元素，点击任何一个都会显示 &lt;code&gt;"This is element #10"&lt;/code&gt;。
这是因为，当任何一个元素的&lt;code&gt;onclick&lt;/code&gt;被调用时，上面的&lt;code&gt;for&lt;/code&gt;循环已经结束，&lt;code&gt;i&lt;/code&gt;的值已经是&lt;code&gt;10&lt;/code&gt;了（对于所有的元素）。&lt;/p&gt;
&lt;p&gt;我们可以像下面这样来解决这个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var elements = document.getElementsByTagName('input');
var n = elements.length;   
var makeHandler = function(num) { 
     return function() {  
         console.log("This is element #" + num);
     };
};
for (var i = 0; i &amp;lt; n; i++) {
    elements[i].onclick = makeHandler(i+1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;makeHandler&lt;/code&gt; 是一个外部函数，并返回一个内部函数，这样就会形成一个闭包，&lt;code&gt;num&lt;/code&gt; 就会调用时传进来的的当时值，这样在点击元素时，就能显示正确的序号。&lt;/p&gt;
&lt;h2&gt;问题#7：未能正确利用原型继承&lt;/h2&gt;
&lt;p&gt;考虑下面代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BaseObject = function(name) {
    if (typeof name !== "undefined") {
        this.name = name;
    } else {
        this.name = 'default'
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码比较简单，就是提供了一个名字，就使用它，否则返回 &lt;code&gt;default&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var firstObj = new BaseObject();
var secondObj = new BaseObject('unique');

console.log(firstObj.name);  // -&amp;gt; 'default'
console.log(secondObj.name); // -&amp;gt; 'unique'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，如果这么做呢:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete secondObj.name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会得到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(secondObj.name); // 'undefined'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当使用 &lt;code&gt;delete&lt;/code&gt; 删除该属性时，就会返回一个 &lt;code&gt;undefined&lt;/code&gt;，那么如果我们也想返回 &lt;code&gt;default&lt;/code&gt; 要怎么做呢？利用原型继承，如下所示:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BaseObject = function (name) {
    if(typeof name !== "undefined") {
        this.name = name;
    }
};

BaseObject.prototype.name = 'default';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BaseObject&lt;/code&gt; 从它的原型对象中继承了&lt;code&gt;name&lt;/code&gt; 属性，值为 &lt;code&gt;default&lt;/code&gt;。因此，如果构造函数在没有 &lt;code&gt;name&lt;/code&gt; 的情况下被调用，&lt;code&gt;name&lt;/code&gt; 将默认为 &lt;code&gt;default&lt;/code&gt;。同样，如果 &lt;code&gt;name&lt;/code&gt; 属性从&lt;code&gt;BaseObject&lt;/code&gt;的一个实例中被移除，那么会找到原型链的 &lt;code&gt;name&lt;/code&gt;，，其值仍然是&lt;code&gt;default&lt;/code&gt;。所以'&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var thirdObj = new BaseObject('unique');
console.log(thirdObj.name);  // -&amp;gt; Results in 'unique'

delete thirdObj.name;
console.log(thirdObj.name);  // -&amp;gt; Results in 'default'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;问题8：为实例方法创建错误的引用&lt;/h2&gt;
&lt;p&gt;考虑下面代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var MyObject = function() {}

MyObject.prototype.whoAmI = function() {
    console.log(this === window ? "window" : "MyObj");
};

var obj = new MyObject();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，为了操作方便，我们创建一个对&lt;code&gt;whoAmI&lt;/code&gt;方法的引用，这样通过&lt;code&gt;whoAmI()&lt;/code&gt;而不是更长的&lt;code&gt;obj.whoAmI()&lt;/code&gt;来调用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var whoAmI = obj.whoAmI;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了确保没有问题，我们把 &lt;code&gt;whoAmI&lt;/code&gt; 打印出来看一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(whoAmI);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function () {
    console.log(this === window ? "window" : "MyObj");
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok,看起来没啥问题。&lt;/p&gt;
&lt;p&gt;接着，看看当我们调用&lt;code&gt;obj.whoAmI()&lt;/code&gt; 和 &lt;code&gt;whoAmI()&lt;/code&gt; 的区别。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.whoAmI();  // Outputs "MyObj" (as expected)
whoAmI();      // Outputs "window" (uh-oh!)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;什么地方出错了？当我们进行赋值时 &lt;code&gt;var whoAmI = obj.whoAmI&lt;/code&gt;,新的变量&lt;code&gt;whoAmI&lt;/code&gt;被定义在全局命名空间。结果，&lt;code&gt;this&lt;/code&gt;的值是 &lt;code&gt;window&lt;/code&gt;，而不是 &lt;code&gt;MyObject&lt;/code&gt; 的 &lt;code&gt;obj&lt;/code&gt; 实例!&lt;/p&gt;
&lt;p&gt;因此，如果我们真的需要为一个对象的现有方法创建一个引用，我们需要确保在该对象的名字空间内进行，以保留 &lt;code&gt;this&lt;/code&gt;值。一种方法是这样做:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var MyObject = function() {}

MyObject.prototype.whoAmI = function() {
    console.log(this === window ? "window" : "MyObj");
};

var obj = new MyObject();
obj.w = obj.whoAmI;   // Still in the obj namespace

obj.whoAmI();  // Outputs "MyObj" (as expected)
obj.w();       // Outputs "MyObj" (as expected)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;问题9：为 &lt;code&gt;setTimeout&lt;/code&gt; 或 &lt;code&gt;setInterval&lt;/code&gt; 提供一个字符串作为第一个参数&lt;/h2&gt;
&lt;p&gt;首先，需要知道的是为 &lt;code&gt;setTimeout&lt;/code&gt; 或 &lt;code&gt;setInterval&lt;/code&gt; 提供一个字符串作为第一个参数，这本身并不是一个错误。它是完全合法的JavaScript代码。这里的问题更多的是性能和效率的问题。很少有人解释的是，如果你把字符串作为&lt;code&gt;setTimeout&lt;/code&gt;或&lt;code&gt;setInterval&lt;/code&gt;的第一个参数，它将被传递给函数构造器，被转换成一个新函数。这个过程可能很慢，效率也很低，而且很少有必要。&lt;/p&gt;
&lt;p&gt;将一个字符串作为这些方法的第一个参数的替代方法是传入一个函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setInterval("logTime()", 1000);
setTimeout("logMessage('" + msgValue + "')", 1000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更好的选择是传入一个函数作为初始参数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setInterval(logTime, 1000); 

setTimeout(function() {      
    logMessage(msgValue);     
}, 1000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;问题10：未使用 "严格模式"&lt;/h2&gt;
&lt;p&gt;"严格模式"（即在JavaScript源文件的开头包括 &lt;code&gt;"use strict"&lt;/code&gt;；）是一种自愿在运行时对JavaScript代码执行更严格的解析和错误处理的方式，同时也使它更安全。&lt;/p&gt;
&lt;p&gt;但是，不使用严格模式本身并不是一个 "错误"，但它的使用越来越受到鼓励，不使用也越来越被认为是不好的形式。&lt;/p&gt;
&lt;p&gt;以下是严格模式的一些主要好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使得调试更容易&lt;/strong&gt;。原本会被忽略或无感知的代码错误，现在会产生错误或抛出异常，提醒我们更快地发现代码库中的JavaScript问题，并引导更快地找到其来源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;防止意外的全局变量&lt;/strong&gt;。在没有严格模式的情况下，给一个未声明的变量赋值会自动创建一个具有该名称的全局变量。这是最常见的JavaScript错误之一。在严格模式下，试图这样做会产生一个错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;消除this 强迫性&lt;/strong&gt;。在没有严格模式的情况下，对 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt;  的 &lt;code&gt;this&lt;/code&gt; 值的引用会自动被强制到全局。在严格模式下，引用&lt;code&gt;null&lt;/code&gt;或&lt;code&gt;undefined&lt;/code&gt;的&lt;code&gt;this&lt;/code&gt;值会产生错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不允许重复的属性名或参数值&lt;/strong&gt;。严格模式在检测到一个对象中的重复命名的属性（例如，&lt;code&gt;var object = {foo: "bar", foo: "baz"};&lt;/code&gt;）或一个函数的重复命名的参数（例如，&lt;code&gt;function foo(val1, val2, val1){}&lt;/code&gt;）时抛出一个错误，从而捕捉到你的代码中几乎肯定是一个错误，否则你可能会浪费很多时间去追踪。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使得&lt;code&gt;eval()&lt;/code&gt;更加安全。&lt;code&gt;eval()&lt;/code&gt;在严格模式和非严格模式下的行为方式有一些不同。最重要的是，在严格模式下，在&lt;code&gt;eval()&lt;/code&gt;语句中声明的变量和函数不会在包含的范围内创建。(在非严格模式下，它们是在包含域中创建的，这也可能是JavaScript问题的一个常见来源)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在无效使用&lt;code&gt;delete的&lt;/code&gt;情况下抛出错误。&lt;code&gt;delete&lt;/code&gt; 操作符（用于从对象中删除属性）不能用于对象的非可配置属性。当试图删除一个不可配置的属性时，非严格的代码将无声地失败，而严格模式在这种情况下将抛出一个错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来源：https://www.toptal.com/javascript/10-most-common-javascript-mistakes?utm_campaign=Weekly%20Vue%20News&amp;amp;utm_medium=email&amp;amp;utm_source=Revue%20newsletter&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Thu, 03 Nov 2022 17:02:18 GMT</pubDate></item><item><title>什么是好的错误消息?</title><link>https://juejin.cn/post/7161591964389867528</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;错误信息是我们在线日常生活的一部分。每次服务器故障或没有网络，或忘记在表格中添加一些信息，我们就会收到错误信息。&lt;strong&gt;"出错了"&lt;/strong&gt; 是常见的做尘。但是什么出错了？发生了什么？而且，最重要的是，我要怎么做才能修复它？&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdba31373edd421db5cb7f52ac9e1c5c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那怎样写才是一个好的提示呢？&lt;/p&gt;
&lt;p&gt;在介绍好的提示之前，我们先来看一下什么是不好的错误提示。&lt;/p&gt;
&lt;h2&gt;不好的错误提示&lt;/h2&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3a1a7ed1a9b4d3f9009cda52241e7f1~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h4&gt;Inappropriate tone&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;不恰当的语气&lt;/strong&gt;： 想象一下，一个医生在做一个手术，然后突然说 "哎呀! 出了点问题......" ，当风险很大的时候，任何人都最不愿意听到这句话。所以这时候不是安可爱的时候。我们需要向用户表明，我们知道这是严重的，我们明白这对他们很重要。&lt;/p&gt;
&lt;h4&gt;Technical jargon&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;专业术语&lt;/strong&gt;： 程序员喜欢把一些专业术语用在错误提示里面。例如：你不能获取我的数据？我的凭证被拒绝了？ 这些专业术语对用户来说并不重要，他们只想知道什么地方出了问题，如何解决。&lt;/p&gt;
&lt;p&gt;####　Passing the blame:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;甩锅&lt;/strong&gt;：比如「无法连接到三方服务」。尽量把重点放在问题上，而不是导致问题的行动上。&lt;/p&gt;
&lt;h4&gt;Generic for no reason&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;太官方的说辞&lt;/strong&gt;：比如「稍后尝试」。知道原因而不告诉用户，是不好的。&lt;/p&gt;
&lt;h4&gt;好的错误提示&lt;/h4&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b1908792ae84f848938d6036285ac9e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h4&gt;Say what happened and why:&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;说明出错的原因&lt;/strong&gt;：让用户清楚的知道发生错误的原因，可以通过视觉和文字的结合来完成。解释用户为什么会出现这个错误。即使是技术原因，也要说明是我们的原因，而不是用户操作错误。比如：「由于技术上的原因，暂时无法连接到你的账户」。&lt;/p&gt;
&lt;h4&gt;Provide reassurance&lt;/h4&gt;
&lt;p&gt;提供保证：比如「你的修改已被保存到草稿」。&lt;/p&gt;
&lt;h4&gt;Be empathetic&lt;/h4&gt;
&lt;p&gt;有同情心：比如用「请」。&lt;/p&gt;
&lt;h4&gt;Help them fix it&lt;/h4&gt;
&lt;p&gt;帮助他们解决：比如「了解如何解决这个问题」，并附加一篇知识库文章和链接。&lt;/p&gt;
&lt;h4&gt;Always give a way out&lt;/h4&gt;
&lt;p&gt;总是给一条出路：比如「如果依旧能解决，请联系客服」。&lt;/p&gt;
&lt;p&gt;来源：https://wix-ux.com/when-life-gives-you-lemons-write-better-error-messages-46c5223e1a2f&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Wed, 02 Nov 2022 17:15:15 GMT</pubDate></item><item><title>我用这9个小技巧封装Vue组件，老大夸我’封得好‘</title><link>https://juejin.cn/post/7158969880362876964</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;组件是前端框架的基本构建块。把它们设计得更好会使我们的应用程序更容易改变和理解。在这节课中，分享一下在过去几年中工作中学到的 9 个技巧。&lt;/p&gt;
&lt;h2&gt;1. 你可能不需要创建一个组件&lt;/h2&gt;
&lt;p&gt;在创建一个组件之前，看看它是为了可重用性和为某些UI添加一个状态，还是仅仅为了组织和划分代码。&lt;/p&gt;
&lt;p&gt;如果是后者，那么你就不需要创建它，因为它只会增加更多不必要的工作，比如传递&lt;code&gt;props&lt;/code&gt;和发射事件。&lt;/p&gt;
&lt;p&gt;不仅如此，它还要求我们跳转到该文件以查看它所包含的内容，而不是直接在父组件中看到它，这就干净多了。&lt;/p&gt;
&lt;h2&gt;2. 使用插槽而不是 prop 来显示内容&lt;/h2&gt;
&lt;p&gt;假设有一个可重复使用的按钮组件，它通过&lt;code&gt;props&lt;/code&gt;获取文本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;BaseButton label="Delete Item"/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想在其中显示一个图标，必须添加更多的道具，如&lt;code&gt;&amp;lt;BaseButton label="Delete Item" icon="delete" /&amp;gt;&lt;/code&gt;并更新组件以显示该图标。&lt;/p&gt;
&lt;p&gt;但有了插槽，我们就可以在每次使用该组件时，以想要的方式显示标签：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;BaseButton&amp;gt;
  Delete Item &amp;lt;Icon name="delete" /&amp;gt;
&amp;lt;/BaseButton&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者你只需要把某个单词加粗。对于插槽，可以直接在文本中使用&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;标记，而不是在组件中解析它。&lt;/p&gt;
&lt;h2&gt;3. 将该组件与触发它的因素分组&lt;/h2&gt;
&lt;p&gt;有时有两个独立的组件在某种情况下一起使用。最好把它们放在一个新的组件中，这样重复使用和移动它们更容易。&lt;/p&gt;
&lt;p&gt;一个常见的例子是 &lt;code&gt;Modal&lt;/code&gt; 组件。我们通常在点击一个特定的按钮时显示&lt;code&gt;Modal&lt;/code&gt;。与其在每次我们想重用它（或把它移到其他地方）时添加&lt;code&gt;showModal&lt;/code&gt;状态和导入modal与它的按钮，不如有一个单一的组件来显示按钮，当用户点击时，它显示相关的modal。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- CreateItemButton.vue --&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;Modal v-if="showModal" @close="showModal = false" /&amp;gt;
  &amp;lt;BaseButton @click="showModal = true"&amp;gt;
    Create Item
  &amp;lt;/BaseButton&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
const showModal = false
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;4. 使用 teleport，从任何地方显示固定位置的元素&lt;/h2&gt;
&lt;p&gt;继续前面的例子，如果我们想正确地显示 modal ，我们需要确保模态使用正确的&lt;code&gt;z-index&lt;/code&gt;，并且它在HTML代码中显示在正确的位置，所以它总是显示在页面上所有东西的上面。&lt;/p&gt;
&lt;p&gt;我们可以通过直接将 modal 显示为&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;元素的一个子元素来轻松地避免这个问题，无论我们在组件结构中使用它。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://vuejs.org/guide/built-ins/teleport.html"&gt;Teleport组件&lt;/a&gt;使我们能够做到这一点。&lt;/p&gt;
&lt;p&gt;我们所要做的就是用 &lt;code&gt;&amp;lt;Teleport to="body"&amp;gt;&lt;/code&gt; 来包装 modal 组件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- BaseModal.vue --&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;Teleport to="body"&amp;gt;
    &amp;lt;div class="modal"&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/Teleport&amp;gt;
&amp;lt;/template&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个组件是Vue 3内置组件的一部分。如果你使用的是Vue 2，请查看&lt;a href="https://github.com/LinusBorg/portal-vue"&gt;PortalVue&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;5. 在一个对象中分组相关的 props&lt;/h2&gt;
&lt;p&gt;组件的 prop 列表是组件界面的一个主要部分。接口越清晰，就越容易使用和推理。&lt;/p&gt;
&lt;p&gt;改进 &lt;code&gt;prop&lt;/code&gt; 列表的一个方法是将相关的属性分组在一起。以这个组件为例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;PostCard
  :title="post.title"
  :date="post.date"
  :layout="currentLayout"
  :image="post.imageUrl"
  &amp;lt;!-- more props --&amp;gt;
/&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要花几秒钟时间来了解这里有哪些 &lt;code&gt;props&lt;/code&gt; 与帖子(post )相关。但我们可以像这样把与帖子相关的 &lt;code&gt;props&lt;/code&gt; 分组，使之更加清晰。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;PostCard :post="post" :layout="currentLayout" /&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以现在我们很快就知道，&lt;code&gt;layout&lt;/code&gt; 不是 &lt;code&gt;post&lt;/code&gt; 数据的一部分。&lt;/p&gt;
&lt;p&gt;不仅如此，我们还通过这种方法使更新 &lt;code&gt;props&lt;/code&gt; 变得更加容易。例如，&lt;code&gt;添加或删除与帖子相关的props&lt;/code&gt; ，不需要我们更新组件的 &lt;code&gt;props&lt;/code&gt;  列表。&lt;/p&gt;
&lt;h2&gt;6. 赋予每个循环item,赋予自己的状态&lt;/h2&gt;
&lt;p&gt;创建一个新的组件的一个很好的理由是给一块用户界面提供它自己的状态。我们需要这样做的一个常见的地方是在&lt;code&gt;v-for&lt;/code&gt;循环中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div v-for="(item, index) in items" :key="item.id"&amp;gt;
      &amp;lt;input type="checkbox" v-model="checkedItems[index]"&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script setup&amp;gt;
const checkedItems = ref(items.map(item =&amp;gt; item.checked))
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了跟踪检查过的 &lt;code&gt;items&lt;/code&gt;，我们不得不创建一个数组，并用 &lt;code&gt;items&lt;/code&gt; 的初始值来填充它。但是这段代码还不够强大。为了让它变得更好，我们必须让 &lt;code&gt;items&lt;/code&gt;  通过它们的&lt;code&gt;id&lt;/code&gt;而不是&lt;code&gt;index &lt;/code&gt;来访问，因为 &lt;code&gt;index&lt;/code&gt; 是不可靠的，可以改变。例如，如果你添加一个支持通过拖放来重新排列items  的功能呢？&lt;/p&gt;
&lt;p&gt;为了简化这段代码，我们可以引入一个新的组件，为每个 &lt;code&gt;item&lt;/code&gt; 保存一个状态。像这样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;Item v-for="item in items" :key="item.id" :item="item" /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Item&lt;/code&gt; 组件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;input type="checkbox" v-model="checked"&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
const props = defineProps({ item: Object })
const checked = ref(props.item.checked)
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法的另一个好处是，我们把所有 item 的相关数据、计算属性和方法都加在一个地方，便于理解和改变。&lt;/p&gt;
&lt;h2&gt;7. 尽可能地将加载数据移至其用户界面附近&lt;/h2&gt;
&lt;p&gt;无论你是用GraphQL还是其他API加载，最好把代码放在尽可能接近使用它的用户界面的地方。这有两个原因:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;移动带有数据的UI组件变得更加容易。只需移动该组件，而无需寻找其依赖关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当所有的碎片被放在一个地方时，总是更容易理解代码--可以看到用户界面和它的数据来自哪里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有时，有多个组件使用同一个获取的数据。在这种情况下，可以将获取的代码上移一级。因此，会有一个父组件，在那里获取数据，还有一个子组件，然后把数据传递给它。&lt;/p&gt;
&lt;p&gt;但一定要确保它是一个单一的层次。如果不是，那就寻找一种方法来改进你的组件设计和它们之间的关系。&lt;/p&gt;
&lt;h2&gt;8. 纯粹的UI组件不应访问应用程序的状态&lt;/h2&gt;
&lt;p&gt;有两种类型的前端组件：纯UI组件和特定应用组件。&lt;/p&gt;
&lt;p&gt;纯粹的UI组件是像按钮、输入框等。它们不应该知道关于应用程序的任何事情。它们的工作仅仅是为了显示UI--它们通过 props 获取数据。&lt;/p&gt;
&lt;p&gt;特定于应用程序的组件是知道应用程序状态的组件，无论是本地状态还是全局状态(通过状态管理库，如Pinia)。&lt;/p&gt;
&lt;p&gt;分离这些组件使得在应用程序的其他地方，甚至在其他应用程序中重用UI组件更加容易。&lt;/p&gt;
&lt;p&gt;如果你正在构建自己的UI组件，这个技巧也适用。如果你使用的是外部库，如 &lt;code&gt;Vuetify&lt;/code&gt; 或Quasar，那么你就不必担心这个问题--这些组件在设计时就考虑到了这一点。&lt;/p&gt;
&lt;h2&gt;9. 不要在组件中指定 width 或 margin&lt;/h2&gt;
&lt;p&gt;当创建一个组件时，你应该把它看作是一块UI，可以像其他本地元素一样使用。&lt;/p&gt;
&lt;p&gt;让用户指定组件周围的空间是实现这一目标的好方法。&lt;/p&gt;
&lt;p&gt;假设你的组件在其根元素上有一个顶部边距，而用户想把它显示在某个元素下面，但没有顶部边距。要做到这一点，用户必须设置一个与组件的&lt;code&gt;margin&lt;/code&gt;相同的负&lt;code&gt;margin&lt;/code&gt;，比如&lt;code&gt;margin-top: -50px；&lt;/code&gt;更不用说在某些情况下，用户必须与选择器的特异性相匹配（或者可能使用&lt;code&gt;!important&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;而宽度也是如此。如果用户想让该组件具有响应性，他们必须覆盖其宽度和最大宽度。&lt;/p&gt;
&lt;p&gt;因此，通过不在组件内部设置宽度和边距，总是给用户这种控制是有意义的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来源：https://tahazsh.com/blog/vue-component-design-tips/&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Wed, 26 Oct 2022 15:43:21 GMT</pubDate></item><item><title>为什么JSON.parse会损坏大数字，如何解决这个问题？</title><link>https://juejin.cn/post/7158616152271388708</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从10多年前JSON在线编辑器的早期开始，用户经常反映编辑器有时会破坏他们JSON文档中的大数字的问题。直到现在，我们也没能解决这个问题。在这篇文章中，我们深入解释了这个问题，并展示如何在JSON Editor Online中解决这个问题。&lt;/p&gt;
&lt;h2&gt;大数字的问题&lt;/h2&gt;
&lt;p&gt;大多数 Web 应用程序处理来自服务器的数据。这些数据以纯文本的JSON文档形式被接收，并被解析成一个JavaScript对象或数组，这样我们就可以读取属性并做一些事情。通常情况下，数据的解析是使用&lt;code&gt;JSON.parse&lt;/code&gt;函数进行的，该函数内置于JavaScript中，非常快速和方便。&lt;/p&gt;
&lt;p&gt;JSON数据格式极其简单，而且它是JavaScript的一个子集。所以它与JavaScript完全可以互换。你可以将一个JSON文档粘贴到一个JavaScript文件中，这就是有效的JavaScript。&lt;/p&gt;
&lt;p&gt;在JavaScript中使用&lt;code&gt;JSON&lt;/code&gt;应该不会出现任何问题，但有一种棘手的情况可能会破坏数据:&lt;strong&gt;大数字&lt;/strong&gt;。这是一个有效的JSON字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{"count": 9123372036854000123}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们将其解析为JavaScript并读取 &lt;code&gt;"count" &lt;/code&gt;键时，我们会得到:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;9123372036854000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析后的数值被破坏了：最后三位数字被重置为零。这是否是一个问题，取决于这些最后的数字是否确实有意义，但一般来说，知道这种情况可能会发生，可能会给你一种不舒服的感觉。&lt;/p&gt;
&lt;h2&gt;为什么大数字会被JSON.parse破坏？&lt;/h2&gt;
&lt;p&gt;像 &lt;code&gt;9123372036854000123&lt;/code&gt; 这样的长数字既是有效的 JSON 也是有效的 JavaScript。当JavaScript 将数值解析为数字时，事情就出错了。最初，JavaScript 只有一种数字类型。&lt;code&gt;Number&lt;/code&gt;。这是一个&lt;strong&gt;64&lt;/strong&gt;位的浮点值，类似于C++、Java或C#中的Double值。这种浮点值可以存储大约&lt;strong&gt;16&lt;/strong&gt;位数字。因此，它不能完全代表像&lt;code&gt;9123372036854000123&lt;/code&gt;这样的数字，它有&lt;strong&gt;19&lt;/strong&gt;位数字。在这种情况下，最后三位数字会丢失，破坏了该值。&lt;/p&gt;
&lt;p&gt;在用浮点数存储分数时也会发生同样的情况：当你在 JavaScript 中计算 &lt;code&gt;1/3&lt;/code&gt;时，结果是:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0.3333333333333333
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在现实中，该值应该有无限的小数，但 JavaScript 的数字在大约 &lt;strong&gt;16位&lt;/strong&gt; 之后就停止了。&lt;/p&gt;
&lt;p&gt;那么，JSON文档中像&lt;code&gt;9123372036854000123&lt;/code&gt;这样的大数字是怎么来的呢？嗯，其他语言如Java或C#确实有其他数字数据类型，如&lt;strong&gt;Long&lt;/strong&gt;。&lt;strong&gt;Long&lt;/strong&gt;是一个&lt;code&gt;64&lt;/code&gt;位的值，可以容纳最多20位的整数。它能容纳更多数字的原因是，它不需要像浮点值那样存储指数值。因此，在像Java这样的语言中，你可以有一个&lt;strong&gt;Long&lt;/strong&gt;值，它不能在JavaScript的Number类型中正确表示，或者在其他语言中的Double类型中正确表示。&lt;/p&gt;
&lt;p&gt;JavaScript 的 &lt;strong&gt;Number&lt;/strong&gt;（或者更好：任何浮点数值）还有一些限制：数值可以溢出或下溢。例如，&lt;code&gt;1e+500&lt;/code&gt;会变成&lt;code&gt;Infinity&lt;/code&gt;，而&lt;code&gt;1e-500&lt;/code&gt;会变成&lt;code&gt;0&lt;/code&gt;。不过，这些限制在实际应用程序中很少成为问题。&lt;/p&gt;
&lt;h2&gt;如何防止数字被 JSON.parse 破坏？&lt;/h2&gt;
&lt;p&gt;多年来，这个用 JavaScript 解析大数字的问题一直是&lt;code&gt;https://jsoneditoronline.org/&lt;/code&gt; 的用户反复要求的。像大多数基于网络的JSON编辑器一样，它也使用了本地的JSON.parse函数和常规的JavaScript数字，所以它受到了上述的限制。&lt;/p&gt;
&lt;p&gt;第一个想法可能是：等等，但是 &lt;code&gt;JSON.parse&lt;/code&gt; 有一个可选的&lt;code&gt;reviver&lt;/code&gt;参数，允许你用不同的方式来解析内容。但问题是，首先文本被解析成一个数字，接下来，它被传递给&lt;code&gt;reviver&lt;/code&gt;。所以到那时，已经太晚了，值已经被破坏了。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，根本不能使用内置的&lt;code&gt;JSON.parse&lt;/code&gt;，必须使用一个不同的JSON解析器。对此有各种优秀的解决方案：&lt;a href="https://github.com/josdejong/lossless-json"&gt;lossless-json&lt;/a&gt;、&lt;a href="https://github.com/sidorares/json-bigint"&gt;json-bigint&lt;/a&gt;、js-jon-bigint或&lt;a href="https://github.com/epoberezkin/json-source-map"&gt;json-source-map&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这些库中的大多数都采取了务实的方法，将长数字直接解析为JavaScript相对较新的&lt;strong&gt;BigInt&lt;/strong&gt;数据类型。&lt;code&gt;lossless-json&lt;/code&gt;库是专门为JSON Editor Online开发的。它采取了比JSON BigInt解决方案更加灵活和强大的方法。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;strong&gt;lossless-json&lt;/strong&gt; 将数字解析成一个轻量级的&lt;code&gt;LosslessNumber&lt;/code&gt;类，该类将数字值作为一个字符串持有。这保留了任何数值，甚至还保留了格式化，比如数值&lt;code&gt;4.0&lt;/code&gt;中的尾部零。当对其进行操作时，&lt;code&gt;LosslessNumber&lt;/code&gt;将被转换为&lt;code&gt;Number&lt;/code&gt;或&lt;code&gt;BigInt&lt;/code&gt;，或者在不安全时抛出一个错误。&lt;/p&gt;
&lt;p&gt;该库允许你传递你自己的数字解析器，所以你可以应用你自己的策略来处理数字值。也许你想把长的数字值转换成&lt;strong&gt;BigInt&lt;/strong&gt;，或者把数值传给某个&lt;code&gt;BigNumber&lt;/code&gt;库。你可以选择是否要在数字信息丢失时抛出一个异常，或者默默地忽略某些类别的信息丢失。&lt;/p&gt;
&lt;p&gt;因此，比较本地&lt;code&gt;JSON.parse&lt;/code&gt;函数和&lt;code&gt;lossless-json&lt;/code&gt;，会得到以下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { parse, stringify } from 'lossless-json'
const text = '{"decimal":2.370,"long":9123372036854000123,"big":2.3e+500}'
// JSON.parse will lose some digits and a whole number:
console.log(JSON.stringify(JSON.parse(text)))
// '{"decimal":2.37,"long":9123372036854000000,"big":null}'
// WHOOPS!!!
// LosslessJSON.parse will preserve all numbers and even the formatting:
console.log(stringify(parse(text)))
// '{"decimal":2.370,"long":9123372036854000123,"big":2.3e+500}'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;使用LosslessJSON解析器是否能解决所有问题？&lt;/h2&gt;
&lt;p&gt;答案是并不能。这取决于你在解析数据后想做什么，但通常情况下，你想用它做一些事情。在屏幕上显示数据，验证它，比较它，排序它，等等。例如，在JSON Editor Online中，你可以编辑数值，转换文档（查询、过滤、排序等），比较两个文档，或者根据JSON模式验证一个文档。一旦你引入&lt;strong&gt;BigInt&lt;/strong&gt;值或&lt;strong&gt;LosslessNumbers&lt;/strong&gt;，你想执行的所有操作都需要支持这些类型的值。&lt;/p&gt;
&lt;p&gt;拥有 &lt;strong&gt;BigInt&lt;/strong&gt; 值或 &lt;strong&gt;LosslessNumbers&lt;/strong&gt; 的数据很可能给不了解这些数据类型的第三方库带来问题。例如，JSON Editor Online支持将你的JSON数据导出到CSV，并使用优秀的&lt;a href="https://github.com/zemirco/json2csv"&gt;json2csv&lt;/a&gt;库来实现。&lt;/p&gt;
&lt;p&gt;这个库不知道&lt;code&gt;BigInt&lt;/code&gt;或&lt;code&gt;LosslessNumber&lt;/code&gt;类型，不会正确串联这些数据类型。为了使其正常工作，包含&lt;code&gt;LosslessNumbers&lt;/code&gt;或&lt;code&gt;BigInt&lt;/code&gt;值的JSON数据必须首先被转换为该库所能理解的数据。&lt;/p&gt;
&lt;p&gt;即使没有第三方库的参与，与&lt;strong&gt;BigInt&lt;/strong&gt;值一起工作也会导致棘手的问题。当对大整数和普通数字的混合操作时，JavaScript可以默默地将一种数字类型强制转化为另一种，这可能会导致错误。下面的代码例子显示了这是如何出错的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const a = 91111111111111e3 // a regular number
const b = 91111111111111000n // a bigint
console.log(a == b) // returns false (should be true)
console.log(a &amp;gt; b) // returns true (should be false)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，你看到两个常数&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;持有相同的数字值。但是一个是数字，另一个是&lt;strong&gt;BigInt&lt;/strong&gt;，用这些东西和普通的操作符（如&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;）一起使用会导致错误的结果。&lt;/p&gt;
&lt;p&gt;结论：要让大数字在一个应用程序中工作，可能需要大量的努力。因此，最好的办法是尽量避免在一开始就处理这些问题。&lt;/p&gt;
&lt;p&gt;如果你真的要处理大数值，你必须使用一个替代的JSON分析器，如&lt;code&gt;lossless-json&lt;/code&gt;。为了防止陷入与拥有&lt;code&gt;BigInt&lt;/code&gt;或&lt;code&gt;LosslessNumber&lt;/code&gt;数据类型有关的难以调试的问题，使用TypeScript明确定义你的数据模型是很有帮助的。这样，你就可以事先知道哪些地方需要能够处理这些特殊的数据类型，你就可以采取行动，而不是让你的应用程序默默地失败。&lt;/p&gt;
&lt;h2&gt;在线JSON编辑器现在可以安全地处理大数字了&lt;/h2&gt;
&lt;p&gt;从今天起，&lt;a href="https://jsoneditoronline.org/"&gt;JSON Editor Online已&lt;/a&gt;经完全支持大数字，所以你不必再担心损坏的数值。它已经集成了&lt;code&gt;lossless-json&lt;/code&gt;库，并确保编辑器的所有功能都能处理大数字：从格式化、排序和查询到导出到CSV。作为一个副作用，它现在甚至保持了数字的格式化，而且由于新的&lt;code&gt;LosslessJSON&lt;/code&gt;解析器，现在可以检测到重复的键。&lt;/p&gt;
&lt;p&gt;试一试：https://jsoneditoronline.org/#left=json.%7B%20%22using%22:%20%22Lossless%20JSON%20Parser%22,%20%22formatted%20number%22:%204.0,%20%22long%22:%209123372036854000123,%20%22large%22:%201e500,%20%22small%22:1e-500%20%7D&lt;/p&gt;
&lt;p&gt;现在，使用&lt;code&gt;lossless-json&lt;/code&gt;有一个缺点：它比原生内置的&lt;code&gt;JSON.parse&lt;/code&gt;慢得多。这只是大的JSON对象或数组的问题，对于大于10MB的文件，它可能会很明显。为了仍能顺利地处理大文件，JSON Editor Online允许你选择你想使用的解析器，默认情况下，它会自动为你选择最合适的解析器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来源：https://jsoneditoronline.org/indepth/parse/why-does-json-parse-corrupt-large-numbers/&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Tue, 25 Oct 2022 16:47:54 GMT</pubDate></item><item><title>创建现代npm包的最佳实践</title><link>https://juejin.cn/post/7152302632143421470</link><description>&lt;blockquote&gt;
&lt;p&gt;本文首发于微信公众号：大迁世界, 我的微信：qq449245884，我会第一时间和你分享前端行业趋势，学习途径等等。
更多开源作品请看 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; ，包含一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;技术一直在变化，我们的流程和做法也需要跟上这些变化。因此，虽然npm已经有12年的历史了，但围绕 npm 包创建的做法应该更现代。&lt;/p&gt;
&lt;p&gt;在这节课中，我们使用现代最佳实践（截至2022年）一步一步地创建一个npm包。首先学习如何创建一个npm包，这样你就可以熟悉构建和发布一个包到 npm 注册表。&lt;/p&gt;
&lt;p&gt;然后，再学习如何通过建立测试框架、持续集成和部署管道、安全检查以及发布的自动语义版本管理，来制作一个更健壮、可用于生产的npm包。&lt;/p&gt;
&lt;h2&gt;简单的npm包示例&lt;/h2&gt;
&lt;p&gt;我们先通过一个简单的例子来熟悉创建和发布npm包的过程。&lt;/p&gt;
&lt;h4&gt;创建项目&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建一个 GitHub 仓库: https://github.com/new&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;克隆本地的 repo。
例如：git clone https://github.com/snyk-labs/simple-npm-package.git&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开你的终端,进入到克隆的项目文件夹。
例如：cd simple-npm-package&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;npm init -y&lt;/code&gt; 来创建 &lt;code&gt;package.json&lt;/code&gt; 文件。注意：如果克隆了示例仓库，就不需要做这一步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在package.json 取一个名称，对应 name 字段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为该包编写你的代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;创建 npm 账户&lt;/h4&gt;
&lt;p&gt;为了能够让我们的 npm 包供他人使用，需要一个npm账户。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 https://www.npmjs.com/signup 注册&lt;/li&gt;
&lt;li&gt;为了提高安全性，请在您的npm账户上启用2FA：https://docs.npmjs.com/configuring-two-factor-authentication&lt;/li&gt;
&lt;li&gt;使用 npm login 命令在终端中用你的 npm账户登录，并按照屏幕上的指示操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; npm login
npm notice Log in on https://registry.npmjs.org/
Username: clarkio
Password:
Email: (this IS public) &amp;lt;email address&amp;gt;
npm notice Please use the one-time password (OTP) from your authenticator application
Enter one-time password from our authenticator app: &amp;lt;OTP&amp;gt;
Logged in as clarkio on https://registry.npmjs.org/.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;如何发布 npm 包&lt;/h2&gt;
&lt;p&gt;一旦你有了一个npm项目和一个npm账户，你就可以把你的npm包发布到公开的官方&lt;code&gt;npmjs&lt;/code&gt;注册表上，让其他人可以使用。以下是你要遵循的步骤，在执行之前检查将发布的内容，然后运行实际的发布过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在终端，运行 &lt;code&gt;npx npm-packlist&lt;/code&gt; 来查看将被包含在发布版本的软件包中的内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这可以确保我们没有遗漏任何源代码文件，这些文件是软件包正常运行所需要的。这也是一个好的做法，以确保我们不会意外地将敏感信息泄露给公众，如带有数据库凭证或API密钥的本地配置文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; npx npm-packlist
LICENSE
index.js
package.json
README.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在终端，运行&lt;code&gt;npm publish --dry-run&lt;/code&gt;，看看实际运行命令时将会做什么。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; npm publish --dry-run
npm notice
npm notice 📦@clarkio/simple-npm-package@0.0.1
npm notice === Tarball Contents ===
npm notice 1.1kB LICENSE
npm notice 1.2kB README.md
npm notice 95B index.js
npm notice 690B package.json
npm notice === Tarball Details===
npm notice name: @clarkio/simple-npm-package
npm notice version: 0.0.1
npm notice filename:@clarkio/simple-npm-package-0.0.1.tgz
npm notice package size:1.7 kB
npm notice unpacked size: 3.1 kB
npm notice shasum:40ede3ed630fa8857c0c9b8d4c81664374aa811c
npm notice integrity:sha512-QZCyWZTspkcUXL... ]L60ZKBOOBRLTg==
npm notice total files:4
npm notice
+ @clarkio/simple-npm-package@0.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="3"&gt;
&lt;li&gt;在终端，运行 &lt;code&gt;npm publish --access=public&lt;/code&gt; 来发布软件包到npm。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：&lt;strong&gt;--access=public&lt;/strong&gt;对于作用哉内的包（&lt;code&gt;@clarkio/modern-npm-package&lt;/code&gt;）是需要的，因为它们默认是私有的。如果它不是作用哉内的，并且在你的 &lt;code&gt;package.json&lt;/code&gt; 中没有将&lt;code&gt;private&lt;/code&gt; 字段设置为 &lt;code&gt;true&lt;/code&gt;，它也将是公开的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; npm publish --access=public
npm notice
npm notice 📦@clarkio/simple-npm-package@0.0.1
npm notice === Tarball Contents ===
npm notice 1.1kB LICENSE
npm notice 1.2kB README.md
npm notice 95B index.js
npm notice 690B package.json
npm notice === Tarball Details===
npm notice name: @clarkio/simple-npm-package
npm notice version: 0.0.1
npm notice filename:@clarkio/simple-npm-package-0.0.1.tgz
npm notice package size:2.1 kB
npm notice unpacked size: 4.1 kB
npm notice shasum:6f335d6254ebb77a5a24ee729650052a69994594
npm notice integrity:sha512-VZ1K1eMFOKeJW[...]7ZjKFVAxLcpdQ==
npm notice total files:4
npm notice
This operation requires a one-time password.
Enter OTP: &amp;lt;OTP&amp;gt;
+ @clarkio/simple-npm-package@0.0.1

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们已经完成了构建和部署自己的npm包。接下来，我们来看一下如何制作一个更强大的包，为生产环境做好准备，并得到更广泛的使用。&lt;/p&gt;
&lt;h2&gt;生产就绪的npm包&lt;/h2&gt;
&lt;p&gt;虽然前面的例子的包可以在生产中使用，但它涉及到人工成本来保持其长期的维护。使用工具和自动化以及适当的测试和安全检查将有助于最大限度地减少保持软件包顺利运行的总工作量。让我们深入了解一下这其中的内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建CommonJS（CJS）和ECMAScript（ESM）模块&lt;/li&gt;
&lt;li&gt;设置和编写单元测试&lt;/li&gt;
&lt;li&gt;实施安全检查&lt;/li&gt;
&lt;li&gt;实现版本管理和发布的自动化&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;构建 CommonJS（CJS）和ECMAScript（ESM）模块&lt;/h4&gt;
&lt;p&gt;虽然ECMAScript模块格式现在在Node.js的12+版本中被原生支持，但它还没有被社区广泛采用。为了面向未来并支持这两种格式，我们来看下使用 TypeScript怎么来配置。&lt;/p&gt;
&lt;p&gt;首先，创建一个基本的 TypeScript 配置文件 &lt;code&gt;tsconfig.base.json&lt;/code&gt;。这是通用的编译设置，无论你的目标是哪种模块格式，都可以使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "checkJs": true,
    "allowJs": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true
  },
  "files": ["../src/index.ts"]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后为 CommonJS 格式创建一个TypeScript配置文件，命名为&lt;code&gt;tsconfig.cjs.json&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;lib&lt;/code&gt; 属性向TypeScript指出它应该参考哪些类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;target&lt;/code&gt; 属性向TypeScript指出要编译的项目代码的JavaScript版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;module&lt;/code&gt; 属性向 TypeScript 指出在编译的项目代码时应该使用哪种JavaScript模块格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;moduleResolution&lt;/code&gt; 属性帮助 TypeScript 弄清 "import"语句应该如何被提及。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;outDir&lt;/code&gt; 和 &lt;code&gt;declarationDir&lt;/code&gt; 属性向TypeScript指出了将编译的代码和定义其中使用的类型的结果放在哪里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "lib": ["ES6", "DOM"],
    "target": "ES6",
    "module": "CommonJS",
    "moduleResolution": "Node",
    "outDir": "../lib/cjs",
    "declarationDir": "../lib/cjs/types"
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后，为 ECMAScript 格式创建一个TypeScript配置文件，命名为&lt;code&gt;tsconfig.esm.json&lt;/code&gt;。这里的属性与你在 CommonJS 配置中看到的相同，但现在针对现代ECMAScript模块格式作为其输出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "lib": ["ES2022", "DOM"],
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "NodeNext",
    "outDir": "../lib/esm",
    "declarationDir": "../lib/esm/types"
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新 &lt;code&gt;package.json&lt;/code&gt; 文件，增加一个 &lt;code&gt;files&lt;/code&gt; 字段，指向&lt;code&gt;lib&lt;/code&gt;文件夹，里面有 TypeScript为你构建软件包的结果。&lt;/p&gt;
&lt;p&gt;更新 &lt;code&gt;package.json&lt;/code&gt; 文件中的 &lt;code&gt;exports&lt;/code&gt; 字段，以定义如何根据使用的模块加载器（CJS vs. ESM）查找源文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;"exports": {
    ".": {
      "import": {
        "types": "./lib/esm/types/index.d.ts",
        "default": "./lib/esm/index.mjs"
      },
      "require": {
        "types": "./lib/cjs/types/index.d.ts",
        "default": "./lib/cjs/index.js"
      }
    }
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新 &lt;code&gt;package.json&lt;/code&gt; 文件的 &lt;code&gt;main&lt;/code&gt;和 &lt;code&gt;types&lt;/code&gt; 字段，以指向软件包的CJS版本。这将作为一个默认的、后备的选项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“types": "./lib/cjs/types/index.d.ts",
"main": "./lib/cjs/index.js",
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;package.json&lt;/code&gt; 文件中添加一个 &lt;code&gt;files&lt;/code&gt; 字段，以表明当 &lt;code&gt;npm&lt;/code&gt; 打包你的代码进行发布时，应该包括哪些文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;"files": [
   "lib/**/*"
],
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;package.json&lt;/code&gt; 中的 &lt;code&gt;scripts&lt;/code&gt; 字段创建命令，使用 &lt;code&gt;tsc&lt;/code&gt; 并编译包的 CJS 和 ESM 格式，并生成 &lt;code&gt;lib&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clean&lt;/code&gt; 命令是用来删除过去构建的输出，并从一个干净的地方开始。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;build:esm&lt;/code&gt;命令末尾的 &lt;code&gt;mv lib/esm/index.js lib/esm/index.mjs&lt;/code&gt; 重命名了文件扩展名，这样Node.js模块加载器就知道它是一个ESM模块。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;prepack&lt;/code&gt;命令是npm在打包npm包准备发布到注册表之前使用的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    "clean": "rm -rf ./lib",
    "build": "npm run clean &amp;amp;&amp;amp; npm run build:esm &amp;amp;&amp;amp; npm run build:cjs",
    "build:esm": "tsc -p ./configs/tsconfig.esm.json &amp;amp;&amp;amp; mv lib/esm/index.js lib/esm/index.mjs",
    "build:cjs": "tsc -p ./configs/tsconfig.cjs.json",
    "prepack": "npm run build"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在可以在终端运行 &lt;code&gt;npm run build&lt;/code&gt;，让TypeScript构建你的项目，为使用和发布做准备&lt;/p&gt;
&lt;p&gt;这就是使用 TypeScript 构建 npm 包所需要做的所有设置，它同时支持 CommonJS 和ECMAScript模块格式。&lt;/p&gt;
&lt;h2&gt;设置和添加测试&lt;/h2&gt;
&lt;p&gt;为了对代码的行为和结果有信心，我们需要有一个测试过程。测试迫使在第一次创建代码时，在happy-path 之外，以不同的方式思考代码的功能。举个例子，可以想办法打破一个函数，使它抛出一个错误或产生一个非预期的结果。这样做将使你的应用程序更有弹性和可持续性，并确保在添加更多内容时不会出现问题。&lt;/p&gt;
&lt;h4&gt;单元测试&lt;/h4&gt;
&lt;p&gt;要确保库以我们想要的方式运行，需要针对代码编写测试。我们需要一些工具来帮助设置我们项目来运行单元测试并显示结果。&lt;/p&gt;
&lt;p&gt;这些工具有 &lt;code&gt;Mocha.js&lt;/code&gt;、&lt;code&gt;Chai.js&lt;/code&gt;和 &lt;code&gt;ts-node&lt;/code&gt;。Mocha.js 是一个测试运行器，Chai.js是一个断言库，帮助确定你是否从你的代码中得到你所期望的结果，而 &lt;code&gt;ts-node&lt;/code&gt; 帮助我们在TypeScript项目中使用这些工具。按照下面的步骤，为 npm包设置和运行测试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在终端中使用以下命令安装开发者的依赖:
&lt;code&gt;npm i -D mocha @type/mocha chai @types/chai ts-node&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在项目的根目录下创建一个新文件 &lt;code&gt;.mocharc.json&lt;/code&gt;，内容如下:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
     "extension": ["ts"],
     "spec": "./**/*.spec.ts",
     "require": "ts-node/register"
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在项目的根目录下创建一个 &lt;code&gt;tests&lt;/code&gt; 文件夹。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;index.spec.ts&lt;/code&gt; 文件中写单元测试来测试 &lt;code&gt;index.ts&lt;/code&gt; 中的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;package.json&lt;/code&gt; 文件的 &lt;code&gt;scripts&lt;/code&gt; 部分添加一个 &lt;code&gt;test&lt;/code&gt; 属性，给它一个 &lt;code&gt;mocha&lt;/code&gt; 的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  "scripts": {
    "clean": "rm -rf ./lib",
    "build": "npm run clean &amp;amp;&amp;amp; npm run build:esm &amp;amp;&amp;amp; npm run build:cjs",
    "build:esm": "tsc -p ./configs/tsconfig.esm.json &amp;amp;&amp;amp; mv lib/esm/index.js lib/esm/index.mjs",
    "build:cjs": "tsc -p ./configs/tsconfig.cjs.json",
    "prepack": "npm run build",
    "test": "mocha"
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;最后，在终端运行 &lt;code&gt;npm test&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bc@mbp-snyk modern-npm-package % npm test

&amp;gt; @clarkio/modern-npm-package@0.0.0-development test
&amp;gt; mocha

  NPM Package
    ✔️ should be an object
    ✔️ should have a helloworld property

  Hello World Function
    ✔️  should be a function
    ✔️ should return the hello world message

4 passing (22ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;管道中的测试&lt;/h2&gt;
&lt;p&gt;按照下面的步骤，创建一个测试工作流，作为项目管道的一部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为仓库创建一个新的GitHub Action ：&lt;code&gt;https://github.com/&amp;lt;your-account-or-organization&amp;gt;/&amp;lt;your-repo-name&amp;gt;/actions/new&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将工作流程重命名为 &lt;code&gt;test.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在工作流程文件中插入以下Snyk动作脚本:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;name: Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:

    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [12.x, 14.x, 16.x, 18.x]

    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm ci
      - run: npm test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个YAML脚本检查出你的最新代码，安装其依赖性，并运行 &lt;code&gt;npm test&lt;/code&gt;命令来执行测试。它对&lt;code&gt;node-version&lt;/code&gt;字段中列出的每一个Node.js版本都会这样做，所以可以确保代码在每次运行时都能按预期工作。&lt;/p&gt;
&lt;p&gt;现在已经完成了对项目的设置，以便对npm包的代码进行运行和评估测试。然而，你可能在想 "我如何在另一个项目中使用我的npm包进行测试？" 让我们来看看。&lt;/p&gt;
&lt;h2&gt;包测试&lt;/h2&gt;
&lt;p&gt;包上传完成后，除了单元测试外，我们还要测试在另一个项目引入我们包使用的情况，看看是否像我们所期望那样。这里有五种可以测试的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 npm pack 输出安装&lt;/li&gt;
&lt;li&gt;通过相对路径安装&lt;/li&gt;
&lt;li&gt;通过npm链接安装&lt;/li&gt;
&lt;li&gt;通过注册表安装（如npmjs.com的npm公共注册表）。&lt;/li&gt;
&lt;li&gt;使用Verdaccio（一个开源的npm私有npm注册项目）来运行端到端的软件包发布和安装步骤，作为你CI的一部分。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;npm pack&lt;/h2&gt;
&lt;p&gt;这种方法将利用&lt;code&gt;npm pack&lt;/code&gt;命令将 npm 包打包并压缩成一个文件（&lt;code&gt;&amp;lt;package-name&amp;gt;.tgz&lt;/code&gt;）。然后你可以到你想使用该包的项目中，通过这个文件安装它。这样做的步骤如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;终端运行 &lt;code&gt;npm pack&lt;/code&gt;。注意它产生的&lt;code&gt;.tgz&lt;/code&gt;文件和它的位置。&lt;/li&gt;
&lt;li&gt;改变目录到你想使用 &lt;code&gt;npm&lt;/code&gt; 包的项目目录。例如：&lt;code&gt;cd /path/to/project&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行&lt;code&gt;npm install /path/to/package.tgz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后就可以在项目中使用该包来测试东西了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;npm link&lt;/h2&gt;
&lt;p&gt;利用 &lt;code&gt;npm link&lt;/code&gt; 命令来安装本地包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在当前包目录中，在终端运行 &lt;code&gt;npm link&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;改变目录到你想使用npm包的项目目录。例如：&lt;code&gt;cd /path/to/project&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在项目中运行 &lt;code&gt;npm link &amp;lt;name-of-your-package&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样在项目中就可以使用我们的包。&lt;/p&gt;
&lt;h2&gt;相对路径&lt;/h2&gt;
&lt;p&gt;这种类似于npm link。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在终端运行 &lt;code&gt;npm install /path/to/your/package&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 &lt;code&gt;npm link&lt;/code&gt; 的方法类似，这允许我们在项目中快速测试包的功能，但不会给你完整的类似生产的体验。这是因为它指向完整的软件包源代码目录，而不是你在npm注册表中找到的软件包的构建版本。&lt;/p&gt;
&lt;h2&gt;npm registry&lt;/h2&gt;
&lt;p&gt;这种方法利用了npm包的公共（或你自己）注册表。它涉及到发布的包，并像你通常对任何其他npm包那样进行安装。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用本文前面概述的步骤，通过 &lt;code&gt;npm publish&lt;/code&gt; 命令发布npm包&lt;/li&gt;
&lt;li&gt;改变目录到想使用npm包的项目目录。例如：&lt;code&gt;cd /path/to/project&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在项目目录中运行 &lt;code&gt;npm install &amp;lt;name-of-your-package&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;实施安全检查&lt;/h2&gt;
&lt;p&gt;就像你不希望在自己的项目中出现安全漏洞一样，你也不希望在其他人的项目中引入漏洞。构建一个预计会在许多其他项目中使用的npm包，这就增加了确保事情安全的责任。你需要有安全检查，以帮助监测、提醒和提供帮助来减少漏洞。这就是像&lt;a href="https://app.snyk.io/login"&gt;Snyk&lt;/a&gt;这样的工具可以简化完成这些需求所需的工作的地方。&lt;/p&gt;
&lt;p&gt;对于这个例子中的npm包，你使用GitHub作为你的源码控制管理工具，所以利用它的GitHub Actions功能将Snyk整合到工作流程中。Snyk 有一个GitHub Actions参考项目，可以帮助启动这方面的工作，并为你的项目可能使用的其他编程语言和工具提供例子。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Snyk是免费的，这里可以进行&lt;a href="https://app.snyk.io/login?redirectUri=L2FjY291bnQ%3D&amp;amp;from=snyk_marketing_site"&gt;注册&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在GitHub上将你的Snyk API令牌添加为仓库秘密： &lt;code&gt;https://github.com/&amp;lt;your-account-or-organization&amp;gt;/&amp;lt;your-repo-name&amp;gt;/settings/secrets/actions/new&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仓库创建一个新的GitHub Action: &lt;code&gt;https://github.com/&amp;lt;your-account-or-organization&amp;gt;/&amp;lt;your-repo-name&amp;gt;/actions/new&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将workflow 重命名为 &lt;code&gt;snyk.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 workflow 文件中插入以下Snyk Action 脚本:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;name: Snyk Security Check
on: [push,pull_request]
jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@main
      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="6"&gt;
&lt;li&gt;提交你的修改。&lt;/li&gt;
&lt;li&gt;验证Action 成功运行: &lt;code&gt;https://github.com/&amp;lt;your-account-or-organization&amp;gt;/&amp;lt;your-repo-name&amp;gt;/actions&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了这个设置，任何时候任何人推送到你的版本库或针对它打开一个拉动请求，都会进行安全检查，以确保它不会在软件包中引入任何漏洞。如果发现了问题，行动将失败，并提醒你发现的安全问题的细节。接下来，你将围绕版本管理和发布你的npm包进行自动化处理。&lt;/p&gt;
&lt;p&gt;关于目前的设置，需要注意的一点是，它只利用了Snyk开源（SCA）产品，而不是Snyk代码（SAST）。Snyk Code是我们的代码安全产品，你需要首先通过你的Snyk账户启用它（免费），然后在这里添加到你的工作流程脚本中，以充分利用它。&lt;/p&gt;
&lt;h2&gt;实现版本管理和发布的自动化&lt;/h2&gt;
&lt;p&gt;每当在主分支中合并变化时，我们不想每次都手动更新npm包的版本并发布它。相反，会想让这个过程自动发生。如果你还记得本篇文章前面那个简单的npm包的例子，用以下命令来更新npm包的版本，然后发布它。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm version &amp;lt;major|minor|patch&amp;gt;
npm publish
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;什么是语义版本管理？&lt;/h4&gt;
&lt;p&gt;语义版本管理规定，版本要用三个占位符进行编号。第一个是主要版本，第二个是次要版本，而最后一个是补丁版本。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://semantic-release.gitbook.io/semantic-release/"&gt;Semantic Release&lt;/a&gt;的工具可以与 GitHub Actions 整合来帮助我们自动修改版本并发布。实现这一过程自动化的关键是，你在向项目提交变更时使用所谓的常规提交。这使得自动化能够相应地更新一切，并知道如何为你准备项目的下一个版本。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;运行：&lt;code&gt;npm i -D semantic-release&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;npx semantic-release-cli setup&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照终端的提示，提供所需的令牌&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;需要一个来自 GitHub 的个人访问令牌。要创建一个，请到 https://github.com///settings/secrets/actions/new&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在创建此令牌时，请使用以下作用域&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d5f102e01154db2ac100e1a13459baf~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;ol start="4"&gt;
&lt;li&gt;还需要一个来自npm的自动化类型的访问令牌，只在CI环境中使用，这样它就能绕过你的账户的2FA。要创建一个，请到https://www.npmjs.com/settings//tokens。请确保选择 "Automation"类型，因为这将用于CI/CD工作流程中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b68b33fe4e3e42ac967d3b763a14a785~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bc@mbp-snyk modern-npm-package % npx semantic-release-cli setup
? What is your npm registry? https://registry.npmjs.org/
? What is vour nom username? clarkio
? What is your pm password? [hidden]
? What is your NPM two-factor authentication code? &amp;lt;2FA code&amp;gt;
Provide a GitHub Personal Access Token (create a token at https://github.com/settings/tokens/new?scopes=repo
&amp;lt;token&amp;gt;
? What CI are you using? Github Actions
bc@mbp-snyk modern-npm-package %
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="5"&gt;
&lt;li&gt;将npm令牌作为仓库秘密添加到GitHub仓库中：&lt;code&gt;https://github.com/&amp;lt;your-name-or-organization/&amp;lt;your-repository&amp;gt;/settings/secrets/actions/new&lt;/code&gt;。将秘密的名称设置为&lt;code&gt;NPM_TOKEN&lt;/code&gt;，其值是你在前面步骤中检索到的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a31451f109e045609eced9eaf1f970e8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;ol start="6"&gt;
&lt;li&gt;回到项目中，进入&lt;code&gt;package.json&lt;/code&gt;文件，像下面这样添加一个&lt;code&gt;release&lt;/code&gt;键。如果你的版本库的主分支仍然叫&lt;code&gt;master&lt;/code&gt;而不是&lt;code&gt;main&lt;/code&gt;，那么就相应地更新上述分支的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;"release": {
    "branches": ["main"]
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="7"&gt;
&lt;li&gt;在 &lt;code&gt;package.json&lt;/code&gt; 文件中也添加一个&lt;code&gt;publishConfig&lt;/code&gt;键。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;"publishConfig": {
    "access": "public"
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="8"&gt;
&lt;li&gt;
&lt;p&gt;通过使用&lt;code&gt;semantic-release npm&lt;/code&gt;脚本进行模拟运行来测试一切。采用以下命令，并将&lt;code&gt;NPM_TOKEN=&lt;/code&gt;和&lt;code&gt;GH_TOKEN=&lt;/code&gt;值设置为使用您各自的令牌值。然后在你的终端中复制并运行完整的命令，看看一切是否运行正常。你会看到进程被记录在终端的输出中。如果出现任何问题，它们会在这里显示出来，并提供解决这些问题的细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在确认试运行成功后，可以为GitHub仓库设置一个新的GitHub动作来为你处理发布过程。转到你在GitHub上的仓库，点击 "Actions"。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击新建工作流程选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将工作流程重命名为release.yml。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在新的工作流程文件中加入以下YAML脚本。这个脚本主要是说，一旦Snyk安全检查工作成功完成，就运行发布工作。发布作业会检查代码，设置Node.js环境，安装你的依赖项，然后使用你的GitHub和npm令牌运行语义发布。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;name: Release
on:
  workflow_run:
    workflows: ['Snyk Security Check', 'Tests']
    branches: [main]
    types:
      - completed

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: 'lts/*'
      - name: Install dependencies
        run: npm ci
      - name: Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: npx semantic-release
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;13.提交你的本地修改并推送到你的GitHub仓库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以通过在终端运行命令 &lt;code&gt;git commit -am '&amp;lt;your commit message&amp;gt;'&lt;/code&gt;，然后&lt;code&gt;git push&lt;/code&gt;来实现。&lt;/li&gt;
&lt;li&gt;也可以在VS Code中通过其版本控制功能做到这一点。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="14"&gt;
&lt;li&gt;在所有这些设置完成后，现在可以使用传统的提交方式将修改推送到你的主分支（或通过合并拉动请求），然后发布工作流就会运行（当然是在Snyk安全检查之后）。你可以在&lt;code&gt;modern-npm-package&lt;/code&gt;版本库工作流程的例子中看到这种情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;我们总结一下在本文中学到的一切。首先，熟悉了设置、创建和部署一个简单的npm包。这对于熟悉首次发布自己的npm包来说是很好的。然而，如果想制作一个供生产使用的npm包，这样做是相当费力的，也是不可持续的。&lt;/p&gt;
&lt;p&gt;为了完成制作一个可用于生产的包，随后学会了如何为CommonJS（CJS）和ECMAScript（ESM）模块格式进行构建，设置和编写单元测试，实现安全检查，并自动进行版本管理和发布。有了这些知识，现在已经准备好制作更多属于你自己的npm包了，这些包很容易被社区或你的公司所使用。&lt;/p&gt;
&lt;p&gt;来源：https://snyk.io/blog/best-practices-create-modern-npm-package/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Sat, 08 Oct 2022 16:27:57 GMT</pubDate></item><item><title>CSS容器查询终于来了</title><link>https://juejin.cn/post/7148962811740160007</link><description>&lt;p&gt;CSS容器查询终于来了! 它们目前在谷歌浏览器（105）中得到了支持，很快就会在Safari 16中得到支持。这对前端来说容器查询与媒体查询一样重要。&lt;/p&gt;
&lt;p&gt;在这节课中，我们介绍一下容器查询是如何工作的，如何使用它们，以及语法是什么样子的，并分享一些现实生活中的例子和用例。&lt;/p&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;在设计一个组件时，我们需要适配不同的变化，并根据CSS类或视口大小来改变它们。这对于我们开发来说不是很理想，会迫使我们根据变化类或视口尺寸来写CSS。&lt;/p&gt;
&lt;p&gt;考虑下面例子：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48dbb5241f354badb6904cf35ff1dd3d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们有一个卡片组件，当视口足够大时，它应该切换到水平样式。乍一看，这可能听起来不错。然而，当你更深入地思考这个问题时，它就有点复杂了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b75c0021c43641aa9e67c31d807765b3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果我们想在不同的地方使用同一个卡片组件，比如在空间狭小的侧边栏和有更多空间的主区域，我们就需要使用不同的类来适配：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.c-article {
  /* Default stacked style */
}

@media (min-width: 800px) {
  /* Horizontal style. */
  .c-article--horizontal {
    display: flex;
    align-items: center;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们不想用上面的方式，那么会出现下面这样的情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2d248843d024a709328207cffbd4136~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这种从用户界面的角度来看，并不友好。&lt;/p&gt;
&lt;p&gt;通过容器查询，我们可以简单地编写响应父级或容器宽度的CSS。请看下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25348c0242704f57a0acb02ef57080f5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;注意到在媒体查询中，我们是如何根据视口或屏幕宽度来查询一个组件的。在容器查询中，同样的情况发生在父级上。&lt;/p&gt;
&lt;h2&gt;什么是容器查询？&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;container-type&lt;/code&gt; 属性查询一个组件与最接近的父类的关系，该父类有一个定义的包含物。&lt;/p&gt;
&lt;p&gt;我们过去在媒体查询中写CSS的方式，但只是针对组件层面。&lt;/p&gt;
&lt;h4&gt;容器查询语法&lt;/h4&gt;
&lt;p&gt;要根据一个组件的父级宽度查询，我们需要使用 &lt;code&gt;container-type&lt;/code&gt; 属性。看下面的例子"&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.wrapper {
  container-type: inline-size;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这些，我们就可以开始查询一个组件。在下面的例子中，如果&lt;code&gt;.card&lt;/code&gt;元素的容器的宽度等于&lt;code&gt;400px&lt;/code&gt;或更大，我们需要添加一个特定的样式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@container (min-width: 400px) {
  .card {
    display: flex;
    align-items: center;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然上述方法可行，但当有多个容器时，就会造成混乱。为了避免这种情况，最好为一个容器命名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.wrapper {
  container-type: inline-size;
  container-name: card;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们可以在 &lt;code&gt;@container&lt;/code&gt; 旁边加容器名称，如下所示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@container card (min-width: 400px) {
  .card {
    display: flex;
    align-items: center;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.wrapper {
  container-type: inline-size;
  container-name: card;
}

.c-article {
  /* Default stacked style */
}

@container card (min-width: 400px) {
  /* Horizontal style. */
  .c-article {
    display: flex;
    align-items: center;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;浏览器支持&lt;/h2&gt;
&lt;p&gt;容器查询现在在Chrome 105中得到支持，并很快在Safari 16中得到支持。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10774b9679a84f1b8324db8050f7ff77~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;事例&lt;/h2&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd09e43911434020b4e7b814d60374d7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这边有10个关于容器查询的事例，地址：https://lab.ishadeed.com/container-queries&lt;/p&gt;
&lt;p&gt;来源：https://ishadeed.com/article/container-queries-are-finally-here/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;</description><author>王大冶</author><pubDate>Thu, 29 Sep 2022 16:30:58 GMT</pubDate></item><item><title>别整一坨 CSS 代码了，试试这几个实用函数</title><link>https://juejin.cn/post/7147849664518160415</link><description>&lt;blockquote&gt;
&lt;p&gt;本文首发于微信公众号：大迁世界, 我的微信：qq449245884，我会第一时间和你分享前端行业趋势，学习途径等等。
更多开源作品请看 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; ，包含一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CSS比较函数从2020年4月就开始支持了，我喜欢使用这些函数，但最喜欢的是 &lt;code&gt;clamp()&lt;/code&gt;，它也是我最常用的一个。在这节课中，我们详细来看下这些比较函数。&lt;/p&gt;
&lt;h2&gt;Clamp(), Max(), 和 Min() 函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;clamp()&lt;/code&gt; 函数的作用是把一个值限制在一个上限和下限之间，当这个值超过最小值和最大值的范围时，在最小值和最大值之间选择一个值使用。它接收三个参数：最小值、首选值、最大值。&lt;/p&gt;
&lt;h4&gt;流体的尺寸和定位&lt;/h4&gt;
&lt;p&gt;在下面这个例子中，有一个手机样式，同时有两张图片放置在上面，如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d7171effbac4cd8986cd64d8d4a9f74~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;当容器的宽度变小时，我们要缩小图片的尺寸，这样才不会变形。一般使用百分比单位来解决，如 &lt;code&gt;width: 20%&lt;/code&gt;，但是这种方式没有给我们太多的控制。&lt;/p&gt;
&lt;p&gt;我们希望能够有一个流体尺寸，要求有最小值和最大值，这就是 &lt;code&gt;clamp&lt;/code&gt; 出场的地方。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section-image {
  width: clamp(70px, 80px + 15%, 180px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58459ffca4f647e59cb803ae4602a4f4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;事例地址：https://codepen.io/shadeed/pen/qBYPdOq?editors=1100&lt;/p&gt;
&lt;h4&gt;装饰性元素&lt;/h4&gt;
&lt;p&gt;有时候，我们需要在页面边角加一些修饰元素，该修饰元素需要具有响应式，比如 PC 端是这样的（黑点部分）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b43794fe70d54116a86d19a2b472ed60~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;然后在移动端是长这样的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/297193c6b7e44d0c861826c9d19c9c90~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为了做到这，我们可以使用媒体查询：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.decorative--1 {
  left: 0;
}

.decorative--2 {
  right: 0;
}

@media (max-width: 600px) {
  .decorative--1 {
    left: -8rem;
  }

  .decorative--2 {
    right: -8rem;
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然这样做可以，但我们可以 &lt;code&gt;clamp()&lt;/code&gt;函数，这样更简洁：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  .decorative--1 {
    left: clamp(-8rem, -10.909rem + 14.55vw, 0rem);
  }

  .decorative--2 {
    right: clamp(-8rem, -10.909rem + 14.55vw, 0rem);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事例地址：https://codepen.io/shadeed/pen/LYmzVZW?editors=1100&lt;/p&gt;
&lt;h4&gt;流体高度&lt;/h4&gt;
&lt;p&gt;有时候，我们页面的主区的高度需要根据视口大小而变化。这种场景，我们倾向于通过媒体查询或使用视口单位来改变这种情况。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4cf1a63ddfd41909a8ca8a5efb88480~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.hero {
  min-height: 250px;
}

@media (min-width: 800px) {
  .hero {
    min-height: 500px;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们也可以混合使用固定值和视口单位:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.hero {
  min-height: calc(350px + 20vh);
}

@media (min-width: 2000px) {
  .hero {
    min-height: 600px;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但需要注意在较大的视口上高度不能太过高，所以我们需要设置一个最大高度,使用CSS &lt;code&gt;clamp()&lt;/code&gt;，我们可以只用一个CSS声明来设置最小、首选和最大高度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.hero {
  min-height: clamp(250px, 50vmax, 500px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当调整屏幕大小时，我们会看到，高度会根据视口宽度逐渐改变。在上面的例子中，&lt;code&gt;50vmax&lt;/code&gt;表示着视口最大尺寸的 &lt;code&gt;50%&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a27cf35cca75407e9fb69801f217b705~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;事例地址：https://codepen.io/shadeed/pen/LYmzVZW?editors=1100&lt;/p&gt;
&lt;h4&gt;Loading Bar&lt;/h4&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43196812e33a4d0e97fe1e05ec4fcc59~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;进度条一般是从左到右一个加载过程，在 CSS 中，我们可以定位在左边：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loading-thumb {
  left: 0%;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了将进度条定位到最右边，我们可以使用 &lt;code&gt;left: 100%&lt;/code&gt;，但这会带来一个问题。进度条会跑到容器外：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca1e003d57624344914d0e9181cd392c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loading-thumb {
  left: 100%;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是正常的情况，100% 是从进度条的末端开始的，而进度条本身也有自己的宽度，所以实际宽度会大于容器的宽度。&lt;/p&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;calc()&lt;/code&gt; 来减去的进度条宽度，这样就可以了，但这并不是100%有效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loading-thumb {
  /* 40px represents the thumb width. */
  left: calc(100% - 40px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们来看下，如何利用CSS变量和比较函数来更好地实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loading-thumb {
  --loading: 0%;
  --loading-thumb-width: 40px;
  position: absolute;
  top: 4px;
  left: clamp(
    0%,
    var(--loading),
    var(--loading) - var(--loading-thumb-width)
  );
  width: var(--loading-thumb-width);
  height: 16px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，我们设定一个最小值为 &lt;code&gt;0%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;首选值是 &lt;code&gt;--loading&lt;/code&gt; CSS变量的当前值&lt;/li&gt;
&lt;li&gt;最大值代表当前的加载量减去进度条件的宽度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里的CSS &lt;code&gt;clamp()&lt;/code&gt;为我们提供了这个组件的三种不同的状态信息，这个方案很 nice:&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69f018a690e3449ebd771e1fff003c4e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;不仅如此，我们还可以以相同的方式来处理不同UI&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86389403f4ac4bcbb643472ce739fc67~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loading-progress {
  width: clamp(10px, var(--loading), var(--loading) - 10px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最小值等于圆圈宽度的一半，首选值是当前的加载百分比，最大值是当前百分比与圆圈一半的减去结果。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0971d8908483a9c41aa30346f02d4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;事例地址：https://codepen.io/shadeed/pen/rNvGVOa?editors=0100&lt;/p&gt;
&lt;h4&gt;动态分割器&lt;/h4&gt;
&lt;p&gt;考虑下图，我们在两个区域之间有一个行分隔符。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d73918b63be54d228cd3deb2e5c043f1~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在移动端上，这个分隔符应该变成水平的，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a35fa0ccdd4f4b7e8e55cc6589a5ee05~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我的解决方案是使用一个边框和flex。思路是，边框作为伪元素，以填补垂直和水平状态的可用空间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.section:before {
  content: "";
  border: 1px solid #d3d3d3;
  align-self: stretch;
}

@media (min-width: 700px) {
  .section {
    align-items: center;
    flex-direction: row;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们也可以使用 &lt;code&gt;clamp&lt;/code&gt; 而不需要媒体查询的解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section {
  --breakpoint: 400px;
  display: flex;
  flex-wrap: wrap;
}

.section:before {
  content: "";
  border: 2px solid lightgrey;
  width: clamp(0px, (var(--breakpoint) - 100%) * 999, 100%);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来剖析一下上面的CSS:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0px：最小值，用于垂直分隔符。它的值是 &lt;code&gt;0&lt;/code&gt;，因为我们使用的是一个CSS边框&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(var(--breakpoint) - 100%) * 999&lt;/code&gt; 是一个个切换器，根据视口宽度在 &lt;code&gt;0px&lt;/code&gt;或 &lt;code&gt;100%&lt;/code&gt; 之间切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d7259c2e03c494185ff74ee9dfd3ec2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h4&gt;动态 border Radius&lt;/h4&gt;
&lt;p&gt;一年前，发现了一个巧妙的CSS技巧。使用CSS &lt;code&gt;max()&lt;/code&gt;函数，根据视口宽度，将卡片的&lt;code&gt;border-radius&lt;/code&gt; 从 &lt;code&gt;0px&lt;/code&gt; 切换到 &lt;code&gt;8px&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99a42174c2914121933c2e9cb409a797~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.card {
  border-radius: max(
    0px,
    min(8px, calc((100vw - 4px - 100%) * 9999))
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来剖析一下上面的CSS:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们有一个 &lt;code&gt;max()&lt;/code&gt; 函数，在 &lt;code&gt;0px&lt;/code&gt; 和 &lt;code&gt;min()&lt;/code&gt;的计算值之间进行比较，并选择较大的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;min()&lt;/code&gt; 函数在 &lt;code&gt;8px&lt;/code&gt; 和 &lt;code&gt;calc((100vw - 4px - 100%) * 9999&lt;/code&gt; 的计算值之间进行比较,这会得到一个非常大的正数或负数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;9999&lt;/code&gt; 是一个很大的数字，这样 &lt;code&gt;min&lt;/code&gt; 的值都是 &lt;code&gt;8px&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;间距&lt;/h4&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c335542fba744cdfa316d38bcb8a3248~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;有时，我们可能需要根据视口宽度来改变一个组件或一个网格的间距。有了CS函数就不一样了,我们只需要设置一次。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.wrapper {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-gap: min(2vmax, 32px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="1034934887-632fc3decc9d8.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/158413c9ab3f4b3e8cac4bc453dbf17a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来源：https://isdeed.com/article/use-cases-css-comparison-functions/&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Mon, 26 Sep 2022 16:28:28 GMT</pubDate></item><item><title>any 和 unknown 傻傻分不清楚？</title><link>https://juejin.cn/post/7108496183298883597</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;13.5W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1WR4y1P7dw"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1WR4y1P7dw/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在你刚学 TypeScript 的时候，是不是遇到了很多令人抓狂的问题，最终你用上 any 大招把问题解决了。如果后期你没有系统的学习 TypeScript 的类型系统，你会发现你可能把 TypeScript 学成了 &lt;strong&gt;AnyScript&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 TypeScript 中，any 类型被称为 top type。所谓的 top type 可以理解为通用父类型，也就是能够包含所有值的类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: any;
​
value = true; // OK
value = 42; // OK
value = "Hello World"; // OK
value = []; // OK
value = {}; // OK
value = Math.random; // OK
value = null; // OK
value = undefined; // OK
value = new TypeError(); // OK
value = Symbol("type"); // OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在 TypeScript 3.0 时，又引入一个新的 top type —— &lt;strong&gt;unknown 类型&lt;/strong&gt;。同样，你也可以把任何值赋给 unknown 类型的变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: unknown;
​
value = true; // OK
value = 42; // OK
value = "Hello World"; // OK
value = []; // OK
value = {}; // OK
value = Math.random; // OK
value = null; // OK
value = undefined; // OK
value = new TypeError(); // OK
value = Symbol("type"); // OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d375fa3373d84f4d8c491166931a3cb5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么现在问题来了，any 类型和 unknown 类型之间有什么区别呢？any 类型可以理解成我不在乎它的类型，而unknown 类型可以理解成我不知道它的类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0823149987214d7698ee39103d52c1d7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其实 any 类型本质上是类型系统的一个逃生舱口，&lt;strong&gt;TypeScript 允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: any;
​
value.foo.bar; // OK
value.trim(); // OK
value(); // OK
new value(); // OK
value[0][1]; // OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会带来什么问题呢？下面我们来举一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function invokeCallback(callback: any) {
 &amp;nbsp; &amp;nbsp;try {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;callback();
 &amp;nbsp;  } catch (err) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.error(err)
 &amp;nbsp;  }
}
​
invokeCallback(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于以上的 TS 代码，在编译期不会提示任何错误，但在运行期将会抛出运行时错误。作为开发人员，any 类型给了我们很大的自由度，但同时也带来了一些隐患。&lt;strong&gt;为了解决 any 类型存在的安全隐患，TypeScript 团队在 3.0 版本时，引入了 unknown 类型，你可以把它理解成类型安全的 any 类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么 unknown 类型是类型安全的体现在哪里呢？这里我们把 invokeCallback 函数参数的类型改为 unknown 类型，之后 TS 编译器就会提示相应的错误信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function invokeCallback(callback: unknown) {
 &amp;nbsp; &amp;nbsp;try {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// Object is of type 'unknown'.(2571)
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;callback(); // Error
 &amp;nbsp;  } catch (err) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.error(err)
 &amp;nbsp;  }
}
​
invokeCallback(1); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相比 any 类型，TypeScript 会对 unknown 类型的变量执行类型检查，从而避免出现 callback 参数非函数类型。要解决上述问题，我们需要缩小 callback 参数的类型，即可以通过 typeof 操作符来确保传入的 callback 参数是函数类型的对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function invokeCallback(callback: unknown) {
 &amp;nbsp; &amp;nbsp;try {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;if (typeof callback === 'function') {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;callback();
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  }
 &amp;nbsp;  } catch (err) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.error(err)
 &amp;nbsp;  }
}
​
invokeCallback(1); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在实际工作中，你还可以通过 instanceof 或用户自定义类型守卫等方式来缩窄变量的类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;declare function isFunction(x: unknown): x is Function;
​
function f20(x: unknown) {
 &amp;nbsp; &amp;nbsp;if (x instanceof Error) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;x; &amp;nbsp;// Error
 &amp;nbsp;  }
 &amp;nbsp; &amp;nbsp;if (isFunction(x)) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;x; &amp;nbsp;// Function
 &amp;nbsp;  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与 any 类型不同，因为 TypeScript 会对 unknown 类型的变量执行类型检查，所以当我们把之前代码中 value 变量的类型改成 unknown 类型时，使用 value 变量的多个语句将出现错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: unknown;
​
// Object is of type 'unknown'.(2571)
value.foo.bar; // Error
value.trim(); // Error
value(); // Error
new value(); // Error
value[0][1]; // Error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，需要注意的是，unknown 类型的变量只能赋值给 any 类型和 unknown 类型本身。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: unknown;
​
let value1: unknown = value; // OK
let value2: any = value; // OK
let value3: boolean = value; // Error
let value4: number = value; // Error
let value5: string = value; // Error
let value6: object = value; // Error
let value7: any[] = value; // Error
let value8: Function = value; // Error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/333580eee6664b01aac61a5a43ddf473~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在往期文章中我们已经介绍过了 keyof 操作符和映射类型。any 类型和 unknown 类型在这些场合中的表现也是不一样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T40 = keyof any; &amp;nbsp;// string | number | symbol
type T41 = keyof unknown; &amp;nbsp;// never
​
type T50&amp;lt;T&amp;gt; = { [P in keyof T]: number };
type T51 = T50&amp;lt;any&amp;gt;; &amp;nbsp;// { [x: string]: number }
type T52 = T50&amp;lt;unknown&amp;gt;; &amp;nbsp;// {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，T50 类型被称为映射类型，在映射过程中，如果 key 的类型是 never 类型，则当前 key 将会被过滤掉，所以 T52 的类型是空对象类型。&lt;/p&gt;
&lt;p&gt;关于 any 类型和 unknown 类型的区别就介绍到这里，现在我们来做个总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可以把任何值赋给 any 类型的变量，并对该变量执行任何操作；&lt;/li&gt;
&lt;li&gt;你可以把任何值赋给 unknown 类型的变量，但你必须进行类型检查或类型断言才能对变量进行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2886ef1f92242239a363cfa23685866~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在平时工作中，为了保证类型安全，我们应该尽可能使用 &lt;strong&gt;unknown&lt;/strong&gt; 类型。最后我们来看一下 unknown 类型与不同类型进行类型运算的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T00 = unknown &amp;amp; null; &amp;nbsp;// null
type T01 = unknown &amp;amp; undefined; &amp;nbsp;// undefined
type T02 = unknown &amp;amp; null &amp;amp; undefined; &amp;nbsp;// null &amp;amp; undefined
type T03 = unknown &amp;amp; string; &amp;nbsp;// string
type T04 = unknown &amp;amp; string[]; &amp;nbsp;// string[]
type T05 = unknown &amp;amp; unknown; &amp;nbsp;// unknown
type T06 = unknown &amp;amp; any; &amp;nbsp;// any
​
type T10 = unknown | null; &amp;nbsp;// unknown
type T11 = unknown | undefined; &amp;nbsp;// unknown
type T12 = unknown | null | undefined; &amp;nbsp;// unknown
type T13 = unknown | string; &amp;nbsp;// unknown
type T14 = unknown | string[]; &amp;nbsp;// unknown
type T15 = unknown | unknown; &amp;nbsp;// unknown
type T16 = unknown | any; &amp;nbsp;// any
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a3a896dfbf4435b6f0eb510f2e7c87~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;any 类型比较特殊，该类型与任意类型进行交叉或联合运算时，都会返回 any 类型。阅读完本文之后，相信你已经了解 any 类型和 unknown 类型之间的区别了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你知道如何检测 any 类型和 unknown 类型么？&lt;/strong&gt; 如果知道的话，可以在评论区提交你的答案。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Sun, 12 Jun 2022 15:30:43 GMT</pubDate></item><item><title>用了模板字面量类型，同事直呼太强了！</title><link>https://juejin.cn/post/7106647263321325605</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;12.7W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1B34y1E7tm/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1B34y1E7tm/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你了解过模板字面量类型么？你想知道如何利用模板字面量类型，来减少 TypeScript 项目中的重复代码么？如果想的话，阅读完本文之后，也许你就懂了。假设我们想要定义一种类型来描述 CSS padding 规则，如果你了解 TypeScript 类型别名和联合类型的话，能很容易定义出 CssPadding 类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4e4a1d85bc945f993589d95fb6ab92a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type CssPadding =
 &amp;nbsp;| "padding-left"
 &amp;nbsp;| "padding-right"
 &amp;nbsp;| "padding-top"
 &amp;nbsp;| "padding-bottom";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但如果我们想要继续定义一种新的类型来描述 CSS margin 规则，你是不是立马想到与定义 CssPadding 类型一样的方式。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MarginPadding =
 &amp;nbsp;| "margin-left"
 &amp;nbsp;| "margin-right"
 &amp;nbsp;| "margin-top"
 &amp;nbsp;| "margin-bottom";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30da3e73d57540968784e22187fa6398~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;对于以上定义的两种类型来说，虽然它们都能满足我们的需求。但在定义这两种类型的过程中，仍然存在一些重复的代码。那么如何解决这个问题呢？这时我们可以使用 TypeScript 4.1 版本引入了新的模板字面量类型，具体的使用方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Direction = "left" | "right" | "top" | "bottom";
​
type CssPadding = `padding-${Direction}`;
type MarginPadding = `margin-${Direction}`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/507a39d3df82491f90e14cbb80251a87~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;看完以上代码，是不是觉得简洁很多。与 JavaScript 中的模板字符串类似，模板字面量类型被括在反引号中，同时可以包含 &lt;code&gt;${T}&lt;/code&gt; 形式的占位符，其中类型变量 T 的类型可以是 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt; 或 &lt;code&gt;bigint&lt;/code&gt; 类型。&lt;/p&gt;
&lt;p&gt;模板字面量类型不仅为我们提供了连接字符串字面量的能力，而且还可以把非字符串基本类型的字面量转换为对应的字符串字面量类型。下面我们来举一些具体的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type EventName&amp;lt;T extends string&amp;gt; = `${T}Changed`;
type Concat&amp;lt;S1 extends string, S2 extends string&amp;gt; = `${S1}-${S2}`;
type ToString&amp;lt;T extends string | number | boolean | bigint&amp;gt; = `${T}`;
​
type T0 = EventName&amp;lt;"foo"&amp;gt;; // 'fooChanged'
type T1 = Concat&amp;lt;"Hello", "World"&amp;gt;; // 'Hello-World'
type T2 = ToString&amp;lt;"阿宝哥" | 666 | true | -1234n&amp;gt;; // "阿宝哥" | "true" | "666" | "-1234"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/346480799b014bc7b43094017053916c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;对于上述的例子来说，其实并不复杂。但现在问题来了，如果传入 EventName 或 Concat 工具类型的实际类型是联合类型的话，那么结果又会是怎样呢？接下来，我们来验证一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T3 = EventName&amp;lt;"foo" | "bar" | "baz"&amp;gt;; 
// "fooChanged" | "barChanged" | "bazChanged"
type T4 = Concat&amp;lt;"top" | "bottom", "left" | "right"&amp;gt;;
// "top-left" | "top-right" | "bottom-left" | "bottom-right"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/433d409800344e288edda8a3d0a9cef6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为什么会生成这样的类型呢？这是因为对于模板字面量类型来说，当类型占位符的实际类型是联合类型（A ｜B ｜C）的话，就会被自动展开：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;`[${A|B|C}]` =&amp;gt; `[${A}]` | `[${B}]` | `[${C}]`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da6ad7f256604ebf83914356f244b33f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;而对于包含多个类型占位符的情形，比如 &lt;code&gt;Concat&lt;/code&gt; 工具类型。多个占位符中的联合类型解析为叉积：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;`${A|B}-${C|D}` =&amp;gt; `${A}-${C}` | `${A}-${D}` | `${B}-${C}` | `${B}-${D}`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23822d8edc648d1b8fb41addcec3014~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;了解完上述的运算规则，你应该就能理解生成的 T3 和 T4 类型了。在使用模板字面量类型的过程中，我们还可以使用 TypeScript 提供的，用于处理字符串类型的内置工具类型，比如 &lt;strong&gt;Uppercase&lt;/strong&gt;、&lt;strong&gt;Lowercase&lt;/strong&gt;、&lt;strong&gt;Capitalize&lt;/strong&gt; 和 &lt;strong&gt;Uncapitalize&lt;/strong&gt;。具体的使用方式是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type GetterName&amp;lt;T extends string&amp;gt; = `get${Capitalize&amp;lt;T&amp;gt;}`;
type Cases&amp;lt;T extends string&amp;gt; = `${Uppercase&amp;lt;T&amp;gt;} ${Lowercase&amp;lt;T&amp;gt;} ${Capitalize&amp;lt;T&amp;gt;} ${Uncapitalize&amp;lt;T&amp;gt;}`;
​
type T5 = GetterName&amp;lt;'foo'&amp;gt;; &amp;nbsp;// "getFoo"
type T6 = Cases&amp;lt;'bar'&amp;gt;; &amp;nbsp;// "BAR bar Bar bar"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实，模板字面量类型的能力是很强大的，结合 TypeScript 的条件类型和 infer 关键字我们还可以实现类型推断。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Direction = "left" | "right" | "top" | "bottom";
type InferRoot&amp;lt;T&amp;gt; = T extends `${infer R}${Capitalize&amp;lt;Direction&amp;gt;}` ? R : T;
​
type T7 = InferRoot&amp;lt;"marginRight"&amp;gt;; // "margin"
type T8 = InferRoot&amp;lt;"paddingLeft"&amp;gt;; // "padding"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，InferRoot 工具类型除了利用模板字面量类型之外，还使用了 TypeScript 条件类型和 infer。如果你对这两个知识点，还不了解的话，可以观看 “用了 TS 条件类型，同事直呼 YYDS” 和 “学会 TS infer，写起泛型真香！” 这两期的视频。&lt;/p&gt;
&lt;p&gt;此外，TypeScript 4.1 版本允许我们使用 as 子句对映射类型中的键进行重新映射。它的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MappedTypeWithNewKeys&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T as NewKeyType]: T[K]
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  ^^^^^^^^^^^^^
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  This is the new syntax!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce1d6a2bbf14c92afb8a938e4b1093b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其中 NewKeyType 的类型必须是 string | number | symbol 联合类型的子类型。在重新映射的过程中，结合模板字面量类型所提供的能力，我们就可以实现一些有用的工具类型。比如，我们可以定义一个 Getters 工具类型，用于为对象类型生成对应的 Getter 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Getters&amp;lt;T&amp;gt; = {
  [K in keyof T as `get${Capitalize&amp;lt;string &amp;amp; K&amp;gt;}`]: () =&amp;gt; T[K]
};
​
interface Person {
 &amp;nbsp; &amp;nbsp;name: string;
 &amp;nbsp; &amp;nbsp;age: number;
 &amp;nbsp; &amp;nbsp;location: string;
}
​
type LazyPerson = Getters&amp;lt;Person&amp;gt;;
// {
// &amp;nbsp; getName: () =&amp;gt; string;
// &amp;nbsp; getAge: () =&amp;gt; number;
// &amp;nbsp; getLocation: () =&amp;gt; string;
// }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2b1d6b3ea74a5c9e96e8c77ff0d38e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，因为 keyof T 返回的类型可能会包含 symbol 类型，而 Capitalize 工具类型要求处理的类型需要是 string 类型的子类型，所以需要通过交叉运算符进行类型过滤。除了实现简单的工具类型之外，我们还可以实现比较复杂的工具类型。比如，用于获取对象类型中，任意层级属性的类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type PropType&amp;lt;T, Path extends string&amp;gt; = string extends Path
 &amp;nbsp;? unknown
  : Path extends keyof T
 &amp;nbsp;? T[Path]
  : Path extends `${infer K}.${infer R}`
 &amp;nbsp;? K extends keyof T
 &amp;nbsp; &amp;nbsp;? PropType&amp;lt;T[K], R&amp;gt;
 &amp;nbsp;  : unknown
  : unknown;
​
declare function getPropValue&amp;lt;T, P extends string&amp;gt;(
 &amp;nbsp;obj: T,
 &amp;nbsp;path: P
): PropType&amp;lt;T, P&amp;gt;;
​
const obj = { a: { b: { c: 666, d: "阿宝哥" } } };
let a = getPropValue(obj, "a"); // { b: {c: number, d: string } }
let ab = getPropValue(obj, "a.b"); // {c: number, d: string }
let abd = getPropValue(obj, "a.b.d"); // string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/640e69f0eb7647249c27c215528dea1b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，PropType 工具类型涉及 TypeScript 中的多个核心知识点。除了递归类型之外，条件类型、条件链和 infer 类型推断这些知识点，阿宝哥在往期的文章中都已经介绍了。而关于递归类型的知识点，阿宝哥将在后续的文章中介绍，感兴趣的话记得关注阿宝哥。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Tue, 07 Jun 2022 15:42:46 GMT</pubDate></item><item><title>type 和 interface 傻傻分不清楚？</title><link>https://juejin.cn/post/7098491203443752974</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;7.1 W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8776a0d30114fda90da2b96b6560d04~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1HB4y1y7KG"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1HB4y1y7KG&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你简历上的技能有写 TypeScript，那么面试官可能会问你 type 和 interface 之间有什么区别？你知道怎么回答这个问题么？如果不知道的话，那看完本文也许你就懂了。&lt;/p&gt;
&lt;p&gt;类型别名 type 可以用来给一个类型起个新名字，当命名基本类型或联合类型等非对象类型时非常有用：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MyNumber = number;
type StringOrNumber = string | number;
type Text = string | string[];
type Point = [number, number];
type Callback = (data: string) =&amp;gt; void;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95381b09336d425586700d28acfaf093~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在 TypeScript 1.6 版本，类型别名开始支持泛型。我们工作中常用的 Partial、Required、Pick、Record 和 Exclude 等工具类型都是以 type 方式来定义的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;// lib.es5.d.ts
type Partial&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [P in keyof T]?: T[P];
};
​
type Required&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [P in keyof T]-?: T[P];
};
​
type Pick&amp;lt;T, K extends keyof T&amp;gt; = {
 &amp;nbsp;  [P in K]: T[P];
};
​
type Record&amp;lt;K extends keyof any, T&amp;gt; = {
 &amp;nbsp;  [P in K]: T;
};
​
type Exclude&amp;lt;T, U&amp;gt; = T extends U ? never : T;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而接口 interface 只能用于定义对象类型，Vue 3 中的 App 对象就是使用 interface 来定义的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;// packages/runtime-core/src/apiCreateApp.ts
export interface App&amp;lt;HostElement = any&amp;gt; {
 &amp;nbsp;version: string
 &amp;nbsp;config: AppConfig
 &amp;nbsp;use(plugin: Plugin, ...options: any[]): this
 &amp;nbsp;mixin(mixin: ComponentOptions): this
 &amp;nbsp;component(name: string): Component | undefined // Getter
 &amp;nbsp;component(name: string, component: Component): this // Setter
 &amp;nbsp;directive(name: string): Directive | undefined
 &amp;nbsp;directive(name: string, directive: Directive): this
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上代码可知，在定义接口时，我们可以同时声明对象类型上的属性和方法。了解 type 和 interface 的作用之后，我们先来介绍一下它们的相似之处。&lt;/p&gt;
&lt;p&gt;1、类型别名和接口都可以用来描述对象或函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型别名&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Point = {
 &amp;nbsp;x: number;
 &amp;nbsp;y: number;
};
​
type SetPoint = (x: number, y: number) =&amp;gt; void;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们通过 type 关键字为对象字面量类型和函数类型分别取了一个别名，从而方便在其他地方使用这些类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface Point {
 &amp;nbsp;x: number;
 &amp;nbsp;y: number;
}
​
interface SetPoint {
  (x: number, y: number): void;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、类型别名和接口都支持扩展&lt;/p&gt;
&lt;p&gt;类型别名通过 &amp;amp;（交叉运算符）来扩展，而接口通过 extends 的方式来扩展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型别名扩展&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Animal = {
 &amp;nbsp;name: string
}
​
type Bear = Animal &amp;amp; { 
 &amp;nbsp;honey: boolean 
}
​
const bear: Bear = getBear() 
bear.name
bear.honey
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;接口扩展&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface Animal {
 &amp;nbsp;name: string
}
​
interface Bear extends Animal {
 &amp;nbsp;honey: boolean
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/032e6bb259724d1faf144e70a9f3ea72~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;此外，接口也可以通过 extends 来扩展类型别名定义的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Animal = {
 &amp;nbsp;name: string
}
​
interface Bear extends Animal {
 &amp;nbsp;honey: boolean
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，类型别名也可以通过 &amp;amp;（交叉运算符）来扩展已定义的接口类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface Animal {
 &amp;nbsp;name: string
}
​
type Bear = Animal &amp;amp; { 
 &amp;nbsp;honey: boolean 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3d9ebb1515b4a108a1b96abbbadb641~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;了解完 type 和 interface 的相似之处之后，接下来我们来介绍它们之间的区别。&lt;/p&gt;
&lt;p&gt;1、类型别名可以为基本类型、联合类型或元组类型定义别名，而接口不行&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MyNumber = number;
type StringOrNumber = string | number;
type Point = [number, number];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、同名接口会自动合并，而类型别名不会&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同名接口合并&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface User {
 &amp;nbsp;name: string;
}
​
interface User {
 &amp;nbsp;id: number;
}
​
let user: User = { id: 666, name: "阿宝哥" };
user.id; // 666
user.name; // "阿宝哥"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;同名类型别名会冲突&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type User = {
 &amp;nbsp;name: string;
};
​
// 标识符“User”重复。ts(2300)
type User = {
 &amp;nbsp;id: number;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e3634daa7704b62a8b845ac6c43ee54~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;利用同名接口自动合并的特性，在开发第三方库的时候，我们就可以为使用者提供更好的安全保障。比如 &lt;a href="https://github.com/antfu/webext-bridge"&gt;webext-bridge&lt;/a&gt; 这个库，使用 interface 定义了 ProtocolMap 接口，从而让使用者可自由地扩展 ProtocolMap 接口。之后，在利用该库内部提供的 &lt;code&gt;onMessage&lt;/code&gt; 函数监听自定义消息时，我们就可以推断出不同消息对应的消息体类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展 ProtocolMap 接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;import { ProtocolWithReturn } from 'webext-bridge'
​
declare module 'webext-bridge' {
 &amp;nbsp;export interface ProtocolMap {
 &amp;nbsp; &amp;nbsp;foo: { title: string }
 &amp;nbsp; &amp;nbsp;bar: ProtocolWithReturn&amp;lt;CustomDataType, CustomReturnType&amp;gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;监听自定义消息&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;import { onMessage } from 'webext-bridge'
​
onMessage('foo', ({ data }) =&amp;gt; {
 &amp;nbsp;// type of `data` will be `{ title: string }`
 &amp;nbsp;console.log(data.title)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62f570dafdab4662b32a23c41017b4cd~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你感兴趣的话，可以看一下该项目的源码。若遇到问题，可以跟阿宝哥交流。最后我们来总结一下类型别名和接口的一些使用场景。&lt;/p&gt;
&lt;p&gt;使用类型别名的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义基本类型的别名时，使用 type&lt;/li&gt;
&lt;li&gt;定义元组类型时，使用 type&lt;/li&gt;
&lt;li&gt;定义函数类型时，使用 type&lt;/li&gt;
&lt;li&gt;定义联合类型时，使用 type&lt;/li&gt;
&lt;li&gt;定义映射类型时，使用 type&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用接口的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要利用接口自动合并特性的时候，使用 interface&lt;/li&gt;
&lt;li&gt;定义对象类型且无需使用 type 的时候，使用 interface&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阅读完本文，相信你已经了解 type 和 interface 之间的区别了。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Mon, 16 May 2022 16:12:28 GMT</pubDate></item><item><title>用了 TS 条件类型，同事直呼 YYDS！</title><link>https://juejin.cn/post/7096265620445986823</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;5.2W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1HR4y1N7ea/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1HR4y1N7ea/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你用过 Exclude、Extract、NonNullable、Parameters 和 ReturnType 这些工具类型吗？&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Exclude&amp;lt;T, U&amp;gt; = T extends U ? never : T;
type Extract&amp;lt;T, U&amp;gt; = T extends U ? T : never;
type NonNullable&amp;lt;T&amp;gt; = T extends null | undefined ? never : T;
type Parameters&amp;lt;T extends (...args: any) =&amp;gt; any&amp;gt; = T extends (...args: infer P) =&amp;gt; any ? P : never;
type ReturnType&amp;lt;T extends (...args: any) =&amp;gt; any&amp;gt; = T extends (...args: any) =&amp;gt; infer R ? R : any;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你知道它们内部是如何工作的吗？&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18becb1cec4f4d63a8ac836a2f093f7a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你想彻底掌握它们且实现自己的工具类型，那么本文千万不要错过。前面看到的那些内置工具类型，它们内部使用了 TypeScript 2.8 版本引入的条件类型（Conditional Types）。该类型的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;T extends U ? X : Y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 T、U、X 和 Y 这些都是类型占位符。你可以这样理解该语法，当类型 T 可以赋值给类型 U 时，那么返回类型 X，否则返回类型 Y。看到这里你是不是也想到了 JavaScript 中的三元表达式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31c4ef5f3a864df4967d552fa22d06d5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么条件类型有什么用呢？这里我们来举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type IsString&amp;lt;T&amp;gt; = T extends string ? true : false;
​
type I0 = IsString&amp;lt;number&amp;gt;; &amp;nbsp;// false
type I1 = IsString&amp;lt;"abc"&amp;gt;; &amp;nbsp;// true
type I2 = IsString&amp;lt;any&amp;gt;; &amp;nbsp;// boolean
type I3 = IsString&amp;lt;never&amp;gt;; &amp;nbsp;// never
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c121684a93604a3290ee25bd257c1eb8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，我们定义了 IsString 工具类型。使用该工具类型，我们可以判断传给类型参数 T 的实际类型是否为字符串类型。除了判断单一类型之外，利用条件类型和条件链，我们还可以同时判断多种类型。&lt;/p&gt;
&lt;p&gt;接下来，我们来看一下如何实现该功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type TypeName&amp;lt;T&amp;gt; =
 &amp;nbsp; &amp;nbsp;T extends string ? "string" :
 &amp;nbsp; &amp;nbsp;T extends number ? "number" :
 &amp;nbsp; &amp;nbsp;T extends boolean ? "boolean" :
 &amp;nbsp; &amp;nbsp;T extends undefined ? "undefined" :
 &amp;nbsp; &amp;nbsp;T extends Function ? "function" :
 &amp;nbsp; &amp;nbsp;"object";
​
type T0 = TypeName&amp;lt;string&amp;gt;; &amp;nbsp;// "string"
type T1 = TypeName&amp;lt;"a"&amp;gt;; &amp;nbsp;// "string"
type T2 = TypeName&amp;lt;true&amp;gt;; &amp;nbsp;// "boolean"
type T3 = TypeName&amp;lt;() =&amp;gt; void&amp;gt;; &amp;nbsp;// "function"
type T4 = TypeName&amp;lt;string[]&amp;gt;; &amp;nbsp;// "object"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们定义了一个新的 TypeName 工具类型，在该工具类型中，我们使用了条件链。为了便于大家理解条件链，我们以 JavaScript 三元表达式为例，来演示一下它的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function example(…) {
 &amp;nbsp; &amp;nbsp;return condition1 ? value1
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : condition2 ? value2
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : condition3 ? value3
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : value4;
}
​
// 等价于
function example(…) {
 &amp;nbsp; &amp;nbsp;if (condition1) { return value1; }
 &amp;nbsp; &amp;nbsp;else if (condition2) { return value2; }
 &amp;nbsp; &amp;nbsp;else if (condition3) { return value3; }
 &amp;nbsp; &amp;nbsp;else { return value4; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在问题来了，对于前面定义的 TypeName 工具类型来说，如果传入的类型是联合类型的话，那么将返回什么结果？下面我们来验证一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T10 = TypeName&amp;lt;string | (() =&amp;gt; void)&amp;gt;; &amp;nbsp;// "string" | "function"
type T11 = TypeName&amp;lt;string | string[] | undefined&amp;gt;; &amp;nbsp;// "string" | "object" | "undefined"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96ce7f75210f42aea55f3cd2a4266c71~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为什么 T10 和 T11 类型返回的是联合类型呢？这是因为 TypeName 属于分布式条件类型。在条件类型中，如果被检查的类型是一个 “裸” 类型参数，即没有被数组、元组或 Promise 等包装过，则该条件类型被称为分布式条件类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0377755c894548e6b03c9b5ed42b1acb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;对于分布式条件类型来说，当传入的被检查类型是联合类型的话，在运算过程中会被分解成多个分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;T extends U ? X : Y 
T =&amp;gt; A | B | C 
A | B | C extends U ? X : Y &amp;nbsp;=&amp;gt; 
(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dd1ef3fea6f464992e875c18d6d03e6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为了便于大家理解，我们来举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Naked&amp;lt;T&amp;gt; = T extends boolean ? "Y" : "N";
​
type WrappedTuple&amp;lt;T&amp;gt; = [T] extends [boolean] ? "Y" : "N";
type WrappedArray&amp;lt;T&amp;gt; = T[] extends boolean[] ? "Y" : "N";
type WrappedPromise&amp;lt;T&amp;gt; = Promise&amp;lt;T&amp;gt; extends Promise&amp;lt;boolean&amp;gt; ? "Y" : "N";
​
type T0 = Naked&amp;lt;number | boolean&amp;gt;; // "N" | "Y"
type T1 = WrappedTuple&amp;lt;number | boolean&amp;gt;; // "N"
type T2 = WrappedArray&amp;lt;number | boolean&amp;gt;; // "N"
type T3 = WrappedPromise&amp;lt;number | boolean&amp;gt;; // "N"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上结果可知，如果条件类型中的类型参数 T 被包装过，该条件类型就不属于分布式条件类型，所以在运算过程中就不会被分解成多个分支。了解完条件类型和分布式条件类型的知识点，我们来举例演示一下 TypeScript 内置工具类型 Exclude 的执行流程。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Exclude&amp;lt;T, U&amp;gt; = T extends U ? never : T;
type T4 = Exclude&amp;lt;"a" | "b" | "c", "a" | "b"&amp;gt;
​
("a" extends "a" | "b" ? never : "a") // =&amp;gt; never
| ("b" extends "a" | "b" ? never : "b") // =&amp;gt; never
| ("c" extends "a" | "b" ? never : "c") // =&amp;gt; "c"
​
never | never | "c" // =&amp;gt; "c"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/281bb2aff49f4194b7a263e58050b169~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;掌握了条件类型之后，再结合往期文章中介绍的&lt;a href="https://juejin.cn/post/7089943758543781896"&gt;映射类型&lt;/a&gt;，我们就可以实现一些有用的工具类型。比如实现 FunctionProperties 和 NonFunctionProperties 等工具类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9091804aa8fb4f308e2149d01d0e3f6d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17ceace0ab244401b4e9a6afcf9e4906~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type FunctionPropertyNames&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];
type FunctionProperties&amp;lt;T&amp;gt; = Pick&amp;lt;T, FunctionPropertyNames&amp;lt;T&amp;gt;&amp;gt;;
​
type NonFunctionPropertyNames&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];
type NonFunctionProperties&amp;lt;T&amp;gt; = Pick&amp;lt;T, NonFunctionPropertyNames&amp;lt;T&amp;gt;&amp;gt;;
​
interface User {
 &amp;nbsp; &amp;nbsp;id: number;
 &amp;nbsp; &amp;nbsp;name: string;
 &amp;nbsp; &amp;nbsp;age: number;
 &amp;nbsp; &amp;nbsp;updateName(newName: string): void;
}
​
type T5 = FunctionPropertyNames&amp;lt;User&amp;gt;; // "updateName"
type T6 = FunctionProperties&amp;lt;User&amp;gt;; // { updateName: (newName: string) =&amp;gt; void; }
type T7 = NonFunctionPropertyNames&amp;lt;User&amp;gt;; // "id" | "name" | "age"
type T8 = NonFunctionProperties&amp;lt;User&amp;gt;; // { id: number; name: string; age: number; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，利用上述的工具类型，我们就可以轻松地提取 User 对象类型中函数类型和非函数类型的属性及相关的对象类型。&lt;/p&gt;
&lt;p&gt;阅读完本文之后，相信你已经了解条件类型和分布式条件类型的作用了，也知道 TS 内部一些工具类型是如何实现的。关于在条件类型中如何利用 infer 实现类型推断，阿宝哥将在后续的文章中介绍。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Tue, 10 May 2022 16:18:52 GMT</pubDate></item><item><title>14.4W 播放量的 TS 动画版进阶教程合集来了！</title><link>https://juejin.cn/post/7095547569777934367</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: orange&lt;/h2&gt;
&lt;p&gt;阿宝哥精心准备的 &lt;strong&gt;&lt;a href="https://space.bilibili.com/406258607"&gt;《轻松学 TypeScript》&lt;/a&gt;&lt;/strong&gt; 视频教程来咯，强烈推荐！通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！目前已更新到第 &lt;strong&gt;19&lt;/strong&gt; 期，其中 1 期的观看量已破 2 W，该合集的播放量目前已达 14.4W+🔥🔥🔥。&lt;/p&gt;
&lt;p&gt;👇 新的一期已经发布了，感兴趣的小伙伴一起学起来。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cfbfe60f59748a7884fbeb96e916674~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你已掌握 TS 的话，那就来做做这 &lt;strong&gt;48&lt;/strong&gt; 道 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247495521&amp;amp;idx=1&amp;amp;sn=dd26b5b4f2cd2c78dcbcc9fd15b27df7&amp;amp;scene=21#wechat_redirect"&gt;TS 练习题&lt;/a&gt;。如果还没开始学 TS 的话，可以先看看 &lt;a href="https://juejin.cn/post/6872111128135073806"&gt;「1.8W字」不可多得的 TS 入门教程&lt;/a&gt;（4347个👍）&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk/"&gt;TypeScript 泛型中的 T、K、V 等到底是个啥？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/d5XUpAA_hG4TL8sBTCPlog"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TypeScript 泛型中的 K、T、V 等变量！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1040d61451f4b89b7a18a9267386fee~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1Wr4y1J7x3/"&gt;用了 TS 映射类型，同事直呼内行！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1Wr4y1J7x3/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/uhL9VZuKg1-CtnGlI0YO7A"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过生动形象的动画，让你搞清楚 TS 内置工具类型的工作原理，同时掌握 TS 映射类型相关语法及重要的知识点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f61f13585fc437fa0ee1c9eed159dfb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1JS4y1Y7Jy/"&gt;Vue 3 中使用的函数重载有啥用？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1JS4y1Y7Jy/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/kyOff_lCrKXWhyAamm-Prw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 Vue3 响应式模块 ref 函数所使用的重载技术，同时了解函数重载和方法重载相关的知识点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d192edf3a4fc48cd9ce7d894fa0d4d92~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1HB4y1y7KG/"&gt;type 和 interface 傻傻分不清楚？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1HB4y1y7KG/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/C-n1vkfv2pATT2fjdNLjmQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TypeScript type 和 interface 之间的区别，还有一个开发 TS 库时，值得学习的 “黑科技”。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0ecd507f53448329e2ee6bd7d5fb2e0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1WR4y1P7dw/"&gt;TypeScript 你还只会用 any？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1WR4y1P7dw/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/-83tlUcG2mOm79nVI2pu3g"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让你轻松搞懂 any 类型和 unknown 类型的区别及在不同场景中的表现。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6564211db2e94d83aa56dbfb6cc757f4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1HR4y1N7ea/"&gt;用了 TS 条件类型，同事直呼 YYDS！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1HR4y1N7ea/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/y-N265ULBluzwnmRGNs2Xg"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以后看到 T extends U ? X : Y 再也不怕了。精心设计设计的动画，让你轻松掌握条件类型、分布式条件类型和 TS 内置工具类型的工作原理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72fd06c2e4a94b36b05fb8162c7698fd~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1qv4y1P7D2/"&gt;学了 TS infer，我也会类型推断了！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1qv4y1P7D2/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/3QlkoSWyPrsNj1Sc8DvzJQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看完本期视频，你就可以轻松地使用条件类型和 infer 来开发各种工具类型实现类型推断。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afbbc8d141b9446dbba202105b3d66a4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1QY411T7Vn"&gt;TS 4.7 版本新特性，让 infer 更简单&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1QY411T7Vn"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/68iX9xt9QbBXzeP4QKF1mQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看完本期视频之后，让你写的 infer 类型推断更加简洁。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44df990ac3fd4be0b9795de230b5ed86~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1B34y1E7tm"&gt;用了模板字面量类型，同事直呼太强了！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1B34y1E7tm"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/Q8MpOTB77SdipwUVrc3Jyw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;模板字面量类型减少重复代码的利器，结合条件类型、映射类型和infer类型推断，你就能轻松应对工作中遇到的问题！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a330e5207c2444e3bbbfa4987d0c28bc~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1RF411T7zu/"&gt;搞懂 TypeScript 交叉类型的多个知识点！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1RF411T7zu/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/OnLXfjpnR9guQbROINIaag"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让你轻松理解交叉类型并掌握其核心知识点，学完后结合映射类型就可以根据工作需要实现一些自定义工具类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34997d985eec49d89dbf44fbea3236ab~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1jY4y1i7Lh/"&gt;搞懂 TypeScript 联合类型的多个知识点！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1jY4y1i7Lh/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/C_sD6oHwngJ-dU4tev5MQw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞懂 TypeScript 联合类型的多个知识点及应用场景！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2150a24e4f040a89c99c085a3cd5733~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1Zq4y1a79K/"&gt;TypeScript 中的类型到底是个啥？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1Zq4y1a79K/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/dL-G-BypnUMHE9e-MAlQwg"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过形象生动的动画，让你搞懂 TypeScript 的类型，打好进阶 TS 的基础！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0358dc1403b9423da920ac054f337a85~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1RY411A7YS/"&gt;仅知道键和值的类型，如何定义 TS 对象类型？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1RY411A7YS/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/L2sIMye6fo5-VnRccMWXqA"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚索引签名、Record 内置工具类型的使用场景和区别。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e6bb3363f84e6ca31651c5e508ac35~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1nT4y1a7AR/"&gt;TS 内置工具类型中的 keyof 操作符有啥用？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1nT4y1a7AR/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/QPAKjiYamib6HPItgqZEsw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TS 内置工具类型中 keyof 操作符的作用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ecd075b0ca44a26be4abb78a3d9733b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1P94y127pd"&gt;TS typeof 操作符，原来有这五种用途！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1P94y127pd/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/ptqYjU_0CQO-J88LsULcRQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TS 内置工具类型中 typeof 操作符的 5 大应用场景。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f89ac4a46634920af534ec42cd39506~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1254y1Z7BL/"&gt;减少 TS 重复代码，Omit 用起来真香！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1254y1Z7BL/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/sty4oaMCCbmjWAcrAOAJmA"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看完之后让你一次搞懂 TS 内置工具类型 Omit 的应用场景和内部实现原理！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8672c2253e3c4df483a79f24b048aa7a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1Da411J7jj/"&gt;听说你熟悉 Pick，那就来手写一个 MyPick！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1Da411J7jj/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/fGWen-uWviauRxF0zmseLw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类型体操开始热身了，看完之后让你一次搞懂 TS 内置工具类型 Pick 的内部实现原理！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eb7eb148f914b9c9b88f6437b33a06d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;《轻松学 TypeScript》 已发布 &lt;strong&gt;19 期&lt;/strong&gt; ，肝视频不易，如果对你有帮助的话，欢迎&lt;strong&gt;点赞与分享&lt;/strong&gt;，谢谢大家！你对 TS 哪方面比较感兴趣，可以给我留言呀！&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Sun, 08 May 2022 17:48:51 GMT</pubDate></item><item><title>用了 TS 映射类型，同事直呼内行！</title><link>https://juejin.cn/post/7089943758543781896</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1Wr4y1J7x3/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1Wr4y1J7x3/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你用过&amp;nbsp;Partial、Required、Pick 和 Readonly 这些工具类型吗？&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9e45e9defd947fe8d3da222adb9b54c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;你知道它们内部是如何工作的吗？&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb55806af6834dbe87d7844753821da7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你想彻底掌握它们且实现自己的工具类型，那么本文介绍的内容千万不要错过。&lt;/p&gt;
&lt;p&gt;在日常工作中，用户注册是一个很常见的场景。这里我们可以使用 TS 定义一个 User 类型，在该类型中所有的键都是必填的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type User = {
 &amp;nbsp;name: string; // 姓名
 &amp;nbsp;password: string; // 密码
 &amp;nbsp;address: string; // 地址
 &amp;nbsp;phone: string; // 联系电话
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常情况下，对于已注册的用户，我们是允许用户只修改部分用户信息。这时我们就可以定义一个新的 UserPartial 类型，表示用于更新的用户对象的类型，在该类型中所有的键都是可选的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type UserPartial = {
 &amp;nbsp;name?: string; // 姓名
 &amp;nbsp;password?: string; // 密码
 &amp;nbsp;address?: string; // 地址
 &amp;nbsp;phone?: string; // 联系电话
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53c621d50d3b4c62a493ab1a67387fb2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;而对于查看用户信息的场景，我们希望该用户对象所对应的对象类型中所有的键都是只读。针对这种需求，我们可以定义 ReadonlyUser 类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type ReadonlyUser = {
 &amp;nbsp;readonly name: string; // 姓名
 &amp;nbsp;readonly password: string; // 密码
 &amp;nbsp;readonly address: string; // 地址
 &amp;nbsp;readonly phone: string; // 联系电话
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d10197e269d54e49a5b1d3856eab1382~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;回顾前面已定义的与用户相关的 3 种类型，你会发现它们中含有很多重复的代码。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21c4f436353d4523bf32379ffcf6f6a2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么如何减少以上类型中的重复代码呢？&lt;/p&gt;
&lt;p&gt;答案是可以使用映射类型，&lt;strong&gt;它是一种泛型类型，可用于把原有的对象类型映射成新的对象类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74cb5f53f5974c8e8216910671f7a446~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a042030efe54889beabc03ec2d55f68~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;映射类型的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;{ [ P in K ] : T }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0f423e206294a7a9d3fb94b16182869~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其中 P in K 类似于 JavaScript 中的 &lt;code&gt;for...in&lt;/code&gt; 语句，用于遍历 K 类型中的所有类型，而 T 类型变量用于表示 TS 中的任意类型。&lt;/p&gt;
&lt;p&gt;在映射的过程中，你还可以使用 &lt;code&gt;readonly&lt;/code&gt; 和问号这两个额外的修饰符。通过添加加号和减号前缀，来增加和移除对应的修饰符。如果没有添加任何前缀的话，默认是使用加号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87caca9a43644334aefadb47adc1a700~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;现在我们就可以总结出常见的映射类型语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;{ [ P in K ] : T }
{ [ P in K ] ?: T }
{ [ P in K ] -?: T }
{ readonly [ P in K ] : T }
{ readonly [ P in K ] ?: T }
{ -readonly [ P in K ] ?: T }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;介绍完映射类型的语法，我们来看一些具体的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type Item = { a: string; b: number; c: boolean };

type T1 = { [P in "x" | "y"]: number }; // { x: number, y: number }
type T2 = { [P in "x" | "y"]: P }; // { x: "x", y: "y" }
type T3 = { [P in "a" | "b"]: Item[P] }; // { a: string, b: number }
type T4 = { [P in keyof Item]: Item[P] }; // { a: string, b: number, c: boolean }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们来看一下如何利用映射类型来重新定义 UserPartial 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type MyPartial&amp;lt;T&amp;gt; = {
  [P in keyof T]?: T[P];
};

type UserPartial = MyPartial&amp;lt;User&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们定义了 MyPartial 映射类型，然后利用该类型把 User 类型映射成 UserPartial 类型。其中 keyof 操作符用于获取某种类型中的所有键，其返回类型是联合类型。而类型变量 P 会随着每次遍历改变成不同的类型，&lt;code&gt;T[P]&lt;/code&gt; 该语法类似于属性访问的语法，用于获取对象类型某个属性对应值的类型。&lt;/p&gt;
&lt;p&gt;下面我们来演示一下 MyPartial 映射类型的完整执行流程，如果不清楚的话，可以多看几遍加深对 TS 映射类型的理解。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f61f13585fc437fa0ee1c9eed159dfb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;TypeScript 4.1 版本允许我们使用 as 子句对映射类型中的键进行重新映射。它的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type MappedTypeWithNewKeys&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T as NewKeyType]: T[K]
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  ^^^^^^^^^^^^^
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  这是新的语法！
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b502a3a628ca40a6baef42699d5950b2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其中 NewKeyType 的类型必须是 string | number | symbol 联合类型的子类型。使用 as 子句，我们可以定义一个 Getters 工具类型，用于为对象类型生成对应的 Getter 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type Getters&amp;lt;T&amp;gt; = {
  [K in keyof T as `get${Capitalize&amp;lt;string &amp;amp; K&amp;gt;}`]: () =&amp;gt; T[K]
};

interface Person {
 &amp;nbsp; &amp;nbsp;name: string;
 &amp;nbsp; &amp;nbsp;age: number;
 &amp;nbsp; &amp;nbsp;location: string;
}

type LazyPerson = Getters&amp;lt;Person&amp;gt;;
// {
// &amp;nbsp; getName: () =&amp;gt; string;
// &amp;nbsp; getAge: () =&amp;gt; number;
// &amp;nbsp; getLocation: () =&amp;gt; string;
// }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc4109e65fb4c96ac64975f9884f2c9~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，因为 keyof T 返回的类型可能会包含 symbol 类型，而 Capitalize 工具类型要求处理的类型需要是 string 类型的子类型，所以需要通过交叉运算符进行类型过滤。&lt;/p&gt;
&lt;p&gt;此外，在对键进行重新映射的过程中，我们可以通过返回 never 类型对键进行过滤：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;// Remove the 'kind' property
type RemoveKindField&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T as Exclude&amp;lt;K, "kind"&amp;gt;]: T[K]
};

interface Circle {
 &amp;nbsp; &amp;nbsp;kind: "circle";
 &amp;nbsp; &amp;nbsp;radius: number;
}

type KindlessCircle = RemoveKindField&amp;lt;Circle&amp;gt;;
// &amp;nbsp; type KindlessCircle = {
// &amp;nbsp; &amp;nbsp; &amp;nbsp; radius: number;
// &amp;nbsp; };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8018d739e8a4521b5121d1b7a5a9cea~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;看完本文之后，相信你已经了解映射类型的作用了，也知道 TS 内部一些工具类型是如何实现的。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c424563ccc6941f7b7c43771e36fe5c0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk"&gt;TypeScript 泛型中的 K、T、V 等到底是个啥？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://space.bilibili.com/406258607"&gt;轻松学 TypeScript&lt;/a&gt; 视频教程已更新了 7 集，本专题将会以形象生动的动画，带你一起学习 TypeScript 核心知识点，感兴趣的小伙伴一起学起来呀！&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Sat, 23 Apr 2022 15:26:03 GMT</pubDate></item><item><title>【动画演示】TypeScript 泛型中的 K、T、V 等到底是个啥？</title><link>https://juejin.cn/post/7084410879223005215</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1sY4y1H7vk/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你首次看到 TypeScript 泛型中的 &lt;strong&gt;T&lt;/strong&gt; 会感到陌生么？&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-1.gif" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdb08f75963b4b53af2973cbc7a29123~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;图中的 T 被称为&lt;strong&gt;泛型变量&lt;/strong&gt;，它是我们希望传递给 identity 函数的&lt;strong&gt;类型占位符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就像传递参数一样，我们把用户指定的实际类型，链式传递给参数类型和返回值类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-2.gif" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1040d61451f4b89b7a18a9267386fee~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么 T 是什么意思呢？图中的泛型变量 T 表示 Type，实际上 T 可以用任何有效的名称代替。除了 T 之外，常见的泛型变量还有 K、V 和 E 等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K 全称 &lt;strong&gt;Key&lt;/strong&gt; 表示对象中键的类型；&lt;/li&gt;
&lt;li&gt;V 全称 &lt;strong&gt;Value&lt;/strong&gt; 表示对象中值的类型；&lt;/li&gt;
&lt;li&gt;E 全称 &lt;strong&gt;Element&lt;/strong&gt; 表示元素类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="泛型变量-3.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/674dbfa8db5144b3ab94df084a2519e8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;当然你并不是只能定义一个类型变量，你可以引入任何数量的类型变量。这里我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数。&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-4.gif" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dec767a1a264da18b105830d8068714~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在调用 identity 函数时，我们可以显式指定泛型变量的实际类型。
当然你也可以不指定泛型变量的类型，让 TypeScript 自动帮我们完成类型推断。&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-5.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05c1a7120f49447f9d90966ae256b469~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;看完以上动画，你是不是已经理解泛型变量了？如果看懂的话，欢迎在评论区留言。看完觉得意犹未尽，那你可以继续阅读阿宝哥之前写的 &lt;a href="https://mp.weixin.qq.com/s/jF0ZEGM9BRQgyKPZ9W9MpA"&gt;你不知道的 TypeScript 泛型&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;p&gt;最后你喜欢以这种形式学 &lt;strong&gt;TS&lt;/strong&gt; 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Fri, 08 Apr 2022 17:32:45 GMT</pubDate></item><item><title>又一个基于 Esbuild 的神器！</title><link>https://juejin.cn/post/7065465955987488776</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 并不支持直接执行 TS 文件，如果要执行 TS 文件的话，我们就可以借助 &lt;a href="https://github.com/TypeStrong/ts-node"&gt;ts-node&lt;/a&gt; 这个库。相信有些小伙伴在工作中也用过这个库，关于 &lt;a href="https://github.com/TypeStrong/ts-node"&gt;ts-node&lt;/a&gt; 这个库的相关内容我就不展开介绍了，因为本文的主角是由 &lt;strong&gt;antfu&lt;/strong&gt; 大佬开源的 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 项目，接下来我将带大家一起来揭开这个项目背后的秘密。&lt;/p&gt;
&lt;p&gt;阅读完本文后，你将了解 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 项目是如何执行 TS 文件。此外，你还会了解如何劫持 Node.js 的 require 函数、如何为 ES Module 的 import 语句添加钩子及如何自定义 https 加载器，以支持 &lt;code&gt;import React from "https://esm.sh/react"&lt;/code&gt; 导入方式。&lt;/p&gt;
&lt;h3&gt;esno 是什么&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 是基于 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 的 TS/ESNext node 运行时。该库会针对不同的模块化标准，采用不同的方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;esno&lt;/code&gt; - Node in CJS mode - by &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;esmo&lt;/code&gt; - Node in ESM mode - by &lt;a href="https://github.com/antfu/esbuild-node-loader"&gt;esbuild-node-loader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 的方式很简单，你可以以全局或局部的方式来安装它：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局安装&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ npm i -g esno
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在安装成功后，你就可以通过以下方式来直接执行 TS 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ esno index.ts
$ esmo index.ts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;局部安装&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ npm i esno
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而对于局部安装的方式来说，一般情况下，我们会以 &lt;strong&gt;npm scripts&lt;/strong&gt; 的方式来使用它：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  "scripts": {
    "start": "esno index.ts"
  },
  "dependencies": {
    "esno": "0.14.0"
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;esno 是如何工作的&lt;/h3&gt;
&lt;p&gt;在开始分析 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 的工作原理之前，我们先来熟悉一下该项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;├── LICENSE
├── README.md
├── esmo.mjs
├── esno.js
├── package.json
├── pnpm-lock.yaml
├── publish.ts
└── tsconfig.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上的项目结构可知，该项目并不会复杂。在项目根目录下的 &lt;strong&gt;package.json&lt;/strong&gt; 文件中，我们看到了前面介绍的 &lt;strong&gt;esno&lt;/strong&gt; 和 &lt;strong&gt;esmo&lt;/strong&gt; 命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  "bin": {
    "esno": "esno.js",
    "esmo": "esmo.mjs"
  },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，在 &lt;strong&gt;package.json&lt;/strong&gt; 的 &lt;strong&gt;scripts&lt;/strong&gt; 字段中，我们发现了 &lt;strong&gt;release&lt;/strong&gt; 命令。顾名思义，该命令用来发布版本。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  "scripts": {
    "release": "npx bumpp --tag --commit --push &amp;amp;&amp;amp; node esmo.mjs publish.ts"
  },
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，在 &lt;code&gt;publish.ts&lt;/code&gt; 文件中，使用到了 2021 年度 Github 上最耀眼的项目 &lt;a href="https://github.com/google/zx"&gt;zx&lt;/a&gt;，利用该项目我们可以轻松地编写命令行脚本。写作本文时，它的 Star 数已经高达 &lt;strong&gt;27.5K&lt;/strong&gt;，强烈推荐感兴趣的小伙伴关注一下该项目。&lt;/p&gt;
&lt;p&gt;简单介绍了 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 项目之后，接下来我们来分析 &lt;code&gt;esno.js&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;#!/usr/bin/env node

const spawn = require('cross-spawn')
const spawnSync = spawn.sync

const register = require.resolve('esbuild-register')

const argv = process.argv.slice(2)

process.exit(spawnSync('node', ['-r', register, ...argv], 
  { stdio: 'inherit' }).status)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上代码可知，当执行 &lt;code&gt;esno index.ts&lt;/code&gt; 命令后，会通过 &lt;code&gt;spawnSync&lt;/code&gt; 来启动 &lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 程序执行脚本。需要注意的是，在执行时使用了 &lt;code&gt;-r&lt;/code&gt; 选项，该选项的作用是预加载模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; -r, --require = ... module to preload (option can be repeated)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里预加载的模块是 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt;，该模块就是 &lt;strong&gt;esno&lt;/strong&gt; 命令执行 TS 文件的幕后英雄。&lt;/p&gt;
&lt;h3&gt;esbuild-register 是什么&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 是一个基于 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 来转换 JSX、TS 和 esnext 特性的工具。你可以通过以下多种方式来安装它：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ npm i esbuild esbuild-register -D
# Or Yarn
$ yarn add esbuild esbuild-register --dev
# Or pnpm
$ pnpm add esbuild esbuild-register -D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在成功安装该模块之后，就可以在命令行中，直接通过 &lt;code&gt;node&lt;/code&gt; 应用程序来执行 ts 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node -r esbuild-register file.ts
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;-r, --require  =  ... module to preload (option can be repeated)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-r&lt;/code&gt; 用于指定预加载的文件，即在执行 &lt;code&gt;file.ts&lt;/code&gt; 文件前，提前加载 &lt;code&gt;esbuild-register&lt;/code&gt; 模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它将会使用 &lt;code&gt;tsconfig.json&lt;/code&gt; 中的 &lt;code&gt;jsxFactory&lt;/code&gt;, &lt;code&gt;jsxFragmentFactory&lt;/code&gt; 和 &lt;code&gt;target&lt;/code&gt; 配置项来执行转换操作。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 不仅可以在命令行中使用，而且还可以通过 API 的方式进行使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const { register } = require('esbuild-register/dist/node')

const { unregister } = register({
  // ...options
})

// Unregister the require hook if you don't need it anymore
unregister()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;了解完 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 的基本使用之后，接下来我们来分析它内部是如何工作的。&lt;/p&gt;
&lt;h3&gt;esbuild-register 是如何工作的&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 内部利用了 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库来劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数，从而让你可以在命令行中，直接执行 &lt;code&gt;ts&lt;/code&gt; 文件。下面我们来看一下 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 模块中定义的 &lt;code&gt;register&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;// esbuild-register/src/node.ts
import { transformSync, TransformOptions } from 'esbuild'
import { addHook } from 'pirates'

export function register(esbuildOptions: RegisterOptions = {}) {
  const {
    extensions = DEFAULT_EXTENSIONS,
    hookIgnoreNodeModules = true,
    hookMatcher,
    ...overrides
  } = esbuildOptions

  // 利用 transformSync 
  const compile: COMPILE = function compile(code, filename, format) {
    const dir = dirname(filename)
    const options = getOptions(dir)
    format = format ?? inferPackageFormat(dir, filename)

    const {
      code: js,
      warnings,
      map: jsSourceMap,
    } = transformSync(code, {
      sourcefile: filename,
      sourcemap: 'both',
      loader: getLoader(filename),
      target: options.target,
      jsxFactory: options.jsxFactory,
      jsxFragment: options.jsxFragment,
      format,
      ...overrides,
    })
// 省略部分代码
  }

  const revert = addHook(compile, {
    exts: extensions,
    ignoreNodeModules: hookIgnoreNodeModules,
    matcher: hookMatcher,
  })

  return {
    unregister() {
      revert()
    },
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上的代码可知，在 &lt;code&gt;register&lt;/code&gt; 函数内部是利用 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 模块提供的 &lt;code&gt;transformSync&lt;/code&gt; API 来实现 &lt;strong&gt;ts -&amp;gt; js&lt;/strong&gt; 代码的转换。其实最关键的环节，还是通过调用 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库提供的 &lt;code&gt;addHook&lt;/code&gt; 函数来注册编译 ts 文件的钩子。
那么 &lt;code&gt;addHook&lt;/code&gt; 函数内部到底做了哪些处理呢？下面我们来看一下它的实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// pirates-4.0.5/src/index.js
export function addHook(hook, opts = {}) {
  let reverted = false;
  const loaders = []; // 存放新的loader
  const oldLoaders = []; // 存放旧的loader
  let exts;

  const originalJSLoader = Module._extensions['.js']; // 原始的JS Loader 
  // 省略部分代码
  exts.forEach((ext) =&amp;gt; {
    // 获取已注册的loader，若未找到，则默认使用JS Loader
    const oldLoader = Module._extensions[ext] || originalJSLoader;
    oldLoaders[ext] = Module._extensions[ext];

    loaders[ext] = Module._extensions[ext] = function newLoader(
  mod, filename) {
      let compile;
      if (!reverted) {
        if (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {
          compile = mod._compile;
          mod._compile = function _compile(code) {
// 这里需要恢复成原来的_compile函数，否则会出现死循环
            mod._compile = compile;
// 在编译前先执行用户自定义的hook函数
            const newCode = hook(code, filename);
            if (typeof newCode !== 'string') {
              throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);
            }

            return mod._compile(newCode, filename);
          };
        }
      }

       oldLoader(mod, filename);
     };
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实 &lt;code&gt;addHook&lt;/code&gt; 函数的实现并不会复杂，该函数内部就是通过替换 &lt;code&gt;mod._compile&lt;/code&gt; 方法来实现钩子的功能。即在调用原始的 &lt;code&gt;mod._compile&lt;/code&gt; 方法进行编译前，会先调用 &lt;code&gt;hook(code, filename)&lt;/code&gt; 函数来执行用户自定义的 &lt;code&gt;hook&lt;/code&gt; 函数，从而对代码进行预处理。&lt;/p&gt;
&lt;p&gt;而对于 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 库中的 &lt;code&gt;register&lt;/code&gt; 函数来说，当 &lt;code&gt;hook&lt;/code&gt; 函数执行时，就会调用该函数内部定义的 &lt;code&gt;compile&lt;/code&gt; 函数来编译 ts 代码，然后再调用 &lt;code&gt;mod._compile&lt;/code&gt; 方法编译生成的 &lt;code&gt;js&lt;/code&gt; 代码。&lt;/p&gt;
&lt;p&gt;关于 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 和 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这两个库的内容就先介绍到这里，如果你想详细了解 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库是如何工作的，可以阅读 &lt;a href="https://mp.weixin.qq.com/s/BFu4SouMdXFYLELRjHhUyg"&gt;如何为 Node.js 的 require 函数添加钩子？&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;p&gt;现在我们已经分析完 &lt;code&gt;esno.js&lt;/code&gt; 文件，接下来我们来分析 &lt;code&gt;esmo.mjs&lt;/code&gt; 文件。&lt;/p&gt;
&lt;h3&gt;esmo 是如何工作的&lt;/h3&gt;
&lt;p&gt;esmo 命令对应的是 esmo.mjs 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;#!/usr/bin/env node

import spawn from 'cross-spawn'
import { resolve } from 'import-meta-resolve'
const spawnSync = spawn.sync

const argv = process.argv.slice(2)
resolve('esbuild-node-loader', import.meta.url).then((path) =&amp;gt; {
  process.exit(spawnSync('node', ['--loader', path, ...argv], 
{ stdio: 'inherit' }).status)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上代码可知，当使用 node 应用程序执行 ES Module 文件时，会通过 &lt;code&gt;--loader&lt;/code&gt; 选项来指定自定义的 ES Module 加载器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; --loader, --experimental-loader = ... use the specified module as a custom loader
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，通过 &lt;code&gt;--loader&lt;/code&gt; 选项指定的自定义加载器只适用于 ES Module 的 import 调用，并不适用于 CommonJS 的 require 调用。&lt;/p&gt;
&lt;p&gt;那么自定义加载器有什么作用呢？在当前最新的 Node.js v17.4.0 版本中，还不支持以 &lt;code&gt;https://&lt;/code&gt; 开头的说明符。我们可以在自定义加载器中，利用 Node.js 提供的钩子机制，让 Node.js 可以使用 &lt;code&gt;import&lt;/code&gt; 导入以 &lt;code&gt;https://&lt;/code&gt; 协议开头的 ES 模块。&lt;/p&gt;
&lt;p&gt;在分析如何自定义 &lt;code&gt;https&lt;/code&gt; 资源加载器前，我们需要先介绍一下 import 说明符的概念。&lt;/p&gt;
&lt;h4&gt;import 说明符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 语句的说明符是 &lt;code&gt;from&lt;/code&gt; 关键字之后的字符串，例如 &lt;code&gt;import { sep } from 'path'&lt;/code&gt; 中的 &lt;code&gt;'path'&lt;/code&gt;。 说明符也用于 &lt;code&gt;export from&lt;/code&gt; 语句，并作为 &lt;code&gt;import()&lt;/code&gt; 表达式的参数。&lt;/p&gt;
&lt;p&gt;有三种类型的说明符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相对说明符，如 &lt;code&gt;'./startup.js'&lt;/code&gt; 或 &lt;code&gt;'../config.mjs'&lt;/code&gt;。它们指的是相对于导入文件位置的路径。对于这种类型，文件扩展名是必须的。&lt;/li&gt;
&lt;li&gt;裸说明符，如 &lt;code&gt;'some-package'&lt;/code&gt; 或 &lt;code&gt;'some-package/shuffle'&lt;/code&gt;。它们可以通过包名来引用包的主入口点。当包没有 &lt;code&gt;exports&lt;/code&gt; 字段的时候，才需要包含文件扩展名。&lt;/li&gt;
&lt;li&gt;绝对说明符，如 &lt;code&gt;file:///opt/nodejs/config.js&lt;/code&gt;。它们直接且明确地引用完整路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;裸说明符解析由 &lt;a href="https://nodejs.org/api/esm.html#resolver-algorithm-specification"&gt;Node.js 模块解析算法&lt;/a&gt;处理，所有其他说明符解析始终仅使用标准的相对&lt;a href="https://url.spec.whatwg.org/"&gt;URL&lt;/a&gt; 解析语义进行解析。&lt;/p&gt;
&lt;p&gt;和 CommonJS 一样，包内的模块文件可以通过在包名上添加路径来访问，除非包的 package.json 包含一个 "exports " 字段，在这种情况下，包中的文件只能通过 "exports " 中定义的路径访问。&lt;/p&gt;
&lt;p&gt;介绍完 import 说明符之后，接下来我们来看一下如何自定义 https 加载器。&lt;/p&gt;
&lt;h4&gt;自定义 https 加载器&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;resolve 钩子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resolve&lt;/code&gt; 钩子用于根据模块的说明符和 &lt;code&gt;parentURL&lt;/code&gt; 生成导入目标的绝对路径，调用该钩子后会返回一个包含 &lt;code&gt;format&lt;/code&gt;（可选） 和 &lt;code&gt;url&lt;/code&gt; 属性的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// https-loader.mjs
import { get } from 'https';

export function resolve(specifier, context, defaultResolve) {
  const { parentURL = null } = context;

  if (specifier.startsWith('https://')) {
    return {
      url: specifier
    };
  } else if (parentURL &amp;amp;&amp;amp; parentURL.startsWith('https://')) {
    return {
      url: new URL(specifier, parentURL).href
    };
  }

  // 让 Node.js 处理其它的说明符
  return defaultResolve(specifier, context, defaultResolve);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，会先判断 &lt;code&gt;specifier&lt;/code&gt; 字符串是否以 &lt;code&gt;'https://'&lt;/code&gt; 开头，如果条件满足的话，该字符串的值直接作为 &lt;code&gt;url&lt;/code&gt; 属性的值，直接返回 &lt;code&gt;{ url: specifier }&lt;/code&gt; 对象。否则，会判断 &lt;code&gt;parentURL&lt;/code&gt; 是否以 &lt;code&gt;'https://'&lt;/code&gt; 开头，如果条件满足的话，则会调用 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/URL"&gt;URL&lt;/a&gt; 构造函数，创建 URL 对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;parentURL&lt;/code&gt; 是从 &lt;code&gt;context&lt;/code&gt; 对象上获取的，那它什么时候会有值呢？假设在 ES 模块 A 中，以相对路径的形式导入 ES 模块 B。在导入 ES 模块 B 时，也会调用 &lt;code&gt;resolve&lt;/code&gt; 钩子，此时 &lt;code&gt;context&lt;/code&gt; 对象上的 &lt;code&gt;parentURL&lt;/code&gt; 就会有值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;load 钩子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;load&lt;/code&gt; 钩子用于定义应该如何解释、检索和解析 URL 的方法，调用该方法后，会返回包含 &lt;code&gt;format&lt;/code&gt; 和 &lt;code&gt;source&lt;/code&gt; 属性的对象。其中 &lt;code&gt;format&lt;/code&gt; 属性值只能是 &lt;code&gt;'builtin'&lt;/code&gt;、&lt;code&gt;'commonjs'&lt;/code&gt;、&lt;code&gt;'json'&lt;/code&gt;、&lt;code&gt;'module'&lt;/code&gt; 和 &lt;code&gt;'wasm'&lt;/code&gt; 中的一种。而 &lt;code&gt;source&lt;/code&gt; 属性值的类型可以为 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;ArrayBuffer&lt;/code&gt; 或 &lt;code&gt;TypedArray&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;import { get } from 'https';

export function load(url, context, defaultLoad) {
  if (url.startsWith('https://')) {
    return new Promise((resolve, reject) =&amp;gt; {
      get(url, (res) =&amp;gt; {
        let data = '';
        res.on('data', (chunk) =&amp;gt; data += chunk);
        res.on('end', () =&amp;gt; resolve({
          format: 'module',
          source: data,
        }));
      }).on('error', (err) =&amp;gt; reject(err));
    });
  }

  // 让 Node.js 加载其它类型的文件
  return defaultLoad(url, context, defaultLoad);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，会通过 &lt;code&gt;https&lt;/code&gt; 模块中的 &lt;code&gt;get&lt;/code&gt; 函数来加载 &lt;code&gt;https://&lt;/code&gt; 协议的 ES 模块。如果不是以 &lt;code&gt;'https://'&lt;/code&gt; 开头，则会使用默认的加载器来加载其它类型的文件。&lt;/p&gt;
&lt;p&gt;创建完 &lt;code&gt;https-loader&lt;/code&gt; 之后，我们来测试一下该加载器。首先创建一个 &lt;code&gt;main.mjs&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// main.mjs
import React from "https://esm.sh/react@17.0.2"

console.dir(React);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在命令行输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node --experimental-loader ./https-loader.mjs ./main.mjs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  Fragment: Symbol(react.fragment),
  StrictMode: Symbol(react.strict_mode),
  Profiler: Symbol(react.profiler),
  Suspense: Symbol(react.suspense),
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;了解完以上的内容后，我们回过头来看一下 &lt;code&gt;esmo.mjs&lt;/code&gt; 文件中所使用的 &lt;a href="https://github.com/antfu/esbuild-node-loader"&gt;esbuild-node-loader&lt;/a&gt; 模块。下面我们来简单分析一下 &lt;code&gt;load&lt;/code&gt; 钩子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// loader.mjs（esbuild-node-loader v0.6.4）
export function load(url, context, defaultLoad) {
  if (extensionsRegex.test(new URL(url).pathname)) {
    const { format } = context;

    let filename = url;
    if (!isWindows) filename = fileURLToPath(url);

    const rawSource = fs.readFileSync(new URL(url), { encoding: "utf8" });
    const { js } = esbuildTransformSync(rawSource, filename, url, format);

    return {
      format: "module",
      source: js,
    };
  }

  // Let Node.js handle all other format / sources.
  return defaultLoad(url, context, defaultLoad);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过观察以上代码，我们可知 &lt;code&gt;load&lt;/code&gt; 钩子的核心处理流程，可以分为两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：使用 &lt;code&gt;fs.readFileSync&lt;/code&gt; 方法读取文件资源的内容；&lt;/li&gt;
&lt;li&gt;步骤二：使用 &lt;code&gt;esbuildTransformSync&lt;/code&gt; 函数对源代码进行转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在 &lt;code&gt;esbuildTransformSync&lt;/code&gt; 函数中，使用了 &lt;code&gt;esbuild&lt;/code&gt; 模块提供的 &lt;code&gt;transformSync&lt;/code&gt; 函数来实现代码的转换。该函数的相关代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// loader.mjs（esbuild-node-loader v0.6.4）
function esbuildTransformSync(rawSource, filename, url, format) {
  const {
    code: js,
    warnings,
    map: jsSourceMap,
  } = transformSync(rawSource.toString(), {
    sourcefile: filename,
    sourcemap: "both",
    loader: new URL(url).pathname.match(extensionsRegex)[1],
    target: `node${process.versions.node}`, 
    format: format === "module" ? "esm" : "cjs",
  });

  // 省略部分代码
  return { js, jsSourceMap };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于 &lt;code&gt;transformSync&lt;/code&gt; 函数的使用方式，我就不展开介绍了。感兴趣的小伙伴可以自行阅读一下 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 官网上的相关文档。&lt;/p&gt;
&lt;p&gt;好的，&lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 这个项目就介绍到这里。如果你对 Node.js 平台下的 &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; hook 机制感兴趣的话，可以详细阅读一下 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt;、&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 和 &lt;a href="https://github.com/antfu/esbuild-node-loader"&gt;esbuild-node-loader&lt;/a&gt; 这几个项目的源码。若有遇到问题的话，欢迎跟阿宝哥交流哟。&lt;/p&gt;
&lt;h3&gt;参考资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://esbuild.github.io/"&gt;esbuild 官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nodejs.org/api/esm.html#loaders"&gt;Node.js 官网 - ESM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/BFu4SouMdXFYLELRjHhUyg"&gt;如何为 Node.js 的 require 函数添加钩子？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><author>阿宝哥</author><pubDate>Wed, 16 Feb 2022 16:22:34 GMT</pubDate></item><item><title>如何为 Node.js 的 require 函数添加钩子？</title><link>https://juejin.cn/post/7062536831664914463</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 是一个基于 &lt;a href="https://v8.dev/"&gt;Chrome V8 引擎&lt;/a&gt;的 JavaScript 运行时环境。早期的 Node.js 采用的是 CommonJS 模块规范，从 &lt;a href="https://nodejs.org/de/blog/release/v13.2.0/"&gt;Node v13.2.0&lt;/a&gt; 版本开始正式支持 ES Modules 特性。直到 v15.3.0 版本 ES Modules 特性才稳定下来并与 NPM 生态相兼容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="nodejs-esm-history.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b651f355770d4f1db87a30cc6d0c3289~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;（图片来源：https://nodejs.org/api/esm.html）&lt;/p&gt;
&lt;p&gt;本文将介绍 Node.js 中 &lt;code&gt;require&lt;/code&gt; 函数的工作流程、如何让 Node.js 直接执行 ts 文件及如何正确地劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数，从而实现钩子的功能。接下来，我们先来介绍 &lt;code&gt;require&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h3&gt;require 函数&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 应用由模块组成，每个文件就是一个模块。对于 CommonJS 模块规范来说，我们通过 &lt;code&gt;require&lt;/code&gt; 函数来导入模块。那么当我们使用 &lt;code&gt;require&lt;/code&gt; 函数来导入模块的时候，该函数内部发生了什么？这里我们通过调用堆栈来了解一下 &lt;code&gt;require&lt;/code&gt; 的过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="how-node-require-work.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ac592857e6842ef83f94570238d09e0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;由上图可知，在使用 &lt;code&gt;require&lt;/code&gt; 导入模块时，会调用 &lt;code&gt;Module&lt;/code&gt; 对象的 &lt;code&gt;load&lt;/code&gt; 方法来加载模块，该方法的实现如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module.prototype.load = function(filename) {
  this.filename = filename;
  this.paths = Module._nodeModulePaths(path.dirname(filename));

  const extension = findLongestRegisteredExtension(filename);

  Module._extensions[extension](this, filename);
  this.loaded = true;
  // 省略部分代码
};
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：本文所引用 Node.js 源码所对应的版本是 &lt;strong&gt;v16.13.1&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在以上代码中，重要的两个步骤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：根据文件名找出扩展名；&lt;/li&gt;
&lt;li&gt;步骤二：通过解析后的扩展名，在 &lt;code&gt;Module._extensions&lt;/code&gt; 对象中查找匹配的加载器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 中内置了 3 种不同的加载器，用于加载 &lt;code&gt;node&lt;/code&gt;、&lt;code&gt;json&lt;/code&gt; 和 &lt;code&gt;js&lt;/code&gt; 文件。
&lt;strong&gt;node 文件加载器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module._extensions['.node'] = function(module, filename) {
  return process.dlopen(module, path.toNamespacedPath(filename));
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;json 文件加载器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module._extensions['.json'] = function(module, filename) {
 const content = fs.readFileSync(filename, 'utf8');
 try {
    module.exports = JSONParse(stripBOM(content));
 } catch (err) {
   err.message = filename + ': ' + err.message;
   throw err;
 }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;js 文件加载器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module._extensions['.js'] = function(module, filename) {
  // If already analyzed the source, then it will be cached.
  const cached = cjsParseCache.get(module);
  let content;
  if (cached?.source) {
    content = cached.source;
    cached.source = undefined;
  } else {
    content = fs.readFileSync(filename, 'utf8');
  }
  // 省略部分代码
  module._compile(content, filename);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们来分析比较重要的 &lt;strong&gt;js 文件加载器&lt;/strong&gt;。通过观察以上代码，我们可知 &lt;code&gt;js&lt;/code&gt; 加载器的核心处理流程，也可以分为两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：使用 &lt;code&gt;fs.readFileSync&lt;/code&gt; 方法加载 &lt;code&gt;js&lt;/code&gt; 文件的内容；&lt;/li&gt;
&lt;li&gt;步骤二：使用 &lt;code&gt;module._compile&lt;/code&gt; 方法编译已加载的 &lt;code&gt;js&lt;/code&gt; 代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么了解以上的知识之后，对我们有什么用处呢？其实在了解 &lt;code&gt;require&lt;/code&gt; 函数的工作流程之后，我们就可以扩展 Node.js 的加载器。比如让 Node.js 能够运行 &lt;code&gt;ts&lt;/code&gt; 文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// register.js
const fs = require("fs");
const Module = require("module");
const { transformSync } = require("esbuild");

Module._extensions[".ts"] = function (module, filename) {
  const content = fs.readFileSync(filename, "utf8");
  const { code } = transformSync(content, {
    sourcefile: filename,
    sourcemap: "both",
    loader: "ts",
    format: "cjs",
  });
  module._compile(code, filename);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们引入了内置的 &lt;code&gt;module&lt;/code&gt; 模块，然后利用该模块的 &lt;code&gt;_extensions&lt;/code&gt; 对象来注册我们的自定义 ts 加载器。&lt;/p&gt;
&lt;p&gt;其实，加载器的本质就是一个函数，在该函数内部我们利用 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 模块提供的 &lt;code&gt;transformSync&lt;/code&gt; API 来实现 &lt;strong&gt;ts -&amp;gt; js&lt;/strong&gt; 代码的转换。当完成代码转换之后，会调用 &lt;code&gt;module._compile&lt;/code&gt; 方法对代码进行编译操作。&lt;/p&gt;
&lt;p&gt;看到这里相信有的小伙伴，也想到了 Webpack 中对应的 loader，想深入学习的话，可以阅读 &lt;a href="https://mp.weixin.qq.com/s/2v1uhw2j7yKsb1U5KE2qJA"&gt;多图详解，一次性搞懂Webpack Loader&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;p&gt;篇幅有限，具体的编译过程，我们就不展开介绍了。下面我们来看一下如何让自定义的 ts 加载器生效。要让 Node.js 能够执行 ts 代码，我们就需要在执行 ts 代码前，先完成自定义 ts 加载器的注册操作。庆幸的是，Node.js 为我们提供了模块的预加载机制：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt; $ node --help | grep preload
   -r, --require=... module to preload (option can be repeated)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即利用 &lt;code&gt;-r, --require&lt;/code&gt; 命令行配置项，我们就可以预加载指定的模块。了解完相关知识之后，我们来测试一下自定义 ts 加载器。首先创建一个 &lt;code&gt;index.ts&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;// index.ts
const add = (a: number, b: number) =&amp;gt; a + b;

console.log("add(a, b) = ", add(3, 5));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在命令行输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node -r ./register.js index.ts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;add(a, b) =  8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很明显我们自定义的 ts 文件加载器生效了，这种扩展机制还是值得我们学习的。另外，需要注意的是在 &lt;code&gt;load&lt;/code&gt; 方法中，&lt;code&gt;findLongestRegisteredExtension&lt;/code&gt; 函数会判断文件的扩展名是否已经注册在 &lt;code&gt;Module._extensions&lt;/code&gt; 对象中，若未注册的话，默认会返回 &lt;code&gt;.js&lt;/code&gt; 字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module.prototype.load = function(filename) {
  this.filename = filename;
  this.paths = Module._nodeModulePaths(path.dirname(filename));

  const extension = findLongestRegisteredExtension(filename);

  Module._extensions[extension](this, filename);
  this.loaded = true;
  // 省略部分代码
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就意味着只要文件中包含有效的 &lt;code&gt;js&lt;/code&gt; 代码，&lt;code&gt;require&lt;/code&gt; 函数就能正常加载它。比如下面的 &lt;strong&gt;a.txt&lt;/strong&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;  module.exports = "hello world";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到这里相信你已经了解 &lt;code&gt;require&lt;/code&gt; 函数是如何加载模块及如何自定义 Node.js 文件加载器。那么，让 Node.js 支持加载 &lt;code&gt;ts&lt;/code&gt;、&lt;code&gt;png&lt;/code&gt; 或 &lt;code&gt;css&lt;/code&gt; 等其它类型的文件，有更优雅、更简单的方案么？答案是有的，我们可以使用 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个第三方库。&lt;/p&gt;
&lt;h3&gt;pirates 是什么&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库让我们可以正确地劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数。利用这个库，我们就可以很容易扩展 Node.js 加载器的功能。&lt;/p&gt;
&lt;h4&gt;pirates 的用法&lt;/h4&gt;
&lt;p&gt;你可以使用 npm 来安装 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;npm install --save pirates
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在成功安装 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库之后，就可以利用该模块导出提供的 &lt;code&gt;addHook&lt;/code&gt; 函数来添加钩子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// register.js
const addHook = require("pirates").addHook;

const revert = addHook(
  (code, filename) =&amp;gt; code.replace("@@foo", "console.log('foo');"),
  { exts: [".js"] }
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是调用 &lt;code&gt;addHook&lt;/code&gt; 之后会返回一个 &lt;code&gt;revert&lt;/code&gt; 函数，用于取消对 &lt;code&gt;require&lt;/code&gt; 函数的劫持操作。下面我们来验证一下 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库是否能正常工作，首先新建一个 &lt;code&gt;index.js&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// index.js
console.log("@@foo")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在命令行输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node -r ./register.js index.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;console.log('foo');
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上结果可知，我们通过 &lt;code&gt;addHook&lt;/code&gt; 函数添加的钩子生效了。是不是觉得挺神奇的，接下来我们来分析一下 pirates 的工作原理。&lt;/p&gt;
&lt;h3&gt;pirates 是如何工作的&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 底层是利用 Node.js 内置 &lt;code&gt;module&lt;/code&gt; 模块提供的扩展机制来实现 &lt;code&gt;Hook&lt;/code&gt; 功能。前面我们已经介绍过了，当使用 &lt;code&gt;require&lt;/code&gt; 函数来加载模块时，Node.js 会根据文件的后缀名来匹配对应的加载器。
其实 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 的源码并不会复杂，我们来重点分析 &lt;code&gt;addHook&lt;/code&gt; 函数的核心处理逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// src/index.js
export function addHook(hook, opts = {}) {
  let reverted = false;
  const loaders = []; // 存放新的loader
  const oldLoaders = []; // 存放旧的loader
  let exts;

  const originalJSLoader = Module._extensions['.js']; // 原始的JS Loader 

  const matcher = opts.matcher || null;
  const ignoreNodeModules = opts.ignoreNodeModules !== false;
  exts = opts.extensions || opts.exts || opts.extension || opts.ext 
    || ['.js'];
  if (!Array.isArray(exts)) {
    exts = [exts];
  }
  exts.forEach((ext) { 
    // ... 
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了提高执行效率，&lt;code&gt;addHook&lt;/code&gt; 函数提供了 &lt;code&gt;matcher&lt;/code&gt; 和 &lt;code&gt;ignoreNodeModules&lt;/code&gt; 配置项来实现文件过滤操作。在获取到 &lt;code&gt;exts&lt;/code&gt; 扩展名列表之后，就会使用新的加载器来替换已有的加载器。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;exts.forEach((ext) =&amp;gt; {
    if (typeof ext !== 'string') {
      throw new TypeError(`Invalid Extension: ${ext}`);
    }
    // 获取已注册的loader，若未找到，则默认使用JS Loader
    const oldLoader = Module._extensions[ext] || originalJSLoader;
    oldLoaders[ext] = Module._extensions[ext];

    loaders[ext] = Module._extensions[ext] = function newLoader(
  mod, filename) {
      let compile;
      if (!reverted) {
        if (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {
          compile = mod._compile;
          mod._compile = function _compile(code) {
// 这里需要恢复成原来的_compile函数，否则会出现死循环
            mod._compile = compile;
// 在编译前先执行用户自定义的hook函数
            const newCode = hook(code, filename);
            if (typeof newCode !== 'string') {
              throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);
            }

            return mod._compile(newCode, filename);
          };
        }
      }

      oldLoader(mod, filename);
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上代码可知，在 &lt;code&gt;addHook&lt;/code&gt; 函数内部是通过替换 &lt;code&gt;mod._compile&lt;/code&gt; 方法来实现钩子的功能。即在调用原始的 &lt;code&gt;mod._compile&lt;/code&gt; 方法进行编译前，会先调用 &lt;code&gt;hook(code, filename)&lt;/code&gt; 函数来执行用户自定义的 &lt;code&gt;hook&lt;/code&gt; 函数，从而对代码进行处理。&lt;/p&gt;
&lt;p&gt;好的，至此本文的主要内容都介绍完了，在实际工作中，如果你想让 Node.js 直接执行 ts 文件，可以利用 &lt;a href="https://github.com/TypeStrong/ts-node"&gt;ts-node&lt;/a&gt; 或 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 这两个库。其中 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 这个库内部就是使用了 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 提供的 Hook 机制来实现对应的功能。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Tue, 08 Feb 2022 18:50:17 GMT</pubDate></item><item><title>问卷还可以这样开发，效率提升 150%</title><link>https://juejin.cn/post/7028793777875582984</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;工作了一天，终于到了最 “鸡冻” 的时刻，等待下班铃声的响起...&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f4aa77df01e4a9ea039dcf32a0d0b64~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;不过没过多久，就听到了那既熟悉而又抗拒的消息提示声。临近下班前的消息，感觉就不太妙。不过还是硬着头皮打开了公司运营妹纸发的消息 —— “宝哥，帮帮忙，明天下午我们有一个新版的 PC 知识库的推广活动，想在我们的知识库模块中添加一个问卷入口，收集一下用户的使用体验”。&lt;/p&gt;
&lt;p&gt;看完以上的消息之后，当时我的心情是这样的👇&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f0e08a748b34809a993b910d32c4eb7~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;本想装作没看见，奈何消息已变成已读。所以我只能强装镇定，给妹纸回了消息，让她把问卷要收集的信息发给我，过了一会儿妹纸把信息发了过来。看完后，发现表单并不会复杂，松了一口气。&lt;/p&gt;
&lt;p&gt;之后，立马让妹纸去协调一下服务端的资源。没想到妹纸却回我说：“宝哥，这个功能不会太复杂，以你的技术能力，应该一个人就可以搞定吧”。既然妹纸都这样说了，我只能委屈的说没问题。接着，跟妹纸大致沟通了需求，确认说表单的数据，可以不用提交到我们的系统。&lt;/p&gt;
&lt;p&gt;既然需求已经明确了，剩下的就是如何快速开发这个功能了。思考了一会儿，一个便捷的开发方案就涌现在脑海中。刚好之前有了解过在线的表单设计器和朋友公司的 Bass 产品 ——  &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 。我就想利用在线表单设计器来快速生成表单代码，然后利用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的服务来存储数据。大致方案已经有了，为了能早点下班，我立马行动起来。&lt;/p&gt;
&lt;h3&gt;一、拖拽生成表单&lt;/h3&gt;
&lt;p&gt;我司新版的 PC 知识库是基于 Vue 2 开发的，使用了 Element UI 组件库。经过一番搜索，我找到了 &lt;a href="https://github.com/JakHuang/form-generator"&gt;form-generator&lt;/a&gt; 这个开源项目。该项目是一款基于 Element UI 表单设计及代码生成器，目前 Github 上的 Star 数是 5.2K，是一个挺不错的开源项目。&lt;/p&gt;
&lt;p&gt;不得不说以拖拽的方式设计表单，使用起来还是很 “香” 的。一顿操作后，表单就生成了，具体效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee165d6f94e54e5380cdfa7a097298a9~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是，该在线工具还允许我们为表单的每个字段配置正则校验&lt;/strong&gt;。在完成表单设计之后，我通过点击 &lt;strong&gt;导出vue文件&lt;/strong&gt; 的按钮，就下载到对应的 Vue 文件。此时，问卷表单的功能已经完成一大半了，就差对接数据提交的功能。所以接下来我们将利用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的能力，来快速生成 API。&lt;/p&gt;
&lt;h3&gt;二、快速生成 API&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 为应用开发者提供高可用、自动弹性伸缩的后端云服务。前端通过统一的 SDK 和 API 连接后端服务（云数据库、云存储、云函数、用户管理、统计分析等），加速移动/Web/IoT/游戏等应用的开发，并降低运维成本。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d16e33d2fc47409a94f8c1c541dc3311~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;（图片来源：https://docs.memfiredb.com/）&lt;/p&gt;
&lt;p&gt;简单介绍了 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 的功能之后，下面我们来介绍如何使用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台快速生成 API。&lt;/p&gt;
&lt;h4&gt;2.1 创建数据库账号&lt;/h4&gt;
&lt;p&gt;首先要使用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台服务提供的服务，我们需要先注册一个账号。在账号注册成功后，我们就能登录 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台的管理后台。在创建表单应用前，我们需要先创建一个数据库账号，具体的操作方式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bf9d2aabc1c4a19bda4fd6fdf4cb8ff~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;2.2 创建表单应用&lt;/h4&gt;
&lt;p&gt;在创建完账号之后，我们就可以创建表单应用了。首先点击左侧 &lt;strong&gt;我的应用&lt;/strong&gt; 菜单，然后点击 &lt;strong&gt;创建应用&lt;/strong&gt; 按钮，在弹出的对话框中输入应用名称并选择前面新增的数据库账号，最后点击 &lt;strong&gt;创建按钮&lt;/strong&gt; 就会开始创建表单应用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47567b1cbb59430c9be881b553a2290a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;2.3 新建数据表&lt;/h4&gt;
&lt;p&gt;在成功创建完表单应用之后，我们就可以新建问卷表了，用于保存表单的数据。首先点击刚新建的表单应用，进入表单应用编辑页面，然后点击左侧 &lt;strong&gt;数据表&lt;/strong&gt; 菜单，接着继续点击 &lt;strong&gt;新建数据表&lt;/strong&gt; 按钮，具体步骤如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea830eea1b84f68a41fa20937aadf0a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;在点击 &lt;strong&gt;新建数据表&lt;/strong&gt; 按钮后，在当前页面右侧会以 Drawer（抽屉）的形式，显示新建数据表的表单。接着我们根据已生成 Vue 表单文件中的字段来创建 &lt;strong&gt;feedbacks&lt;/strong&gt; 数据表的字段，具体的过程如以下动图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c3bcab9c7734af5b5216b0fb93ed07d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;以上动图只演示了添加 &lt;code&gt;name&lt;/code&gt; 字段的过程，通过 &lt;strong&gt;添加字段&lt;/strong&gt; 按钮，我们陆续添加了 &lt;strong&gt;mobile、post、score 和 suggestion&lt;/strong&gt; 等字段。最后每个字段的详细配置信息如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88da9001dfcf49df86dc640652c1e774~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：上图中的 &lt;code&gt;id&lt;/code&gt; 字段是默认生成的，它的值会不断自增。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过一番配置之后，我们问卷的 API 就已经创建好了，整体操作起来还是挺方便的。下面我们只要对接一下客户端 SDK 就可以提交表单数据了。&lt;/p&gt;
&lt;h3&gt;三、集成 JS 客户端 SDK&lt;/h3&gt;
&lt;p&gt;在集成 JS 客户端 SDK 的时候，可以通过 &lt;code&gt;npm&lt;/code&gt; 或 &lt;code&gt;CDN&lt;/code&gt; 的方式来安装 SDK。这里我们使用 &lt;code&gt;npm&lt;/code&gt; 的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;npm install @supabase/supabase-js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在成功安装了 &lt;code&gt;@supabase/supabase-js&lt;/code&gt; 模块之后，我们需要在表单页面中引入该模块，然后使用表单项目总览页面中的信息来创建 JS 客户端对象，需获取的 JS 客户端对象初始化信息如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9210fd811aeb4809a9f5b152d7783fba~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;在获取初始化信息之后，我们就可以创建  JS 客户端对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;import { createClient } from "@supabase/supabase-js";

const supabase = createClient(
  "https://c5s0hnq5g6heb3j9g3gg.baseapi.memfiredb.com", // baseURL
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYW" // 公开的密钥（仅截取部分内容）
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了 &lt;code&gt;supabase&lt;/code&gt; 客户端对象之后，我们就可以利用该对象提供的方法来提交表单数据了，具体的使用方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// src/components/FeedbackForm.vue
export default {
  data() {
    return {
      // 省略其他属性
      submitting: false
    };
  },
  methods: {
    submitForm() {
      this.$refs["elForm"].validate(async (valid) =&amp;gt; {
        if (!valid || this.submitting) return;
        this.submitting = true; // 避免快速点击，重复提交数据
        const { error } = await supabase
          .from("feedbacks") // 数据表的表名
          .insert(this.formData);  
        const msg = error == null ? "感谢您的反馈!" : "服务器开小差，请稍后再试";
        alert(msg);
        if(!error) this.$refs["elForm"].resetFields(); // 复位表单
        this.submitting = false;
      });
    },
    resetForm() {
      this.$refs["elForm"].resetFields();
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，&lt;code&gt;supabase.from&lt;/code&gt; 方法用于指定数据表的表名，而 &lt;code&gt;insert&lt;/code&gt; 方法用来插入新增的数据。需要注意的是，&lt;code&gt;insert&lt;/code&gt; 方法的参数也可以是数组，即可以批量插入多条数据。在插入数据时，也可以配置 &lt;code&gt; { upsert: true }&lt;/code&gt; 选项来执行 &lt;code&gt;upsert&lt;/code&gt; 操作。&lt;/p&gt;
&lt;p&gt;其实除了 &lt;code&gt;insert&lt;/code&gt; 方法之外，该 SDK 也为我们提供了 &lt;code&gt;select（获取数据）&lt;/code&gt;、&lt;code&gt;update（修改数据）&lt;/code&gt;、&lt;code&gt;delete（删除数据）&lt;/code&gt; 等方法。同时，也提供了强大的修改器（limit、order、range 等）和过滤器（filter、or、not、eq 等），感兴趣的小伙伴可以阅读 &lt;a href="https://docs.memfiredb.com/base/javascript/select.html"&gt;MemFire Cloud JS 客户端文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在完成以上三个步骤之后，我们调查问卷功能就已经开发完成了。成功收集的问卷数据，我们可以在 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台管理后台中进行查看：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a70610745e2248fa8b5ce00e9755ea65~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;四、总结&lt;/h3&gt;
&lt;p&gt;利用 &lt;a href="https://github.com/JakHuang/form-generator"&gt;form-generator&lt;/a&gt; 表单设计器和 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的简单易用、功能强大的数据存储功能，我快速完成了公司运营妹纸的调查问卷功能，成功逃过加班的 “厄运”。其实后期还可以考虑对这两个工具做进一步的整合，即可以根据表单设计器生成的字段信息，自动创建对应的表结构，同时自动生成客户端 SDK 的调用代码。&lt;/p&gt;
&lt;p&gt;在日常生活中，利用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的数据库即服务的功能，我们还可以快速开发一些小的工具。比如网页书签收集器，感兴趣的小伙伴可以参考 &lt;a href="https://github.com/d2-projects/d2-daily-chrome-extension"&gt;d2-daily-chrome-extension&lt;/a&gt; 这个项目，只需把 &lt;code&gt;axios&lt;/code&gt; 替换成 &lt;code&gt;@supabase/supabase-js&lt;/code&gt; 客户端，你就可以快速开发一个网页书签收集器的 Chrome 插件。如果你还有其它更好玩的想法，欢迎给我留言哟。&lt;/p&gt;
&lt;h3&gt;五、参考资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.memfiredb.com/base/javascript/installing.html"&gt;MemFire Cloud 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/JakHuang/form-generator"&gt;Github — form-generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/d2-projects/d2-daily-chrome-extension"&gt;Github — d2-daily-chrome-extension&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><author>阿宝哥</author><pubDate>Tue, 09 Nov 2021 20:30:13 GMT</pubDate></item><item><title>十月份火火火的 GitHub 开源项目</title><link>https://juejin.cn/post/7162461841027760135</link><description>&lt;p&gt;本篇文章盘点 10 月份 GitHub 上比较受欢迎的开源项目，你可以点击上方的&amp;nbsp;#每月盘点&amp;nbsp;查看历史盘点的开源项目合集。&lt;/p&gt;
&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;命令行记录神器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;口袋妖怪全息效果 CSS 样式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;金庸群侠传 3D 重制版&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;curl&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开源的视频播放器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;命令行记录神器&lt;/p&gt;
&lt;p&gt;开源项目 vhr 上周开源，截止目前已经获得了 3.7k 的 Star。想必你也经常录制一个 Gif 或者视频，来演示在 Terminal 上的一些命令。而开源项目 vhr 就是一个很好用的工具，可以生成终端的 Gif，帮助你能够方便演示你的命令，比如下面的 Gif 图就是使用 vhr 生成的。&lt;/p&gt;
&lt;p&gt;编程语言：Go&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0713a7feb7d4cad9360eb5b0c313a03~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/charmbracelet/vhs&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;口袋妖怪全息效果 CSS 样式&lt;/p&gt;
&lt;p&gt;这个开源项目是一组高级 CSS 样式，可为口袋妖怪卡片的表面创建逼真的全息效果，在 GitHub 开源一天内就获得了 2k 左右的 Star。&lt;/p&gt;
&lt;p&gt;建议大家去体验一下效果，如何使用 CSS + JS + HTML 做出如此逼真的卡组效果，光泽都能看的一清二楚。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23ca5a9fb214b648c432f13fdc1aaec~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf4b3e2476fb4097bf6ff417ff874dc3~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/simeydotme/pokemon-cards-css&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;金庸群侠传 3D 重制版&lt;/p&gt;
&lt;p&gt;金庸群侠传是 1996 年发布的中文角色扮演游戏，直到现在都有一群忠实的玩家用户。由于是 1996 年，这个游戏的画面相对粗糙，分辨率也特别低。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9eb48a1445744ed97f8a7ad36cc178b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;开源项目《群侠传，启动》 是一个开源的武侠 RPG 游戏框架，旨在致敬经典游戏《金庸群侠传》，至今已经获得了 5.8K 的 Star。&lt;/p&gt;
&lt;p&gt;来看看使用 使用 Unity 引擎重制的效果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87c329897df14997926b04bc3efd56b6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ffe204a3d2e49c1a52da7b28c065f2c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/jynew/jynew&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;curl&lt;/p&gt;
&lt;p&gt;curl 大家应该非常熟悉，是工作中常用的命令行工具，用来请求 Web 服务器。在 GitHub 上获得了 27k 的 Star。&lt;/p&gt;
&lt;p&gt;获得如此多的 Star 因为 curl 的功能强大，命令行参数多达几十种。熟练使用，常常可以取代 Postman 这一类的图形界面调试工具。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/048e94c1d6ea4b4c9f601e174ebdf63a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/curl/curl&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;开源的视频播放器&lt;/p&gt;
&lt;p&gt;Jellyfin 是一批开发者资源开发的视频播放器，或者说是媒体解决方案。使用 Jellyfin 可以保持、管理你的视频、音乐或者图片。&lt;/p&gt;
&lt;p&gt;采用 C# 构建，界面简单简洁，在 GitHub 上已经获得了 17.4K 的 Star。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ca4247a6de3429e86196d44cb3424d9~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5baccc7b39142dd807b64eeff500a0b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/jellyfin/jellyfin&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;开源地址：https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/398b314d46694282b7d239077027d024~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Sat, 05 Nov 2022 01:33:07 GMT</pubDate></item><item><title>本文推荐 4 个开源微信小程序</title><link>https://juejin.cn/post/7162461047729684510</link><description>&lt;p&gt;本文推荐几个开源微信小程序，这个开源的小程序都是 Recently updated，下载下来部署就能使用的。&lt;/p&gt;
&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;答题小程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;又是一个答题小程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;贝壳小盒子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;酱茄小程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;01&lt;/h2&gt;
&lt;h2&gt;答题小程序&lt;/h2&gt;
&lt;p&gt;这个一个答题小程序，你可以选择自己感兴趣的题库，开始答题。会记录你答错的错题，除了答题，还有其他一些小工具，比如：汉字词典、词语大全、题库导出、PDF工具等等。&lt;/p&gt;
&lt;p&gt;前端采用微信小程序原生开发 + Vant 开源组件，后端基于 Java 框架、MySQL 数据库。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7907abcc6c14cba9a7532f7fc4152af~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f170fb62825e4a4ab99d7c5b856dce19~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/mark420524/question&lt;/p&gt;
&lt;h2&gt;02&lt;/h2&gt;
&lt;h2&gt;又是一个答题小程序&lt;/h2&gt;
&lt;p&gt;不知道为啥，GitHub 上的开发者看来很喜欢开发答题小程序，大概是想找到曾经期末考试的感觉hhh。小程序前后端开源，易于二次开发，方便学习。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaf9bd34619340a9a9738ca868a7a36f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ee1df28d2b64399a1b1ba48649a5919~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/kesixin/QuestionWechatApp&lt;/p&gt;
&lt;h2&gt;03&lt;/h2&gt;
&lt;h2&gt;贝壳小盒子&lt;/h2&gt;
&lt;p&gt;这个小程序有意思了，这是一个校园猫咪档案小程序。每个大学校园都会有一些流浪猫，这个小程序就是中大校园里面猫咪的档案库。逛姐的学校里就有六只可爱的猫咪，每次遇到逛姐都要蹲在地上和她们互动一下~太可爱了呀~~&lt;/p&gt;
&lt;p&gt;贝壳小盒子可以查看中大校区的猫咪，大家还给猫咪起了名字，做了备注，也可以为猫猫拍摄萌照上传照片。&lt;/p&gt;
&lt;p&gt;该开源项目提供完整的部署视频，和相关教程，感兴趣的可以 clone 下来学习。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5408e6290234432a17f41cc246671e7~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3c7776b8c554e8d879297108882ef9a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86c682e8321f4f798b723d9bc36cad87~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09ad741cdb6d408698d8f23b2252f8ac~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/sysucats/zhongdamaopu&lt;/p&gt;
&lt;h2&gt;04&lt;/h2&gt;
&lt;h2&gt;酱茄小程序&lt;/h2&gt;
&lt;p&gt;酱茄小程序开源版，基于WordPress的微信小程序，适用于博客小程序和新闻资讯小程序。&lt;/p&gt;
&lt;p&gt;追格资讯小程序开源版（又称酱茄free），实现WordPress网站数据与小程序同步共享，简单的配置就能搭建自己的资讯/博客小程序。一套代码多端适用（微信端、百度端、QQ端、H5端）&lt;/p&gt;
&lt;p&gt;逛姐如果搭建一个带有打卡功能的专业知识学习小程序赠与老逛，相信老逛一定会非常开心~&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e999ce591f2497fab6eebc6848dc82d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5da3211e80e407dac6735455a26ec33~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/zhuige-com/jiangqie_kafei&lt;/p&gt;
&lt;h2&gt;历史盘点&lt;/h2&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;开源地址：https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38ba3d052ea942308be4fea89fa1b4f5~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Sat, 05 Nov 2022 01:29:49 GMT</pubDate></item><item><title>推荐 7 个本周 yyds 的开源项目</title><link>https://juejin.cn/post/7126458144833667108</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. Web 是如何工作的？&lt;/p&gt;
&lt;p&gt;2. 发现好教程&lt;/p&gt;
&lt;p&gt;3. FastAPI&lt;/p&gt;
&lt;p&gt;4. 编程大学&lt;/p&gt;
&lt;p&gt;5. 全栈 Web 框架：Remix&lt;/p&gt;
&lt;p&gt;6. 用户身份访问管理&lt;/p&gt;
&lt;p&gt;7. 科技爱好者周刊&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. Web 是如何工作的？&lt;/h3&gt;
&lt;p&gt;当我们在浏览器中输入 www.google.com 后会发生什么事？&lt;/p&gt;
&lt;p&gt;这个开源项目详细的解释了这一操作背后的原理，从计算机网络、服务器响应、解析渲染，把每一个细节都做了解释。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/vasanthk/how-web-works"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bd0208915f84ee9be202cc3e409e10c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 发现好教程&lt;/h3&gt;
&lt;p&gt;这个开源项目搜集了 YouTube 上优质的机器学习教程，方向包括机器学习、深度学习、计算机视觉、自然语言处理、无监督学习等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/dair-ai/ML-YouTube-Courses"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93b3d40887084214bcc4cf3ae87ce5a3~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee85841541b9473dbe3649cd86a01dd2~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. FastAPI&lt;/h3&gt;
&lt;p&gt;FastAPI 框架：一个快速（高性能）的 Web 框架，是最快的 Python 框架之一。这个开源项目有 47.5K 的 Star。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/tiangolo/fastapi"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc59e43c8ecd44d6acdaf84e28aaf833~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 编程大学&lt;/h3&gt;
&lt;p&gt;这个开源项目记录了一个亚马逊的工程师从零到一学习编程的计划，这位开发者每天学习 8 小时，大约进行了 8 个月的学习，如愿以偿的从零到一，拿到了亚马逊的 Offer！&lt;/p&gt;
&lt;p&gt;这是软件工程的学习计划，而不是 Web 开发。谷歌、亚马逊、Facebook 和微软等大型软件公司将软件工程视为与 Web 开发不同。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/jwasham/coding-interview-university"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eb474e42c8c49049d73f1b4f86f6c1d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;05. 全栈 Web 框架：Remix&lt;/h3&gt;
&lt;p&gt;Remix 是一个全栈 Web 框架，可让你专注于用户界面并通过 Web 基础知识进行工作，以提供快速、流畅且有弹性的用户体验，可部署到任何 Node.js 服务器。该开源项目已经斩获 18.1k 的 Star！&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/remix-run/remix"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86c1a7bf66194bc08672569e0afcb0eb~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;06. 用户身份访问管理&lt;/h3&gt;
&lt;p&gt;Logto 是针对登陆的解决方案，通过多平台 SDK 可将应用程序与 Logto 快速集成，可在几分钟内建立用户身份和不错的登录体验。&lt;/p&gt;
&lt;p&gt;该开源项目提供基于 OIDC 的身份服务，支持集成多社交平台登陆，比如 GitHub、谷歌、微信、支付宝等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/logto-io/logto"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b92bd9330fa49a3ad3e8323e86a73e6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;07. 科技爱好者周刊&lt;/h3&gt;
&lt;p&gt;科技爱好者周刊，记录每周值得分享的科技内容，周五发布。本开源项目由 阮一峰 维护，从 2019 年起，已经持续更新两年多。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ruanyf/weekly"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b97bcb3e15344a4a6db41b4978de977~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/p&gt;
&lt;p&gt;https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/910279204e4f480585c35393872946a7~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 31 Jul 2022 00:59:25 GMT</pubDate></item><item><title>粉丝推荐的 GitHub 项目 yyds</title><link>https://juejin.cn/post/7126456742409568269</link><description>&lt;p&gt;本期盘点的开源项目由逛逛 GitHub 的读者投稿，如果你或者所在的组织开源了高质量的项目，希望被更多人看到，你可以关注逛逛 GitHub 后在底部菜单栏找到投稿入口。&lt;/p&gt;
&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 小游戏收集器&lt;/p&gt;
&lt;p&gt;2. 云原生的开源分布式存储系统&lt;/p&gt;
&lt;p&gt;3. 整理常见的国内镜像&lt;/p&gt;
&lt;p&gt;4. 跨平台跨框架 Web 解决方案&lt;/p&gt;
&lt;p&gt;5. 基于Go+Vue实现的openLDAP后台管理项目&lt;/p&gt;
&lt;p&gt;6. 跨平台的文件搜索引擎&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;小游戏收集器&lt;/p&gt;
&lt;p&gt;小游戏收集器，一键解析下载 Flash 和 Unity3D Web 小游戏，支持进度管理，希望能帮助你收集到来自童年的一份快乐。&lt;/p&gt;
&lt;p&gt;开发者 @Cnotech 今年大四，写毕业论文的时候无聊顺手做的小玩具。零零碎碎写了几个月感觉功能已经基本完善，自测也遇不到新的 bug 了，开发者来逛逛 GitHub 投稿希望有更多人看到，最好能帮忙一起完善。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/Cnotech/flash-collector&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aacf50b21be4dc1b62ce64b23c6b935~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;云原生的开源分布式存储系统&lt;/p&gt;
&lt;p&gt;网易开源的分布式存储系统：Curve ，由云原生计算基金会 (CNCF) 作为沙盒项目托管，对标 Ceph 性能缺陷，主打性能，已经有落地用户。本开源项目累计 Star 有 1.3K，由 @opencurve 开源。&lt;/p&gt;
&lt;p&gt;编程语言：C++&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/opencurve/curve&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/003b843cf84f4f46a20ba7d4d6574be1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;整理常见的国内镜像&lt;/p&gt;
&lt;p&gt;由于国内网络原因，下载依赖包或者软件，对于不少互联网从业者来说，都有不小的挑战，时间浪费在这上边，实在可惜。这个项目介绍了常见依赖，软件的国内镜像，助力大家畅爽编码。&lt;/p&gt;
&lt;p&gt;这是一个归纳梳理类的项目，由开发者 @eryajf 创建，整理了常见的包管理工具，软件，系统的国内镜像，以助力运维同学自建企业私服，开发同学直接上手使用。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/eryajf/Thanks-Mirror&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6148b9a307d421d9d53041ac77de75f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;跨平台跨框架 Web 解决方案&lt;/p&gt;
&lt;p&gt;Elux：基于“微模块”和“模型驱动”的跨平台、跨框架同构方案，由开发者 @hiisea 开源。&lt;/p&gt;
&lt;p&gt;用同一个工程模式开发 Web（浏览器页面）SSR（服务器渲染）Micro（微前端）MP（小程序）APP（手机应用），更可以把 Redux 当 vuex 用，也可以把 vuex 当 redux 用。、&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/hiisea/elux&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d249646840c42aa98672e365d1087e5~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;基于Go+Vue实现的openLDAP后台管理项目&lt;/p&gt;
&lt;p&gt;基于 Go + Vue 实现的 openLDAP 后台管理项目。现代化 openLDAP 管理后台，设计简洁，交互简单，助力运维人员快速简单地应用并管理 openLDAP。本项目由开发者 @eryajf 创建。&lt;/p&gt;
&lt;p&gt;支持钉钉，企业微信，飞书的组织架构，以及员工信息自动同步到平台，一座打通 IM 与常见支持 ldap 认证的应用的桥梁。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/eryajf/go-ldap-admin&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a7edc123e9c423fbe84234eeaedb1b0~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;06&lt;/h1&gt;
&lt;p&gt;跨平台的文件搜索引擎&lt;/p&gt;
&lt;p&gt;Orange是一款跨平台的文件搜索引擎。由开发者 @naaive 创建该项目。使用简单，自带中文简繁体分词、拼音、补全、高亮，支持毫秒级搜索响应。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/naaive/orange&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d83af5e3e864259abb5fc67ca8944d6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55de0f41aa26439fb8e11c00628ffbfd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 31 Jul 2022 00:53:55 GMT</pubDate></item><item><title>盘点 6 月 yyds 的开源项目！</title><link>https://juejin.cn/post/7113563869296984078</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. Nginx 可视化神器&lt;/p&gt;
&lt;p&gt;2. Elastic UI 框架&lt;/p&gt;
&lt;p&gt;3. 新一代建站工具&lt;/p&gt;
&lt;p&gt;4. 前端测试工具&lt;/p&gt;
&lt;p&gt;5. 30 天 JavaScript 编程挑战&lt;/p&gt;
&lt;p&gt;6. 使用 Go + HTML + CSS + JS 构建漂亮的跨平台桌面应用&lt;/p&gt;
&lt;p&gt;7. 适用于 Android 的魔法面具&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;Nginx 可视化神器&lt;/p&gt;
&lt;p&gt;一款可以一键生成 Nginx 配置的神器，相当给力。&lt;/p&gt;
&lt;p&gt;先来看看它都支持什么功能的配置：反向代理、HTTPS、HTTP/2、IPv6, 缓存、WordPress、CDN、Node.js 支持、 Python (Django) 服务器等等。&lt;/p&gt;
&lt;p&gt;如果你想在线进行配置，只需要打开网站：https://nginxconfig.io/，按照自己的需求进行操作就行了。选择你的场景，填写好参数，系统就会自动生成配置文件。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/digitalocean/nginxconfig.io&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eabdb2adf5a40cc91ffcaaad0506c37~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;Elastic UI 框架&lt;/p&gt;
&lt;p&gt;Elastic UI 框架是一组 React UI 组件，用于在 Elastic 中快速构建用户界面。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/elastic/eui&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f4b660824ff41deb212f5d5cf6821e6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;新一代建站工具&lt;/p&gt;
&lt;p&gt;VitePress 是 VuePress 的精神继承者，建立在 vite 之上。VitePress 在写博客网站，技术文档，面试题网站等方面，就有着它先天的优势。&lt;/p&gt;
&lt;p&gt;不仅如此，它还有极易上手、构建速度快等优点。目前，它开箱即用，由于正处于 alpha 阶段，配置和 API 可能可能会在次要版本之间发生变化。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/vuejs/vitepress&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c635ce8627d4210b69e464e1c2cd176~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;前端测试工具&lt;/p&gt;
&lt;p&gt;Cypress 可以对在浏览器中运行的任何东西进行快速、简单和可靠的测试。&lt;/p&gt;
&lt;p&gt;Cypress 是为现代网络而构建的下一代前端测试工具，用于解决开发者和 QA 工程师在测试现代应用程序时面临的关键难题。&lt;/p&gt;
&lt;p&gt;Cypress 简化了设置测试、编写测试、运行测试和调试测试，支持端到端测试、集成测试和单元测试，支持测试在浏览器中运行的任意内容。支持 Mac OS、Linux 和 Windows 平台。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/cypress-io/cypress&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbedef26becd4cada5050bb9133546e5~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;30 天 JavaScript 编程挑战&lt;/p&gt;
&lt;p&gt;30 天 JavaScript 编程挑战是在 30 天内学习 JavaScript 编程语言的分步指南。此挑战可能需要100多天，请按照自己的节奏进行。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/Asabeneh/30-Days-Of-JavaScript&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/128f605dc4e7436c9e98250e98d45eaf~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;06&lt;/h1&gt;
&lt;p&gt;构建漂亮的跨平台桌面应用&lt;/p&gt;
&lt;p&gt;使用 Go 和 Web 技术构建桌面应用程序。为 Go 程序提供 Web 界面的传统方法是通过内置 Web 服务器。&lt;/p&gt;
&lt;p&gt;Wails 提供了一种不同的方法：它提供了将 Go 代码和 Web 前端一起打包成单个二进制文件的能力。通过提供的工具，可以很轻松的完成项目的创建、编译和打包。你所要做的就是发挥想象力！&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/wailsapp/wails&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0bb7f1b9ef4f8d99f6649b8fb0ed06~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;07&lt;/h1&gt;
&lt;p&gt;适用于 Android 的魔法面具&lt;/p&gt;
&lt;p&gt;Magisk 是当前 Android 社区用来获取 root 权限的主流方式。同时，Magisk 特殊的运作机制还赋予了它 systemless 的特质。&lt;/p&gt;
&lt;p&gt;systemless 让 Magisk 一方面可以有针对性地隐藏 root，甚至暂时隐藏 Magisk 本身。另一方面，挂载系统的存在，也让 Magisk 拥有了多样的模块化生态系统。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/topjohnwu/Magisk&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b56f8a0af1b44809003afebcaeb0be6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de1c360b7ec448eab4b45b4261103a1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 26 Jun 2022 07:01:45 GMT</pubDate></item><item><title>盘点最近 火火火火 的 GitHub 项目</title><link>https://juejin.cn/post/7111331196948185101</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 文章同步插件&lt;/p&gt;
&lt;p&gt;2. 读书笔记插件&lt;/p&gt;
&lt;p&gt;3. 在线简历排版工具&lt;/p&gt;
&lt;p&gt;4. 表情包生成器&lt;/p&gt;
&lt;p&gt;5. 开源的在线文档&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;文章同步插件&lt;/p&gt;
&lt;p&gt;还在为一次编辑，N 个平台需多次排版上传脑壳疼吧？为广大自媒体朋友撸了个提高生产力的小工具、可以做到的在多个内容平台无缝同步。&lt;/p&gt;
&lt;p&gt;一键同步文章到多个内容平台，支持今日头条、WordPress、知乎、简书、掘金、CSDN、typecho各大平台，一次发布，多平台同步发布。解放个人生产力。&lt;/p&gt;
&lt;p&gt;编程语言：JavaScript&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/wechatsync/Wechatsync&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e55ad130e20c42deab5f6873b8d00158~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;读书笔记插件&lt;/p&gt;
&lt;p&gt;一个还不错的微信读书笔记工具，方便你导出书本标注等内容，对常使用 Markdown 做笔记的用户比较有帮助，可以 一键导出标注、热门标注、书评、想法、目录。&lt;/p&gt;
&lt;p&gt;编程语言：Typescript&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/Higurashi-kagome/wereader&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10f93edbd294c168a03c818e6806826~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;在线简历排版工具&lt;/p&gt;
&lt;p&gt;这是一个支持 Markdown 和富文本的在线简历排版工具，如下图所示，你可以通过 Markdown 语法或者富文本编辑的方式编辑一个美观的简历。&lt;/p&gt;
&lt;p&gt;编程语言：JavaScript&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/mdnice/markdown-resume&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b8afa14f2145d09d1db77103047d9e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;表情包生成器&lt;/p&gt;
&lt;p&gt;Sorry 是一个很有意思的项目，源自"Sorry，有钱事真的能为所欲为" 这梗 … 而这个开源项目是一个可以将自己的梗生成 GIF 的表情包生成器。&lt;/p&gt;
&lt;p&gt;编程语言：CSS &amp;nbsp;HTML&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/xtyxtyx/sorry&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18f551ba07da4d648f1b16aca3b45e68~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;开源的在线文档&lt;/p&gt;
&lt;p&gt;云策文档是一款开源知识管理工具。通过独立的知识库空间，结构化地组织在线协作文档，实现知识的积累与沉淀，促进知识的复用与流通。该项目基于 next.js、nest.js、MySQL 等技术栈。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/fantasticit/think&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba02f55ed58d40f283ba086662bbac2a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b18eeaef0f85464693178855cdf9a40c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b802bbd5caa4e1eb61ef76a239392ff~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Mon, 20 Jun 2022 06:37:30 GMT</pubDate></item><item><title>Google 有哪些牛逼的开源项目？</title><link>https://juejin.cn/post/7107144360013398029</link><description>&lt;p&gt;本文盘点 Google 开源项目中 Star 最多的 6 个开源项目。@逛逛GitHub 历史还盘点过百度、阿里、腾讯等互联网大厂的开源成果，可以查看历史文章翻阅。&lt;/p&gt;
&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 核心 Java 库&lt;/p&gt;
&lt;p&gt;2. 使用 Node.js 高效编写脚本&lt;/p&gt;
&lt;p&gt;3. 谷歌开源项目风格指南&lt;/p&gt;
&lt;p&gt;4. 高效的 KV 数据库&lt;/p&gt;
&lt;p&gt;5. Python Fire&lt;/p&gt;
&lt;p&gt;6. Gson&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. 核心 Java 库&lt;/h3&gt;
&lt;p&gt;Guava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、图形库以及用于并发、I/O、缓存、字符串等的实用程序！它广泛用于 Google 内部的大多数 Java 项目，也被许多其他公司广泛使用。&lt;/p&gt;
&lt;p&gt;开源项目：https://github.com/google/guava&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bddd492577e4217bf131d459f18f732~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 使用 Node.js 高效编写脚本&lt;/h3&gt;
&lt;p&gt;如果你尝试编写一个在 Node.js 下运行的 Shell 脚本，你可能会发现它并不像你希望的那样流畅。而Google 的 zx 库有助于使用 Node.js 高效且愉快地编写 Shell 脚本。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/zx&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/034a91a8075b4c44b2af25db83ae5788~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. 谷歌开源项目风格指南&lt;/h3&gt;
&lt;p&gt;每个开源项目都有自己的风格指南：一组关于如何为该项目编写代码的约定。当其中的所有代码都采用一致的样式时，理解大型代码库会容易得多。&lt;/p&gt;
&lt;p&gt;“风格”涵盖了很多方面，从“使用驼峰式命名变量名”到“从不使用全局变量”到“从不使用异常”。这个开源项目是一个索引页，可以帮你快速了解 Google 开源项目的风格规范。&lt;/p&gt;
&lt;p&gt;开源地点：https://github.com/google/styleguide&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/463786f1fafb49f8928f3822a05733ba~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 高效的 KV 数据库&lt;/h3&gt;
&lt;p&gt;Leveldb 是一个 Google 实现的非常高效的 KV 数据库，版本 1.2 能够支持 Billion 级别的数据量了。在这个数量级别下还有着非常高的性能，主要归功于它的良好的设计。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/leveldb&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d4261fc6f7544318472abd6b58bca18~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;05. Python Fire&lt;/h3&gt;
&lt;p&gt;Python Fire 是一个 Python 库，只需对 Fire 进行一次调用即可将任何 Python 组件转变为命令行界面。不需要做任何额外的工作，只需要从主模块中调用 fire.Fire()，它会自动将你的代码转化为 CLI，Fire() 的参数可以说任何的 Python 对象。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/python-fire&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4ce913e648c400c8082189d4e256304~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;06. Gson&lt;/h3&gt;
&lt;p&gt;Google Gson 是一个简单的基于 Java 的库，用于将 Java 对象序列化为 JSON，反之亦然。它是由 Google 开发的一个开源库。&lt;/p&gt;
&lt;p&gt;以下几点说明为什么应该使用这个库，Gson是一个由Google管理的标准化库、这是对 Java 标准库的可靠，快速和高效的扩展、Gson 库经过高度优化、它为泛型提供了广泛的支持、它支持具有深度继承层次结构的复杂对象。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/gson&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d975d9217394d77833e83cf60860b1f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a80ced5396314208a49057768d881e16~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;</description><author>逛逛GitHub</author><pubDate>Wed, 08 Jun 2022 23:50:27 GMT</pubDate></item><item><title>推荐 4 个视频自动生成器</title><link>https://juejin.cn/post/7106394465580875784</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 编程生成视频的库&lt;/p&gt;
&lt;p&gt;2. 半佛风格视频生成器&lt;/p&gt;
&lt;p&gt;3. 快速高效的生成短视频&lt;/p&gt;
&lt;p&gt;4. 知乎文章转视频乞丐版&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. 编程生成视频的库&lt;/h3&gt;
&lt;p&gt;Remotion 是一套使用编程生成视频的库，为使用 React 以编程方式创建视频奠定了基础。&lt;/p&gt;
&lt;p&gt;有很多方法可以使用编程的方式创建视频，比如：利用网络技术，使用 CSS、Canvas、SVG、WebGL 等，也可以使用变量、函数、API、数学和算法来创造新的效果。但是利用 React，可重用组件、有强大的组合、快速刷新、包含包生态系统。&lt;/p&gt;
&lt;p&gt;开源地址：开源地址：https://github.com/remotion-dev/remotion&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a75cb81cd11d40e181eb9bc6574f122d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 半佛风格视频生成器&lt;/h3&gt;
&lt;p&gt;半佛在 2020 年凭借众多沙雕表情包视频 + 魔性的文案迅速出圈。这个开源项目会爬取半佛的公众号文案，然后进行断句，将文案根据短句分割，每句作为一条字幕，根据字幕搜索表情包并选择设置。&lt;/p&gt;
&lt;p&gt;利用语音合成手段合成配音，直到所有的字幕均完成表情包设定、字幕设定、配音设定，合成视频并加入背景音乐，就能导出成品了。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/WithHades/banfoStyle&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f82ced5799b14bb2b122c4e2b1f73f4f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. 快速高效的生成短视频&lt;/h3&gt;
&lt;p&gt;一种基于 Python 编写的视频自动生成程序。这个小项目实现了文字转视频和音频转视频的功能。&lt;/p&gt;
&lt;p&gt;任意输入或者利用爬虫爬取一段文字语料，首先将其生成音频，然后将这段音频生成视频并添加字幕。音频中可加入各种声效，视频可换任意背景图。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/qihao123/GenVIdeo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7592045accdb4e929964e6418eef33d4~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 知乎文章转视频乞丐版&lt;/h3&gt;
&lt;p&gt;这个开源项目是开发者写的一个小 Demo，实现文字转视频功能。在实现文章转视频需要解决的几个问题：文字分割、文字生成图片、文字转语言等。&lt;/p&gt;
&lt;p&gt;这个开源项目都是使用的比较基础和简单的手段解决这些问题。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/leoython/text-to-video&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b0c3e66bc6402abcccec0a7ff6219c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;历史盘点：https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22f40a9c3a6845dda8b1066ef06d77dc~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Mon, 06 Jun 2022 23:20:14 GMT</pubDate></item><item><title>推荐 8 个 GitHub 开源项目</title><link>https://juejin.cn/post/7106020139799150629</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. App ideas&lt;/p&gt;
&lt;p&gt;2. 中国程序员容易发音错误的单词&lt;/p&gt;
&lt;p&gt;3. 新型冠状病毒数据库&lt;/p&gt;
&lt;p&gt;4. 全新的构建 &amp;nbsp;Web 界面的方法&lt;/p&gt;
&lt;p&gt;5. Vite &amp;amp; Vue 支持的静态站点生成器。&lt;/p&gt;
&lt;p&gt;6. 视频制作机器人&lt;/p&gt;
&lt;p&gt;7. 50 天 50 个项目&lt;/p&gt;
&lt;p&gt;8. 北京买房攻略&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;App ideas&lt;/p&gt;
&lt;p&gt;这个项目是一个项目列表，该列表会根据开发者的水平提供一些练手项目，帮助你提升编程技巧。&lt;/p&gt;
&lt;p&gt;这个开源项目可以帮助你：提高编程能力;助你尝试新技术;增加你的项目经验。这个列表中提到的小项目，易于完成，易于扩展。&lt;/p&gt;
&lt;p&gt;这不仅是一个简单的列表，每个项目都描述的足够详细，有明确的描述性目标和应当实施的用户故事列表，以方便你从头开始进行开发。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/florinpop17/app-ideas&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c09b5aa66294178958d78ab804f0e2e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;中国程序员容易发音错误的单词&lt;/p&gt;
&lt;p&gt;本开源项目收集了技术栈相关的容易发音错误的单词。本着简单的原则，又为了避免程序猿们出现选择困难症， '正确音标'采用了最接近有道词典音频的英式 DJ 音标,，不代表其唯一性。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/shimohq/chinese-programmer-wrong-pronunciation&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c91a47a9bf8040ee97876ae229283ecd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;新型冠状病毒数据库&lt;/p&gt;
&lt;p&gt;这是由约翰霍普金斯大学系统科学与工程中心 (JHU CSSE) 运营的 2019 年新型冠状病毒可视化仪表板的数据存储库。此外，由 ESRI Living Atlas 团队和约翰霍普金斯大学应用物理实验室 (JHU APL) 提供支持。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/CSSEGISandData/COVID-19&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2bd52588a8c4f5d9709374e93579abe~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;全新的构建 &amp;nbsp;Web 界面的方法&lt;/p&gt;
&lt;p&gt;Svelte 是一种全新的构建用户界面的方法。传统框架如 React 和 Vue 在浏览器中需要做大量的工作，而 Svelte 将这些工作放到构建应用程序的编译阶段来处理。&lt;/p&gt;
&lt;p&gt;与使用虚拟（virtual）DOM 差异对比不同。Svelte 编写的代码在应用程序的状态更改时就能像做外科手术一样更新 DOM。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/sveltejs/svelte&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1b4d99a2c9249808df7ea4469c49004~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;Vite &amp;amp; Vue 支持的静态站点生成器。&lt;/p&gt;
&lt;p&gt;Vite 和 Vue 支持的静态站点生成器，简单、强大且高性能。满足您一直想要的现代 SSG 框架。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/vuejs/vitepress&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87872f04c67c4fc581d11139c488c002~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cae6d5c5c0904e4f8beaf6091d9b21a8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;06&lt;/h1&gt;
&lt;p&gt;视频制作机器人&lt;/p&gt;
&lt;p&gt;有些在抖音、快手上的视频获得了数百万的观看次数，你仔细分析他们的视频，他们唯一做的原创事情收集材料、然后拼接在一起。尤其是一些新闻类的视频，本开源项目就是把这个过程自动化了。&lt;/p&gt;
&lt;p&gt;你只需要准备好视频材料，就能自动生成一个视频。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/elebumm/RedditVideoMakerBot&lt;/p&gt;
&lt;h1&gt;07&lt;/h1&gt;
&lt;p&gt;50 天 50 个项目&lt;/p&gt;
&lt;p&gt;50 多个使用 HTML、CSS 和 JS 搭建的迷你 Web 项目。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/bradtraversy/50projects50days&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a5b491e50354aefb7b9d222cbba07a0~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;08&lt;/h1&gt;
&lt;p&gt;北京买房攻略&lt;/p&gt;
&lt;p&gt;本文总结了北京买房的一些基础知识与经验，由于市场和房贷政策随时间会发生变化，并不保证所有信息的真实有效性，也不构成任何投资建议。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/facert/beijing_house_knowledge&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32f2772167b74cc1a8d8da345036547d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10c2258575141029daab7e4ab11ca0e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 05 Jun 2022 23:08:06 GMT</pubDate></item><item><title>盘点最近 yyds 的开源项目</title><link>https://juejin.cn/post/7104110370645606430</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 一个清新文艺的微社区&lt;/p&gt;
&lt;p&gt;2. 30 天学会 React&lt;/p&gt;
&lt;p&gt;3. 零配置 API 样板&lt;/p&gt;
&lt;p&gt;4. 系统设计资源&lt;/p&gt;
&lt;p&gt;5. Wiki 应用程序&lt;/p&gt;
&lt;p&gt;6. 即时通讯项目&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. 一个清新文艺的微社区&lt;/h3&gt;
&lt;p&gt;一个美观清新的微社区开源项目，整套系统使用 Go + Zinc 的架构，前端由 Vue3 构建，采用小清新风格，布局类似 Twitter 的三栏设计。用 Go 写的后端服务运行内存仅 8MB，在单实例 100QPS 时，内存也能稳定在 20MB 左右，资源占用极低。&lt;/p&gt;
&lt;p&gt;全文检索用 Zinc &amp;nbsp;替代了笨重的ElasticSearch，10 万条数据运行内存在 10MB 左右。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/rocboss/paopao-ce"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/295a34338a214bf3bcd5fe73fced4ce6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44b3016d0fbc4e6584cf15322244058d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 30 天学会 React&lt;/h3&gt;
&lt;p&gt;这个项目是《30 天 React 挑战》，是在 30 天内学习 React 的分步指南。它需要你学习 React 之前具备 HTML、CSS 和 JavaScript 知识储备。&lt;/p&gt;
&lt;p&gt;除了 30 天学会 React，开发者还发布过 30 天学会 JavaScript 等项目。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Asabeneh/30-Days-Of-React"&gt;开源地址&lt;/a&gt;
&lt;a href="https://github.com/Asabeneh/30-Days-Of-HTML"&gt;开源地址&lt;/a&gt;
&lt;a href="https://github.com/Asabeneh/30-Days-Of-JavaScript"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afee9b85ab3949bf90336d9593f64e67~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. 零配置 API 样板&lt;/h3&gt;
&lt;p&gt;Hydra 是 Laravel Sanctum 的零配置 API 样板，并带有开箱即用的优秀用户和角色管理 API。使用 Hydra 开始您的下一个大型 API 项目，专注于构建业务逻辑，并节省无数时间一次又一次地编写无聊的用户和角色管理 API。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/hasinhayder/hydra"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d03cbaf82aa349e4835fbe8dfa2118ef~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 系统设计资源&lt;/h3&gt;
&lt;p&gt;开源项目收集了网上优秀的系统设计的资源，包括视频处理、集群、消息队列、系统设计、分布式、数据等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/InterviewReady/system-design-resources"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2dc1e20261742f6815bb47665265a6f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;05. Wiki 应用程序&lt;/h3&gt;
&lt;p&gt;这个 14.7 K Star 的开源项目是基于 Node.js 构建的现代且强大的 wiki 应用程序。使用 Wiki.js 漂亮而直观的界面让编写文档成为一种乐趣！&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/requarks/wiki"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44a1de6d640a470889c9ce1ce09a0dcc~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;06. 即时通讯项目&lt;/h3&gt;
&lt;p&gt;由 IM 技术专家打造的基于 Go 实现的即时通讯（IM）项目。从服务端到客户端 SDK 开源即时通讯（IM）整体解决方案，可以轻松替代第三方 IM 云服务，打造具备聊天、社交功能的 App。&lt;/p&gt;
&lt;p&gt;支持 Andorid、iOS 原生开发，支持 Flutter、uni-app 跨端开发，支持小程序、React 等所有主流 web 前端技术框架， PC 支持 Electron，Flutter、iOS、uni-app 已有成熟 demo 可以体验。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/OpenIMSDK/Open-IM-Server"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/100485c8f2df45fc985f8a9e4be6806f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1520242baac444e3a80d24a75cbaad66~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Tue, 31 May 2022 19:37:54 GMT</pubDate></item></channel></rss>