<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>掘金</title><link>https://juejin.cn/</link><description>代码不止,掘金不停</description><lastBuildDate>Mon, 29 Aug 2022 22:46:56 GMT</lastBuildDate><generator>PyRSS2Gen-1.1.0</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>「程序人生」在腾讯工作是怎么样的体验</title><link>https://juejin.cn/post/6976896524198346760</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: condensed-night-purple&lt;/h2&gt;
&lt;h2&gt;在腾讯工作是怎么样的体验&lt;/h2&gt;
&lt;p&gt;大家好，我是&lt;strong&gt;TianTian&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最近有读者私信我说，腾讯工作体验如何，有幸是一名腾讯人，借此回答一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首发文章，&lt;a href="https://mp.weixin.qq.com/s/ouZcSyZfIMMyGnG8A7yGRA"&gt;点这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;我是21届毕业的，4月拿到腾讯offer，提前来实习了。对我之前的经历感兴趣的话，推荐大家阅读这篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6945625394154307592"&gt;&amp;lt;阿里腾讯面试梳理&amp;amp;个人成长经历分享&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过也有人问我，&lt;strong&gt;怎么进的腾讯？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嗯，我只能说&lt;strong&gt;更多是运气，现在的我，肯定进不了腾讯了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;20年下半年还在&lt;strong&gt;网易实习&lt;/strong&gt;，那个时候盯着巨大的压力。你可以想象很多同龄人都斩获满意offer，而我刚刚入门。&lt;/p&gt;
&lt;p&gt;在网易的半年，下班会去补知识，周末去公司静下心来做总结，写博客。好在一直危机感蛮强的，特别是在网易这样的大环境中。 我蛮感激那会的自己，因为热爱，努力希望进更好的公司。&lt;/p&gt;
&lt;p&gt;努力的意义何在，共勉：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;拼着一切代价，奔你的前程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;从哪里说起&lt;/h2&gt;
&lt;p&gt;前段时间腾讯上了一波微博热搜，相信大家都看到了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="热搜" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/190c7df6effe46d6805a8575dc8f2092~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那我们从加班开始说起吧，正好也是大家关心的点。&lt;/p&gt;
&lt;p&gt;从网上流出的加班管理机制表上看，&lt;strong&gt;“双休”确实是双休，但“不加班”却不是通常理解的不加班。只有周三是6点下班，其他工作日则是最晚9点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很多人存在质疑，其他部门我不敢保证，但是在我们组，&lt;strong&gt;已经落实了！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每周双休，一日六点。&lt;/p&gt;
&lt;p&gt;其实很爽了，很多外人觉得不已为然，那我们来看看其他大厂加班情况。&lt;/p&gt;
&lt;p&gt;还是拿数据来说话吧，去年的这统计数据，腾讯连前十都进不去。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SpringBoot+Prometheus+Grafana实现应用监控和报警&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="互联网加班排名-1" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0fc96fe62a348d0ba374977f01b4fbb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;再看看另外的一份互联网大厂的加班排名：&lt;/p&gt;
&lt;p&gt;&lt;img alt="互联网加班排名-2" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47c216e0ba5a4a8abd9e984c3a8f8030~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;也许有人说，这个事情不值得称赞，他们做了本应该的事情。不可否认从某种意义上来说，确实是这样子。但是在当下的互联网趋势下，其实真的不多，毕竟对比其他大厂后，大家都明白xxxxx&lt;/p&gt;
&lt;p&gt;&lt;img alt="你懂吧" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d823a287c5b465680dc1dd71e20da90~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;说到这里，提一句，可以来我们组看看机会，投了简历，我会随时跟进&lt;strong&gt;面试反馈&lt;/strong&gt;以及后续结果的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于团队：&lt;a href="http://www.alloyteam.com/"&gt;AlloyTeam 腾讯文档前端团队&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;一天是如何度过的&lt;/h2&gt;
&lt;p&gt;最近开始养成一个习惯，做好每天规划，类似于：&lt;/p&gt;
&lt;p&gt;&lt;img alt="每日ToDo" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a88af111230a4bd1a6d81970d7ba3536~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;会按照每日清单，做好时间上的规划，尽可能执行，晚上做好复盘。可能这是提高效率的一种途径吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;上午&lt;/h3&gt;
&lt;p&gt;基本上8点起床，有时候睡个懒觉，出门的时间会在9点左右。&lt;/p&gt;
&lt;p&gt;去公司的路上，基本上需要50分钟，一般会&lt;strong&gt;听课&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="最近听得课" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b406b0608e7e4d278c2ee0b2badad53e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;一般我会听类似于这样子课程，&lt;strong&gt;理论知识多一些&lt;/strong&gt;。要是状态不好的话，会选择听歌，看会儿知乎。&lt;/p&gt;
&lt;p&gt;基本上深圳9点以后的一号线，应该人很多的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="赶地铁的同志" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81d37bf0f2f048dfbb216ee06803b0b3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="9.jpeg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77fbd39475e042a2a76b456273dd681d~tplv-k3u1fbpfcp-watermark.image" /&gt;
偷拍无礼，还望原谅。&lt;/p&gt;
&lt;p&gt;可能今天下雨的缘故，人不多。公司早些时候发了邮件，可以居家办公（&lt;strong&gt;挺人性化&lt;/strong&gt;），估计大家都在家工作吧。&lt;/p&gt;
&lt;p&gt;到公司第一件事情，&lt;strong&gt;干饭&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;腾讯的食堂很不错，好吃又便宜。早餐是免费自助，很多种类什么都有，热干面，虎皮鸡爪，肠粉，等等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="早餐" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/029440db85ef4a6e9a2120b2ec7990a7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;吃完早餐，到工位的话，基本上都10：30。&lt;/p&gt;
&lt;p&gt;打开电脑，开始计划今天的任务。&lt;/p&gt;
&lt;p&gt;&lt;img alt="工位" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5b76c1a8f6f4babbd4c460d61c49748~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;当时没有申请iMac，期待正式入职的&lt;strong&gt;iMac办公&lt;/strong&gt;。不过我感觉现在办公设备还不错，要是能再有一个4k显示屏，那体验更加棒。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;中午&lt;/h3&gt;
&lt;p&gt;上午的任务完成后，接下来就是午饭时间啦～&lt;/p&gt;
&lt;p&gt;一般选择在公司食堂吃，偶尔跟同事出去吃顿好的。个人感觉，口味还是挺多的，暂时还没有忌口的，都还吃的习惯，就放张留在相册里面的照片吧：&lt;/p&gt;
&lt;p&gt;&lt;img alt="牛肉蛋包饭" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76508f3ed4054a0c920d677dece8fe06~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;吃完饭后，偶尔散下步，回到工位基本上12:50，这个时候会&lt;strong&gt;写写文章&lt;/strong&gt;，看看公众号文章，准备明天的推文。&lt;/p&gt;
&lt;p&gt;不过计划也会变，有时候会跟&lt;strong&gt;同事开黑&lt;/strong&gt;，打两把游戏，当午休的一个环节。&lt;/p&gt;
&lt;p&gt;打完后，接下来会午休，有行军床，睡起来很爽，比趴着桌子上舒服很多。&lt;/p&gt;
&lt;p&gt;一般我们组午休的时间，都会在14:10左右结束。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;下午&lt;/h3&gt;
&lt;p&gt;主要工作就是跟进技术需求，把今天任务完成。有些时候会被会议突然打断。&lt;/p&gt;
&lt;p&gt;下午个人觉得效率是很高的时间段，基本上会充分利用好，尽量不被打扰。&lt;/p&gt;
&lt;p&gt;当然啦，与同事讨论问题，是一个互相学习一起进步的过程。&lt;/p&gt;
&lt;p&gt;&lt;img alt="debug" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbc1bc2ead5a45bab5efc5c39217a0a1~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;旁边来了位实习生，是个女孩子，挺厉害的。&lt;/p&gt;
&lt;p&gt;有时候，会一起讨论下遇到的bug，讨论下一些技术问题，还是挺愉快的，可以互相交流学习下。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;晚上&lt;/h3&gt;
&lt;p&gt;晚上有夜宵卷，基本上吃饭不花钱或者你也可以拿着夜宵卷去麦当劳。&lt;/p&gt;
&lt;p&gt;吃完饭，会出去散步，绕公司走一圈。不同人可能选择是不一样的，有些人会选择去健身。&lt;/p&gt;
&lt;p&gt;腾讯还是会提供健身的地方的，滨海大厦就有不错的场所。不过我基本上还没有健身的习惯：&lt;/p&gt;
&lt;p&gt;&lt;img alt="滨海大厦健身房" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5fec26224cc4d20a38dec06572975ae~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;有些人，会选择去打球。比如我们提供对应的&lt;strong&gt;打球场地&lt;/strong&gt;。（虽然我还没有去过）&lt;/p&gt;
&lt;p&gt;我基本上回工位，继续把今日任务完成。&lt;/p&gt;
&lt;p&gt;晚上10点后打滴滴回家公司报销，体验过几次10点回去，基本上整层楼，数得过来为数不多的人，主要我不是卷，我是想在公司搞完任务，回去可以写自己的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不是卷！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深圳的夜晚怎么样？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候，觉得很璀璨，有时间觉得到一丝丝的艰难。&lt;/p&gt;
&lt;p&gt;&lt;img alt="滨海大厦" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e0b3a8777e4d429ec96314b48d56d6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;一切取决于你，是否选择&lt;strong&gt;躺平划水&lt;/strong&gt;，还是奋勇前进。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;感受&lt;/h2&gt;
&lt;p&gt;平淡的描述我大致一天的做的事情，可能你会觉得真的忙，无聊。&lt;/p&gt;
&lt;p&gt;其实我想说，不是这样子的，腾讯的福利也很多，有很多游戏福利，包括XXXXX，很爽。&lt;/p&gt;
&lt;p&gt;小组里或者整个团队还会不定时组织团建，而且大多都是工作日去团建哈哈哈。&lt;/p&gt;
&lt;p&gt;上次整个大组一起去团建滑雪了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="朋友拍的" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/399cac86dc5c459f869e36ce65354bd5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;不仅玩的好，吃得好，住的也是挺不错的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="朋友拍的" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01b81e59827f4a23aaa8a0f9a9c80098~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;是啊，我们的生活并不只有&lt;strong&gt;coding&lt;/strong&gt;。这么有意思的一个团队，不值得你加入吗！！！&lt;/p&gt;
&lt;p&gt;静下心来思考，在腾讯上班，可以用几个点来表达：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、太拼命了，自己要多主动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是我的第一印象，大家都很努力。&lt;/p&gt;
&lt;p&gt;第一天入职，想着稍微表现下，等大家一起，后来发现有些同事会很晚走。&lt;/p&gt;
&lt;p&gt;为了和大家步伐一致，需要自己多主动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、自豪感。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这点是有切身体会的，跟亲戚朋友说你在腾讯工作，还挺有面的。他们第一反应，可能是“哇，腾讯啊，大公司”。&lt;/p&gt;
&lt;p&gt;前女友知道我去腾讯了，后续也找过我好几次。&lt;/p&gt;
&lt;p&gt;隔三差五的小福利让你在朋友圈&lt;strong&gt;赚足虚荣心&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、福利待遇好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这点对比国内互联网大厂来说，综合性价比来说，还是挺好的。无息贷款90W，各种其他的福利，这里保密了。&lt;/p&gt;
&lt;p&gt;如果你部门是很得力的，比如游戏部门。年终奖还真的很可观，10个月以上的还是有的。&lt;/p&gt;
&lt;p&gt;再加上可以搞点期权的话，挺有有盼头的，毕竟这些年腾讯股票已经涨了若干若干倍了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、身边人越来越优秀。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;竞争还是蛮激烈的，不管是校招生，还是社招，进来的牛人大把，都是高智商，竞争和比拼的压力还是蛮大的。&lt;/p&gt;
&lt;p&gt;同事们的做事能力，抗压能力，管理能力以及与人沟通能力，都是让我挺欣赏的。&lt;/p&gt;
&lt;p&gt;学习氛围好，组内技术沉淀氛围好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;让我深刻体会到了，越是优秀的人，越努力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、环境越来越好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;办公环境越来越好，听说每年会有各种&lt;strong&gt;兴趣协会&lt;/strong&gt;、&lt;strong&gt;运动培训班&lt;/strong&gt;、&lt;strong&gt;嘉年华活动&lt;/strong&gt;，走到哪里都有的班车，各种便利的OA等等。&lt;/p&gt;
&lt;p&gt;腾讯的HR、行政一直以“&lt;strong&gt;用户体验&lt;/strong&gt;”作为目标提升工作。&lt;/p&gt;
&lt;p&gt;腾讯的食堂很不错，好吃又便宜。这些都让我觉得，外界条件在往越来越好的地方发展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、上下级，同事之间都很平等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里没有很强烈的上下级概念，都是喊昵称或者xxx哥。&lt;/p&gt;
&lt;p&gt;交流问题的时候，给我感觉，大家都是平等的，一视同仁。&lt;/p&gt;
&lt;p&gt;对于我这个新人来说，初期让我负责一个项目，大家会相信我，放心让我去做。&lt;/p&gt;
&lt;p&gt;这点我觉得挺舒服的！！！&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果你是应届生，&lt;strong&gt;腾讯是值得来的&lt;/strong&gt;。优秀的同事以及完善的新人培养机制会在职业生涯的初期让你&lt;strong&gt;更快成长&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总之，不去诋毁腾讯，也不是希望你盲目乐观的看待腾讯的工作，里面有快乐也有不快乐，&lt;strong&gt;兼听则明&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于团队：&lt;a href="http://www.alloyteam.com/"&gt;AlloyTeam 腾讯文档前端团队&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果喜欢，双击点赞~~&lt;/strong&gt;&lt;/p&gt;</description><author>TianTianUp</author><pubDate>Wed, 23 Jun 2021 00:02:50 GMT</pubDate></item><item><title>「前端性能」避免回流和重绘的必要性</title><link>https://juejin.cn/post/6953029989306466317</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: condensed-night-purple&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本文会介绍浏览器中帧（Frame）的概念，它的流程是怎么样的。&lt;/p&gt;
&lt;p&gt;至于写这个文章的出发点在于，我好奇浏览器中像素工作流程是怎么样的，什么时候开始的，最后的结果是什么。&lt;/p&gt;
&lt;p&gt;基于这些好奇，查阅了些外文资料，本文提供了些参考，参考链接在文末。&lt;/p&gt;
&lt;p&gt;最近搞了性能优化思维导图，还在持续输出中，&lt;a href="https://docs.qq.com/mind/DWnljWm52eEVjWWNE"&gt;点击这里&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;缘由&lt;/h2&gt;
&lt;p&gt;在讲帧的概念前，我们得从背景开始看起，也就是渲染页面的这个过程，有哪些关键性的路径呢。&lt;/p&gt;
&lt;h3&gt;五大关键渲染路径&lt;/h3&gt;
&lt;p&gt;像素输出到页面，肯定经历了很多的过程，那我们作为前端工程师，工作中需要注意的点是哪些呢，这里给出参考:&lt;/p&gt;
&lt;p&gt;&lt;img alt="渲染关键路径" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b04e38ce457a4940af9446daf6fcb6fd~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这五个主要的部分，应该是我们值得去关注的，因为我们拥有最大控制权的部分。至于每一个过程具体是怎么样的呢，不清楚的可以参考下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="详细的工作" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e25e5314ce947e8859820a36680f59c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;所以在这么一个像素的管道里，每部分都有可能造成卡顿，所以我们需要额外的关注这些，毕竟那一部分不当，都会开了不必要的性能开销。&lt;/p&gt;
&lt;h3&gt;三种输出方式&lt;/h3&gt;
&lt;p&gt;当时我的疑问是: 难道每一帧都总是会经过管道每个部分的处理嘛，其实不是这样子的，从视觉的角度来说，管道针对指定帧的运行通常有三种方式:&lt;/p&gt;
&lt;p&gt;&lt;img alt="指定帧的运行通常有三种方式" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03fd70517789475c9d2e4ed50af7736c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果我们以第三种方式来更新视图，也就是更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。&lt;/p&gt;
&lt;h3&gt;跑个demo&lt;/h3&gt;
&lt;p&gt;为了更加具体的验证上述的过程，可以动手跑一个demo，来验证一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;demo地址:https://googlechrome.github.io/devtools-samples/jank/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="主线程-火焰图" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53d192456b80423cb765fad3b12c2df0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们添加多个dom元素进行动画，效果更佳明显，接着我们打开Performance，Record这个过程，我们需要关注的是Main选项卡，也就是主线程，我们在放大里面的Task，就有了下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="主线程-火焰图-2" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5862ea6557704d998ef91f358b3e845d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;经历的过程，也是很清楚看到，Update Layer Tree --&amp;gt;&amp;gt; Layout --&amp;gt;&amp;gt; Paint --&amp;gt;&amp;gt; Composite Layers。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你不是很清楚Performance中名称的含义,可以参考下面这篇文章，&lt;a href="https://mp.weixin.qq.com/s/iodsGPWgYc97yWLb09Xk6A"&gt;点这里&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;https://mp.weixin.qq.com/s/iodsGPWgYc97yWLb09Xk6A&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着，我们按下，Optimize按钮，按照之前的流程走，Record后，发现不对劲，还是这样子步骤，难道是哪里存在问题嘛，好奇的我，打开了Sources面板，然后就发现了:&lt;/p&gt;
&lt;p&gt;&lt;img alt="优化后的动画" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acc257718a5f4c109dc783f6408a3165~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;它的源码优化动画，使用的是rAF,了解过的人一定不会陌生，你可以简单的理解就是:按帧对网页进行重绘。这里就引出了帧的概念，后续会说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rAF的详细介绍，后续会对它进行梳理，可以持续关注。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;如何避免回流与重绘&lt;/h3&gt;
&lt;p&gt;回到前面我们设想的点，我们如何才能保证直接跳到合成过程，避免Layout以及Paint呢，当然有，我们需要对app.js中的uppdate函数进行改造，使用&lt;strong&gt;transform: translateX(0px);&lt;/strong&gt;  做动画，做完update函数的处理逻辑后，我们再次Record一下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="优化后的动画" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73cb710cdf1347a3b4ea52be86664535~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从Task子任务中，我们可以发现，&lt;strong&gt;Layout --&amp;gt;&amp;gt; Paint&lt;/strong&gt;, 布局和绘制的过程跳过了。这也是为什么我们常说的需要避免回流与重绘。从主线程上来看，能够完全的避免这些过程，避免了很多的运算开销。&lt;/p&gt;
&lt;p&gt;这也是为什么经常可以看到这样子的建议:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;坚持使用 transform 和 opacity 属性更改来实现动画。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;will-change&lt;/code&gt; 或 &lt;code&gt;translateZ&lt;/code&gt; 提升移动的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至于使用will-change和translatez来提升图层，这又是另外知识点了，这里就不张开了。&lt;/p&gt;
&lt;p&gt;介绍到这里，我们已经清楚的明白，避免回流和重绘的意义，那么我们提到的&lt;strong&gt;帧&lt;/strong&gt;和&lt;strong&gt;rAF&lt;/strong&gt; 与 渲染路径有啥关系呢。&lt;/p&gt;
&lt;h2&gt;帧&lt;/h2&gt;
&lt;p&gt;我做的第一件事情就是google，然后维基百科给出如下定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在&lt;a href="https://zh.wikipedia.org/wiki/%E8%A7%86%E9%A2%91"&gt;视频&lt;/a&gt;领域，&lt;a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%BD%B1"&gt;电影&lt;/a&gt;、&lt;a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%A7%86"&gt;电视&lt;/a&gt;、&lt;a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%A7%86%E9%A2%91"&gt;数字视频&lt;/a&gt;等可视为随时间连续变换的许多张画面，其中&lt;strong&gt;帧&lt;/strong&gt;是指每一张画面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，不是很好理解，知道我找到了这张图，才解答了我的困惑:&lt;/p&gt;
&lt;p&gt;&lt;img alt="anatomy-of-a-frame.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5780421fc5144028e6b260b36ccb709~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这就真的是&lt;strong&gt;一图胜千言&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个图，你可以理解成就是像素放到屏幕的完整过程。你肯定对里面的一些关键信息很迷惑，这里作出一些解释。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接下来大部分内容都是翻译的，没有更多的总结，感兴趣可以看看原文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;PROCESSES(进程)&lt;/h3&gt;
&lt;p&gt;映入眼帘的就是进程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Renderer Process&lt;/strong&gt;: 渲染进程。
&lt;ul&gt;
&lt;li&gt;一个标签的周围容器。&lt;/li&gt;
&lt;li&gt;它包含了多个线程，这些线程共同负责让你的页面出现在屏幕上的各个环节。&lt;/li&gt;
&lt;li&gt;这些线程是&lt;strong&gt;合成线程&lt;/strong&gt;（Compositor）、&lt;strong&gt;图块栅格化线程&lt;/strong&gt;（Tile Worker）和主线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPU Process&lt;/strong&gt;:  GPU进程。
&lt;ul&gt;
&lt;li&gt;这是服务于所有标签和周围浏览器进程的单一进程。&lt;/li&gt;
&lt;li&gt;当帧被提交时，GPU进程将上传任何磁贴和其他数据（如四维顶点和矩阵）到GPU，以便实际将像素推送到屏幕上。&lt;/li&gt;
&lt;li&gt;GPU进程包含一个单一的线程，称为GPU线程，实际完成工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;RENDERER PROCESS THREADS（渲染进程中的线程）&lt;/h3&gt;
&lt;p&gt;现在我们来看看Renderer Process中的线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Compositor Thread&lt;/strong&gt;(合成线程):
&lt;ul&gt;
&lt;li&gt;这是第一个被告知vsync事件的线程(这是操作系统告诉浏览器制作新帧的方式)。&lt;/li&gt;
&lt;li&gt;它还将接收任何输入事件。&lt;/li&gt;
&lt;li&gt;如果可以的话，合成器线程将避免进入主线程，并将尝试将输入（比如说--滚动甩动）转换为屏幕上的运动。它将通过更新图层位置并通过GPU线程直接将帧提交给GPU来实现。&lt;/li&gt;
&lt;li&gt;如果因为输入事件处理程序或其他视觉工作而无法做到这一点，那么就需要使用主线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Main Thread&lt;/strong&gt;(&lt;strong&gt;主线程&lt;/strong&gt;)：
&lt;ul&gt;
&lt;li&gt;这是浏览器执行我们都知道和喜欢的任务的地方。JavaScript、样式、布局和绘画。(在未来的&lt;a href="https://surma.link/things/houdini-intro/"&gt;Houdini&lt;/a&gt;中，这种情况会有所改变，我们将能够在Compositor线程中运行一些代码。)&lt;/li&gt;
&lt;li&gt;这个线程赢得了 "最有可能导致jank "的奖项，主要是因为这里有很多东西在运行。(jank值得是&lt;strong&gt;页面抖动&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Compositor Tile Worker(s) (&lt;strong&gt;合成图块栅格化线程&lt;/strong&gt;):
&lt;ul&gt;
&lt;li&gt;由合成线程派生的一个或多个线程，用于处理栅格化任务。我们稍后再讨论。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在很多方面，你应该把Compositor线程视为 "大老板"。虽然它不运行JavaScript、Layout、Paint或其他任何东西，但它是完全负责启动主线程工作的线程，然后将帧运送到屏幕上。如果它不需要等待输入事件处理程序，它就可以在等待主线程完成工作的同时运送帧。&lt;/p&gt;
&lt;p&gt;你也可以想象Service Workers和Web Workers生活在这个过程中，不过我没有把他们包括在内，因为这让事情变得更加复杂。&lt;/p&gt;
&lt;h3&gt;THE FLOW OF THINGS(主线程流程)&lt;/h3&gt;
&lt;p&gt;让我们成主线程开始吧。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a7ef1a216604eb282954c9673a1e5e9~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;让我们一步步走过这个流程，从vsync到像素，并谈谈在事件的 "全胖 "版本中事情是如何进行的。值得记住的是，浏览器不需要执行所有这些步骤，这取决于什么是必要的。例如，如果没有新的HTML要解析，那么解析HTML就不会启动。事实上，很多时候，提高性能的最好方法就是简单地消除部分流程被启动的必要性!&lt;/p&gt;
&lt;p&gt;同样值得注意的是，样式和布局下的红色箭头似乎指向了 &lt;strong&gt;requestAnimationFrame&lt;/strong&gt;。在你的代码中完全有可能意外地触发这两者。这就是所谓的强制同步布局（或样式，视情况而定），它通常对性能不利。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Frame Start&lt;/strong&gt;（&lt;strong&gt;开始新的一帧&lt;/strong&gt;）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;垂直同步信号触发，开始渲染新的一帧图像。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Input event handlers&lt;/strong&gt; （&lt;strong&gt;输入事件的处理&lt;/strong&gt;）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-输入数据从合成器线程传递给主线程上的任何输入事件处理程序。&lt;/li&gt;
&lt;li&gt;所有的输入事件处理程序（触摸移动、滚动、点击）都应该首先启动，每帧一次，但情况不一定如此。&lt;/li&gt;
&lt;li&gt;调度器会做出最大努力的尝试，其成功率在不同的操作系统中有所不同。在用户交互和事件进入主线程处理之间也有一些延迟。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是对屏幕进行视觉更新的理想位置，因为你有新鲜的输入数据，而且这是你要得到的最接近vsync的地方。&lt;/li&gt;
&lt;li&gt;其他的视觉任务，比如样式计算，都是在这个任务之后进行的，所以它的理想位置是突变元素。&lt;/li&gt;
&lt;li&gt;如果你突变--比如说--100个类，这不会导致100个样式计算；它们将被分批处理，并在后面处理。唯一需要注意的是，你不要查询任何计算过的样式或布局属性（比如el.style.backgroundImage或el.style.offsetWidth）。&lt;/li&gt;
&lt;li&gt;如果你这样做，你会把重新计算的样式、布局或两者都向前带，导致强制的同步布局，或者更糟糕的是，布局打乱。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Parse HTML&lt;/strong&gt; (&lt;strong&gt;解析 HTML&lt;/strong&gt;):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任何新添加的HTML都会被处理，并创建DOM元素。&lt;/li&gt;
&lt;li&gt;在页面加载过程中或appendChild等操作后，你可能会看到更多的这种情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Recalc Styles&lt;/strong&gt;（&lt;strong&gt;重新计算样式&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;样式是为任何新添加或突变的东西计算的，这可能是整个树，也可能是范围，这取决于改变了什么。&lt;/li&gt;
&lt;li&gt;这可能是整个树，也可能是范围缩小，这取决于改变了什么。&lt;/li&gt;
&lt;li&gt;例如，改变主体上的类可能影响深远，但值得注意的是，浏览器已经非常聪明地自动限制了样式计算的范围。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Layout&lt;/strong&gt;（绘制）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算每个可见元素的几何信息（每个元素的位置和大小）。它通常对整个文档进行计算，通常使计算成本与DOM大小成正比。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Update Layer Tree&lt;/strong&gt;（&lt;strong&gt;更新图层树&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建叠加上下文和深度排序元素的过程。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Paint&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是两部分过程中的第一部分：绘制是记录任何新元素或视觉上有变化的元素的绘制调用（在这里填充一个矩形，在那里写文字）。&lt;/li&gt;
&lt;li&gt;第二部分是光栅化（见下文），在这里执行绘图调用，并填充纹理。这一部分是对绘制调用的记录，通常比光栅化快得多，但这两部分通常统称为 "绘画"。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Composite&lt;/strong&gt;（&lt;strong&gt;合成&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算出图层和瓷砖的信息，并传回给合成器线程来处理。&lt;/li&gt;
&lt;li&gt;这将会考虑到，除其他事项外，像will-change，重叠元素，以及任何硬件加速的canvases。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Raster Scheduled&lt;/strong&gt; （&lt;strong&gt;栅格化规划&lt;/strong&gt;）and &lt;strong&gt;Rasterize&lt;/strong&gt;（&lt;strong&gt;栅格化&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;现在会执行在Paint任务中记录的绘制调用。这是在Compositor Tile Workers中完成的，其数量取决于平台和设备能力。&lt;/li&gt;
&lt;li&gt;例如，在Android上，你通常会发现一个Worker，在桌面上，你有时可以找到四个。栅格化是以图层为单位进行的，每个图层都是由瓷砖组成的。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Frame End（帧结束）:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当各个图层的磁贴都栅格化后，任何新的磁贴都会和输入数据（可能在事件处理程序中被改变）一起提交给GPU线程。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Frame Ships&lt;/strong&gt;（&lt;strong&gt;发送帧&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最后，但绝不是最不重要的，磁贴由GPU线程上传至GPU。GPU使用四边形和矩阵（所有常见的GL好东西）将磁贴绘制到屏幕上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大致上，整个的过程就是上述。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;requestIdleCallback&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;要说这个的话，我们得拿&lt;strong&gt;requestAnimationFrame&lt;/strong&gt;来类比，requestAnimationFrame是在重新渲染屏幕&lt;strong&gt;之前&lt;/strong&gt;执行的，上面提到的rAF，当时做的就是优化动画，所以很适合做动画。&lt;/p&gt;
&lt;p&gt;requestIdleCallback你通过主线程里面中的Task去查找的话，会发现它是在渲染屏幕&lt;strong&gt;之后&lt;/strong&gt;执行，通过查阅文章发现，一般会看浏览器是否空闲。&lt;/p&gt;
&lt;p&gt;这里篇幅有限，想要了解这个的话，推荐&lt;a href="https://juejin.cn/post/6844904196345430023"&gt;一篇文章&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://juejin.cn/post/6844904165462769678&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;最近查阅外文文献，发现要学的东西太多了，如果这篇文章有写的不对，或者翻译不佳的地方，欢迎小伙伴指出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文首发地址&lt;a href="https://mp.weixin.qq.com/s/nMp8j2VnwllLzS8PVJnecQ"&gt;点这里&lt;/a&gt;,欢迎大家关注公众号「TianTianUp」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我是TianTian，我们下一期见！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;[1] &lt;strong&gt;w3c-longTasks:&lt;/strong&gt; https://github.com/w3c/longtasks&lt;/p&gt;
&lt;p&gt;[2] &lt;strong&gt;chrome-fps-meter:&lt;/strong&gt; https://developer.chrome.com/docs/devtools/evaluate-performance/reference/#fps-meter&lt;/p&gt;
&lt;p&gt;[3] &lt;strong&gt;devtools-samples:&lt;/strong&gt; https://googlechrome.github.io/devtools-samples/jank/&lt;/p&gt;
&lt;p&gt;[4] &lt;strong&gt;Analyze runtime performance:&lt;/strong&gt; https://developer.chrome.com/docs/devtools/evaluate-performance/&lt;/p&gt;
&lt;p&gt;[5] &lt;strong&gt;Timeline Event Reference:&lt;/strong&gt; https://developer.chrome.com/docs/devtools/evaluate-performance/performance-reference/&lt;/p&gt;
&lt;p&gt;[6] &lt;strong&gt;The Anatomy of a Frame:&lt;/strong&gt; https://aerotwist.com/blog/the-anatomy-of-a-frame/&lt;/p&gt;
&lt;p&gt;[7] &lt;strong&gt;performance-rendering:&lt;/strong&gt; https://developers.google.com/web/fundamentals/performance/rendering&lt;/p&gt;
&lt;p&gt;[8] &lt;strong&gt;维基百科:&lt;/strong&gt; https://zh.wikipedia.org/wiki/&lt;/p&gt;</description><author>TianTianUp</author><pubDate>Mon, 19 Apr 2021 16:33:16 GMT</pubDate></item><item><title>如何使用Lighthouse性能检测工具</title><link>https://juejin.cn/post/6950855971379871757</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近做性能检测工具，很多知识点不清楚，打算查缺补漏，补一补。&lt;/p&gt;
&lt;p&gt;接下来从官方提供的性能检测工具Lighthouse(灯塔)开始我们的学习，简单介绍了下Lighthouse的一些点。&lt;/p&gt;
&lt;p&gt;阅读完本文，你可以了解到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lighthouse 是什么。&lt;/li&gt;
&lt;li&gt;如何快速上手Lighthouse (使用入门)。&lt;/li&gt;
&lt;li&gt;Lighthouse中的一些Metrics指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能相关的总结准备搞个思维导图，可以&lt;a href="https://docs.qq.com/mind/DWnljWm52eEVjWWNE"&gt;点这里&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://docs.qq.com/mind/DWnljWm52eEVjWWNE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Lighthouse 是什么&lt;/h2&gt;
&lt;p&gt;官方对它的解读:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/GoogleChrome/lighthouse"&gt;Lighthouse&lt;/a&gt; 是一个开源的自动化工具，用于改进网络应用的质量。 您可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 您为 Lighthouse 提供一个您要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它是如何工作的呢？&lt;/p&gt;
&lt;p&gt;如果你跟我一样，翻过它的代码，看过它的介绍肯定很懵逼，它的代码依赖性如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse内部模块依赖.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134180f910bf46019ceb8e71e57c1c54~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;感兴趣的可以看看它的仓库，参考链接已经给出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://github.com/GoogleChrome/lighthouse&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;使用入门&lt;/h2&gt;
&lt;p&gt;运行 Lighthouse 的方式有两种: 作为 Chrome 扩展程序运行，或作为命令行工具运行。 Chrome 扩展程序提供了一个对用户更友好的界面，方便读取报告。 命令行工具允许您将 Lighthouse 集成到持续集成系统。&lt;/p&gt;
&lt;h3&gt;Chrome 扩展程序&lt;/h3&gt;
&lt;p&gt;下载 Google Chrome 52 或更高版本。&lt;/p&gt;
&lt;p&gt;安装 &lt;a href="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk"&gt;Lighthouse Chrome 扩展程序&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;地址:https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;点击 &lt;strong&gt;Generate report&lt;/strong&gt; 按钮以针对当前打开的页面运行 Lighthouse 测试。&lt;/p&gt;
&lt;h3&gt;命令行工具&lt;/h3&gt;
&lt;p&gt;Node CLI在配置和报告Lighthouse运行情况方面提供了最大的灵活性。如果用户需要更多的高级功能，或者想自动运行Lighthouse，可以使用Node CLI。安装 Lighthouse 作为一个全局节点模块。&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm install -g lighthouse
# or use yarn:
# yarn global add lighthouse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;针对一个页面运行 Lighthouse 审查。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;lighthouse https://www.example.com --view
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传递 &lt;code&gt;--help&lt;/code&gt; 标志以查看可用的输入和输出选项。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;lighthouse --help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于一些options不清楚的，可以点击这个链接:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://github.com/GoogleChrome/lighthouse#cli-options&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设我们审查后，就会有这么一个结果:&lt;/p&gt;
&lt;p&gt;&lt;img alt="light-metrics.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb85726649d34805a36742eeeb88d8d8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到一共6个Metrics，Lighthouse 6.0在报告中引入了三个新指标。其中两个新的指标--最大内容画（LCP）和累积布局偏移（CLS）--是Core Web Vitals的实验室实现。&lt;/p&gt;
&lt;p&gt;那么接下来，我们看看这些Metrics指标的含义。&lt;/p&gt;
&lt;h2&gt;几个Metrics指标&lt;/h2&gt;
&lt;h3&gt;First Contentful Paint (FCP)&lt;/h3&gt;
&lt;p&gt;第一次内容丰富的绘画(FCP)指标衡量了从页面开始加载到页面内容的任何部分呈现在屏幕上的时间。对于该指标，"内容 "指的是文本、图像（包括背景图像）、&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;元素或非白色&lt;canvas&gt;元素。&lt;/canvas&gt;&lt;/svg&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse-fcp.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8401aa9ee484d7186f5de6ea3308f57~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在上面的负载时间线中，FCP发生在第二帧中，就像呈现给屏幕的第一文本和图像元素时一样。&lt;/p&gt;
&lt;p&gt;你会注意到，虽然部分内容已经呈现，但并非所有内容都已呈现。这是First Contentful Paint (FCP)和Largest Contentful Paint (LCP)之间的一个重要区别--LCP的目的是衡量页面的主要内容何时完成加载。&lt;/p&gt;
&lt;p&gt;知道了概念，如何衡量FCP呢，我们可以接触的有&lt;strong&gt;Field tools&lt;/strong&gt;和&lt;strong&gt;Lab tools&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要在JavaScript中测量FCP，你可以使用Paint Timing API。下面的例子展示了如何创建一个PerformanceObserver，该PerformanceObserver监听名称为first-contentful-paint的油漆条目，并将其记录到控制台。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;new PerformanceObserver((entryList) =&amp;gt; {
  for (const entry of entryList.getEntriesByName('first-contentful-paint')) {
    console.log('FCP candidate:', entry.startTime, entry);
  }
}).observe({type: 'paint', buffered: true});

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Speed Index&lt;/h3&gt;
&lt;p&gt;速度指数是Lighthouse报告中性能部分跟踪的六个指标之一。每项指标都能反映出页面加载速度的某些方面。&lt;/p&gt;
&lt;p&gt;那么它是如何检测的呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;速度指数衡量的是内容在页面加载过程中的视觉显示速度。Lighthouse首先会在浏览器中捕获一段页面加载的视频，并计算出各帧之间的视觉进度。然后，Lighthouse使用Speedline Node.js模块来生成速度指数得分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于具体的计算，可以参考GitHub里面的代码，这里就不展开了。&lt;/p&gt;
&lt;p&gt;那么我们有机会提升它的性能吗？&lt;/p&gt;
&lt;p&gt;利用Lighthouse报告中的 "&lt;strong&gt;Opportunities&lt;/strong&gt; "部分来确定哪些改进对你的页面最有价值。机会越重要，对性能评分的影响就越大。例如，下面的Lighthouse截图显示，消除渲染阻塞资源将带来最大的改善。&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse-speedindex.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5279e1bb4643f9aec3b9e13f6605bb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;Largest Contentful Paint (LCP)&lt;/h3&gt;
&lt;p&gt;最大内容画（LCP）指标报告了在视口中可见的最大图像或文本块的渲染时间，相对于页面首次开始加载的时间。&lt;/p&gt;
&lt;p&gt;&lt;img alt="light-lcp.svg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fe34160f7344500b6527912c2d5723b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从图上也能看出来，为了提供良好的用户体验，网站应该努力使最大内容画幅达到2.5秒或更少。&lt;/p&gt;
&lt;p&gt;更多信息，请观看Paul Irish对LCP的深度剖析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://www.youtube.com/watch?v=diAc65p15ag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Cumulative Layout Shift (CLS)&lt;/h3&gt;
&lt;p&gt;官方对它的解释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cumulative Layout Shift (CLS)是一种视觉稳定性的测量方法，它量化了页面内容在视觉上的移动程度。它量化了一个页面的内容在视觉上移动的程度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单理解就是:&lt;/p&gt;
&lt;p&gt;CLS测量的是整个页面生命周期内发生的每一次意外布局转变的所有单个布局转变得分的总和。&lt;/p&gt;
&lt;p&gt;布局偏移发生在可见元素从一个渲染帧到下一个渲染帧改变其位置的任何时候。关于如何计算单个布局偏移分数，请参见下文）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://web.dev/cls/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="lighthouse-cls.svg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f428f403b344e69baabcef5434adb18~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从上面的图来看，CLS得分低是给开发者的一个信号，表明他们的用户没有经历不必要的内容移动；CLS得分低于0.10被认为是 "好"。&lt;/p&gt;
&lt;h3&gt;Total Blocking Time (TBT)&lt;/h3&gt;
&lt;p&gt;我们看看官方对它的解读：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总阻塞时间（Total Blocking Time，TBT）量化了负载响应能力，测量了主线程被阻塞的时间长到足以阻止输入响应的总时间。TBT衡量的是第一次有内容的绘画（FCP）和交互时间（TTI）之间的总时间。它是TTI的配套指标，它为量化主线程活动带来了更多的细微差别，这些活动阻碍了用户与您的页面进行交互的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，TBT与核心网络生命力的现场指标First Input Delay（FID）有很好的相关性。&lt;/p&gt;
&lt;p&gt;需要更多的了解，可以参考链接:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://web.dev/tbt/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;最新评分标准&lt;/h3&gt;
&lt;p&gt;Lighthouse中的性能得分是由多个指标加权混合计算出来的，总结出一个页面的速度。6.0的性能得分公式如下。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;Phase&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;Metric Name&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;Metric Weight&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Early (15%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;First Contentful Paint (FCP)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;15%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Mid (40%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Speed Index (SI)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;15%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Largest Contentful Paint (LCP)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;25%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Late (15%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Time To Interactive (TTI)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;15%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Main Thread (25%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Total Blocking Time (TBT)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;25%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Predictability (5%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Cumulative Layout Shift (CLS)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;5%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;那么你是不是会跟我一样，有疑问，我们不能修改这个权重嘛，当然可以试一试:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://googlechrome.github.io/lighthouse/scorecalc/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;点击上面的链接，会展示这个一个画面:&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse-Scoring-calculator.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5272b1ec14c44293ba2537b660c23e0f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这个网站发布了一个评分计算器，帮助你了解性能评分。同时，该计算器还能为你提供Lighthouse 5版和6版的评分比较。当你使用Lighthouse 6.0版本进行审计时，报告中会有一个链接，链接到计算工具，并将结果填入其中。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;到这里，其实Lighthouse如何使用，以及一些关键的指标也做了说明，你一定会有疑问:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我如何通过计算他们具体的值呢，有对应的JavaScript API？&lt;/li&gt;
&lt;li&gt;既然可以通过Lighthouse来衡量性能并找到加快页面加载的机会，那么我们如何优化呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;想必看到这里，你遇到的疑惑跟之前一样，那么如何解决呢。&lt;/p&gt;
&lt;p&gt;嗯，上面说的部分并没有详细的展开，剩下的部分，尝试去翻一翻官方文档，查一查资料，收获一定很大。&lt;/p&gt;
&lt;p&gt;使用入门，很简单，没有难度，后续会继续梳理，思维导图在&lt;a href="https://docs.qq.com/mind/DWnljWm52eEVjWWNE"&gt;这里&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://docs.qq.com/mind/DWnljWm52eEVjWWNE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我是TianTianUp，我们下一期见！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;[1] &lt;strong&gt;Lighthouse performance scoring&lt;/strong&gt;: https://web.dev/performance-scoring/&lt;/p&gt;
&lt;p&gt;[2] &lt;strong&gt;GoogleChrome-lighthouse&lt;/strong&gt;: https://github.com/GoogleChrome/lighthouse&lt;/p&gt;
&lt;p&gt;[3] &lt;strong&gt;What's New in Lighthouse 6.0&lt;/strong&gt;: https://web.dev/lighthouse-whats-new-6.0/&lt;/p&gt;
&lt;p&gt;[4] &lt;strong&gt;Measure:&lt;/strong&gt; https://web.dev/measure/&lt;/p&gt;
&lt;p&gt;[5] &lt;strong&gt;How does Lighthouse work?&lt;/strong&gt;: https://github.com/GoogleChrome/lighthouse/blob/master/docs/architecture.md&lt;/p&gt;
&lt;p&gt;[6] &lt;strong&gt;Largest Contentful Paint (LCP)&lt;/strong&gt;: https://web.dev/lcp/&lt;/p&gt;
&lt;p&gt;[7] &lt;strong&gt;Total Blocking Time (TBT):&lt;/strong&gt; https://web.dev/tbt/&lt;/p&gt;
&lt;p&gt;[8] &lt;strong&gt;Cumulative Layout Shift (CLS):&lt;/strong&gt; https://web.dev/cls/&lt;/p&gt;
&lt;p&gt;[9] &lt;strong&gt;First Contentful Paint (FCP):&lt;/strong&gt; https://web.dev/fcp/&lt;/p&gt;
&lt;p&gt;[10] &lt;strong&gt;Speed Index:&lt;/strong&gt; https://web.dev/speed-index/&lt;/p&gt;</description><author>TianTianUp</author><pubDate>Tue, 13 Apr 2021 19:51:39 GMT</pubDate></item><item><title>阿里腾讯面试梳理&amp;个人成长经历分享</title><link>https://juejin.cn/post/6945625394154307592</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: condensed-night-purple&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;好久没有更新了，最近忙着面试，写毕业设计和论文。&lt;/p&gt;
&lt;p&gt;不过不想停下记笔记的习惯，所以偷偷的发面经，然后"惊艳"老铁们。&lt;/p&gt;
&lt;p&gt;校招面经，面试难度中等，看官老爷们看个热闹就行。&lt;/p&gt;
&lt;p&gt;历经一个月战线，投了阿里和腾讯，具体部门这里不展开了，都是核心部门，提供的舞台很大，至于最后选择去哪一家公司，可以关注文末。&lt;/p&gt;
&lt;p&gt;接下来复盘一下这一个月来的面试感受吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文不会泄题，只是根据我的简历，来展开谈一谈，可能会被问到的题目。&lt;/p&gt;
&lt;p&gt;最后以下都是个人观点，个人能力有限，&lt;strong&gt;如果有错误，希望能纠正我。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;简单介绍&lt;/h2&gt;
&lt;p&gt;2021届毕业生，掘金里面的TianTianUp，双非本科院校(江西师大)，没有听错，那个彩礼“天价”的省份。&lt;/p&gt;
&lt;p&gt;21届里面，应该算起步比较晚的了。2020年暑假7月份，才开始认认真真“复习”前端，当时连js作用域，闭包，浏览器缓存都不清楚。因为起步晚，所以后续错过了秋招。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在我才深刻意识到，视野的重要性。&lt;/p&gt;
&lt;p&gt;当时大三学了点vue，做了点看起来牛逼的东西，就觉得很牛了，于是春招投了阿里，结果惨不忍睹。&lt;/p&gt;
&lt;p&gt;重点当时没有放心上，还是继续玩，继续打游戏。&lt;/p&gt;
&lt;p&gt;还好之后觉悟过来，才有了后面网易的故事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，也导致后续很多环节跟不上其他同届大佬。&lt;/p&gt;
&lt;p&gt;秋招的时候，jack，三元同学，林不渡，单哥，承和等大佬都是offer收割机，各种腾讯，快手，字节ssp，无不冲击着我这个萌新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;暗自下决心: 我也要去大厂核心部门，去做有意思的事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了规划，接下来就是看技术博客，动手实践，总结梳理，写博客。&lt;/p&gt;
&lt;p&gt;熬了无数的夜，无数个周末在社区徘徊，这个知识点不懂，查文档，看不明白就换一篇文章，争取做到一遍过。&lt;/p&gt;
&lt;p&gt;这么坚持了半年，2021年的春招，结果让我满意，但结果还是有些遗憾的。&lt;/p&gt;
&lt;p&gt;满意的地方: 借面试机会，跟着大佬交流学习了一波。&lt;/p&gt;
&lt;p&gt;遗憾的地方: 其他大厂没有去尝试，没有趁着面试机会去接触其他领域的大佬。我觉得原因可以归咎于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找不到大厂核心部门的内推，希望去核心部门。&lt;/li&gt;
&lt;li&gt;需要笔试，觉得流程很慢，没有人跟进。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以后面提到了面试机会。&lt;/p&gt;
&lt;p&gt;整个春招的过程中，聊一聊心态发生的改变吧，迷茫--紧张--坦然--自信，最后到意向书，到拿到offer。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小tips&lt;/strong&gt;⬇️&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你是在校生，推荐你阅读三元同学博客，干货满满。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;面试机会&lt;/h2&gt;
&lt;p&gt;基本上我是靠内推的，腾讯文档，是一位校招大佬帮忙推的，觉得履历还行，给了个面试机会，才勉强给我通过的。真的是勉强给的机会，因为学校确实跟985比起来，差距很大，还好有网易实习经历buff，加上写了点博客笔记等笔记输出，才有这个面试机会。&lt;/p&gt;
&lt;p&gt;内推，内推，内推，这是最快，最有效的方式，可以第一时间知道面试结果，面评，以及后续的面试流程。&lt;/p&gt;
&lt;p&gt;至于其他的，美团，百度，shopee走的都是官网流程，需要笔试。腾讯这边到四面总监面的时候，我基本上都放弃了。&lt;/p&gt;
&lt;p&gt;最好的方式就是找靠谱的内推吧，比如秋风大佬，字节找ssh（昊神），很靠谱的。&lt;/p&gt;
&lt;p&gt;好的履历也很重要:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学校985，211。&lt;/li&gt;
&lt;li&gt;大厂实习经历，众多offer。&lt;/li&gt;
&lt;li&gt;扎实的基础，读过源码，理解框架设计思想。&lt;/li&gt;
&lt;li&gt;社区有一定影响力，坚持做博客产出。&lt;/li&gt;
&lt;li&gt;开源贡献，开源项目维护者，热爱前端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上，我会把握其中的一两个点，争取做好，才会有后续的面试机会。&lt;/p&gt;
&lt;p&gt;有了面试机会后，剩下的就是如何去做好一场面试的准备工作了。&lt;/p&gt;
&lt;h2&gt;如何准备&lt;/h2&gt;
&lt;p&gt;这个链接里面总结的特别好，我基本上看它复习的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://bitable.feishu.cn/app8Ok6k9qafpMkgyRbfgxeEnet?from=logout&amp;amp;table=tblEnSV2PNAajtWE&amp;amp;view=vewJHSwJVd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过面完，给我感觉，重在平时的积累，基本上都是围绕项目展开的，之前做的项目得好好准备一下，比如项目难点，项目如何做优化的，项目的亮点。&lt;/p&gt;
&lt;p&gt;这里推荐一个链接：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;面试被问项目经验不用慌，按这个步骤回答绝对惊艳&lt;/p&gt;
&lt;p&gt;https://juejin.cn/post/6844904102795706375&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于其他的部分，更多的是向面试官展示自己的优点，闪光点。&lt;/p&gt;
&lt;h2&gt;面经心得&lt;/h2&gt;
&lt;p&gt;基本上都是围绕我的简历来的，有兴趣的话，可以联系我要pdf，可以给你参考下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="简历-技能部分.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e339408f918434e8c76e2c823db257f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简历上技能写的不多，基本上能保证的是我写的都能聊上两句。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从我简历部分来看，主要涉及几个点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React部分，这里面可以问的内容也很多。&lt;/li&gt;
&lt;li&gt;浏览器相关的。&lt;/li&gt;
&lt;li&gt;计算机网络部分。&lt;/li&gt;
&lt;li&gt;算法与数据结构，基本上这算是我的一个杀手锏吧。&lt;/li&gt;
&lt;li&gt;webpack相关的，同时会涉及到babel。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我现在回顾我的面试部分，都是围绕这些点张开的。可能我是应届生校招的原因，很多时候，考察的是我学习能力，理解能力，对前端热爱的程度这些方面。&lt;/p&gt;
&lt;p&gt;基于这几点，展开聊聊我面试过程中会注意的点，以及围绕我写的专业技能，会聊到的一些话题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;自我介绍&lt;/h3&gt;
&lt;p&gt;很重要的一个环节，说不定可以奠定本次面试的节奏，会根据你说的内容，来张开问你，同时也会给&lt;strong&gt;给面试官一个缓冲的时间来重新熟悉你的简历&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;面试自我介绍，要：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遵守极简原则，突出重点，忽略细节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小参考:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我是谁。&lt;/li&gt;
&lt;li&gt;我的亮点，可以描述一下几个点，最近的经历。&lt;/li&gt;
&lt;li&gt;我为什么需要这份工作（其实这个我自我介绍都是忽略的）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;围绕上面的点，我会着重突出，我在大学的经历，主要是算法相关的经历，接着就是我在网易实习期间的收获，以及中间会持续更新博客，写总结。&lt;/p&gt;
&lt;p&gt;基本上，面试官对我的掘金博客，以及大学搞算法的经历感兴趣，进入了自己擅长的领域，就会轻松很多。&lt;/p&gt;
&lt;p&gt;记住一个点，&lt;strong&gt;面试是跟人打交道&lt;/strong&gt;，学会去展示自己，以及及时跟面试官做合理的沟通很重要。&lt;/p&gt;
&lt;p&gt;以上是我会注意的一些点，我也是这么去做的，尽量围绕自己的&lt;strong&gt;亮点&lt;/strong&gt;去展开，当然了，有些面试官有自己的风格，&lt;strong&gt;可能一上来就是问你项目&lt;/strong&gt;，那么我们应该如何把握呢。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;项目相关&lt;/h3&gt;
&lt;p&gt;我觉得项目相关的话题，是个挺难的话题，围绕它展开的话，可以延伸出很多话题，我列举了些有意思的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目难点。（如何发现问题，解决思路，最后结果）&lt;/li&gt;
&lt;li&gt;项目考虑过优化吗，你是如何优化的，思路是什么。&lt;/li&gt;
&lt;li&gt;项目的组织架构，你对它的现有架构的理解，哪些优点值得借鉴，哪些缺点需要改进。&lt;/li&gt;
&lt;li&gt;如果让你从0到1建一个项目，你考虑的点是什么，有哪些流程需要注意的。&lt;/li&gt;
&lt;li&gt;项目中代码规范，你们项目有方案吗，你了解的代码规范有哪些方案。&lt;/li&gt;
&lt;li&gt;说一说项目中你们是如何测试的，有哪些单元测试方案，能不能说一说。&lt;/li&gt;
&lt;li&gt;项目中引入TS的原因，为什么这么做。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过对于&lt;strong&gt;应届生&lt;/strong&gt;来说，问项目都是围绕你简历来问的，比如我当时的项目，我觉得没有好的难点，我就&lt;strong&gt;着重说明&lt;/strong&gt;了下，我对项目是如何优化的，优化了哪些点。&lt;/p&gt;
&lt;p&gt;整个面试下来，都会问，你项目写到的优化的地方，能不能具体聊一聊。&lt;/p&gt;
&lt;p&gt;这个时候，真的要把握机会了，问到你会的点，你得有清晰的思路，可以参考STAR法则。&lt;/p&gt;
&lt;p&gt;重新回顾一下 STAR 法则四要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Situation&lt;/strong&gt;：事情是在什么情况下发生，基于一个怎样的背景；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Task&lt;/strong&gt;：你是如何明确你的任务的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Action&lt;/strong&gt;：针对这样的情况分析，你采用了什么行动方式，具体做了哪些工作内容；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Result&lt;/strong&gt;：结果怎样，带来了什么价值，在整个过程中你学到了什么，有什么新的体会。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有段话，我觉得说的很不错:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;往往大部分同学一上来就直接介绍做了什么以及实现的过程，条理也比较清晰，内容也颇具技术含量。但很多同学很容易忽略了 Situation 和 Result 的部分也就是背景和结果。或者是在面试官进一步了解追问细节的时候容易惊慌失措。这些原因往往都是由于面试前对自己的经历没有将来龙去脉讲清楚以及总结不够全面和深入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上，我对项目这块目前能聊的就是这么多，对了，如果你面&lt;strong&gt;大厂核心部门&lt;/strong&gt;，可能还需要关注的点是，&lt;strong&gt;项目的组织架构理解&lt;/strong&gt;，让你实现一个项目，整个流程需要注意考虑哪些点。&lt;/p&gt;
&lt;p&gt;这块真的可以着重准备一下，以我这次春招经验来谈，是重点。&lt;/p&gt;
&lt;p&gt;聊完项目，接下来就围绕我&lt;strong&gt;简历写到的专业技能&lt;/strong&gt;，依此来梳理一下。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;JS基础&lt;/h3&gt;
&lt;p&gt;考察的是一些基础问题，这里最好过一遍，切记不要丢大分。&lt;/p&gt;
&lt;p&gt;比如我写了对异步编程有理解，所以得看一下，异步编程的解决方案，它的发展过程，每种解决方案的优缺点，得了得，最后我会&lt;strong&gt;拓展一下async方案存在的缺陷&lt;/strong&gt;，对错误的捕获，聊到&lt;strong&gt;babel相关&lt;/strong&gt;的，现有的babel社区是否实现了对async语法做错误捕获处理，以及谈了下，社区里面的这个插件存在的缺陷。&lt;/p&gt;
&lt;p&gt;总结的话，我会围绕&lt;strong&gt;面试官问的基础点展开&lt;/strong&gt;，把相关连的部分描述一下， 面试官有兴趣的话，会顺着你的思路往下问。&lt;/p&gt;
&lt;p&gt;至于面试过程中问到&lt;strong&gt;JS基础&lt;/strong&gt;相关的题，这里就不列举了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;React相关&lt;/h3&gt;
&lt;p&gt;第二部分，简历上写了React相关的，那我总结了些可以会问到内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React框架的原理，聊一聊它是如何执行的。&lt;/li&gt;
&lt;li&gt;React更新流程，主要经历了哪些步骤。&lt;/li&gt;
&lt;li&gt;React中setState的理解，需要注意哪些。&lt;/li&gt;
&lt;li&gt;vue和React区别，如何从项目的选型上区分它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;React框架的理解，vdom，patch，批量更新，渲染的过程，经历了啥。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你对React源码很感兴趣，可以关注一下&lt;strong&gt;卡颂大佬&lt;/strong&gt;，他的&lt;a href="https://ke.sifou.com/course/1650000023864436"&gt;自顶向下学 React 源码&lt;/a&gt;值得推荐学习一下。&lt;/p&gt;
&lt;p&gt;当然了，React真的要问，太多可以问你的啦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如让你手写一个Hoc组件，实现类似怎么样的功能，思路是怎么样的。&lt;/li&gt;
&lt;li&gt;比如Hook你对它的理解，当时面试问到了Hook实现原理，还好看平时喜欢折腾，看了下大致流程。&lt;/li&gt;
&lt;li&gt;React-fiber机制引入，解决了什么问题，具体的流程是怎么样的，数据结构上发生了哪些变化。&lt;/li&gt;
&lt;li&gt;React中的时间切片了解嘛，如何实现的，流程能不能说一说。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这次问到好几个React相关的问题，更关注的点是你对原理的过程，有关注嘛，大致是一个怎么样的过程，最后又从中学到了哪些点。简历上写看过React原理相关的，得慎重啊！！！&lt;/p&gt;
&lt;p&gt;快进到浏览器部分。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;浏览器相关&lt;/h3&gt;
&lt;p&gt;这也是我简历上专业技能写到的一个点，这里也写了几个点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入URL到页面渲染。&lt;/li&gt;
&lt;li&gt;DNS解析的端口号是多少，为什么采用UDP协议。&lt;/li&gt;
&lt;li&gt;你渲染流程知道的这么详细，图层，分层，绘制，栅格化线程池，GPU加速，能不能说一下，对你开发有啥影响呢。(其实这个时候，被无情打脸了，知道这个有什么用，当时反问我)&lt;/li&gt;
&lt;li&gt;浏览器缓存。(可以拓展一下，结合webpack如何命中缓存，然后就到你熟悉的webpack领域了)&lt;/li&gt;
&lt;li&gt;浏览器进程架构历史。&lt;/li&gt;
&lt;li&gt;浏览器内核。（这个可以了解）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浏览器的垃圾回收机制&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经典八股文了，不过其实我感觉也是可以拓展的，问到浏览器缓存的时候，结合webpack谈一谈如何命中缓存的。比如讲到浏览器的渲染流程时，我们都知道里面的一些具体流程，比如分层，绘制，栅格化操作，然后其实可以结合实际去思考一下，有哪些具体的用途呢，这里我们需要借助浏览器中的performance来看看。&lt;/p&gt;
&lt;p&gt;&lt;img alt="浏览器中的performance相关.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0579d17015b145a88dd93992c6447d7d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;里面有很多关键性指标，比如 Long  Task执行的细节，跟面试官交流了下，&lt;strong&gt;排查性能问题&lt;/strong&gt;，我是如何通过这个Performance相关的细节去把握的，当然了，里面的内存使用情况，是否出现&lt;strong&gt;内存泄露&lt;/strong&gt;问题，都可以借助它。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非要我总结的话，我觉得哪怕是八股文，我们也要尽可能的展示出亮点来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近也在学习性能优化相关的部分，发现Performance相关的部分，还是有很多地方可以学习的，&lt;strong&gt;可以持续关注我&lt;/strong&gt;噢～&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;webpack相关&lt;/h3&gt;
&lt;p&gt;基本上，看我简历上写了这部分的，会问到，部分问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;webpack打包原理。&lt;/li&gt;
&lt;li&gt;import最终被webpack编译打包成什么。&lt;/li&gt;
&lt;li&gt;路由懒加载的原理是啥，能不能结合webpack说一说。&lt;/li&gt;
&lt;li&gt;写过webpack loader 或者插件吗。&lt;/li&gt;
&lt;li&gt;webpack 如何做性能优化。&lt;/li&gt;
&lt;li&gt;babel的原理了解吗，babel是用来干嘛的。&lt;/li&gt;
&lt;li&gt;说一说常见的babel库，你有使用过哪些。&lt;/li&gt;
&lt;li&gt;写过 babel 插件吗？用来干啥的？怎么写的 babel 插件&lt;/li&gt;
&lt;li&gt;知道怎么转化成 AST 的吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上考察，你是否实践过，因为自己简历上写了这方面的，可能问的比较多。&lt;/p&gt;
&lt;p&gt;比如问到babel原理可以这么答:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;babel的转译过程分为三个阶段：&lt;strong&gt;parsing、transforming、generating&lt;/strong&gt;，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ES6代码输入&lt;/li&gt;
&lt;li&gt;babylon 进行解析得到 AST&lt;/li&gt;
&lt;li&gt;plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树&lt;/li&gt;
&lt;li&gt;用 babel-generator 通过 AST 树生成 ES5 代码&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上至少得知道它大致的原理，平时如果有积累的话，其实问题不大。&lt;/p&gt;
&lt;p&gt;比如babel的话，推荐可以看看babel是如何处理async错误捕获转换的，这个有点意思，正好借这个机会跟面试官交流一下这块的知识点，个人觉得还是很有意思。&lt;/p&gt;
&lt;p&gt;学的时候，&lt;strong&gt;多折腾一下&lt;/strong&gt;，应该就问题不大了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;算法与数据结构相关&lt;/h3&gt;
&lt;p&gt;其实这块，我希望面试官问我多一些，因为大学期间，更多的精力放在算法。有幸碰到过面试官也是打过ICPC，CCPC等比赛的，曾经都是热血青年，最后因为生活，选择了向生活低头。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;聊得过程还是很愉快的～ 也是第一次，跟面试官聊到了，线段树，主席树，最小费用流，二分图匹配（匈牙利）算法，差分约束，Graham扫描法，有限状态自动机，AC自动机。&lt;/p&gt;
&lt;p&gt;似乎找回了大二的那份对算法对热情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记得退役的时候，在QQ个签上，写过这么一句话:&lt;strong&gt;我永远热爱算法，无论它虐我千百遍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能是真的熬了无数的夜，才会有这样子的感慨吧。有点跑题了，感兴趣的话，后续会更新，我是如何走上算法这条路的，最后给我的成长收获又是哪些。&lt;/p&gt;
&lt;p&gt;回到正题，至于这部分的话，我觉得没有一个很明确的范围吧，毕竟算法太广了，过一遍吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向图判断是否有环。&lt;/li&gt;
&lt;li&gt;给定一个数组，如何拆分，保证两个数组的和接近。(想到的是贪心，正解应该是dp)&lt;/li&gt;
&lt;li&gt;Json.parse()实现。&lt;/li&gt;
&lt;li&gt;常见的数据结构。&lt;/li&gt;
&lt;li&gt;数组和链表区别。&lt;/li&gt;
&lt;li&gt;时间复杂度和空间复杂度计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排序算法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;你是如何看待算法的，给你的收获是什么。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法很重要的，对你未来的发展，我觉得还是很有必要去学习的。至于怎么学，我没有能力回答这个问题，要我给建议的话，&lt;strong&gt;看书是一个选择&lt;/strong&gt;，如果要临时应对面试，刷一刷leetcode来说，只能说短期有效果。&lt;/p&gt;
&lt;p&gt;个人建议：&lt;/p&gt;
&lt;p&gt;可以结合书的内容，分专题去刷，比如动态规划dp专题很难，我记得我当时看完书后，对它的理解就很清晰了，当然做题是另外一回事，通过题目不断巩固你对一个算法知识点的理解，我觉得是没有问题的，但是至于完完全全刷leetcode，应付面试，不从最基础的开始，这样子“超车”，觉得意义不大。&lt;/p&gt;
&lt;p&gt;以上是我个人理解，&lt;strong&gt;能力有限&lt;/strong&gt;，说的不对，您就当看个笑话。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;个人经历&lt;/h3&gt;
&lt;p&gt;问到这部分的话，可能是总监面你的时候会问，也可能是hr会问，到hr环节的话，基本十拿九稳了。不过也不能大意，说不定一不留神，卡你学历啥的，一个月的面试付诸东流，还是要认真对待的，罗列了几个点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整个经历自我介绍，越详细越好，什么时候接触计算机，什么时候接触前端。&lt;/li&gt;
&lt;li&gt;整个经历中，你认为最值得骄傲的事情，最难的事情是什么。&lt;/li&gt;
&lt;li&gt;什么事情让你自豪，什么事情让你有挫败感。&lt;/li&gt;
&lt;li&gt;未来的发展，自己的规划。&lt;/li&gt;
&lt;li&gt;为什么现在才来秋招，不选择秋招。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拿我来说，我&lt;strong&gt;双非本科&lt;/strong&gt;，最担心的就是卡学历。当时hr明确问了我，你对现在的学校满意嘛，师范类的院校，怎么选择走软件工程呀，诸如此类的问题很多，无不困扰着我。&lt;/p&gt;
&lt;p&gt;不过我也不搞虚的。实话实话，为什么高中成绩差，又为什么选择软件工程，争取做到坦诚相待的态度，表达出自己最真实的想法吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;看到这里的话，可能对你来说，没有具体说明白，哪些知识点会考，哪些不会考察。&lt;/p&gt;
&lt;p&gt;我面腾讯和阿里的时候，也没有看到我这个部门具体的面试题。&lt;/p&gt;
&lt;p&gt;我觉得更重要的是，把握好&lt;strong&gt;专业技能和项目经历&lt;/strong&gt;的表达，引导面试官去往你所知道的领域交流问题，最后在这个领域拿出自己的&lt;strong&gt;杀手锏&lt;/strong&gt;，这样子面试官会更有好感，接下来的交流会更加愉快。&lt;/p&gt;
&lt;p&gt;对简历感兴趣的话，可以参考下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="个人简历模版.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/453bf44bb9864947bf318974e997f129~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;需要获取简历模板pdf的话，私信我（文末有联系方式），或者&lt;strong&gt;公众号: TianTianUp&lt;/strong&gt;回复，&lt;strong&gt;个人简历&lt;/strong&gt;，即可获取。&lt;/p&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;作为一个即将毕业的我来说，第一份工作很重要。在我面临选择的时候，慎重考虑以及找前辈交流过后，最后选择了&lt;strong&gt;腾讯&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在即将毕业的最后阶段，我应该算交上了一份满意的答卷，未来的路还很长，让我们拭目以待吧！&lt;/p&gt;
&lt;p&gt;有想交流的问题，欢迎联系我⬇️&lt;/p&gt;
&lt;p&gt;微信:DayDay2021&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后做一个简单，自由，有爱的技术人吧。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>TianTianUp</author><pubDate>Tue, 30 Mar 2021 17:34:05 GMT</pubDate></item><item><title>2020的TianTianUp在掘金| 掘金年度征文</title><link>https://juejin.cn/post/6911095991986814989</link><description>&lt;section id="nice"&gt;&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;2020个人总结，基本上是对今年的絮絮叨叨，不是啥干活，感兴趣可以看看。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020即将结束，简单回顾一下，做了哪些事情，收获了什么，哪些不足的地方，做个小结。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;2020年，我大四，似乎才刚刚开始。&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;2021年，我大四，似乎又快结束了。&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;经常这么鼓励自己➡️  为什么要进大厂呢⬇️&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;年轻时候去大厂的目标，是为了避免，【你得顿悟，是别人的基本功】&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;PS: 挤牙膏一样，还是挤不出啥东西。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;前端之旅&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020这一年，真的是波折的一年吧，一直在&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;考研和工作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;之间徘徊，不知道如何选择，想了好久，综合很多方面，于是就走上前端这条曲折又难走的道路。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我，就读于一所本科院校，没有学历光环，没有任何加分项，作为一个Acmer爱好者，跌跌撞撞的搞了算法，奈何实属菜鸡，没有拿到所谓的荣誉证明，一块icpc的奖牌都不从拥有，似乎我的大学将以失败告终！&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;那个时候是最沮丧的时候，算法组成员，很多都已经捧杯无数，似乎只有我，没有一块奖牌来证明自己。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;那个灰暗的时光，似乎过了好久。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可能是因为累了，疲倦了，大三的时候，选择遗憾的退役了，现在想一想，还是很遗憾。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020这一年春天，在前女友的鼓励下，我尝试向互联网公司投了简历，很显然，前端基础不扎实，阿里直接拒绝。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可能是太压抑了，加上之前的失意，似乎我一直都在逃避，一直到今年6🈷️。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;身边的朋友，开始陆陆续续准备考研，工作，而我，机缘巧合下，与一位学长的沟通，坚定了我的前端之路。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我的直系学长，秋招拿到美图offer，春招拿到Shopee的offer，跟他沟通后，发现很多东西都冲刷了我对前端的认知。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;6月底，开始疯狂补前端基础知识，刷题，写博客，特意翻了翻GitHub的提交记录。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="2020-掘金截图" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad013c9ab50b42018cc6f9cb80086f8e~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;2020-掘金截图&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，持续学习，持续总结，希望能赶上同届的大佬们，三元，Jack，曹佬，甘佬，林佬，现在的人太猛了，抓紧时间吧。&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;掘金&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;简单介绍一下，自己是如何知道掘金社区，并且是如何开始写作的吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020-06-24,我在大学宿舍，注册了掘金账号。百无聊赖的翻了几篇文章后，才发现，这里面有很多的文章特别如何我的胃口，总结梳理的很棒，说实话，当时看得很投入，于是乎，我跟它的故事便悄悄开始了。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;第一篇文章&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;在写这篇文章时，我特意去翻了翻我在掘金的第一篇文章，到底是哪一篇“水文”。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de92cbfc576b407d8baf4a67d172d20a~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;注册的当天，我似乎就下定了决心，希望接下来有个&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;不平凡&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的2020。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;立个flag：希望在2020秋招前完成对前端知识点的回顾总结。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这是我当时的Flag，似乎我已经完成了一些，至于多少，也许最清楚的人就是我了。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我依稀记得那个时候，JavaScript基础乃至前端基础，都十分的薄弱，与其说这么说，还不如说啥都不会，这是对我最中肯的评价了，我确实没有花时间在前端领域。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;持续写作&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;为了夯实基础，看书籍，这里推荐的就是&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;红宝石&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; ⬇️&lt;/p&gt;
&lt;img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e1b5a98123d4f74b828571e8dd61c77~tplv-k3u1fbpfcp-watermark.image" /&gt;
![个人总结-2020-红宝石](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1f168663eb748b8a8e855dc964ba4c3~tplv-k3u1fbpfcp-watermark.image)
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;啃完这本书，我觉得至少大厂的第一轮技术面试，完全是可以过的。对这本书籍的评价，绝对是一本值得你花时间去品味的书籍。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，在这里的话，我除了看书籍外，会结合很多博客，比如&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;若川&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;冴羽&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;等很多前辈的博客，很多点，看完他们对知识点的解读，完全可以get到重点。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;于是，我会把易错的点，通过笔记的方式记录下来，然后发在掘金上，很显然，一开始是没有人阅读的，这个也是我的预期，懂得都明白，我也没有把它放在心上。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;慢慢的，开始有了一些阅读量，一些人关注，给我点赞，当时对我是莫大的肯定，也一直坚定了我坚持记笔记的决心。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6846687590540640263" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「浏览器工作原理」写给女友的秘籍-浏览器组成&amp;amp;网络请求篇（1.2W字)&lt;/a&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当时看了极客的专栏，对于浏览器这块，我前所未有的对它了解的这么清楚，我记得那几天，我彻夜难眠，似乎它真的解开了我很多的心结，让我对前端体系有了更深的理解，于是我准备梳理一遍，也就是这篇文章，让我开始点赞UpUp，关注UpUp。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;很显然，学东西就是模仿，参考，借鉴创新的过程，我也勘误了原作者，还是有很多人来撕逼，其实你可以完全不去搭理他们，知识不就是如此吗，自己加深了理解，对他人有所帮助，这就够了，说明你理解到位了。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;如何坚持写，如何鼓励自己&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;上篇讲到，很多时间，你会受到很多的质疑，我举个例子：&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="Git命令" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c919f55501aa496b9b2c163de630d2d8~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;Git命令&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;就拿这个来说，Git命令很简单，为啥这样子的文章，有1800+👍，4W万阅读呢？&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;如果我现在看来，根本不需要记那么多命令行，直接用SourceTree这个工具托管，不香吗，它真的香！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;这个时间点，我真好刚刚入职网易，当时开发流程上，有很多不清楚地方，每次更同事合并分支的时候，会遇到些问题，当然了，操作了两遍，就会了，难道这么简单的东西，不是实践几遍就会吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;我写这个初衷是因为有些时候，比如版本回退，有些很难记的东西，需要查资料，还不如，我总结出来，做个脑图，方便以后工作需要。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可是工作不久，等我接触了SourceTree时，我觉得我这篇文章，其实没有必要了，太香了，基本上能满足你日常的开发需求。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;很多时候，你会受到质疑，为啥这么简单的内容，你都要做笔记，你应该这么对自己说，不同的阶段，你会遇到不同阶段的事情，可能过不了多久，你就会觉得之前写的东西很傻，但这不影响你成长，这更是一种对自我的对比，知道接下来如何梳理总结出更加满意的内容。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，有点跑题，我希望传达的意思就是：做自己认为对的事情，写作分享是一件有意义的事情，至于内容的好坏，取决于不同读者对它的解读，我们需要的保持初心，坚持写下去。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;算法&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;本着作为半个Acmer出身，虽然退役了，但是依旧热爱算法，所以把算法给梳理了一遍，花了两个月时间吧，写作不易，也比较用心的去梳理一遍，每个点难理解地方，如何利用技巧去解读它，这里就列一下吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6900698814093459463" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」你可能需要的一份前端算法总结&lt;/a&gt;（910+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6888451657504391181" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」Trie树之美&lt;/a&gt;（200+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6885104477297344525" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」分治算法之美&lt;/a&gt;（190+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6882394656148045838" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这是部分链接，当然了，你需要每个专题的题集的话，我这边也有一份不错的leetcode题集PDF，可以来找我领取噢～&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;贵人相助&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;在这最艰难的7，8月内，是最难熬的一段时间了，在掘金这个社区，认识一堆人，我们虽然隔着屏幕，分享着一些囧事，分享着前端领域中遇到的难题，有时候，会在各自坚持不下去的时候，互相鼓励，有时候，你需要的可能就是能倾诉的朋友吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;太多小伙伴了，这里就不提及了，我可能最要感激的一个人，就是&lt;a href="https://juejin.cn/user/764915822103079" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;@阿宝哥&lt;/a&gt; 。有时候，有人给你引导如何去规划，如何做出做得更好，如何规划接下来的路，宝哥就是这么一个人，帮我找工作，帮我安排其他一些事情，教我如何做好一个公众号等等。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;希望下次去厦门的生活，能跟宝哥搓一顿饭。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;小结&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;写的再多，都无法描述，我在2020这一年夏天，7月，8月所发生的事情，可能这两个月，对我的意义非凡吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;希望这份简简单单的描述，对现在的你，有那么一点点帮助的话，也许它就有存在的意义了吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;坚持+运气+拼命，似乎一切都来了。&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;网易&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当时投的公司就三家左右吧，匆匆忙忙的投递，嗯，网易的流程很快，算下来，两天的时间就走完了，基本上就敲定了它。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;面试回顾&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我印象中，可能是四轮技术面吧，应该没有记错的话。&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;一面技术电话面，记得是一个周五的上午，是个声音非常nice的小哥哥。基本上大厂的电话面都属于简历评估环节吧，简单的聊了30分钟，问的都是前端基础，没有问算法。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;二面技术视频面，全程高冷，基本上抛出问题，让我回答，当时很紧张吧，有些地方回答不是很好，手写一些常见api，接着写了两道算法题，感觉写的一般，整体下来，只能说面评一般。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;三面技术，还是视频面。也就是我现在的导师，可能就是她的微笑吧，看我问题答错了，也是通过微笑来缓解，整体来说，问的难度还能接受，目前看来，导师非常nice。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;四面技术面，依旧是视频面，目前团队的leader，全程70分钟，问了三个大的场景题，嗯，还有些课程相关的问题。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;五面+hr面，几分钟结束战斗。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这里是面经，感兴趣可以看看。&lt;/p&gt;
&lt;h6 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 16px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;a href="https://juejin.cn/post/6862855292577644552" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「面经」你可能需要的三轮网易面经&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h6&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;翻了翻朋友圈，当时感觉整个团队偏年轻化，字里行间可以看得出有多高兴～&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/973a117409a645fa9469901df05a2756~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;转眼间，4个月过去了，收获也是巨大的～，这里离不开导师mentor对我的帮助，还是很幸运遇到非常nice的导师。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;从产品提需求，到需求定稿，开会评估工期，跟UI同事沟通好，以及和测试说好提测时间，接着就是bugfix，正常上线。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;看着自己负责的板块，如期上线，原来，我写的东西也被数以万计的用户使用～&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，项目上线后，也会出现bug，嗯，定位bug原因，bugfix，然后提测，一般而言，遇到小bug跟随下一个版本发，重大的bug话，通常采用hotfix热更新办法，嗯，基本上整个流程都走了一遍了吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;还记得当时debug的时候，定位问题，到解决问题的过程⬇️&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="个人总结-2020-bugfix.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30d165f916f64507a70b4a4c3d3d30a1~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;个人总结-2020-bugfix&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那是一个难熬的夜晚，现在想一想，确实很”程序员“。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;谈起网易，很多人都会想到🐷厂伙食，没错，几个月下来，都胖了一圈了。&lt;/p&gt;
&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66b678dee2f249978347cab885ac7161~tplv-k3u1fbpfcp-watermark.image" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;2021新期待&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;希望能合理把生活，工作，学习，公众号，这几方面安排妥当。&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;React源码系列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;前端工程化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;node&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;最后期待粉丝**10000+**吧，能认识更多有趣的人。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，留个联系方式，微信: &lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;DayDay2021&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;, 期待我们能有交流。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;目前我的文章都会发在公众号「&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;前端UpUp&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;」上，感兴趣的朋友可以关注一下&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Sun, 27 Dec 2020 16:22:38 GMT</pubDate></item><item><title>「算法与数据结构」你可能需要的一份前端算法总结</title><link>https://juejin.cn/post/6900698814093459463</link><description>&lt;hr /&gt;
&lt;h1&gt;主题列表：juejin, github, smartblue, cyanosis, channing-cyan, fancy, hydrogen, condensed-night-purple, greenwillow, v-green, vue-pro&lt;/h1&gt;
&lt;h1&gt;贡献主题：https://github.com/xitu/juejin-markdown-themes&lt;/h1&gt;
&lt;h2&gt;theme: juejin
highlight:smartblue&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近好多事情，最近前端分享会也如期而至，有幸这次分享会，正好周末有时间，做个总结吧。&lt;/p&gt;
&lt;p&gt;这次想分享的就是&lt;strong&gt;算法与数据结构&lt;/strong&gt;，刷了一段时间题目，逛了逛LeetCode，看了很多关于这个方面的文章，有所感悟，准备做个记录吧。&lt;/p&gt;
&lt;p&gt;当你想花时间去了解学习一件对你来说，很苦难的事情的时候，我们需要明确目标，学习它的意义，它有什么用，对你有哪方面帮助。&lt;/p&gt;
&lt;p&gt;升职加薪必备，对以后成长有所帮助，嗯，加薪，加薪，加薪。&lt;/p&gt;
&lt;p&gt;那么问题来了，为什么要进大厂呢⬇️&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;年轻时候去大厂的目标，是为了避免，【你得顿悟，是别人的基本功】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，闲聊就止步于此，接下来开始吧～&lt;/p&gt;
&lt;p&gt;站在巨人肩膀上，学起来就很轻松了， 这里我是参考网上的算法刷题路线，可以参考一下～&lt;/p&gt;
&lt;p&gt;公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，回复&lt;strong&gt;算法&lt;/strong&gt;，即可获取脑图，以及文末的题目汇总pdf。&lt;/p&gt;
&lt;p&gt;&lt;img alt="算法与数据结构" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cabe509f34e40a28ea46191b72689ec~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们就根据这个脑图来梳理一遍吧~&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;数据结构&lt;/h2&gt;
&lt;p&gt;数据结构可以说是算法的基石，如果没有扎实的数据结构基础，想要把算法学好甚至融会贯通是非常困难的，而优秀的算法又往往取决于你采用哪种数据结构。学好这个专题也是很有必要的，那么我们可以稍微的做个分类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常用数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组，字符串&lt;/li&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高级数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图&lt;/li&gt;
&lt;li&gt;前缀树&lt;/li&gt;
&lt;li&gt;线段树&lt;/li&gt;
&lt;li&gt;树状数组&lt;/li&gt;
&lt;li&gt;主席树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么显然，最常见的数据结构一定是需要掌握的，对于高级的数据结构而言，如果你有时间，对它有所热爱的话，可以深入了解，比如这个&lt;strong&gt;主席树&lt;/strong&gt;在解决一些问题 的时候，算法复杂度是log级别的，某些场景下很有帮助。&lt;/p&gt;
&lt;p&gt;这里想提及的就是&lt;strong&gt;树&lt;/strong&gt;。它的结构很显然是很直观的，树当然有很多的性质，这里也列举不完，比如面试中常考的树：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于它而言的话，我们需要到哪些程度呢？&lt;/p&gt;
&lt;p&gt;对于常见树的遍历，从树的前序遍历，到中序遍历，后续遍历，以至于层次遍历，掌握好这四种遍历的递归写法和非递归写法是非常重要的，接下来需要懂得分析各种写法的时间复杂度和空间复杂度。&lt;/p&gt;
&lt;p&gt;面试准备阶段，把树这个结构花时间去准备的话，对于你理解递归还是很有帮助的，同时也能帮助你学习一些图论的知识，更加准确的说，树是面试考察的热门考点，尤其是二叉树！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;掌握好这些数据结构是基础，绝大部分的算法面试题都得靠它们来帮忙，因此，一定要花功夫勤练题目来深入理解它们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;排序算法&lt;/h2&gt;
&lt;p&gt;这应该是面试最常考，最核心的算法。如果你能把排序算法理解的很透彻的话，接下来的其他算法也是一样的旁敲侧击。&lt;/p&gt;
&lt;p&gt;当时我梳理得是常见的6个排序算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-1"&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-5"&gt;计数排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-9"&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-13"&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-17"&gt;插入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-21"&gt;选择排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在此之前，我也写过一篇排序算法的文章，个人觉得言简意赅，可以看看&lt;a href="https://juejin.cn/post/6856546833025237006"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有时候，面试官喜欢会问冒泡排序和插入排序，基本上这些都是考察你的基础知识，并且看看你能不能快速地写出没有bug的代码。&lt;/p&gt;
&lt;p&gt;又比如，当面试官问你归并排序、快速排序和拓扑排序等的时候，这个时候考察的是你平时对算法得积累，所以有必要做个总结。&lt;/p&gt;
&lt;p&gt;我们拿&lt;strong&gt;归并排序&lt;/strong&gt;来举例子，我们应该如何表达清楚呢？首先，我们应该把这个它的思路说清楚：&lt;/p&gt;
&lt;p&gt;归并排序的核心思想就是分治，它将一个复杂的问题分成两个或者多个相同或相似的子问题，然后把子问题分成更小的子问题，直到子问题可以简单的直接求解，最原问题的解就是子问题解的合并。&lt;strong&gt;归并排序&lt;/strong&gt;将分治的思想体现得淋漓尽致。&lt;/p&gt;
&lt;p&gt;当你向面试官理清楚这个思路时，面试官心里就有底了，他会想，嘿，这个小伙子不错！那你接下来都有底气了！&lt;/p&gt;
&lt;p&gt;有了思想，那么实现起来就不难了:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一开始先把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，才开始排序。&lt;/p&gt;
&lt;p&gt;排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;贴一份之前的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const merge = (left, right) =&amp;gt; { // 合并数组

    let result = []
    // 使用shift()方法偷个懒,删除第一个元素,并且返回该值
    while (left.length &amp;amp;&amp;amp; right.length) {
        if (left[0] &amp;lt;= right[0]) {
            result.push(left.shift())
        } else {
            result.push(right.shift())
        }
    }
    while (left.length) {
        result.push(left.shift())
    }

    while (right.length) {
        result.push(right.shift())
    }
    return result
}

let mergeSort = function (arr) {
    if (arr.length &amp;lt;= 1)
        return arr
    let mid = Math.floor(arr.length / 2)
    // 拆分数组
    let left = arr.slice(0, mid),
        right = arr.slice(mid);
    let mergeLeftArray = mergeSort(left),
        mergeRightArray = mergeSort(right)
    return merge(mergeLeftArray, mergeRightArray)
}

// let arr = [2, 9, 6, 7, 4, 3, 1, 7, 0, -1, -2]
// console.log(mergeSort(arr))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于这部分的算法而言，可以围绕从&lt;strong&gt;解题思路&lt;/strong&gt;--&amp;gt;&amp;gt;&lt;strong&gt;实现过程&lt;/strong&gt;--&amp;gt;&amp;gt;&lt;strong&gt;代码实现&lt;/strong&gt;。 基本上以这三步来实现的话，掌握常见的排序算法完成是没有问题的。&lt;/p&gt;
&lt;p&gt;那么这部分就暂时梳理到这里吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;动态规划&lt;/h2&gt;
&lt;p&gt;动态规划难，可以说是很多面试者也是我最怕的部分，尤其是面试的时候，怕面试官考这个算法了。遇到没有做过的题目，这个时候，能否写出状态转移方程是十分重要的。接下来我们聊一聊这个专题吧。&lt;/p&gt;
&lt;p&gt;首先，强烈推荐我之前分析这个专题如何准备的： &lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果从点赞角度来看，可以说，是我写算法以来，得到大家肯定最多的一次了，可以看看，不过这里也会涵盖部分。&lt;/p&gt;
&lt;p&gt;如何学动态规划，从哪里入手，应该这么去做，这么去刷题，肯定是很多初学者一开始就会遇到的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;动态规划解决了什么问题&lt;/li&gt;
&lt;li&gt;动态规划解题的步骤&lt;/li&gt;
&lt;li&gt;如何高效率刷dp专题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，你得了解动态规划是什么，它的思想是什么，定义又是啥。这里引入维基百科对它的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Wikipedia 定义：它既是一种数学优化的方法，同时也是编程的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然了，看完这段话，我们肯定对它不了解的，我们可以翻译一下，首先它可以算是一种优化的手段，优化一些重复子问题的操作，将很多重叠子问题通过编程的方式来解决，比如&lt;strong&gt;记忆划搜索&lt;/strong&gt;。 又比如，如果一个原问题，可以拆分成很多子问题，它们之间没有任何后续性，当前的决策对后续没有影响的话，每个子问题的最优解，就可以组合成原问题的最优解了。&lt;/p&gt;
&lt;p&gt;当然了，对于动态规划每个人理解是不同的，对于应用到具体的场景中，需要我们都去用多维度的状态去表述它的含义，这里也就是状态转移方程的含义所在。&lt;/p&gt;
&lt;p&gt;嗯，那么动态规划解决了什么问题呢，很显然，对于重复性问题来说，它可以很好的解决，那么从某个维度上来看，它可以优化一个算法的时间复杂度，也就是通常意义上的，拿空间来换取时间的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态规划解题步骤&lt;/strong&gt;： 这个应该就是实际落地的操作，需要我们去通过大量的题目来完成，具体我们需要怎么做呢？&lt;/p&gt;
&lt;p&gt;解题思路，三大步骤👇&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;状态定义&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列出状态转移方程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;强烈推荐这篇问题，里面讲的很清楚了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何高效率刷dp专题&lt;/strong&gt;：首先，你得找到对应的dp专题，这里的话，我帮你准备好了，接下来我说一下我是怎么刷leetcode上面的题目的。&lt;/p&gt;
&lt;p&gt;一般而言，刷完中等的leetcode上的dp专题，基本上可以满足要求了。那么对于中等的dp题目，很多时候，我是写不吃来的，那我应该如何去做呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，我先看题解，把它的状态转移方程写下来，仔细的品味一下，它这么定义，解决了我之前的什么难点，为啥我是没有想到的。&lt;/li&gt;
&lt;li&gt;然后，看完之后，尝试按照这个题解思路，我自己能不能单独实现呢？&lt;/li&gt;
&lt;li&gt;如果不能的话，就照着它的代码，写一遍，多看看状态转移方程是如何写的，把这个题目收藏起来。&lt;/li&gt;
&lt;li&gt;等到下次，或者是隔天，再来看一遍题目，然后看看能不能单独完成，如果不能，第三天再这么操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有，我个人建议，刷dp的话，最好从易到难，这样子自己也会有信心，也不会再去畏惧它。&lt;/p&gt;
&lt;h3&gt;进阶题目汇总&lt;/h3&gt;
&lt;p&gt;以下是我收集的部分题目，希望对你们有帮助。&lt;/p&gt;
&lt;h4&gt;简单&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/climbing-stairs/"&gt;爬楼梯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/house-robber/"&gt;打家劫舍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/"&gt;使用最小花费爬楼梯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/contiguous-sequence-lcci/"&gt;连续数列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/"&gt;三步问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;中等&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/house-robber-ii/"&gt;打家劫舍 II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/"&gt;最佳买卖股票时机含冷冻期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/house-robber-iii/"&gt;打家劫舍 III&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/unique-paths/"&gt;不同路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/unique-paths-ii/"&gt;不同路径 II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/"&gt;最长上升子序列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;困难&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/"&gt;买卖股票的最佳时机 III&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/"&gt;买卖股票的最佳时机 IV&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/frog-jump/"&gt;青蛙过河&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/word-break-ii/"&gt;单词拆分 II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/max-submatrix-lcci/"&gt;最大子矩阵&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;搜索算法&lt;/h2&gt;
&lt;p&gt;这部分也是尤其重要的，那么重点学习深度优先搜索算法（简称为 DFS）和广度优先搜索算法（简称为 BFS）。&lt;/p&gt;
&lt;p&gt;我翻了翻我的博客，恰好有一篇类似的问题，大家可以看看**「算法与数据结构」DFS和BFS算法之美**。&lt;/p&gt;
&lt;p&gt;不过，我看了一下，我当时写得时候，有点粗糙，很多基本的概念都没有讲明白，所以可能适合一些对这部分有基础的小伙伴。&lt;/p&gt;
&lt;p&gt;在这里推荐一个有趣的题目：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-with-rotations/"&gt;穿过迷宫的最少移动次数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你也遇到过迷宫类似的问题，就可以考虑搜索算法了，从我个人的角度来说，它的思路其实就是模拟人的思路，每次走到一个路口的时候，我可以走哪里，我之前走过的路，怎么确保，接下来是不能走的，这里需要在编程的角度，如何去实现呢？&lt;/p&gt;
&lt;p&gt;这里说一说我的经验，对于刚刚提到的题目而言，我盲猜使用BFS，题目做多了，自然就会有心得，对于BFS和DFS而言，做了两个类似的题目，会发现，原来搜索算法也是有迹可循，也是存在某些套路的。&lt;/p&gt;
&lt;p&gt;给些建议：&lt;/p&gt;
&lt;p&gt;一开始可能做的时候，抓不到头脑，有思路，但是代码很难写清楚，那么如何去做呢？ &lt;strong&gt;看题解&lt;/strong&gt;，了解别人的写法是很不错的，可以多个对比，看看哪一份题解代码是你目前可以理解的，然后抄下来，看一遍。&lt;/p&gt;
&lt;p&gt;最普通的办法就是：先画图，看看思维上跟实际代码需要做哪些改变，如何去优化这个过程。最后结合别人代码，一定不要直接copy，不去思考为什么这么写，不然后期发现，是没有多大效果的，一定要多结合自己的理解。&lt;/p&gt;
&lt;p&gt;嗯，不会就看题解，多思考为什么这么写！！！&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;写到这里的时候，已经凌晨1点了，算法与数据结构这个方向太大了，一篇文章不可能写得完，我更希望这篇文章对你，有那么一点点的帮助，对我，或你都些许有所帮助，那么它得存在就有那么一点点意义。&lt;/p&gt;
&lt;p&gt;以下是我刷的题集，需者自取，公众号：&lt;strong&gt;前端UpUp&lt;/strong&gt;，关注它，找我领pdf文档也可以。&lt;/p&gt;
&lt;h3&gt;进阶题目汇总&lt;/h3&gt;
&lt;p&gt;这个专题想进阶，就刷我下面提供的题目吧👇&lt;/p&gt;
&lt;h3&gt;DFS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/"&gt;二叉树的最大深度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/"&gt;二叉树的最小深度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/friend-circles/"&gt;朋友圈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/find-eventual-safe-states/"&gt;找到最终的安全状态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/"&gt;矩阵中的最长递增路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minesweeper/"&gt;扫雷游戏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/word-ladder/"&gt;单词接龙&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;BFS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/"&gt;N叉树的层序遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/"&gt;二叉树的层序遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-height-trees/"&gt;最小高度树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minesweeper/"&gt;扫雷游戏&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;题目汇总&lt;/h2&gt;
&lt;p&gt;我之前刷题历程是根据这套题来的，我觉得里面题目梯度还是质量都是很不错的。&lt;/p&gt;
&lt;p&gt;拿到这个pdf有段时间了，所以不清楚具体作者是谁，有侵权的话，可删。&lt;/p&gt;
&lt;h3&gt;数组&amp;amp;链表&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/rotate-array/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/merge-two-sorted-lists/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/merge-sorted-array/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/swap-nodes-in-pairs/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/3sum/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Map &amp;amp; Set&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/valid-anagram/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/group-anagrams/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;堆栈&amp;amp;队列&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-outermost-parentheses/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/largest-rectangle-in-histogram/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/trapping-rain-water/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二分查找&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/arranging-coins/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/powx-n/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/dungeon-game/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;递归&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/symmetric-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-paths/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/range-sum-of-bst/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;哈希表&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/two-sum/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/valid-anagram/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/top-k-frequent-words&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/number-of-atoms/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二叉树&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/symmetric-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二叉搜索树&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/validate-binary-search-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/range-sum-of-bst/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/contains-duplicate-iii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;图&lt;/h3&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/number-of-islands/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/course-schedule-ii&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;堆和排序&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/find-median-from-data-stream/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DFS&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/friend-circles/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/find-eventual-safe-states/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minesweeper/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/word-ladder/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;BFS&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/binary-tree-level-order-traversal-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minesweeper/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-height-trees/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Trie树&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/longest-word-in-dictionary/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/implement-trie-prefix-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/word-search-ii/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;分治算法&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/majority-element/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-subarray/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/search-a-2d-matrix-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;回溯算法&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/letter-case-permutation/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/subsets/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/permutations/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/combinations/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/n-queens/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;贪心算法&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/assign-cookies/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;动态规划&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/climbing-stairs/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/house-robber/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/house-robber-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/house-robber-iii/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/unique-paths/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/unique-paths-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;❤️ 感谢大家&lt;/h2&gt;
&lt;p&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/li&gt;
&lt;li&gt;关注公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，联系作者👉 &lt;strong&gt;DayDay2021&lt;/strong&gt; ，我们一起学习一起进步。&lt;/li&gt;
&lt;li&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6888451657504391181"&gt;「算法与数据结构」Trie树之美&lt;/a&gt;（200+👍）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6885104477297344525"&gt;「算法与数据结构」分治算法之美&lt;/a&gt;（190+👍）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6861376131615227912"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6874708801208254478"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6882394656148045838"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description><author>TianTianUp</author><pubDate>Sun, 29 Nov 2020 16:06:46 GMT</pubDate></item><item><title>「算法与数据结构」二叉树之美</title><link>https://juejin.cn/post/6890680584033533960</link><description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这次梳理的内容是数据结构专题中的&lt;strong&gt;树&lt;/strong&gt;，如果你看到&lt;code&gt;树&lt;/code&gt;这类数据结构时，满脑子头疼，觉得它很难理解，如果是这样子的话，那么本文可能对你或许有点帮助。&lt;/p&gt;
&lt;p&gt;俗话说得好，要想掌握理解的话，我们得先了解它的概念，性质等内容。&lt;/p&gt;
&lt;p&gt;围绕以下几个点来展开介绍树👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树的基本概念&lt;/li&gt;
&lt;li&gt;基本术语&lt;/li&gt;
&lt;li&gt;树的种类&lt;/li&gt;
&lt;li&gt;二叉树概念&lt;/li&gt;
&lt;li&gt;二叉树的遍历&lt;/li&gt;
&lt;li&gt;二叉树题目汇总&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，回复&lt;strong&gt;二叉树&lt;/strong&gt;，即可获取脑图。&lt;/p&gt;
&lt;p&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;p&gt;脑图👇&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/345ae35ff7c040cf893fc9b0f06dbb52~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;树的基本概念&lt;/h2&gt;
&lt;p&gt;树是用来模拟具有树状结构性质的数据集合。或者你可以把它认为是一种&lt;strong&gt;抽象数据结构&lt;/strong&gt;或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。&lt;/p&gt;
&lt;p&gt;那么根据维基百科给出的定义，我们似乎可以这么理解：&lt;/p&gt;
&lt;p&gt;它是由n（n&amp;gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;每个节点都只有有限个子节点或无子节点；&lt;/li&gt;
&lt;li&gt;没有父节点的节点称为根节点；&lt;/li&gt;
&lt;li&gt;每一个非根节点有且只有一个父节点；&lt;/li&gt;
&lt;li&gt;除了根节点外，每个子节点可以分为多个不相交的子树；&lt;/li&gt;
&lt;li&gt;树里面没有环路(cycle)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个时候，我们就需要拿出一张图来看👇&lt;/p&gt;
&lt;p&gt;&lt;img alt="树的概念" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a797132557334101a5af5631068d230b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从图中来看，以上的五个特点都可以很好的总结出来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A节点作为根节点，没有父节点，所以是根节点。&lt;/li&gt;
&lt;li&gt;除根节点（A）外，其他的节点都有父节点，并且每个节点只有有限个子节点或无子节点。&lt;/li&gt;
&lt;li&gt;从某个节点开始，可以分为很多个子树，举个例子，从B节点开始，即是如此。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然对树有一定认识后，我们需要了解它的一些术语。&lt;/p&gt;
&lt;h2&gt;基本术语&lt;/h2&gt;
&lt;p&gt;&lt;img alt="树的基本术语" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffe6a7a99096480c8077c53912a1ccc8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为了更加规范的总结，这里给出的描述来自于维基百科：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;节点的度&lt;/strong&gt;：一个节点含有的子树的个数称为该节点的度；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的度&lt;/strong&gt;：一棵树中，最大的节点度称为树的度；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;叶节点&lt;/strong&gt;或&lt;strong&gt;终端节点&lt;/strong&gt;：度为零的节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非终端节点&lt;/strong&gt;或&lt;strong&gt;分支节点&lt;/strong&gt;：度不为零的节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;父亲节点&lt;/strong&gt;或&lt;strong&gt;父节点&lt;/strong&gt;：若一个节点含有子节点，则这个节点称为其子节点的父节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;孩子节点&lt;/strong&gt;或&lt;strong&gt;子节点&lt;/strong&gt;：一个节点含有的子树的根节点称为该节点的子节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兄弟节点&lt;/strong&gt;：具有相同父节点的节点互称为兄弟节点；&lt;/li&gt;
&lt;li&gt;节点的&lt;strong&gt;层次&lt;/strong&gt;：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;深度&lt;/strong&gt;：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高度&lt;/strong&gt;：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堂兄弟节点&lt;/strong&gt;：父节点在同一层的节点互为堂兄弟；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点的祖先&lt;/strong&gt;：从根到该节点所经分支上的所有节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子孙&lt;/strong&gt;：以某节点为根的子树中任一节点都称为该节点的子孙；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;森林&lt;/strong&gt;：由m（m&amp;gt;=0）棵互不相交的树的集合称为森林。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以结合上述的图来理解这些概念，通过两者的结合，你一定会对树有进一步的了解的。&lt;/p&gt;
&lt;p&gt;有以上基本概念，以及一些专业术语的掌握，接下来我们需要对树进行一个分类，看看树有哪些种类。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;树的种类&lt;/h2&gt;
&lt;p&gt;理解了树的概念以及基本术语，接下来，我们需要拓展的内容就是树的种类。&lt;/p&gt;
&lt;p&gt;我们可以根据维基百科的依据来作为分类的标准👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为&lt;a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E6%A0%91"&gt;自由树&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；
&lt;ul&gt;
&lt;li&gt;二叉树：每个节点最多含有两个子树的树称为二叉树；
&lt;ul&gt;
&lt;li&gt;完全二叉树：对于一颗二叉树，假设其深度为d（d&amp;gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"&gt;满二叉树&lt;/a&gt;：所有叶节点都在最底层的完全二叉树；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"&gt;平衡二叉树&lt;/a&gt;（&lt;a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91"&gt;AVL树&lt;/a&gt;）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；&lt;/li&gt;
&lt;li&gt;排序二叉树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91"&gt;霍夫曼树&lt;/a&gt;：&lt;a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84&amp;amp;action=edit&amp;amp;redlink=1"&gt;带权路径&lt;/a&gt;最短的二叉树称为哈夫曼树或最优二叉树；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/B%E6%A0%91"&gt;B树&lt;/a&gt;：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然树的分类有这么多的话，那么我们是不是都需要一一掌握呢，我个人觉得，掌握二叉树这种结构就足够了，它也是树最简单、应用最广泛的种类。&lt;/p&gt;
&lt;p&gt;那么接下来，我们就来介绍一下二叉树吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;二叉树的概念&lt;/h2&gt;
&lt;p&gt;二叉树是一种典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。&lt;/p&gt;
&lt;p&gt;&lt;img alt="二叉树" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928edb599f30491c8f62935da572a0eb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;图片来自网络，具体出处不明。&lt;/p&gt;
&lt;p&gt;从这个图片的内容来看，应该很清楚的展示了二叉树的结构。&lt;/p&gt;
&lt;p&gt;至于二叉树的性质的话，可以参考下图，作为补充知识吧，个人觉得这个不是重点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="二叉树的性质" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a977e2da02a847ad92c68adcbfd05a27~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;重点的话，我们需要掌握的应该是它的遍历方式。&lt;/p&gt;
&lt;h2&gt;二叉树的遍历&lt;/h2&gt;
&lt;p&gt;我们知道对于二叉树的遍历而言，有常见得三种遍历方式，分别是以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历&lt;/li&gt;
&lt;li&gt;中序遍历&lt;/li&gt;
&lt;li&gt;后序遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于任何一种遍历方式而言，我们不仅需要掌握它的非递归版本，同时对于它的递归版本来说，更是考察一个人的算法基本功，那么接下来，我们来看看吧。&lt;/p&gt;
&lt;h3&gt;前序遍历&lt;/h3&gt;
&lt;p&gt;点击这里，练习&lt;a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/"&gt;二叉树的前序遍历&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回它节点值的 &lt;strong&gt;前序&lt;/strong&gt; 遍历。&lt;/p&gt;
&lt;p&gt;假设我们mock一下假数据👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;输入: [1,null,2,3]
   1
    \
     2
    /
   3
输出: [1,3,2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么根据我们对前序遍历的理解，我们可以写出解题伪代码👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;//   TianTianUp
//   * function TreeNode(val, left, right) {
//   *     this.val = (val===undefined ? 0 : val)
//   *     this.left = (left===undefined ? null : left)
//   *     this.right = (right===undefined ? null : right)
//   * }
let preorderTraversal  = (root, arr = []) =&amp;gt; {
    if(root) {
      arr.push(root.val)
      preorderTraversal(root.left, arr)
      preorderTraversal(root.right, arr)
    }
    return arr
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本👇&lt;/p&gt;
&lt;p&gt;对于非递归的话，我们需要借助一个数据结构去存储它的节点，需要使用的就是栈，它的思路可以借鉴👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点为目标节点，开始向它子节点遍历&lt;/li&gt;
&lt;li&gt;1.访问目标节点&lt;/li&gt;
&lt;li&gt;2.左孩子入栈 -&amp;gt; 直至左孩子为空的节点&lt;/li&gt;
&lt;li&gt;3.节点出栈，以右孩子为目标节点，再依次执行1、2、3&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;  let preorderTraversal = (root, arr = []) =&amp;gt; {
    const stack = [], res = []
    let current = root
    while(current || stack.length &amp;gt; 0) {
      while (current) {
        res.push(current.val)
        stack.push(current)
        current = current.left
      }
      current = stack.pop()
      current = current.right
    }
    return res
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;中序遍历&lt;/h3&gt;
&lt;p&gt;给定一个二叉树，返回它的中序 遍历。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [1,null,2,3]
1
&lt;br /&gt;
2
/
3&lt;/p&gt;
&lt;p&gt;输出: [1,3,2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进阶: 递归算法很简单，你可以通过迭代算法完成吗？&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;递归版本👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const inorderTraversal  = (root, arr = []) =&amp;gt; {
  if(root) {
    inorderTraversal(root.left, arr)
    arr.push(root.val)
    inorderTraversal(root.right, arr)
  }
  return arr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本，这里就不解释了，跟前序遍历一样，思路一样，用栈维护节点信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const inorderTraversal = (root, arr = []) =&amp;gt; {
  const stack = [], res = []
  let current = root
  while(current || stack.length &amp;gt; 0) {
    while (current) {
      stack.push(current)
      current = current.left
    }
    current = stack.pop()
    res.push(current.val)
    current = current.right
  }
  return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;后续遍历&lt;/h3&gt;
&lt;p&gt;给定一个二叉树，返回它的 后序 遍历。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [1,null,2,3]&lt;br /&gt;
1
&lt;br /&gt;
2
/
3&lt;/p&gt;
&lt;p&gt;输出: [3,2,1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进阶: 递归算法很简单，你可以通过迭代算法完成吗？&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;递归版本👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const postorderTraversal  = (root, arr = []) =&amp;gt; {
  if(root) {
    postorderTraversal(root.left, arr)
    postorderTraversal(root.right, arr)
    arr.push(root.val)
  }
  return arr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本👇&lt;/p&gt;
&lt;p&gt;其实，嗯，做完前面两个后，会发现都是有套路滴~&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const postorderTraversal = (root, arr = []) =&amp;gt; {
  const stack = [], res = []
  let current = root, last = null  // last指针记录上一个节点
  while(current || stack.length &amp;gt; 0) {
    while (current) {
      stack.push(current)
      current = current.left
    }
    current = stack[stack.length - 1]
    if (!current.right || current.right == last) {
      current = stack.pop()
      res.push(current.val)
      last = current
      current = null              // 继续弹栈
    } else {
      current = current.right
    }
  }
  return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/"&gt;二叉树的层次遍历 ⭐⭐&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/"&gt;二叉树的层序遍历&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给你一个二叉树，请你返回其按 &lt;strong&gt;层序遍历&lt;/strong&gt; 得到的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;p&gt;示例：
二叉树：[3,9,20,null,null,15,7],&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;/ &lt;br /&gt;
9  20
/  &lt;br /&gt;
15   7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回其层次遍历结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[
[3],
[9,20],
[15,7]
]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;递归版本👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const levelOrder = function(root) {
  if(!root) return []
  let res = []
  dfs(root, 0, res)
  return res
}

function dfs(root, step, res){
  if(root){
      if(!res[step]) res[step] = []
      res[step].push(root.val)
      dfs(root.left, step + 1, res)
      dfs(root.right, step + 1, res)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本👇&lt;/p&gt;
&lt;p&gt;这里借助的就是队列这个数据结构，先进先出的机制。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const levelOrder = (root) =&amp;gt; {
  let queue = [], res = []
  if (root) queue.push(root);
  while (queue.length) {
      let next_queue = [],
          now_res = []
      while (queue.length) {
          root = queue.shift()
          now_res.push(root.val)
          root.left &amp;amp;&amp;amp; next_queue.push(root.left)
          root.right &amp;amp;&amp;amp; next_queue.push(root.right)
      }
      queue = next_queue
      res.push(now_res)
  }
  return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;题目汇总&lt;/h2&gt;
&lt;p&gt;还是那句话，题目做不完的，剩下的就靠刷leetcode了，我还准备了一些常见的二叉树题集，题目的质量还是不错的👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/"&gt;二叉树的最小深度⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/"&gt;二叉树的最大深度⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/same-tree/"&gt;相同的树⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/range-sum-of-bst/"&gt;二叉搜索树的范围和⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/symmetric-tree/"&gt; 对称二叉树⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/"&gt;将有序数组转换为二叉搜索树⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/"&gt;二叉树的层次遍历 II⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/"&gt;二叉树的最近公共祖先⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/validate-binary-search-tree/"&gt;验证二叉搜索树⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/path-sum-iii/"&gt;路径总和 III⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/contains-duplicate-iii/"&gt;存在重复元素 III⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/"&gt;计算右侧小于当前元素的个数⭐⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;❤️ 感谢大家&lt;/h2&gt;
&lt;p&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关注公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，联系作者👉 &lt;strong&gt;DayDay2021&lt;/strong&gt; ，我们一起学习一起进步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6888451657504391181"&gt;「算法与数据结构」Trie树之美&lt;/a&gt;（200+👍）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6885104477297344525"&gt;「算法与数据结构」分治算法之美&lt;/a&gt;（190+👍）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6861376131615227912"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6856546833025237006"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6874708801208254478"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6882394656148045838"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6850418120755494925"&gt;「算法与数据结构」链表的9个基本操作(190+👍)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description><author>TianTianUp</author><pubDate>Mon, 02 Nov 2020 16:06:16 GMT</pubDate></item><item><title>「算法与数据结构」Trie树之美</title><link>https://juejin.cn/post/6888451657504391181</link><description>&lt;section id="nice" style="padding: 0 10px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px;"&gt;&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这次分享的Trie字典树，是数据结构专题中的一个分支，认识了解Trie这种树型数据结构，对构建算法与数据结构知识体系有一定的帮助。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;我对Trie树的理解：把字符串都串接起来，消灭不必要的存储，利用的就是字符串的公共前缀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;其实对于它的理解，你理解了这句话即可👇&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高。&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;如果你还不了解什么是Trie数据结构的话，或者知道一些，但是对于它具体是如何实现一个简单Trie树时，那么这篇文章可能适合你阅读。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么围绕以下几个点来展开介绍Trie树👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;基本概念&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;基本性质&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;应用场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;2个例题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;基本概念&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;首先，我们对Trie树得做一些基本的了解。Trie树中文名叫字典树，前缀树等，接下来我就以字典树称呼。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;我们来看下维基百科对它的描述吧⬇️&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;在&lt;a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;计算机科学&lt;/a&gt;中，&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;trie&lt;/strong&gt;，又称&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;前缀树&lt;/strong&gt;或&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;字典树&lt;/strong&gt;，是一种有序&lt;a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;树&lt;/a&gt;，用于保存&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;关联数组&lt;/a&gt;，其中的键通常是&lt;a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;字符串&lt;/a&gt;。与&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;二叉查找树&lt;/a&gt;不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的&lt;a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;前缀&lt;/a&gt;，也就是这个节点对应的字符串，而根节点对应&lt;a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;空字符串&lt;/a&gt;。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;朴实无华的描述，其实我们看一张图就能看明白了~，我在网上找了一张不错的图，具体的出处，这里就不补充了，因为实在找不到原作者~&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="字典树图解1" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80d94807ec494830b8d7945a153883e9~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;字典树图解1&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这里需要说明的内容就是，一般而言，&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;应该是用一个点来表示一个字符&lt;/strong&gt;，这里为了更好的说明，所以我就是&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;用边来描述字符&lt;/strong&gt;。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;可以发现，这棵字典树用边来代表字母，而&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;从根结点到树上某一结点的路径就代表了一个字符串&lt;/strong&gt;。举个例子， 1→2→6表示的就是字符串 &lt;code&gt;aba&lt;/code&gt; 。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;再比如，&lt;code&gt;1→4→8&lt;/code&gt;构成的字符串是&lt;code&gt;ca&lt;/code&gt;，那么如果在往下拓展的话，我们是不是有 &lt;code&gt;caa&lt;/code&gt;,&lt;code&gt;cab&lt;/code&gt;，那么他们都会经过&lt;code&gt;1→4→8&lt;/code&gt;，这些路径，说明他们是有一段公共的前缀，这个前缀的内容就是&lt;code&gt;ca&lt;/code&gt;，说道这里，我们就知道字典树利用的就是字符串的前缀来解决问题。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么具体它有哪些性质的话，我们下文介绍一下~&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;基本性质&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;对于上述概念有了一定的理解后，我们接下来就看下Trie树的基本性质。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;可以根据这个，大体上分成三个点来说👇&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;根节点不包含字符，除根节点外，每个节点只包含一个字符。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;每个节点的所有子节点包含的字符串不相同。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;接下来我们可以稍微分析一下，可以结合一个图来看看👇&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;我们通过拿how,hi,her,hello,so,see这6个字符串构造出来的就是下面图这个样子。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="图解Trie树" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a834aa9e63ff47248f6fe0ec5f03bc4d~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;图解Trie树&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;（图片出处不明，网上引用处太多~）&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;第一个性质：&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;从图中也可以看出，根节点是&lt;code&gt;/&lt;/code&gt;, 代表的内容也就是空，其他的节点比如，根节点下一个层级，有 &lt;code&gt;h&lt;/code&gt;和&lt;code&gt;s&lt;/code&gt;，分别代表的是两个字符。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;第二个性质：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;比如&lt;code&gt;how&lt;/code&gt;表示的就是一个字符串，&lt;code&gt;hi&lt;/code&gt;,也表示的是一个字符串，可是你会不会好奇，&lt;code&gt;he&lt;/code&gt;和&lt;code&gt;hel&lt;/code&gt;为什么不能表示一个字符串呢？&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;当你想到这里的话，说明你已经看得很仔细，马上就要掌握它了，确实，从图中看，我们会发现有些节点颜色不同，这是因为，我们预定好以这个深色的节点代表当前是一个字符串的结尾，想一想，这样子的作用是啥？&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么实际代码中，我们应该如何去约定或者做个标记呢，其实只要设置一个标记位即可。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;比如下面这样子👇&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;const&lt;/span&gt; TrieNode = &lt;span class="hljs-function" style="line-height: 26px;"&gt;&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;function&lt;/span&gt; (&lt;span class="hljs-params" style="line-height: 26px;"&gt;&lt;/span&gt;) &lt;/span&gt;{
&lt;span&gt;  &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;this&lt;/span&gt;.next = &lt;span class="hljs-built_in" style="color: #e6c07b; line-height: 26px;"&gt;Object&lt;/span&gt;.create(&lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;null&lt;/span&gt;)
&lt;span&gt;  &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;this&lt;/span&gt;.isEnd = &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;false&lt;/span&gt;
&lt;span&gt;};
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;当前的isEnd变量就表示当前的节点是不是结束串，当isEnd为True时，表示从根节点开始，到这个字符，所构成的字符串是存在的，是一个完整的字符串。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;第三个性质：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;每个节点的所有子节点包含的字符串不相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;很明显，我们从根节点开始，依次往下走，会发现，每个节点下面的节点是不相同的，所以依次组成的字符串不可能相同。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;应用场景&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;对Trie树，有一定了解后，我们就可以看看它有哪些的实际应用场景了。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这里参考的是网上所提供的几个点👇&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;在搜索引擎中关键词提示，引擎会自动弹出匹配关键词的下拉框，这种应用场景大家应该都很熟悉。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="下拉框" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d770fe23422402bb052c28d083535d7~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;下拉框&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么应该如何利用一种高效的数据结构存储呢，这里就符合字典树的性质，所以可以利用字典树来构造特定的数据，达到一种更加快速检索的效果。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;字符串检索&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率，可以举例子说明情况👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;词频统计&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;给定很长的一个串，统计频数出现次数最多情况，举个例子👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;字符串最长公共前缀&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;到现在，我们应该知道，Trie树利用多个字符串的公共前缀来节省存储空间，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀，所以可以利用这个特点来解决一些前缀问题。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;非要举个例子的话，有个例子👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;应用场景还是有很多的，剩下的可以自行去探索，接下来，我们通过实际的题目来看看，如何构造字典树吧~&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;2个例子&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;接下来，我们通过二个题目作为例子，来看看字典树在实际应用可以解决哪些问题👇&lt;/p&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 16px; font-weight: bold; display: inline-block; margin-left: 8px; color: rgb(60,112,198);"&gt;&lt;a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;词典中最长的单词⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;词典中最长的单词&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;若无答案，则返回空字符串。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;示例 1：&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;输入：
&lt;span&gt;words = [&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"w"&lt;/span&gt;,&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wo"&lt;/span&gt;,&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wor"&lt;/span&gt;,&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"worl"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"world"&lt;/span&gt;]
&lt;span&gt;输出：&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"world"&lt;/span&gt;
&lt;span&gt;解释： 
&lt;span&gt;单词&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"world"&lt;/span&gt;可由&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"w"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wo"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wor"&lt;/span&gt;, 和 &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"worl"&lt;/span&gt;添加一个字母组成。
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;示例 2：&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;输入：
&lt;span&gt;words = [&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"a"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"banana"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"appl"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"ap"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apply"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;]
&lt;span&gt;输出：&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;
&lt;span&gt;解释：
&lt;span&gt;&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apply"&lt;/span&gt;和&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;都能由词典中的单词组成。但是&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;的字典序小于&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apply"&lt;/span&gt;。
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;提示：&lt;/p&gt;
&lt;span class="span-block-equation" style="cursor: pointer;"&gt;&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" class="equation" src="https://juejin.cn/equation?tex=%E6%89%80%E6%9C%89%E8%BE%93%E5%85%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E5%8F%AA%E5%8C%85%E5%90%AB%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E3%80%82words%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E8%8C%83%E5%9B%B4%E4%B8%BA[1,1000]%E3%80%82words[i]%E7%9A%84%E9%95%BF%E5%BA%A6%E8%8C%83%E5%9B%B4%E4%B8%BA[1,30]%E3%80%82" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;/figure&gt;&lt;/span&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-word-in-dictionary
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这题无非就是找到一个最长的单词，可以拆分成words数组中某一部分，最暴力的思路就是去枚举每一项，但是这样子的时间复杂度是巨大的， 这个时候，我们是不是可以思考一下，这个问题有哪些地方是共性的呢？&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;没错，就是前缀是相同的，从这点来看，是不是就可以利用这个前缀树，把它数据存储下来&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;然后遍历一遍这课树，只要这颗树只有一个分支，则表示它有解，如果存在两个分支以上的话，则无答案。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;复杂度分析&lt;/p&gt;
&lt;span class="span-block-equation" style="cursor: pointer;"&gt;&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" class="equation" src="https://juejin.cn/equation?tex=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9AO(\sum%20w_i)%E3%80%82w_i%20%E6%8C%87%E7%9A%84%E6%98%AF%20words[i]%E7%9A%84%E9%95%BF%E5%BA%A6%E3%80%82" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;/figure&gt;&lt;/span&gt;
&lt;span class="span-block-equation" style="cursor: pointer;"&gt;&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" class="equation" src="https://juejin.cn/equation?tex=%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9AO(\sum%20w_i)%EF%BC%8C%E5%89%8D%E7%BC%80%E6%A0%91%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E3%80%82" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;/figure&gt;&lt;/span&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这点应该很好理解，这里就跳过了。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这里的话，我的解法构造字典树，当然了，也有其他的解法，这里就不展开了，可以看下我得代码噢～&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="最长的串" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7376b352a77643f7b988899f6fa070a8~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;最长的串&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/Tire%E6%A0%91/leetcode-%E5%AD%97%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D.js" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;代码点这里&lt;/a&gt;☑️&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;其实你会发现，构造一个Trie树的话，是很消耗空间的，有点空间换时间的意思，所以具体得根据实际的题目来解决问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 16px; font-weight: bold; display: inline-block; margin-left: 8px; color: rgb(60,112,198);"&gt;&lt;a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;实现Trie（前缀树）⭐⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;实现 Trie (前缀树)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;示例:&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;Trie trie = new Trie();
&lt;span&gt;trie.insert(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;);
&lt;span&gt;trie.search(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;);   // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;true&lt;/span&gt;
&lt;span&gt;trie.search(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;);     // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;false&lt;/span&gt;
&lt;span&gt;trie.startsWith(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;); // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;true&lt;/span&gt;
&lt;span&gt;trie.insert(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;);   
&lt;span&gt;trie.search(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;);     // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;true&lt;/span&gt;
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;说明:&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;你可以假设所有的输入都是由小写字母 a-z 构成的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;保证所有输入均为非空字符串。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这个题目就是典型的写Trie树，对于第一次写这个题目的话，如果没有思路的话，可以尝试先看看别人的代码，看看基本的&lt;code&gt;套路&lt;/code&gt;在哪里。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;话不多说，可以参考这份代码，可以看看如何构造一颗字典树👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="leetcode-实现Trie树" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c61a33b0a184bc1984e1452916d0b4d~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;leetcode-实现Trie树&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/Tire%E6%A0%91/leetcode-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AATrie%E6%A0%91.js" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;剩下的删除操作，还有统计字符串出现的频率，可以自己来实现一下，这个基本上不难，画个图，就知道如何实现啦～&lt;/p&gt;
&lt;hr /&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;题目是做不完的，做完这些题目后，希望你能对Trie字典树有所认识，能对它有更加深入的理解~，接下来准备了四道题集，希望对你们有帮助~&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;词典中最长的单词&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;实现 Trie (前缀树)&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/word-search-ii/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;单词搜索 II&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;Loading question&lt;/a&gt;&lt;/p&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;❤️ 感谢大家&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;关注公众号&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;前端UpUp&lt;/strong&gt;，联系作者，遇到问题的话，欢迎打扰我，我们一起探讨一起进步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6885104477297344525" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」回溯算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」分治算法之美(180+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p class="nice-suffix-juejin-container" id="nice-suffix-juejin-container" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;"&gt;本文使用 &lt;a href="https://mdnice.com/?from=juejin" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;mdnice&lt;/a&gt; 排版&lt;/p&gt;&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Tue, 27 Oct 2020 15:53:48 GMT</pubDate></item><item><title>「算法与数据结构」分治算法之美</title><link>https://juejin.cn/post/6885104477297344525</link><description>&lt;section id="nice"&gt;&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这次分享的内容是，经典算法思想-分治，你可以把它称之为一种思想，也可以叫它分治算法，为了更好的区分，接下来我们以&lt;strong style="color: #595959; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;分治法&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;来称呼它。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你还不了解什么是分治法，或者知道一些，但是对于它具体是如何实现&lt;code&gt;回溯&lt;/code&gt;，那么这篇文章可能适合你阅读。&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;我对分治算法的理解：&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;它的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;求出子问题的解，就可得到原问题的解，可以理解成一种分目标完成程序的算法。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;二分法很多时候，就是一种分治的思想。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么围绕以下几个点来展开介绍分治算法👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;基本思路&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;适用情况以及求解哪些经典问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;经典例题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;分治法基本思想&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;一句话，对分治法概括它的话👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;将原问题划分成n个规模较小而结构与原问题相似的子问题，递归去解决这些子问题，然后依次再合并其结果，最后得到原问题的解。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么具体的来说，我们似乎可以分成三个步骤👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;分解：将要解决的问题划分成若干规模较小的同类问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;解决：当子问题划分得足够小时，用较简单的方法解决。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;其实思想还是不变的，将一个难以直接解决的大问题，分割成一些小规模的相同问题，以便各个击破，分而治之。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;分治法适用情况&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;利用分治法求解一个问题，在于我们能否掌握分治法的几个特征：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;把一个问题可以缩小到一定程度，变成更小的问题来解决。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;分解成若干个小问题后，规模更小且是同类问题，这样子的话，该问题应该就是最优子结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;利用该问题分解出来的子问题的解，合并为该问题的解。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;分解出来的各个子问题是相互独立的，即子问题之间不包含公共的子问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那我们来说一说这几个特征吧~&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第一条特征：一个问题的计算复杂性一般是随问题的规模增加而增加的，所以绝大多数问题都满足。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第二条特征：应用分治法的前提是得满足它，你可以理解成它某种程度上反映了递归思想的应用。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第三条特征：这个应该就是分治法的关键了吧，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;了解分治法的特征，我们来看看有哪些经典的问题是利用这个思想来解决问题的👇&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;分治法求解经典问题&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;什么情况下，可以用该思路来求解呢，以下来自网上搜集的内容👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（1）二分搜索&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（2）大整数乘法&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（3）Strassen矩阵乘法&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（4）棋盘覆盖&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（5）合并排序&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（6）快速排序&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（7）线性时间选择&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（8）最接近点对问题&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（9）循环赛日程表&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（10）汉诺塔&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我想提起的是合并（归并）排序，它完成照应分治法的思想，&lt;code&gt;分解大问题，解决各个规模小问题，最后合并&lt;/code&gt;，那我们来看看合并（归并）排序代码👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="归并排序" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05eb4f8501584bb494ac0029249ba9fd~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;归并排序&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于归并排序的思路，是如何实现的，之前的排序一章以及提及过，采用的是分治思路，可以看看是如何实现的，这里就不具体展开了。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;2个例子&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;接下来，我们通过三个题目作为例子，来看看怎么利用分治的思想来解决问题👇&lt;/p&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-subarray/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;最大子序和⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/maximum-subarray/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;最大子序和&lt;/a&gt;&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;示例:&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;进阶:&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先，我们看看能不能以O(n)复杂度解决这个问题，其实仔细想一想的话，我们可以通过一个简单&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;更多得是，我们这题尝试一下用分治法来解决这题。对于一个数组的最大子序和，它对答案的贡献，只能是以下几种情况👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;出现在左半边&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;出现在右半边&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;出现在中间，穿过中间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么我们是不是可以递归处理呢，对于出现在左边和出现在右边的答案，我们可以把它们当作是一种情况，然后递归去处理，当然了递归的出口，很显然，当递归的数组的长度为1时，我们需要递归结束。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于出现在中间答案的情况，我们可以通过计算来算出答案，所以思路理清楚， 接下来，我们看如何写👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="分治法求最大和" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72e2c3430d264166b61cc8f7fa66be8e~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;分治法求最大和&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，这题用动态规划思路更好求解，也更加得好理解👇&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;//dp[i]表示nums中以nums[i]结尾的最大子序和&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;
&lt;p&gt;&lt;img alt="动态规划求连续和" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167f14786b934fbf95201d6d8b8d4f48~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/p&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;动态规划求连续和&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/leetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%82%E8%A7%A3%E8%BF%9E%E7%BB%AD%E6%9C%80%E5%A4%A7%E5%92%8C.js" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;搜索二维矩阵 II⭐⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;搜索二维矩阵 II&lt;/a&gt;&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
示例:&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;现有矩阵 matrix 如下：&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;[
[1,   4,  7, 11, 15],
[2,   5,  8, 12, 19],
[3,   6,  9, 16, 22],
[10, 13, 14, 17, 24],
[18, 21, 23, 26, 30]
]&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定 target = &lt;code&gt;5&lt;/code&gt;，返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定 target = &lt;code&gt;20&lt;/code&gt;，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/search-a-2d-matrix-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这题的题目很清晰👉矩阵的每行从左到右是升序， 每列从上到下也是升序，在矩阵中查找某个数。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，我们有一个简单的思路👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;维护两个指针（row,col),找到目标元素时，我们就放回true&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;当指向当前的元素值小于target时，我们就col++，向上移动一行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;如果当前的值大于当前的target，我们就row--，向左移动一列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;知道col &amp;gt; 矩阵的行，或者row &amp;lt; 0时，我们直接return false，表示不存在。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;时间复杂度：O(n+m)&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;时间复杂度分析的关键是注意到在每次迭代（我们不返回 true）时，行或列都会精确地递减/递增一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;由于行只能减少 m 次，而列只能增加 n次，因此在导致 while 循环终止之前，循环不能运行超过 n+m 次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;因为所有其他的工作都是常数，所以总的时间复杂度在矩阵维数之和中是线性的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;根据以上的伪代码，我们基本上就能解出这个题目👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="二维矩阵求值" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5a9a8aa6a847ddaf57a6faf7e01e94~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;二维矩阵求值&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这样子的解法，简单且容易理解，其实这并不是真正意义上的二分，只是根据数据的特殊性，使用特定的搜索方式完成对矩阵的查找。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;既然一维数组查某个值时，我们可以将复杂度降为&lt;code&gt;log&lt;/code&gt;级别的时间复杂度，那么在二维的情况下，我们是不是也可以这么考虑呢?&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这个思路，可以借鉴一下👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;我们可以迭代矩阵对角线，二分搜索这些行和列，对它们进行切片。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;在对角线上迭代，二分搜索行和列，知道对角线上的迭代元素用完为止（这个时候，就可以放回true或者是false）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;说得更加简单一些，二分查找的思想是沿着对角线，行查找一下，列查找一下。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可以借鉴一下代码，就会明白如何利用矩阵的对角线去分治。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/175cd11798554cf3b23d1b0371430230~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/leetcode-%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%B1%82%E5%80%BC.js" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;理清楚分治法思路，对它的特征有了一定的了解，明白何如利用它解决实际的问题，那或许这就是这篇文章的意义所在吧~&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;题目汇总&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;题目不多，但是对于基本的入门分治法，应该还是不错的选择👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-subarray/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;最大子序和&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://leetcode-cn.com/problems/contiguous-sequence-lcci/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;连续数列&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://leetcode-cn.com/problems/qie-fen-shu-zu/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;切分数组&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;❤️ 感谢大家&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;关注公众号&lt;strong style="color: #595959; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;前端UpUp&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，联系作者👉 &lt;strong style="color: #595959; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;DayDay2021&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; ，我们一起学习一起进步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p class="nice-suffix-juejin-container" id="nice-suffix-juejin-container" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; margin-top: 20px !important;"&gt;本文使用 &lt;a href="https://mdnice.com/?from=juejin" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;mdnice&lt;/a&gt; 排版&lt;/p&gt;&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Sun, 18 Oct 2020 15:24:24 GMT</pubDate></item><item><title>「算法与数据结构」带你看回溯算法之美</title><link>https://juejin.cn/post/6882394656148045838</link><description>&lt;section id="nice"&gt;&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这次梳理的是回溯算法，掌握它的解决问题思路，对很多搜索尝试问题，都会在日后学习工作中有所帮助。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;我对回溯算法有一定理解：回溯算法建立在DFS基础之上的，但不同的是在搜索的过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索，因此我们可以这样子理解，回溯算法与DFS的区别就是有无状态重置。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你还不了解什么是回溯算法，或者知道一些，但是对于它具体是如何实现&lt;code&gt;回溯&lt;/code&gt;，那么这篇文章可能适合你阅读。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么围绕以下几个点来展开介绍回溯算法👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;来源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;基本思路&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;算法框架&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;经典例题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;回溯算法的来源&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先，我们得明白啥叫回溯算法，它的由来是什么。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;根据维基百科给出的定义👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;用回溯算法解决问题的一般步骤：&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;1、 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;2 、确定易于搜索的解空间结构,使得能用&lt;code&gt;回溯法&lt;/code&gt;方便地搜索整个解空间 。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;3 、以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;用更加简单的话术来解释的话👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;回溯法可以理解成为通过选择不同的岔路口，来寻找目的地，一个岔路口一个岔路口的去尝试找到目的地，如果走错了路的话，继续返回到上一个岔路口的另外一条路，直到找到目的地。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;基本思路&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先，我们得明确这个回溯算法的思路是什么，有了思路，我们才可以根据这个思路写出伪代码，有了伪代码之后，根据实际的问题，写出相应的解决方案。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我们可以把这类回溯问题，看成是解决一个决策树的遍历过程，这样子也方便我们接下来的解释👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;基本思路：&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;从决策树的一条路开始走，能进则进，不能进则退回来，换一条路试一试。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;举个例子来说，还是拿八皇后问题来解释：&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;第一步按照顺利，也就是在第一行，我们放置第一个皇后。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;第二步，我们需要在第二行放置一个皇后，我们需要遍历，将符合要求的位置放置皇后。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;第三步，也就是在第三行，我们需要去遍历，找到符合的位置，如果都没有符合要求，我们就需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销第二步操作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，那么需要改变第二个皇后位置，重新放置第二个皇后位置，直到满足第三个皇后放置的位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;当你改变第二个皇后位置后，都无法满足第三个皇后位置的时候，我们就需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销第一步操作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，重新去放置第一个皇后位置，然后按照顺序完成后续操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我们可以通过另外一个例子来看，也就是回溯在迷宫搜索中也很常见，简单来说，就是这条路走不通的话，我们就需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销上个操作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，返回前一个路口，继续下一条路。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;似乎你已经发现了，回溯说到底就是&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;穷举法&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，但是如果你只是单纯的穷举的话，不剪枝的话，时间复杂度是巨大的，那么如何剪枝呢？&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我们将回溯优化的方法可以称之为剪枝，或者是剪枝函数，通过这个函数，我们可以减去一些状态，剪去一些不可能到达（&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;最终状态&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;），这里说的最终状态，可以认为是答案状态，这样子的话，就减少了部分空间树节点的生成，具体如何剪枝的话，可以根据做题经验多加练习，这里就不张开了。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;算法框架&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;其实刷了一定的题量，你会发现，对于这种回溯思路而言，都是有一定的套路的，那么接下来就给出伪代码👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;接下来是自己的一点理解，觉得按照这个步骤来的话，也好理解一些👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可以按照3个步骤来思考这类的问题：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;路径&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：记录做出的选择。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;选择列表&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：通常而言，用数组存储可以选择的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;结束条件&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：一般而言，就是递归的结束点，也就是搜索的结束点。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;result = []
&lt;span&gt;
&lt;span&gt;&lt;span class="hljs-function" style="line-height: 26px;"&gt;&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;function&lt;/span&gt; &lt;span class="hljs-title" style="color: #61aeee; line-height: 26px;"&gt;backtrack&lt;/span&gt;(&lt;span class="hljs-params" style="line-height: 26px;"&gt;路径, 选择列表&lt;/span&gt;) &lt;/span&gt;{
&lt;span&gt;    &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;if&lt;/span&gt;(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;'满足结束条件'&lt;/span&gt;) {
&lt;span&gt;        &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 这里就是对答案做更新,依据实际题目出发&lt;/span&gt;
&lt;span&gt;        result.push(路径)
&lt;span&gt;        &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;return&lt;/span&gt;
&lt;span&gt;    } &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;else&lt;/span&gt; {
&lt;span&gt;        &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;for&lt;/span&gt;(&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;let&lt;/span&gt; i = &lt;span class="hljs-number" style="color: #d19a66; line-height: 26px;"&gt;0&lt;/span&gt;; i &amp;lt; 选择列表.length; i++) {
&lt;span&gt;            &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 对一个选择列表做相应的选择&lt;/span&gt;
&lt;span&gt;            
&lt;span&gt;            做选择
&lt;span&gt;            
&lt;span&gt;            backtrack(路径, 选择列表)
&lt;span&gt;            
&lt;span&gt;            &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 既然是回溯算法,那么在一次分岔路做完选择后&lt;/span&gt;
&lt;span&gt;            &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 需要回退我们之前做的操作&lt;/span&gt;
&lt;span&gt;            
&lt;span&gt;            撤销选择
&lt;span&gt;        }
&lt;span&gt;    }
&lt;span&gt;}
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;做过类似的题目都知道，核心的处理就是for循环里面的递归操作，每次在递归之前，&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;做选择&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，在这种方案结束后，我们需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销选择&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，这样子的话，就不会影响同一层决策树的其他选择。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;举个例子，在走迷宫这类题型中，我们需要不断的去搜索，去试探答案，这个过程就是一个回溯算法的过程，每次要走下一个格子的时候，我们需要先将这个格子&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;做个标记&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，代表这个格子已经走过，然后在往后继续搜索...&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当这个方案不合理的时候，我们是不是需要将之前标记的格子清除标记呢？仔细想一想的话，这样子是非常合理的，在当前方案行不通的时候，我们要将这个&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;步骤撤销掉&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于以上的基础知识，有了一定了解，接下来我们就通过这么基础知识来解决问题。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;怎么样写回溯&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;做一些题目后，对回溯算法有初步认识后，我觉得可以参考下面的步骤来刻意练习👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;首先画出递归树，找到状态变量（这里可以理解成回溯函数参数）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;确定递归出口，一般根据具体题目条件而言。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;找准选择列表（一般而言与函数参数有关）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;剪枝，对于一些情况而言，可以适当剪枝。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;做出选择，递归调用，进入下一层。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;撤销选择。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我觉得这个对回溯算法的总结，是挺不错的，可以借鉴下。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;2个例子&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;接下来，我们通过三个题目作为例子，来看看怎么根据我们之前提及的&lt;code&gt;算法框架&lt;/code&gt;来解决问题👇&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;&lt;a href="https://leetcode-cn.com/problems/letter-case-permutation/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字母大小写全排列⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/letter-case-permutation/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字母大小写全排列&lt;/a&gt;&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;示例：&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入：S = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入：S = "3z4"
输出：["3z4", "3Z4"]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入：S = "12345"
输出：["12345"]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;提示：&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;S 的长度不超过12。
S 仅由数字和字母组成。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/letter-case-permutation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，这题的话，可以通过画图举个例子来说，我这里就借鉴网上的图了👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="字母全排列" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93b6631eb83447609f909fea94d63c9f~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;字母全排列&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于数字而言的话，我们直接跳过，字母的话，无非就是两种状态，大小写字母，那么我们就有接下来的思路👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;遇到数字的话，不会涉及新的分支，我们就直接往后搜，这样子的话，对于数字就只需要搜索一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;对于单个字母而言，我们需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;搜索2次&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，小写字母搜索一次，大写字母搜索一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;我们可以去维护一个index，遇到数字的话，index+1，继续递归，遇到字母的话，需要递归两次，假设当字母是小写时，我们递归一次(index+1),然后回溯时将字母转为大写，又去递归一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;递归尽头：即搜索完整个字符串为止，我们前面维护的index，这个时候就可以作为条件判断。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;按照这个思路走的话，我们就可以写出完整的解题代码&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;代码👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="回溯算法代码-1" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05057b7c673b46ae9956fddcf4b0e900~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;回溯算法代码-1&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-%E5%AD%97%E6%AF%8D%E5%85%A8%E6%8E%92%E5%88%97.js" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;&lt;a href="https://leetcode-cn.com/problems/subsets/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集🐍⭐⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/subsets/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集&lt;/a&gt;&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;说明：解集不能包含重复的子集。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;示例:&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入: nums = [1,2,3]
输出:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/subsets
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;做这类题目的时候，不太懂的话，可以先画图，从上面的题来看，我们可以画类似一个树的结构，然后看看如何去遍历这个决策树，看看能不能剪枝，直接借鉴一下网上的图👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="子集的递归树" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5f58298bf1f4f8d859b368d39fdcf60~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;子集的递归树&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;其实把这个图画出来，你应该就成功一半了，从这个图来看，我们似乎又可以去遍历这颗树。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先我们得把我们思路整理一下👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;这题肯定是求树的所有节点！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;对这颗树而言，我们可以遍历它的分支，选择其中一个分支，然后继续向下操作，不选这个分支的话，选择另外一个分支又是另外一个情况，所以每次枚举下一个数字的时候,也就是两种选择：选或不选。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;可以考虑使用一个index指针来记录&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;节点&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的状态,即当前递归考察的数字&lt;code&gt;nums[index]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;递归结束的条件： index === nums.length, 这个时候代表考察完所有的数字，把当前的子集加入题解，结束当前递归分支。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;每次结束一个分支，即结束递归，需要撤销当前的选择，（从list中删除），回到选择前的状态，做另外一个选择，即不选择当前的数字，往下递归，继续生成子集。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;根据以上的伪代码，我们基本上就能解出这个题目👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="回溯算法题解-2" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6a5cbcfe7eb465a802faccea3ef20ab~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;回溯算法题解-2&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-%E5%AD%90%E9%9B%86.js" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;题目是做不完的，做完这些题目后，希望你能找出回溯算法的规律，能对它有更加深入的理解~，接下来准备了些题集，希望对你们有帮助~&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;进阶题目汇总&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;以下是我在网上看到一套不错的回溯算法题集，如果你还在刻意找的话，可以看看这里。&lt;/p&gt;
&lt;section class="table-container"&gt;&lt;table style="display: table; text-align: left;"&gt;
&lt;thead&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"&gt;
&lt;th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; color: #595959;"&gt;类型&lt;/th&gt;
&lt;th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; color: #595959;"&gt;题目链接&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody style="border: 0;"&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;子集，组合&lt;/td&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/subsets/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/subsets-ii/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集 II&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/combinations/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;组合&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/combination-sum/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;组合总和&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/combination-sum-ii/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;组合总和 II&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;"&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;全排列&lt;/td&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/permutations/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;全排列&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/permutations-ii/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;全排列 II&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字符串的全排列&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/letter-case-permutation/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字母大小写全排列&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;搜索&lt;/td&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/sudoku-solver/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;解数独&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/word-search/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;单词搜索&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/eight-queens-lcci/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;N皇后&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/palindrome-partitioning/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;分割回文串&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/binary-watch/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;二进制手表&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/section&gt;&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;❤️ 感谢大家&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;关注公众号&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;前端UpUp&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，联系作者，我们一起学习一起进步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p class="nice-suffix-juejin-container" id="nice-suffix-juejin-container" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; margin-top: 20px !important;"&gt;本文使用 &lt;a href="https://mdnice.com/?from=juejin" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;mdnice&lt;/a&gt; 排版&lt;/p&gt;&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Sun, 11 Oct 2020 08:11:57 GMT</pubDate></item><item><title>带你了解 Tree Shaking</title><link>https://juejin.cn/post/7135217402983235592</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="佳民.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4bcf3e8f8294db798dd11c54b597805~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 156 篇不掺水的原创，想获取更多原创好文，请搜索公众号【政采云前端团队】关注我们吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;JavaScript 绝大多数情况需要通过网络进行加载再执行，加载的文件越小，整体执行时间更短，所以就有了 Tree Shaking 去除无用代码，从而减小文件体积。&lt;/p&gt;
&lt;h3&gt;什么是 Tree Shaking&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Tree-shaking&lt;/strong&gt; (摇树) 是一个术语，通常指通过打包工具"摇"我们的代码，将未引用代码 (Dead Code) "摇" 掉。在 Webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝，虽然依赖了某些模块，但其实只使用其中的某些方法，通过 Tree Shaking ，将没有使用的方法摇掉，这样来达到删除无用代码的目的。&lt;/p&gt;
&lt;h3&gt;Tree Shaking 具体做了什么&lt;/h3&gt;
&lt;p&gt;我们通过例子来详细了解一下 Webpack 中 Tree Shaking 到底做了什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未使用的函数消除&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// utils.js
export function sum(x, y) {
  return x + y;
}

export function sub(x, y) {
  return x - y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// index.js
import { sum } from "./utils";
// import * as math from "./utils";

console.log(sum(1, 2));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在 utils 中定义了 sum 与 sub 两个方法， 仅使用了 sum 方法，而 sub 方法并没有被使用。我们一起看一下打包后的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;(()=&amp;gt;{"use strict";console.log(3)})();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;未使用的 JSON 数据消除&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;// main.json
{
  "a": "a",
  "b": "b"
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// index.js
import main from "./main.json";

console.log(main.a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到仅使用了 JSON 中的 a 。我们一起看一下打包后的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;(()=&amp;gt;{"use strict";console.log("a")})();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Tree Shaking 的原理&lt;/h3&gt;
&lt;p&gt;Tree Shaking 在去除代码冗余的过程中，程序会从入口文件出发，扫描所有的模块依赖，以及模块的子依赖，然后将它们链接起来形成一个 “抽象语法树” (AST)。随后，运行所有代码，查看哪些代码是用到过的，做好标记。最后，再将“抽象语法树”中没有用到的代码“摇落”。经历这样一个过程后，就去除了没有用到的代码。
&lt;img alt="image-20200729195132323" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bed23d8877d4ddf8ffc249f7cbbf276~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;前提是模块必须采用 ES6 Module 语法，因为 Tree Shaking 依赖 ES6 的静态语法：import 和 export。不同于 ES6 Module，CommonJS 支持动态加载模块，在加载前是无法确定模块是否有被调用，所以并不支持 Tree Shaking 。如果项目中使用了 babel 的话， &lt;code&gt;@babel/preset-env&lt;/code&gt; 默认将模块转换成 CommonJs 语法，因此需要设置 &lt;code&gt;module：false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;CommonJS 与 ES6 Module 模块的依赖的区别在于，CommonJS 是&lt;strong&gt;动态的&lt;/strong&gt;，ES6 Module 是&lt;strong&gt;静态的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CommonJS 导入时，&lt;code&gt;require&lt;/code&gt; 的路径参数是支持表达式的，路径在代码执行时是可以动态改变的，所以如果在代码编译阶段就建立各个模块的依赖关系，那么一定是不准确的，只有在代码运行了以后，才可以真正确认模块的依赖关系，因此说CommonJS 是动态的。&lt;/p&gt;
&lt;p&gt;ES6 模块不是对象，它的对外接口只是一种静态定义，在代码编译，静态解析阶段就会生成，这样我们就可以使用各种工具对JS模块进行依赖分析，优化代码。&lt;/p&gt;
&lt;h4&gt;Development 模式下&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// webpack.config.js

module.exports = {
  // mode: "production",
  mode: "development",
  devtool: false,
  optimization: {
    usedExports: true, // 目的使未被使用的export被标记出来
  },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打包后的 bundle.js&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sum": () =&amp;gt; (/* binding */ sum)
/* harmony export */ });
/* unused harmony export sub */
function sum(x, y) {
  return x + y;
}

function sub(x, y) {
  return x - y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1、可以看到未被使用的 sub 会被标记为 &lt;code&gt;/* unused harmony export sub */&lt;/code&gt;，不会被 &lt;code&gt;__webpack_require__.d&lt;/code&gt; 进行 exports 绑定；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于 &lt;code&gt;__webpack_require__.d&lt;/code&gt; 的含义，可参考 &lt;a href="https://segmentfault.com/a/1190000024457777"&gt;深入了解 webpack 模块加载原理&lt;/a&gt; 一文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、经过压缩工具（UglifyJSPlugin）压缩后，未使用的接口代码会被删除。原理显而易见，未被 &lt;code&gt;__webpack_require__.d&lt;/code&gt; 引用，所以压缩工具可以将其安全移除。&lt;/p&gt;
&lt;h4&gt;Production 模式下&lt;/h4&gt;
&lt;p&gt;由前面的例子可以看出 &lt;code&gt;dist/bundle.js&lt;/code&gt; 中整个 bundle 都已经被 压缩工具 压缩和混淆破坏，但是如果仔细观察，则不会看到引 &lt;code&gt;sub&lt;/code&gt; 函数，但能看到 &lt;code&gt;sum&lt;/code&gt; 函数的混淆破坏版本（&lt;code&gt;function r(e){return e*e*e}n.a=r&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;再看一下两次打包的文件体积会发现，bundle 的体积明显减少了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20220721071044241" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c7005dcdb934685a2ee94629944f464~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;Tree Shaking 和 sideEffects&lt;/h3&gt;
&lt;p&gt;提到 Tree Shaking 就要聊一下 sideEffects。什么是 sideEffects ？sideEffects 又是与 Tree Shaking 如何搭配使用的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sideEffect&lt;/strong&gt;(副作用) 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。&lt;/p&gt;
&lt;p&gt;webpack v4 开始新增了一个 &lt;code&gt;sideEffects&lt;/code&gt; 特性，通过给 &lt;code&gt;package.json&lt;/code&gt; 加入 &lt;code&gt;sideEffects: false&lt;/code&gt; 声明该包模块是否包含副作用，从而可以为 Tree Shaking 提供更大的优化空间。&lt;/p&gt;
&lt;p&gt;举例说明&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// a.js
// 无副作用，仅仅是单纯的 export
function a () {
  console.log('a')
}
export default {
  a
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// b.js
function b () {
  console.log('b')
}

// 执行了特殊行为
Array.prototype.fun = () =&amp;gt; {}

export default {
  b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 a 在 import 后未使用，Tree Shaking 完全可以将其优化掉；但是 b 在 import 后未使用，但因为存在他还执行了为数组原型添加了方法，副作用还是会被保留下来。这时就需要使用  &lt;code&gt;sideEffects: false&lt;/code&gt; ，可以强制标识该包模块不存在副作用，那么不管它是否真的有副作用，只要它没有被引用到，整个 模块/包 都会被完整的移除。&lt;/p&gt;
&lt;p&gt;如果你的项目中存在一些副作用代码 b 需要被保留下来，比如 polyfill、css、scss、less 等，可以按下面方法一样配置；保证必要的代码不被 Tree Shaking&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;// package.json
{
  "name": "your-project",
  "sideEffects": ["./src/b.js", "*.css"]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;通过以上讲解，使 Webpack 更精确地检测无效代码，完成 Tree Shaking 操作，需要符合以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 ES6 Module 语法（即 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;确保没有 &lt;code&gt;@babel/preset-env&lt;/code&gt;等工具将 ES6Module 语法转换为 CommonJS 模块。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optimization: { minimize: true, usedExports: true }&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用支持 Tree Shaking 的包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://segmentfault.com/a/1190000040037144"&gt;Tree shaking原理及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://webpack.docschina.org/guides/tree-shaking/"&gt;Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7132628898453880840"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7124839474575441934"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 23 Aug 2022 15:28:44 GMT</pubDate></item><item><title>厉害！这篇正则表达式竟写的如此详尽</title><link>https://juejin.cn/post/7132628898453880840</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="伟豪.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70253e0ef87045d29397163c2220f829~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 156 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/regexp"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;h3&gt;为什么要学正则表达式？&lt;/h3&gt;
&lt;p&gt;作为一个菜鸟程序员，遇到复杂的正则时往往会求助&lt;strong&gt;搜索引擎&lt;/strong&gt;。虽然能够解决燃眉之急，但往往会有&lt;a href="https://blog.csdn.net/weixin_33994444/article/details/93408973"&gt;边界值&lt;/a&gt;和团队正则不统一的问题。而这种问题往往会被细测测出来，造成不必要的麻烦。对于这种情况，最好的解决方式就是去吃透它，最终能将它手写出来。所谓知其然，也要知其所以然。&lt;/p&gt;
&lt;p&gt;&lt;img alt="RegEx.jpeg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b714067b4b6d46fdb57c76c98be5b87e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;什么是正则表达式？&lt;/h3&gt;
&lt;p&gt;1951年,一位名叫史蒂芬·克林（Stephen Kleene）的数学科学家，发表了一篇名叫《神经网事件的表示法》的论文。论文中引入了&lt;code&gt;正则表达式&lt;/code&gt;的概念。直至七十多年后的今天，&lt;code&gt;正则表达式&lt;/code&gt;仍然影响着我们互联网生活的方方面面。&lt;/p&gt;
&lt;p&gt;&lt;img alt="创建密码：.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b167206d89e242f9a661cc59c93ad426~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;比如需要填入&lt;strong&gt;符合特定规则&lt;/strong&gt;的密码、手机号、邮箱等。
&lt;img alt="9f78f90f4fc7eea055079baf1e0b608d.jpg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25e9d40b63f24cd9b212307eb61e0470~tplv-k3u1fbpfcp-watermark.image" /&gt;
&lt;img alt="" src="https://www.zoo.team/images/upload/upload_9fbf19e559132e6fca267dfc8d7d18cf.png" /&gt;&lt;/p&gt;
&lt;p&gt;又比如我们需要对输入框加一个中文、英文或价格等&lt;strong&gt;输入限制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过在我们学习正则表达式之前，我们需要先熟悉下它的&lt;strong&gt;调试工具&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;怎么检测我的正则对不对呢？&lt;/h2&gt;
&lt;h3&gt;编辑器内置的搜索工具&lt;/h3&gt;
&lt;p&gt;我们可以使用&lt;a href="https://code.visualstudio.com/"&gt;Vscode&lt;/a&gt;提供的正则的搜索方法，来使用正则匹配我们需要搜索的内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="2bd784719bc5b6978b666890e9f11b50.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/876967e4bafc402c8bff29f5bcfa53bc~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;函数调用&lt;/h3&gt;
&lt;p&gt;也可以在自己熟悉的编程语言中调用函数去测试。&lt;/p&gt;
&lt;p&gt;&lt;img alt="eba976de552d2f27a5fa4488610a6fd4.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0f190be786b46dfb88707b7295a4232~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;在线测试网站&lt;/h3&gt;
&lt;p&gt;亦或是使用我这边推荐的一个&lt;a href="https://c.runoob.com/front-end/854/"&gt;在线测试网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="9bc0825470062a225ba48862618cef84.jpg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c13d65c761147c5853c768b9f04d61b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;了解了调试工具后我们开始从&lt;strong&gt;基础&lt;/strong&gt;学习吧。&lt;/p&gt;
&lt;h2&gt;基础&lt;/h2&gt;
&lt;h3&gt;限定符(Quantifiers)&lt;/h3&gt;
&lt;h4&gt;?&lt;/h4&gt;
&lt;p&gt;&lt;img alt="782b5df53d9f928c3665e4ad921432d1.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1b3cd91275b4a5286cf7b8a4011362f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;“?”表示前面的字符可以出现&lt;strong&gt;1次或者0次&lt;/strong&gt;。说简单点就是"co"中的"o"这个字母可有可无。&lt;/p&gt;
&lt;h4&gt;+&lt;/h4&gt;
&lt;p&gt;&lt;img alt="5f90add12862e68dac52415793a22110.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14d0f357912546cc84875e3ead58dfd3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;“+”表示前面的字符至少匹配&lt;strong&gt;1次或多次&lt;/strong&gt;。比如上列中”poverty“、“poor”得到了匹配。“premier”却没有匹配。&lt;/p&gt;
&lt;h4&gt;*&lt;/h4&gt;
&lt;p&gt;&lt;img alt="729092bb5629b191be2acc9a44d14cf7.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78bd71544370478786636c99b6e41e24~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;“*”可以匹配&lt;strong&gt;0个或者多个字符&lt;/strong&gt;。可以看到出现 0 次的“pr”和 2 次的“poor”得到了匹配。我们如何匹配&lt;strong&gt;固定次数&lt;/strong&gt;或&lt;strong&gt;一定范围&lt;/strong&gt;的字符呢？&lt;/p&gt;
&lt;h4&gt;{...}&lt;/h4&gt;
&lt;p&gt;&lt;img alt="39a63a55e7025e5452963a83ce2aafed.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f53c57710857488ca85a605edce12172~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;“{...}”可以用来匹配&lt;strong&gt;固定数量&lt;/strong&gt;的字符或&lt;strong&gt;某个范围&lt;/strong&gt;内的字符。&lt;/p&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;“{2}”当只有一个参数时，只匹配固定数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“{2,3}”当有两个参数时，匹配范围内的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“{2,}”当后面的参数为空时，匹配n个及以上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;(...)&lt;/h4&gt;
&lt;p&gt;以上都讲的是匹配单个字符，当我们想匹配&lt;strong&gt;多个字符&lt;/strong&gt;该怎么办呢？&lt;/p&gt;
&lt;p&gt;&lt;img alt="104f053573d0205258cc98118a8b2619.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fca190b218074c41b87664584c161f7e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以将我们需要匹配的字符用“(...)”括起来，可以看到“(...)”搭配我们上文所学的“+“成功匹配了”banana“和”anna“。&lt;/p&gt;
&lt;h3&gt;或运算符(OR Operator)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="c5dae76af93356ac4ed278c7815e1f59.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c76abd55b57e45afab60ff7dd3fda25d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;当我们需要匹配&lt;strong&gt;两个或多个条件&lt;/strong&gt;时我们就需要使用"|"(或运算符)。图中我们匹配了拥有“an”或“na”的单词。值得注意的是这里的“｜”最外层的"()"是必不可少的。&lt;/p&gt;
&lt;h3&gt;字符类(Character class)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="1458bf56eb5d965823ace88ef27a91ec.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb2fdedc07fb495c91e9db088db355cf~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;比如我们要匹配&lt;strong&gt;拥有“123”中任意字符&lt;/strong&gt;的字符串则需要使用“[...]”,需要匹配的字符只能取自方括号中的内容。另外我们也可以使用字符类去匹配指定范围，如[a-z]、[0-9]、[\u4e00-\u9fa5]等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="708c3df8641ef81355556e12cceae373.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87b18c140cf94e26a80dfaa65ff6b7bf~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;另外我们也可以在前面加”^“用来匹配&lt;strong&gt;非此范围&lt;/strong&gt;的字符串，如上我们就匹配了非英文的字符串。&lt;/p&gt;
&lt;p&gt;另外正则表达式也提供了很多&lt;code&gt;元字符&lt;/code&gt;可以让我们简写我们的正则表达式。&lt;/p&gt;
&lt;h3&gt;元字符(Meta character)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="b7f5812a8a3593cb255f3540f0f372bf.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b5339b063a94173acbdf72a7c5be3d7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用“\d”代替我们之前的“[0-9]”,这里还有两个特殊字符“^”会匹配&lt;strong&gt;开始&lt;/strong&gt;(这里要注意与我们前面讲到的&lt;code&gt;字符类&lt;/code&gt;中的运用要区分)，“$“会匹配结束。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;\d,\w,\s - 匹配数字、字符、空格(分别代表着：digit、word、space)。&lt;/li&gt;
&lt;li&gt;\D,\W,\S - 匹配非数字、非字符、非空格。&lt;/li&gt;
&lt;li&gt;. - 除换行符以外的所有字符(句号句子的结束符)。&lt;/li&gt;
&lt;li&gt;^ - 字符串开头。&lt;/li&gt;
&lt;li&gt;$ - 字符串结尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们来学习一下正则表达式的&lt;strong&gt;高级概念&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;高级概念&lt;/h2&gt;
&lt;h3&gt;懒惰匹配和贪婪匹配(Lazy and Greed)&lt;/h3&gt;
&lt;p&gt;当我们想要匹配文本中的HTML时我们会写下如下正则表达式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="b75cdf169ee888acb769c77838b8dd80.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65ddfa578cd241bf8608aaff781c342d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;根据前面的知识我们知道，此正则将会匹配&amp;lt;开头&amp;gt;结尾中间可以有至少1个任意字符。但结果是匹配了“&amp;lt;”和“&amp;gt;” 标签包含的所有内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc5d409da9aa40792ba90e5b537ebb35.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3e6d077fc2b41c18c50e2c5f7c154b3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以在正则表达式中加“?”来开启&lt;code&gt;懒惰匹配&lt;/code&gt;。开启懒惰匹配后，正则会&lt;strong&gt;尽可能少的匹配&lt;/strong&gt;。所以当匹配的时候发现标签 “ &amp;lt;div&amp;gt; ”已经是符合要求的，所以会匹配&amp;lt;div&amp;gt;标签，然后继续向下匹配，发现&amp;lt;/div&amp;gt;标签也是符合要求的，继续向下匹配，发现文字不符合要求，继续向下，发现&amp;lt;span&amp;gt;和&amp;lt;/span&amp;gt;标签都是符合要求的，所以最后会匹配 &amp;lt;div&amp;gt;, &amp;lt;/div&amp;gt;, &amp;lt;span&amp;gt;, &amp;lt;/span&amp;gt;四个标签。&lt;/p&gt;
&lt;h3&gt;分组(Group)&lt;/h3&gt;
&lt;p&gt;前面我们认识了“(...)”的用法，将其结合我们后面所学的知识就是正则的&lt;code&gt;分组&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="a7392ff6dd264803a4452a4df3e8f920.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36f87aae91f14a2fade79b94a66e7ca8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如上图所示第一个分组中我们匹配 4 个数字，第二个分组中我们匹配 7 个数字。中间使用“-”进行连接，便很容易匹配到了文本中出现的座机电话号。&lt;/p&gt;
&lt;h3&gt;非捕获分组(Non-capture Group)&lt;/h3&gt;
&lt;p&gt;非捕获分组：&lt;code&gt;(?:表达式)&lt;/code&gt;，分组匹配之后，不需要的用“?: ”语法过滤子表达式内容。也就是代码匹配，但是不保存。&lt;/p&gt;
&lt;p&gt;在使用非捕获前:&lt;/p&gt;
&lt;p&gt;&lt;img alt="bd7414a425996817887ea8ff34768dec.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a0d0e49c2d4e8f9f4b25638ecca651~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在使用非捕获后:&lt;/p&gt;
&lt;p&gt;&lt;img alt="29711c018bc8d6c196613e0ed930e554.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c95603ad5fd04ac49c0f0f4418ed666a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;.exec&lt;/code&gt;方法并没有捕获到月份。&lt;/p&gt;
&lt;h3&gt;回溯(Flash Back)&lt;/h3&gt;
&lt;p&gt;当我们想匹配一个正确的HTML标签时，使用"&amp;lt;[\w]+&amp;gt;.*&amp;lt;\/[\w]+&amp;gt;"。&lt;/p&gt;
&lt;p&gt;&lt;img alt="d974356d2305441e19234b3de6a402e0.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f03bd385d1374e40bcffde5d39f2a619~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到虽然可以匹配HTML开始和结束标签，但是&lt;strong&gt;却不能校验前后的一致性&lt;/strong&gt;。如“&amp;lt;/span&amp;gt;”并不是“&amp;lt;div&amp;gt;”的结束标签。&lt;/p&gt;
&lt;p&gt;&lt;img alt="38a9b1c3218a7a0642d44772f0e63d90.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c45f27b04bf34b2c8569910a08793ea3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以把后面的部分改成“&amp;lt;\/\1&amp;gt;”其中“\1”就是引用第一个&lt;code&gt;分组&lt;/code&gt;。这样一来我们就可以匹配正确的HTML标签了。&lt;/p&gt;
&lt;h3&gt;断言(Assertion)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;断言&lt;/strong&gt;有些地方也叫&lt;a href="https://blog.csdn.net/lxcnn/article/details/4304754"&gt;环视(Lookaround)&lt;/a&gt;，它只进行子表达式的匹配，不占有字符，匹配到的内容不保存到最终的匹配结果。&lt;/p&gt;
&lt;h4&gt;正向先行断言&lt;/h4&gt;
&lt;p&gt;正向先行断言：&lt;code&gt;(?=表达式)&lt;/code&gt;，指在某个位置往右看，所在的位置右侧必须匹配&lt;code&gt;表达式&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="c16a1e3118f7225c9c5b109c4a1df01f.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2f48fef68a94b02a31e54ed9dd7012a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到“/喜欢(?=你)”正确匹配到了“你”前面有“喜欢”的文本。&lt;/p&gt;
&lt;h5&gt;实现一个密码强度校验&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;至少有一个大写字母。
至少有一个小写字母。
至少有一个数字。
至少有8个字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="3b6d35aa5cefc456ebc5ef02b412f44a.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f1b58d921a4d889f1f48210cf355b3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h4&gt;反向先行断言&lt;/h4&gt;
&lt;p&gt;反向先行断言：&lt;code&gt;(?!表达式)&lt;/code&gt;，指在某个位置往右看，不能存在&lt;code&gt;表达式&lt;/code&gt;中的内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="f324acb154bd9b76c8f3e05f8167e23e.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f07f3125eca34d70ae9a38ec93296c19~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如上就排除了“喜欢”后面有“你”的字符串。&lt;/p&gt;
&lt;h4&gt;正向后行断言&lt;/h4&gt;
&lt;p&gt;正向后行断言：&lt;code&gt;(?&amp;lt;=表达式)&lt;/code&gt;，指在某个位置往左看，存在&lt;code&gt;表达式&lt;/code&gt;中的内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="84cea0dfb73d0222db6baec62fbeb2be.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/280a1be38d1e4b3899bbf31ce39e0001~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如上就匹配了“喜欢”前面有“我”的字符串。&lt;/p&gt;
&lt;h4&gt;反向后行断言&lt;/h4&gt;
&lt;p&gt;反向后行断言：&lt;code&gt;(?&amp;lt;!表达式)&lt;/code&gt;，指在某个位置往左看，不能存在&lt;code&gt;表达式&lt;/code&gt;中的内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="d853e7b39730aa7648879a717647ad66.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd0d2ed15b1f4523893862c63d37dd44~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如上就排除了“喜欢”前面有“我”的字符串。&lt;/p&gt;
&lt;p&gt;至此正则表达式的&lt;strong&gt;高级部分&lt;/strong&gt;学完啦，接下来我们学习正则提供的&lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;方法&lt;/h2&gt;
&lt;p&gt;在JavaScript中，&lt;code&gt;RegExp&lt;/code&gt;对象是一个预定义了属性和方法的正则表达式对象。&lt;/p&gt;
&lt;h3&gt;test()&lt;/h3&gt;
&lt;p&gt;&lt;img alt="640.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67e6e27ea7ba445d9cef33dacc93dbc7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;该方法用于检测一个字符串是否匹配某个正则表达式，&lt;strong&gt;匹配&lt;/strong&gt;返回 true，&lt;strong&gt;不匹配&lt;/strong&gt;返回 false。&lt;/p&gt;
&lt;h3&gt;exec()&lt;/h3&gt;
&lt;p&gt;&lt;img alt="94254b2d0aa9579258f63de420322fd4.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a665ff5356584716808c7a87337a3253~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;该方法用于检测字符串中对正则表达式的匹配。&lt;/p&gt;
&lt;p&gt;该函数返回一个&lt;strong&gt;数组&lt;/strong&gt;，其中存放匹配的结果。如果未找到匹配，则返回值为 null。&lt;/p&gt;
&lt;p&gt;除了正则自身携带的方法，配合 &lt;strong&gt;String 对象&lt;/strong&gt;的方法一起使用也会有额外的效果。&lt;/p&gt;
&lt;h2&gt;配合String提供的方法&lt;/h2&gt;
&lt;h3&gt;match&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;match&lt;/strong&gt; 这个方法主要用来提取数据，它配合分组的（）一起使用，可以很方便的提取数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var str = '2022-04-22'
var reg = /^(\d{4})-(\d{2})-(\d{2})$/
console.log(str.match(reg));
// &amp;nbsp;['2022-04-22', '2022', '04', '22', index: 0, input: '2022-04-22', groups: undefined]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;replace&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;replace&lt;/strong&gt;这个api主要用于替换数据，多用于字符串的处理和转义。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var str = '贾维斯：您今天共产生了8个BUG'
var reg = /\w{3}/g
console.log(str.replace(reg,"Beautiful Code"))
// 贾维斯：您今天共产生了8个Beautiful Code
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;什么是 $1 $2&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;let str = "前端1组-开发部";
console.log(str.replace(/(.{4})-(.{3})/, "$2 $1"));
// 开发部 前端1组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;$1&lt;/strong&gt;,&lt;strong&gt;$2&lt;/strong&gt;上就是按顺序对应小括号里面的&lt;strong&gt;分组&lt;/strong&gt; 捕获到的内容。这里我们将 2组和1组进行内容替换，就得到了替换后的内容。&lt;/p&gt;
&lt;h3&gt;split&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;split&lt;/strong&gt;主要用于来切分字符串为数组，它的第一个参数也可以为正则的形式。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const str1 = '2022-04-21'
const str2 = '2022.04.22'
const str3 = '2022/04/23'
const regsSplit = /[\.\-\/]/
console.log(str1.split(regsSplit))
console.log(str2.split(regsSplit))
console.log(str3.split(regsSplit))
// ['2022', '04', '21']
// ['2022', '04', '22']
// ['2022', '04', '23']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;了解完了结合String用法，我们再来了解一下&lt;strong&gt;兼容性问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;正则表达式兼容性调研&lt;/h2&gt;
&lt;p&gt;在我们日常使用中，一定会遇到兼容性问题。这里主要对一些不完全兼容的方法进行调研。&lt;/p&gt;
&lt;h3&gt;@@split&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@@split&lt;/code&gt;  方法切割String对象为一个其子字符串的数组 。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var re = /-/g;
var str = '2022-01-02';
var result = re[Symbol.split](str);
console.log(result);  // ["2022", "01", "02"]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="5c998fd1bb7ed1f4f1edf47892b674bc.jpg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebb1364abb5d471ebefda975ba67da77~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;@@match&lt;/h3&gt;
&lt;p&gt;对正则表达式匹配字符串时，&lt;code&gt;@@match&lt;/code&gt; 方法用于获取匹配结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var re = /[0-9]+/g;
var str = '2022-01-02';
var result = re[Symbol.match](str);
console.log(result);  // ["2022", "01", "02"]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="fb392fd5814bd1a403776ff6cd3947fe.jpg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ac9f44299564576bfd06a28e5931b78~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;@@search&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@@search&lt;/code&gt; 方法执行了一个在给定字符串中的一个搜索以取得匹配正则模式的项。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var re = /-/g;
var str = '2016-01-02';
var result = re[Symbol.search](str);
console.log(result);  // 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="01a09f895f172c2492ec4c70901e20aa.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f4ec4fecf114dbc88b9eb1c4baf1f6f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;@@replace&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@@replace&lt;/code&gt; 方法会在一个字符串中用给定的替换器，替换所有符合正则模式的匹配项，并返回替换后的新字符串结果。用来替换的参数可以是一个字符串或是一个针对每次匹配的回调函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var re = /-/g; 
var str = '2016-01-01';
var newstr = re[Symbol.replace](str, '.');
console.log(newstr);  // 2016.01.01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="6529acfb1c3fd4665e0bf9ddfe2ce6b6.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ef1f3c04c554a29b6d53e0d6c93f00e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;flags&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flags&lt;/code&gt; 属性返回一个字符串，由当前正则表达式对象的标志组成。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/foo/ig.flags;   // "gi"
/bar/myu.flags;  // "muy"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="921a751282a73cda11768b842bbbd01b.jpg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7928bf17b7ab49e9a616641128bb8db6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;dotAll&lt;/h3&gt;
&lt;p&gt;正则中的点匹配就是 &lt;code&gt;dotAll&lt;/code&gt; ，都是匹配任意字符，但是很多字符是无法匹配的。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;四个字节的 &lt;code&gt;UTF-16&lt;/code&gt; 的字符&lt;/li&gt;
&lt;li&gt;行终止符 &lt;code&gt;\n&lt;/code&gt; &lt;code&gt;\r&lt;/code&gt; 换行 回车&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;console.log(/foo.bar/.test('foo\nbar'))
// false
console.log(/foo.bar/.test('fooabar'))
// true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加上 &lt;code&gt;s&lt;/code&gt; 可以匹配换行符&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;console.log(/foo.bar/s.test('foo\nbar'))
// true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="cfda85f9c82bb1c904951d7744167fb6.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d182be57ac0d4d8d97bb02f953f57699~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;最后我们让来点&lt;strong&gt;干货&lt;/strong&gt;吧&lt;/p&gt;
&lt;h2&gt;干货&lt;/h2&gt;
&lt;h3&gt;保留两位小数的价格输入框&lt;/h3&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;
// 输入限制
const changePiece = (e) =&amp;gt;{
      e.target.value = e.target.value.replace(/^\D*(\d*(?:\.\d{0,2})?).*$/g, '$1');
  }
  return (
    &amp;lt;div&amp;gt;
       &amp;lt;input type="text" onKeyUp={ (e) =&amp;gt; {changePiece(e)}} /&amp;gt; 
    &amp;lt;/div&amp;gt;
  );

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常用正则表达式&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 手机号码的校验
const phoneReg = /^[1][3,4,5,6,7,8,9][0-9]{9}$/
// 身份证的校验
const idCardReg = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/
// URL的校验
const urlReg = /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/
// 邮箱的校验
const emailReg = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/
// 日期 YYYY-MM-DD 校验
const dateReg = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上&lt;strong&gt;干货&lt;/strong&gt;大家也可以通过上文所学的知识自己尝试实现，自己实践才会有更深刻的印象和更深度的认知。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://caniuse.com/?search=RegExp"&gt;《Can I Use——正则表达式》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7016871226899431431"&gt;《有了这25个正则表达式，代码效率提高80%》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.bilibili.com/video/BV1da4y1p7iZ?spm_id_from=333.337.search-card.all.click"&gt;《10分钟快速掌握正则表达式》&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7124839474575441934"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7119639489567260686"&gt;表单数据形式配置化设计&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 16 Aug 2022 16:03:02 GMT</pubDate></item><item><title>学习 HTTP Referer</title><link>https://juejin.cn/post/7130033583284027429</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="维尼.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8583065dd4a64c1ca84f3dac99506518~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 155 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;HTTP 中 Referer 字段在工作中或许并不会吸引你的注意，隐藏在 Network 的请求之下，但是却有着非常重要的作用。平常你一定会遇到一些问题需要去排查，假如这个问题在你排查完全部代码后，依然没有解决，这个时候你会怎么办？此时我们就需要将排查问题的角度转换一下，切换到 HTTP 协议上。&lt;/p&gt;
&lt;p&gt;最近工作当中也碰到了与此相关的一些问题，借此机会也同时做个记录和总结。HTTP 协议整体包含内容非常多，本次我们只把其中的 Referer 字段拿出来和大家详细说一下。&lt;/p&gt;
&lt;h1&gt;HTTP Referer&lt;/h1&gt;
&lt;h2&gt;Referer 是什么？&lt;/h2&gt;
&lt;p&gt;HTTP Referer 是 HTTP 表头的一个字段，用来表示当前网页是来源于哪里，采用的格式是 URL。我们通过这个 HTTP Referer，可以查到访客的来源。&lt;/p&gt;
&lt;p&gt;可以通过 Network 面板看到，页面访问及资源请求的 Request Headers 请求头信息里有一个 Referer 字段，用来标记来源的 URL。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af20b28299904394973399bfbbf341a8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;有同学可能会注意到 Referer “似乎”拼写有误，应该是 “Referrer" 才对，这其实是个历史原因，在早期 HTTP 规范当中就存在的拼写错误，后面为了向下兼容，所以将错就错。&lt;/p&gt;
&lt;p&gt;拼写错误只有 Request Headers 的 “Referer”，在其他地方比如General Headers、 JavaScript 及 DOM 上，都是正确的拼写。&lt;/p&gt;
&lt;p&gt;General Headers：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f7bfd870e624641a4ac6eda7b04b4be~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;// javascript
document.referrer

// DOM
&amp;lt;a target="_blank" href="https://edu.zcygov.cn/live" referrerpolicy="no-referrer"&amp;gt;查看链接&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此大家应该对 Referer 有了一个大概的了解，那么 Referer 字段在什么条件下会展示，以及如何去控制 Referer 返回的具体内容呢？答案就在 Referrer-Policy 当中，下面就带大家详细讲一下 Referrer-Policy 策略。&lt;/p&gt;
&lt;h2&gt;Referrer-Policy 策略&lt;/h2&gt;
&lt;h3&gt;有哪些策略？&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;Referrer-Policy: no-referrer&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;顾名思义，这个策略表示不发送 Referer 信息。&lt;/p&gt;
&lt;p&gt;工作中实际使用的场景：&lt;/p&gt;
&lt;p&gt;在双品牌“乐彩云”推广中为降低双域名跳转改造成本，运维层面在Nginx添加了一个规则，若访问链接（例如 news.zcygov.cn）的 Referer 包含 lecaiyun.com 域名，则会强制将访问链接的域名变更为 lecaiyun.com ，实现链接跳转统一。&lt;/p&gt;
&lt;p&gt;若部分域名不需要走这一套逻辑，不携带 Referer 头信息，则需要指定 Referrer-Policy 策略为 no-referrer 。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/903db37bc96443b8992aa7c16c21a907~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: no-referrer-when-downgrade&lt;/h4&gt;
&lt;p&gt;如果从 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，其他情况发送（包括 HTTP 网址链接到 HTTP 网址）。&lt;/p&gt;
&lt;p&gt;此规则原先是大多数浏览器的默认策略，现在随着隐私安全性的要求变高之后，浏览器将默认规则变更成了 strict-origin-when-cross-origin。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: origin&lt;/h4&gt;
&lt;p&gt;Referer字段一律只发送源信息（协议+域名+端口），不管是否跨域。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: origin-when-cross-origin&lt;/h4&gt;
&lt;p&gt;同源时，发送完整的Referer字段，跨域时发送源信息。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: same-origin&lt;/h4&gt;
&lt;p&gt;链接到同源网址（协议+域名+端口 都相同）时发送，否则不发送。注意，https://foo.com 链接到 http://foo.com 也属于跨域，因为两者的协议不同。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: strict-origin&lt;/h4&gt;
&lt;p&gt;如果从 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，其他情况只发送源信息。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: strict-origin-when-cross-origin&lt;/h4&gt;
&lt;p&gt;同源时，发送完整的Referer字段；跨域时，如果 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，否则发送源信息。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: unsafe-url&lt;/h4&gt;
&lt;p&gt;Referer字段包含源信息、路径和查询字符串，不包含锚点、用户名和密码。&lt;/p&gt;
&lt;p&gt;针对以上策略，可以根据策略及 Referer 携带信息的完整度，可以总结成一个表格，可以按照自己的需求配置不同的策略：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;不携带任何 Referer 信息&lt;/th&gt;
&lt;th style="text-align: left;"&gt;Referer 只携带域名 Origin 信息&lt;/th&gt;
&lt;th style="text-align: left;"&gt;Referer 携带完整 URL 信息&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;no-referrer&lt;/td&gt;
&lt;td style="text-align: left;"&gt;✅&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;origin&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;✅&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;unsafe-url&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;strict-origin&lt;/td&gt;
&lt;td style="text-align: left;"&gt;从 HTTPS 请求到 HTTP 的网址时&lt;/td&gt;
&lt;td style="text-align: left;"&gt;满足以下任意条件：&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;从 HTTPS 请求到 HTTPS 网址时&lt;/li&gt;&lt;li&gt;从 HTTP 请求到 HTTP 的网址时&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;no-referrer-when-downgrade&lt;/td&gt;
&lt;td style="text-align: left;"&gt;从 HTTPS 请求到 HTTP 的网址时&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;满足以下任意条件：&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;从 HTTPS 请求到 HTTPS 网址时&lt;/li&gt;&lt;li&gt;从 HTTP 请求到 HTTP 的网址时&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;origin-when-cross-origin&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;跨域请求&lt;/td&gt;
&lt;td style="text-align: left;"&gt;同源请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;same-origin&lt;/td&gt;
&lt;td style="text-align: left;"&gt;跨域请求&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;同源请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;strict-origin-when-cross-origin&lt;/td&gt;
&lt;td style="text-align: left;"&gt;从 HTTPS 请求到 HTTP 的网址时&lt;/td&gt;
&lt;td style="text-align: left;"&gt;满足以下任意条件：&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;跨域请求&lt;/li&gt;&lt;li&gt;从 HTTPS 请求到 HTTPS 网址时&lt;/li&gt;&lt;li&gt;从 HTTP 请求到 HTTP 网址时&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;同源请求&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;浏览器默认的策略&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;浏览器&lt;/th&gt;
&lt;th style="text-align: left;"&gt;默认的策略&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Chrome&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Chrome 85 版本默认策略变更为：strict-origin-when-cross-origin&lt;br /&gt;原策略：no-referrer-when-downgrade&lt;br /&gt;&lt;br /&gt;详细可查看：&lt;a href="https://developer.chrome.com/blog/referrer-policy-new-chrome-default/"&gt;https://developer.chrome.com/blog/referrer-policy-new-chrome-default/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Firefox&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Firefox 87 版本默认策略变更为：strict-origin-when-cross-origin&lt;br /&gt;原策略：strict-origin-when-cross-origin&lt;br /&gt;&lt;br /&gt;详细可查看：&lt;a href="https://blog.mozilla.org/security/2021/03/22/firefox-87-trims-http-referrers-by-default-to-protect-user-privacy/"&gt;https://blog.mozilla.org/security/2021/03/22/firefox-87-trims-http-referrers-by-default-to-protect-user-privacy/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Edge&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Edge 88 版本默认策略变更为：strict-origin-when-cross-origin&lt;br /&gt;原策略：no-referrer-when-downgrade&lt;br /&gt;&lt;br /&gt;详细可查看：&lt;a href="https://docs.microsoft.com/zh-cn/deployedge/microsoft-edge-policies"&gt;https://docs.microsoft.com/zh-cn/deployedge/microsoft-edge-policies&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Safari&lt;/td&gt;
&lt;td style="text-align: left;"&gt;类似于 strict-origin-when-cross-origin&lt;br /&gt;&lt;br /&gt;依赖智能跟踪预防 (ITP)策略，详细可查看：&lt;a href="https://webkit.org/blog/9661/preventing-tracking-prevention-tracking/"&gt;https://webkit.org/blog/9661/preventing-tracking-prevention-tracking/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;设置 Policy 的方法&lt;/h3&gt;
&lt;p&gt;当我们需要变更 Referer 策略的时候，浏览器本身以及W3C规范都给我们提供了路径，有以下几种方式可以操作：&lt;/p&gt;
&lt;h4&gt;rel 属性&lt;/h4&gt;
&lt;p&gt;&amp;lt;a&amp;gt;、&amp;lt;area&amp;gt;标签均支持 rel 属性，最常见的就是在 &amp;lt;a&amp;gt; 标签中对单个链接设置 &lt;code&gt;rel="noreferrer"&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;&amp;lt;a href="xxx" rel="noreferrer" target="_blank"&amp;gt;新地址&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecf32aea34a34a20bd3b464fce113ede~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;设置之后，新开的网页请求头中，将不再携带来源页面的 Referer 信息。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d3159e114dd4a1b92b2f9e9fd8cc127~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;&amp;lt;meta&amp;gt; 标签&lt;/h4&gt;
&lt;p&gt;在HTML的 &amp;lt;head&amp;gt; 标签内，可以新增 &amp;lt;meta&amp;gt; 标签，设置整个网页的 Referer Policy 策略。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;&amp;lt;meta name="referrer" content="no-referrer"&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Headers 请求头&lt;/h4&gt;
&lt;p&gt;更改 HTTP 头信息中的 Referer-Policy 值即可。比如你使用的是 Nginx，则可以设置 add_headers 设置请求头。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;add_header Referrer-Policy "no-referrer";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置完请求头，最终体现在浏览器 Headers 里字段是：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;Referrer-Policy: no-referrer
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;referrerpolicy 属性&lt;/h4&gt;
&lt;p&gt;这个目前看还是实验性功能，并且在 IE 浏览器上也是完全不支持的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;&amp;lt;a href="xxx" referrerpolicy="no-referrer" target="_blank"&amp;gt;新地址&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;支持的标签：&amp;lt;a&amp;gt;、&amp;lt;area&amp;gt;、&amp;lt;img&amp;gt;、&amp;lt;iframe&amp;gt;、&amp;lt;link&amp;gt;&lt;/p&gt;
&lt;h4&gt;优先级&lt;/h4&gt;
&lt;p&gt;以上几种设置方式，有页面级和元素级，当这两者都存在时，优先级按以下方式进行生效：&lt;/p&gt;
&lt;p&gt;1、元素级政策&lt;/p&gt;
&lt;p&gt;2、页面级政策&lt;/p&gt;
&lt;p&gt;3、浏览器默认&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;&amp;lt;meta name="referrer" content="strict-origin-when-cross-origin"&amp;gt;

&amp;lt;a href="https://foo.com" rel="no-referrer" target="_blank"&amp;gt;地址一&amp;lt;/a&amp;gt;
&amp;lt;a href="https://bar.com" target="_blank"&amp;gt;地址二&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;页面中地址一，则优先按元素级策略，走 no-referrer，而页面中其他元素（包括但不限于 a 标签）则按 meta 页面级策略执行&lt;/p&gt;
&lt;h1&gt;作用及使用场景&lt;/h1&gt;
&lt;p&gt;以下列举了几个比较常见的作用及使用场景：&lt;/p&gt;
&lt;h3&gt;（1）防盗链&lt;/h3&gt;
&lt;p&gt;以 CDN 加速为例，一般都提供了防盗链配置，其内部实现原理是按照 Referer 来源来判断是否在配置的白名单或者黑名单中，来决定资源能否可被访问。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68641f37f1ef41918d2c780851924e75~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;图片来自&lt;a href="https://help.aliyun.com/document_detail/27134.html"&gt;阿里云CDN的防盗链配置&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;（2）埋点分析&lt;/h3&gt;
&lt;p&gt;埋点分析有一种情况是用于追溯用户的完整访问路径，这个时候可以依赖的就是 HTTP Referer，可以通过 Referer 来源逐步分析用户的来源网址和整体访问链路。&lt;/p&gt;
&lt;h3&gt;（3）错误排查（接口日志）&lt;/h3&gt;
&lt;p&gt;排查接口请求报错时，一般会关注日志系统，而日志系统里如果没有对于接口访问来源的字段，那么想快速精确找到接口访问的页面是比较困难的。这时候 Referer 就提供了一个比较好的帮助，可以看到接口的请求来源。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c75c68d4184927bf5370adcb2cb4cd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;（4）用户隐私保护&lt;/h3&gt;
&lt;p&gt;为什么各浏览器厂商都升级了 Policy 默认策略？&lt;/p&gt;
&lt;p&gt;目的其实是为了保护用户隐私，过于完整的 Referer 信息能够通过日志抓取到完整链路，也就意味着你的访问路径和来源是没有任何隐藏，这样可能会对隐私及网站的安全性带来一定的危害。&lt;/p&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80"&gt;HTTP来源地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ruanyifeng.com/blog/2019/06/http-referer.html"&gt;HTTP Referer 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types"&gt;链接类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.dev/referrer-best-practices/"&gt;引荐来源 (Referer) 和引荐来源政策 (Referrer-Policy) 最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7124839474575441934"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7119639489567260686"&gt;表单数据形式配置化设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7117042614313943070"&gt;如何将传统 Web 框架部署到 Serverless&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 09 Aug 2022 16:12:17 GMT</pubDate></item><item><title>浅谈低代码平台远程组件加载方案</title><link>https://juejin.cn/post/7127440050937151525</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="百里.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6240750d2ff44fe59d99bdb9766d22e7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 154 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/low-code"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;低代码开发平台（LCDP）是无需编码（0代码）或通过少量代码就可以快速生成应用程序的开发平台。通过可视化进行应用程序开发的方法，使具有不同经验水平的开发人员可以通过图形化的用户界面，使用拖拽组件和模型驱动的逻辑来创建网页和移动应用程序。这两年越来越多的公司和开发人员开始自研低代码平台来达到降本提效的目的。今天和大家分享一下低代码平台开发过程中遇的一个问题和对应的解决思路。&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;低代码平台之所以不需要写代码是因为平台提供了很多可配置的组件，让平台的用户可以通过配置的方式生成自己想要的产物。那么如果想要能配置出更多的效果，就需要保证物料库足够丰富。&lt;/p&gt;
&lt;p&gt;如果物料组件很多，就需要按需加载组件。现有的开发工具如 webpack 也支持代码分割。但是在低代码平台的开发场景中，平台应用是和组件分离的，需要用户在选择某个组件的时候，要加载远程组件代码。&lt;/p&gt;
&lt;h2&gt;加载方案&lt;/h2&gt;
&lt;h3&gt;组件代码&lt;/h3&gt;
&lt;p&gt;我们以 vue 框架为例，假如当前有一个组件 A，代码如下，如何远程加载这个组件呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-vue"&gt;&amp;lt;template&amp;gt;
    &amp;lt;div class="wp"&amp;gt;{{text}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import { defineComponent, ref } from 'vue';
import _ from 'lodash';
  
export default defineComponent({
  setup(props) {
    console.log(_.get(props, 'a'));
    return {
      onAdd,
      option,
      size,
      text: 'hello world',
    };
  },
});
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
.wp {
    color: pink;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方案一：放在全局对象上&lt;/h3&gt;
&lt;h4&gt;步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打包：组件代码打包为 umd 格式，打包时配置 webpack externals, 使打包产物不包含公共的依赖；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传：打包的组件 js 上传到 cdn；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加载：在需要使用组件时，插入一个 script ，在这个 script 中将组件放在一个全局对象上；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注册：在 script 插入完成后，从全局对象上获取组件，并进行注册；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;组件打包&lt;/h4&gt;
&lt;p&gt;首先需要增加一个入口文件&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;import Component from './index.vue';

if(!window.share) {
  window.share = {};
}

window.share[Component.name] = Component;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上面的入口文件为入口，用 webpack 打包为 umd 格式&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// 组件打包 webpack 配置
const path = require('path');
const { VueLoaderPlugin } = require('vue-loader')

module.exports = {
  mode: 'production',
  entry: path.resolve(__dirname, './comps/index.js'),
  output: {
    filename: 'index.js',
    path: path.resolve(__dirname, 'dist'),
    library: { type: 'umd' }
  },
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: 'vue-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.js$/,
        loader: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [
          'vue-style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new VueLoaderPlugin()
  ],
  externals: {
    vue: 'vue',
    lodash: 'lodash',
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;html 模板&lt;/h4&gt;
&lt;p&gt;组件公共依赖都需要先加入到模板 html 中&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang="en"&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&amp;gt;
    &amp;lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;script src="https://cdn/vue.global.js"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src="https://cdn/lodash@4.17.21.min.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id="root"&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;组件加载逻辑&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;const loadComponent = (name) =&amp;gt; new Promise((resolve) =&amp;gt; {
  const script = document.createElement('script');
  script.src=`http://xxx/${name}.js`;
  script.onload = script.onreadystatechange = function(){
     resolve();
  };
  document.querySelector('head').appendChild(script);
})

const addComp = async (name) =&amp;gt; {
  await loadComponent(name);
  // 注册组件，其中 app 为 Vue 应用实例对象
  app.component(name, window.share[name]);
}

// 动态注册组件
addComp('A');


&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;组件的依赖共享，需要依赖提前先放到全局，html 模板需要较频繁改动；&lt;/li&gt;
&lt;li&gt;全局对象上要挂载的内容越来越多，影响加载性能，没有做到真正的按需加载；&lt;/li&gt;
&lt;li&gt;依赖版本难以管理。如 A 组件依赖了 loadsh 1.0， 而 B 组件依赖了 lodash 2.0，但是全局对象上的 lodash,同时挂载两个版本就必然会有冲突，因此版本必须一致；且后续如果某个组件要升级某个依赖的版本，也势必会影响所以其他组件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;方案二：amd&lt;/h3&gt;
&lt;p&gt;amd 格式也是一种模块化方案，这里我们选择知名度比较高的 require.js 作为 amd 模块加载器。&lt;/p&gt;
&lt;h4&gt;步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;打包：组件代码打包为 umd 或 amd 格式，打包时配置 webpack externals，使打包产物不包含公共的依赖；&lt;/li&gt;
&lt;li&gt;上传：打包的组件 js 上传到 cdn；&lt;/li&gt;
&lt;li&gt;加载&amp;amp;注册：在需要使用组件时，用 requirejs 获取组件，并进行注册。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;组件打包&lt;/h4&gt;
&lt;p&gt;用 amd 格式来做远程加载时不需要像方案一一样，增加额外的入口文件，可以直接将 .vue 文件作为入口。以下是 webpack 打包配置示例&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// 组件打包 webpack 配置
const path = require('path');
const { VueLoaderPlugin } = require('vue-loader')

module.exports = {
  mode: 'production',
  entry: path.resolve(__dirname, './comps/index.vue'),
  output: {
    filename: 'index.js',
    path: path.resolve(__dirname, 'dist'),
    library: { type: 'umd' }  // 输出 amd 或者 umd
  },
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: 'vue-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.js$/,
        loader: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [
          'vue-style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new VueLoaderPlugin()
  ],
  externals: {
    vue: 'vue',
    lodash: 'lodash',
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;html 模板&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang="en"&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&amp;gt;
    &amp;lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;script src="./require.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id="app"&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;组件加载逻辑&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// main.js
requirejs.config({
  baseUrl: 'https://cdn.xxx.com',
  map: {
    '*': {
      css: 'require-css',
    },
  },
  paths: {
    echarts: 'echarts@5.1.1',
    vueDemo: 'vue-demo',
    vue: 'vue@3.2.37',
    moment: 'https://cdn/moment@2.29.1.min',
  },
  shim: {
    'ant-design-vue': ['css!https://cdn/ant-design-vue@2.1.6.min.css'],
  },
});

requirejs(['vue', 'vue-demo', 'vue-app'], function (vue, vueDemoModule, VueAppModule) {
  const app = Vue.createApp(VueAppModule.default);
  app.component('vue-demo', vueDemoModule.default);
  const vm = app.mount('#app');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;平台代码（上述代码的&lt;code&gt;vue-app&lt;/code&gt;）也需要编译为 amd 格式，然后上传到 cdn 上，开发流程改变，需要定制化的开发平台项目的发布机制。&lt;/li&gt;
&lt;li&gt;有些第三方库没有提供 amd 或 umd 格式，需要开发者自己开发工具去转换（此过程中可能有很多坑要踩）；&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;优点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;相比于方案一，组件的依赖可以有版本差异且互相不影响。&lt;/li&gt;
&lt;li&gt;组件和组件的依赖都可以按需加载，真正做到按需加载。&lt;/li&gt;
&lt;li&gt;有现成的加载 css 文件的机制；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;方案三：ESModule&lt;/h3&gt;
&lt;h4&gt;步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;打包：组件代码打包为 esm 格式，打包时配置webpack externals, 使打包产物不包含公共的依赖；&lt;/li&gt;
&lt;li&gt;上传：打包的组件 js 上传到 cdn；&lt;/li&gt;
&lt;li&gt;加载&amp;amp;注册：在需要使用组件时，用 esm 的动态引入获取组件，并进行注册；&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;组件打包&lt;/h4&gt;
&lt;p&gt;这里需要注意的是，externals 配置项中直接把公共依赖配置为 cdn 地址；&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;import path from 'path';
import VueLoader from 'vue-loader';

const VueLoaderPlugin = VueLoader.VueLoaderPlugin;

const __dirname = path.resolve();

export default {
  mode: 'development',
  entry: path.resolve(__dirname, './src/vue-demo.vue'),
  output: {
    filename: 'vue-demo.esm.js',
    path: path.resolve(__dirname, 'components'),
    library: { type: 'module' }
  },
  experiments: { outputModule: true },
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: 'vue-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.js$/,
        loader: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [
          'vue-style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new VueLoaderPlugin()
  ],
  externals: {
    vue: 'https://cdn.jsdelivr.net/npm/vue@3.2.37/dist/vue.esm-browser.js',
    'lodash': 'https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.js'
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用上述配置打包后产物，中会把 &lt;code&gt;'vue'&lt;/code&gt; 替换为 externals 中的 cdn 地址&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// 输入
import Vue from 'vue';

// 输出结果
import Vue from 'https://cdn.jsdelivr.net/npm/vue@3.2.37/dist/vue.esm-browser.js';
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;组件加载逻辑&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;const list = ref([]);

const addComp = async () =&amp;gt; {
  const VueDemo = await import(/* @vite-ignore */`http://cdn/components/vue-demo.esm.js`)
  window.app.component('vue-demo', VueDemo.default);
  list.value.push({ key: new Date().valueOf(), name: 'vue-demo' });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;vite 配置&lt;/h4&gt;
&lt;p&gt;需要注意的是要保证本地开发时引入的 &lt;code&gt;vue&lt;/code&gt; 也是远程的，所以需要在 vite 的配置文件中增加 alias 配置。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      'vue': 'https://cdn.jsdelivr.net/npm/vue@3.2.37/dist/vue.esm-browser.js'
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;兼容性问题：很多 Webpack 已经支持很好的功能还没有得到主流浏览器的支持&lt;/li&gt;
&lt;li&gt;对很多第三方依赖的转化处理不完善，缺失完善的解决机制。要将第三方依赖的加载全部交给浏览器本身来接管，那么首先开发工具要做的就是将第三方依赖全部转换为 ESModule 的模块，而现在 npm 上的绝大部分包都是只支持 CommonJS 版本的，因此这里的转换过程通常需要由开发者自己来接管，而这其中有很多底层的问题并没有得到好的解决。同时，在 ESModule 规范推进的过程中，有许多如&lt;code&gt;exports.default&lt;/code&gt;、&lt;code&gt;exports.__esModule&lt;/code&gt;等利用语法来兼容 ESModule 和 CommonJS 的废案往往也都被 babel 实现，而且被许多开发者使用并且发布到了 npm 上，这就导致了现在 npm 上的许多包中有大量的废弃兼容性代码，而这些代码往往会对开发工具的转化造成阻碍。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;优点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;真正的按需加载&lt;/li&gt;
&lt;li&gt;代码上更加优雅&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;关于 webpack 模块联邦&lt;/h3&gt;
&lt;p&gt;基于笔者对模块联邦的了解，笔者认为 Webpack 的模块联邦，目前更加适合微前端的场景，但是不太适用于低代码平台的场景。但是笔者对 webpack 模块联邦了解不够深入，判断不一定准确，欢迎有不同意见的小伙伴在评论区讨论。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;对比上面三个方案，方案一实现起来最简单，但是没有真正实现按需加载，随着项目规模和需要满足的业务场景的扩大，组件的公共依赖会越来越多。方案二 、方案三 都能实现真正的按需加载，其中 require.js 虽然听上去已经是上个世纪的东西了，但是兼容性和坑相对比较少。说到 ESModule， 虽然有兼容性和上面提到的一些格式转化的问题，但随着近些年 Vite 、Snowpack 的发展，在未来 ESModule 一定是大势所趋，目前笔者也正在将负责的我司内部大屏低代码平台改造为 ESModule 方式加载。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.requirejs-cn.cn/"&gt;requirejs 中文文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/0AHmP70HnLUZeJWQlRtUKw"&gt;ESModule 系列 ㈠ ：演进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/lihefei_coder/article/details/81333036"&gt;Require.js加载css依赖&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7124839474575441934"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7119639489567260686"&gt;表单数据形式配置化设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7117042614313943070"&gt;如何将传统 Web 框架部署到 Serverless&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7114450860335169543"&gt;浅谈前端埋点 &amp;amp; 监控&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 02 Aug 2022 16:28:24 GMT</pubDate></item><item><title>政采云 2023 届前端校招提前批来了！！！🎉</title><link>https://juejin.cn/post/7126788456864284709</link><description>&lt;h3&gt;岗位介绍&lt;/h3&gt;
&lt;p&gt;开发-前端&lt;/p&gt;
&lt;h3&gt;面向人群&lt;/h3&gt;
&lt;p&gt;毕业时间在 &lt;strong&gt;2022 年 11 月 - 2023 年 10 月&lt;/strong&gt;的海内外院校应届毕业生&lt;/p&gt;
&lt;h3&gt;工作地点&lt;/h3&gt;
&lt;p&gt;杭州&lt;/p&gt;
&lt;h3&gt;时间起止&lt;/h3&gt;
&lt;p&gt;开始时间：2022 年 8 月 1 日&lt;/p&gt;
&lt;p&gt;截止时间：2022 年 9 月 1 日&lt;/p&gt;
&lt;h3&gt;投递方式&lt;/h3&gt;
&lt;p&gt;扫描下方二维码，投递简历&lt;/p&gt;
&lt;p&gt;&lt;img alt="8256C0A1-D44C-4EE4-9459-5393FA9D8CF9.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5a78136b0e64cac80de563bca6e03de~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;团队介绍&lt;/h3&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。等你扫描下方的二维码。&lt;/p&gt;
&lt;h3&gt;更多问题&lt;/h3&gt;
&lt;p&gt;关于招聘，如果有更多问题，欢迎关注【政采云前端团队】公众号并回复 &lt;strong&gt;交流群&lt;/strong&gt; 获取入群二维码，咨询猴子或其他团队成员了解更多政采云前端团队详情和招聘资讯✌️！&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Sun, 31 Jul 2022 22:19:30 GMT</pubDate></item><item><title>前端富文本基础及实现</title><link>https://juejin.cn/post/7124839474575441934</link><description>&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4eb6a01e6564840817b127265b07edd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="页航.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b0e82e8fb4d4c46ab9360fe96b91c44~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 153 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/rich-text"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在日常生活中我们会经常接触到各种各样的文档格式和形式，其中富文本在文档格式中扮演了重要角色。对于前端而言，富文本产品也层出不穷，其应用也越来越广。&lt;/p&gt;
&lt;p&gt;这篇文章将会为大家介绍前端富文本的一些基础知识以及简单的实现思路。&lt;/p&gt;
&lt;h2&gt;什么是富文本&lt;/h2&gt;
&lt;p&gt;纯文本就是用纯文字编辑器编写，输入什么就是什么的文档，只包含字符。&lt;/p&gt;
&lt;p&gt;富文本对应的是富文本格式（Rich Text Format），即 RTF 格式，又称多文本格式，是由微软公司开发的跨平台文档格式。除字符外还有丰富的样式。doc，docx，rtf，pdf 等都是富文本格式的文件类型。&lt;/p&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (1).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40601a6b7f24488b9f438485655b5503~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;前端中的富文本&lt;/h2&gt;
&lt;p&gt;前端富文本通过 html 的各个元素配合各种样式（一般是内联样式）实现。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (3).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/343f0e7cd7f94cd3adb5babf66951b19~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;富文本编辑器中的富文本，是由红色框中带有语义化标签和内联样式的 html 渲染实现的。通过富文本编辑器，即可实现富文本的编写、展示。&lt;/p&gt;
&lt;p&gt;目前常见的前端富文本编辑器有 tinymce，UEeditor，draft 等。&lt;/p&gt;
&lt;p&gt;文章下文将会讲述实现前端富文本编辑器的一些基础知识和步骤。&lt;/p&gt;
&lt;h2&gt;富文本输入模式实现&lt;/h2&gt;
&lt;p&gt;实现前端富文本编辑器首先要实现文本输入，一般常用两种方式实现。&lt;/p&gt;
&lt;h3&gt;iframe&lt;/h3&gt;
&lt;p&gt;第一种方式是使用 iframe 标签。&lt;/p&gt;
&lt;p&gt;在空白的 HTML 文档中嵌入一个 iframe，并将 designMode 属性设置为 on，文档就会变成可编辑的，实际编辑的则是 iframe 内的 body 元素。文档变成可编辑后，就可以像使用文字处理程序一样编辑文本。&lt;/p&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="QQ20220722-172729.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24586e6aa44f4099881c019b292d50eb~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;元素设置 contenteditable&lt;/h3&gt;
&lt;p&gt;第二种方式是使用 contenteditable 属性指定 HTML 文档中的元素。该方式是 IE 最早实现的。使用方式是在一个元素上添加 contenteditable 属性并设置为 true，然后该元素会立即被用户编辑。&lt;/p&gt;
&lt;p&gt;此种方式通常会和 autocapitalize（首字母自动大写属性）、spellcheck（检查元素的拼写错误，实验功能）等属性共同使用以提升体验。&lt;/p&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="QQ20220722-171453.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a19813363e5c43d08220e3c24f3f75e8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;两者特点&lt;/h3&gt;
&lt;p&gt;两种方式都可以实现编辑模式，并且这种编辑模式与 textarea 不同，其内部会用块级元素（默认为 div 元素）做换行处理，最终体现在 dom 结构中。&lt;/p&gt;
&lt;p&gt;两者不同的是：iframe 方式可做到样式隔离，内部样式与外部样式不存在污染与冲突（ tinymce 实现方式）；元素设置 contentEditable 的方式（ wangEditor 等实现方式）则和其他元素一样受到页面 css 作用。个人认为两者没有优劣之分，开发者根据自身需求选择即可。&lt;/p&gt;
&lt;h2&gt;富文件选区&lt;/h2&gt;
&lt;p&gt;富文本编辑中我们在进行编辑时首先会先选择一块文本区域（即选区），比如选择一段文字并进行字体加粗等操作，那么选区本身包含了哪些信息呢，下面为大家简单介绍一下。&lt;/p&gt;
&lt;p&gt;Selection 对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区，可能横跨多个元素。文本选区由用户拖拽鼠标经过文字而产生。调用  &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getSelection"&gt;window.getSelection()&lt;/a&gt; 可得到此对象，其内部常用属性如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;anchorNode&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回选中区域对应的节点
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;anchorOffset&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回选中区域的起始下标，需要注意起始下标会根据左右方向选择的次序不同来展示不同的下标。如果 anchorNode 是字符串则对应文字下标，anchorNode 是元素，则对应选中区域对应它之前的同级节点的数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;focusNode&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回选中区域终点所在的节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;focusOffset&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与 anchorOffset 类似，如果是 focusNode 是字符串，则对应最后一个选中的字符所在的位置，focusOffset 是元素，则对应选中区域对应同级节点的总数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rangeCount&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回选中的区域所对应的连续的范围内的数量。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回选中区域所对应的类别是连续( Range )，还是同一个位置的( Caret )。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们常通过 anchorNode 与 anchorOffset 属性判断选区起始位置，通过 focusNode 与 focusOffset 属性判断选区终止位置。&lt;/p&gt;
&lt;h3&gt;选区示例&lt;/h3&gt;
&lt;p&gt;如图：anchorNode 为选区起始位置所在节点("政采云"文本节点)，focusNode 为选区结束位置所在节点("ZOO"文本节点)，anchorOffset 与 focusOffset 分别为起始位置的 index，通过此信息可得到选区范围，此时 Selection 对象 type 为 Range 。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (4).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b58237b063924f2f9473b20c24eeb865~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;光标示例（起始位置是同一个位置的选区）&lt;/h3&gt;
&lt;p&gt;如图：anchorNode 与 focusNode 为同一节点("ZOO"文本节点)，anchorOffset 与 focusOffset 指向节点同一处，通过此信息可得到光标位置，此时 Selection 对象 type 为 Caret 。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (5).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a61ef2f6715143e7815e0cdd514cf6b6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;用途&lt;/h3&gt;
&lt;h4&gt;删除、替换选区内容&amp;amp;插入操作&lt;/h4&gt;
&lt;p&gt;Selection 对象有 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection/deleteFromDocument"&gt;deleteFromDocument&lt;/a&gt; 方法，可以在编辑区域删除选区内容。如想删除后插入，可获取新的 Selection 对象，利用此时位置所在 dom 元素的方法插入对应的文字、元素。&lt;/p&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="QQ20220722-175519.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/475bcde68fd54fb5b95fee3ef75ba825~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;插入逻辑代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;  const insert = () =&amp;gt; {
    // 删除所选内容
    window.getSelection().deleteFromDocument()
    const selection = window.getSelection()
    // 删除后选取的起始位置就是插入位置，由 anchorNode 及 anchorOffset 确定
    const { anchorNode, anchorOffset } = selection
    // anchorNode 分为两种情况，一种是文本节点，另一种是其他类型节点，处理逻辑不同
    if (anchorNode.nodeType === 3) {
      const string = anchorNode.nodeValue
      // anchorNode 为文本节点时，需要将内部字符串与索要插入的内容拼接
      anchorNode.nodeValue = (string.substring(0, anchorOffset) + '😄' + string.substring(anchorOffset, Infinity))
    } else {
      const newNode = document.createElement('span')
      newNode.innerText = '😄'
      // anchorNode 为其他类型节点时，需要根据 anchorOffset 在 anchorNode 中插入片元素
      anchorNode.insertBefore(newNode, anchorNode.childNodes[anchorOffset])
    }
  }
  
  //也可根据 Selection 提供的原生方法实现
  const insert2 = () =&amp;gt; {
    lastRange = window.getSelection().getRangeAt(0);
    const newNode = document.createElement('span');
    newNode.textContent = '😄'
    lastRange.deleteContents()
    lastRange.insertNode(newNode)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于选区的更多用途，可参考选区属性和方法进行灵活实现：&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection#methods"&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Selection#methods&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;富文本工具栏实现&lt;/h2&gt;
&lt;p&gt;根据前文介绍的方法实现输入功能后，我们即实现了纯文本编辑的功能，那么如何进一步实现富文本编辑呢？&lt;/p&gt;
&lt;p&gt;document 提供了 execCommand() 方法，该方法会影响使用 designMode 或contentEditable 属性实现可编辑区域的元素。方法说明如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;document.execCommand(*aCommandName*, *aShowDefaultUI*, *aValueArgument*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;aCommandName&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个 &lt;a href="https://developer.mozilla.org/zh-CN/docs/conflicting/Web/JavaScript/Reference/Global_Objects/String_6fa58bba0570d663099f0ae7ae8883ab"&gt;DOMString&lt;/a&gt; ，命令的名称。可用命令列表请参阅 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand#%E5%91%BD%E4%BB%A4"&gt;命令&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;aShowDefaultUI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"&gt;Boolean&lt;/a&gt;， 是否展示用户界面，一般为 false。Mozilla 没有实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;aValueArgument&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一些命令（例如 insertImage）需要额外的参数（insertImage 需要提供插入 image 的 url），默认为 null。&lt;/p&gt;
&lt;p&gt;该方法执行后，会返回 boolean 值，如果是 false，表示操作不被支持或未被启用。&lt;/p&gt;
&lt;p&gt;不同浏览器支持的命令也不一样。下标列出了最常用的命令。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;可选值&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;backColor&lt;/td&gt;
&lt;td style="text-align: left;"&gt;设置文档背景颜色。在styleWithCss模式下，则只影响容器元素的背景颜色。&lt;/td&gt;
&lt;td style="text-align: left;"&gt;颜色值字符串（IE使用这个命令设置文本背景色）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;bold&lt;/td&gt;
&lt;td style="text-align: left;"&gt;切换选中文本的粗体样式&lt;/td&gt;
&lt;td style="text-align: left;"&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;createLink&lt;/td&gt;
&lt;td style="text-align: left;"&gt;将选中内容转换为指向给定URL的链接&lt;/td&gt;
&lt;td style="text-align: left;"&gt;URL链接值，至少包含一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;fontSize&lt;/td&gt;
&lt;td style="text-align: left;"&gt;将选中文本改为指定字体大小&lt;/td&gt;
&lt;td style="text-align: left;"&gt;提供HTML字体尺寸(1-7)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;foreColor&lt;/td&gt;
&lt;td style="text-align: left;"&gt;将选中文本改为指定颜色&lt;/td&gt;
&lt;td style="text-align: left;"&gt;颜色值字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;formatBlock&lt;/td&gt;
&lt;td style="text-align: left;"&gt;将选中文本包含在指定的HTML标签中&lt;/td&gt;
&lt;td style="text-align: left;"&gt;提供HTML标签，如&lt;h1&gt;&lt;/h1&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;insertImage&lt;/td&gt;
&lt;td style="text-align: left;"&gt;在光标位置插入图片&lt;/td&gt;
&lt;td style="text-align: left;"&gt;图片的URL链接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;insertParagraph&lt;/td&gt;
&lt;td style="text-align: left;"&gt;在光标位置插入&lt;p&gt;元素&lt;/p&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;italic&lt;/td&gt;
&lt;td style="text-align: left;"&gt;切换选中文本的斜体样式&lt;/td&gt;
&lt;td style="text-align: left;"&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;styleWithCSS&lt;/td&gt;
&lt;td style="text-align: left;"&gt;用这个取代useCSS命令。切换使用HTML tags还是CSS来生成标记。&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Boolean值，false使用CSS，true使用HTML&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关于 document.exexCommand 的更多命令，可参考 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand"&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;常用功能（字体样式、插入图片）演示&lt;/h3&gt;
&lt;p&gt;下图挑选了几个常用命令(加粗、斜体、改变字体颜色、插入图片)作为演示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="QQ20220723-184134.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00b6d7e5db5f4ee0aeacb18e36ffe60b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;代码示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;  // 加粗
  const bold = (val) =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('Bold', false, val)
  }
  // 斜体
  const italic = (val) =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('italic', false, val)
  }
  // 改变字体颜色
  const changeColor = (val = '#ff0000') =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('foreColor', false, val)
  }
  // 插入图片
  const insertImage = (val = 'https://avatar-static.segmentfault.com/339/131/3391311562-5d5653daaad5f_huge256') =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('insertImage', false, val)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;富文本数据收集存储与回填&lt;/h2&gt;
&lt;p&gt;富文本容器的 innerHTML 即是富文本数据。&lt;/p&gt;
&lt;p&gt;编辑区域可通过获取编辑元素的 innerHTML拿到对应富文本数据，存入数据库。&lt;/p&gt;
&lt;p&gt;网络请求的富文本数据设置为富文本容器的 innerHTML，即可展示富文本内容。&lt;/p&gt;
&lt;p&gt;下列图片可简单表明：&lt;/p&gt;
&lt;p&gt;&lt;img alt="QQ20220723-183242.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cbdb9442eda4a2eb07bafe7ec8eaa3a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;结尾（附Demo）&lt;/h2&gt;
&lt;p&gt;根据本文介绍内容我们依次了解了前端富文本的概念、输入模式实现、选区的信息及应用、富文本工具栏的实现和富文本数据收集回填。将这些内容汇总即可实现一个简单的前端富文本编辑器。&lt;/p&gt;
&lt;p&gt;下方附上本文内容汇总的代码 demo ，内含基于 iframe 和 div 元素分别实现的富文本编辑器，功能简单，供读者参考。读者可根据文章内容进行拓展实现自己的前端富文本编辑器。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;html lang="en"&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset="UTF-8"&amp;gt;
  &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&amp;gt;
  &amp;lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;style&amp;gt;
  .rt-container {
    height: 200px;
    width: 500px;
    padding: 10px;
    overflow: auto;
  }
&amp;lt;/style&amp;gt;

&amp;lt;body&amp;gt;
  --------------------------------------------------------------&amp;lt;br /&amp;gt;
  &amp;lt;button onclick="bold()"&amp;gt;粗体&amp;lt;/button&amp;gt;
  &amp;lt;button onclick="italic()"&amp;gt;斜体&amp;lt;/button&amp;gt;
  &amp;lt;button onclick="changeColor()"&amp;gt;改变颜色&amp;lt;/button&amp;gt;
  &amp;lt;button onclick="insertImage()"&amp;gt;插入图片&amp;lt;/button&amp;gt;
  &amp;lt;button onclick="insert()"&amp;gt;插入字符(表情)&amp;lt;/button&amp;gt;&amp;lt;br /&amp;gt;
  元素设置contenteditable&amp;lt;br /&amp;gt;
  --------------------------------------------------------------&amp;lt;br /&amp;gt;
  // 元素设置 contenteditable 方式
  &amp;lt;div class="rt-container" contenteditable="true"&amp;gt;政采云前端团队&amp;lt;/div&amp;gt;
  ------------------------------------------------------------------&amp;lt;br /&amp;gt;

  &amp;lt;button onclick="boldIframe()"&amp;gt;iframe粗体&amp;lt;/button&amp;gt;&amp;lt;br /&amp;gt;
  iframe设置designMode&amp;lt;br /&amp;gt;
  // iframe 设置 designMode 方式
  &amp;lt;iframe class="rt-container" name="editor"&amp;gt;&amp;lt;/iframe&amp;gt;&amp;lt;br /&amp;gt;

  ------------------------------------------------------------------
  &amp;lt;div&amp;gt;政采云&amp;lt;span&amp;gt;前端&amp;lt;/span&amp;gt;团队&amp;lt;img src="https://avatar-static.segmentfault.com/339/131/3391311562-5d5653daaad5f_huge256"
      width="32" height="32"&amp;gt;
    &amp;lt;div&amp;gt;ZOO&amp;lt;/div&amp;gt;TEAM
  &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
  window.addEventListener("load", () =&amp;gt; {
    frames["editor"].document.designMode = "on";
  });
  const bold = (val) =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('Bold', false, val)
  }
  const italic = (val) =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('italic', false, val)
  }
  const changeColor = (val = '#ff0000') =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('foreColor', false, val)
  }
  const insertImage = (val = 'https://avatar-static.segmentfault.com/339/131/3391311562-5d5653daaad5f_huge256') =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('insertImage', false, val)
  }

  const boldIframe = (val) =&amp;gt; {
    frames["editor"].document.execCommand('StyleWithCSS', true, true)
    frames["editor"].document.execCommand('Bold', false, val)
  }
  const insert = () =&amp;gt; {
    window.getSelection().deleteFromDocument()
    const selection = window.getSelection()
    const { anchorNode, anchorOffset } = selection
    if (anchorNode.nodeType === 3) {
      const string = anchorNode.nodeValue
      anchorNode.nodeValue = (string.substring(0, anchorOffset) + '😄' + string.substring(anchorOffset, Infinity))
    } else {
      const newNode = document.createElement('span')
      newNode.innerText = '😄'
      anchorNode.insertBefore(newNode, anchorNode.childNodes[anchorOffset])
    }
  }
  const insert2 = () =&amp;gt; {
    lastRange = window.getSelection().getRangeAt(0);
    const newNode = document.createElement('span');
    newNode.textContent = '😄'
    lastRange.deleteContents()
    lastRange.insertNode(newNode)
  }
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (6).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/115dadd7cf8a464089b39b4e205d98db~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7119639489567260686"&gt;表单数据形式配置化设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7117042614313943070"&gt;如何将传统 Web 框架部署到 Serverless&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7114450860335169543"&gt;浅谈前端埋点 &amp;amp; 监控&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7111848825232293918"&gt;如何让 x == 1 &amp;amp;&amp;amp; x == 2 &amp;amp;&amp;amp; x == 3 等式成立&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 26 Jul 2022 16:17:49 GMT</pubDate></item><item><title>可视化搭建系统之数据源</title><link>https://juejin.cn/post/7122240814108901406</link><description>&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4eb6a01e6564840817b127265b07edd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="明昼.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bb672bfce5b469b808e29c436ce5dcc~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 152 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/visual-construction"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;接上一篇文章&lt;a href="https://juejin.cn/post/6844903950508883982#heading-21"&gt;《前端工程实践之可视化搭建系统（一）》&lt;/a&gt;，鸽了比较久，看过的同学应该也都已经不记得了，也是又看到两年前文章下热评一位同学问的问题，两年后我们换个形式来讨论下这个问题(手动艾特水白泉同学)。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84779318c9014bb29eaf388856f33196~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;众所周知，可视化搭建系统是为了提效，从纯人工撸代码开发需求到拖拖拽拽完成业务需求，大大提高了效率，降低了开发同学的压力。我司可视化搭建系统鲁班也已投入使用两年有余，取得的效果也十分显著，但由于时间的推移，问题也逐渐暴露出来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;大量的页面使用相同组件，运营同学经常需要重复配置一个组件，导致每天要花费了大量的时间去维护页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件中耦合大量的特殊业务接口，导致组件复用性以及扩展性极差。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何帮助运营同学提效？如何提高组件复用性同时并降低组件业务耦合度？这就是我们今天要聊的主题，可视化搭建系统中的数据源。&lt;/p&gt;
&lt;h1&gt;数据源是什么&lt;/h1&gt;
&lt;p&gt;从字面上来看，其实就是数据的来源，告诉应用所需要的数据在什么位置。数据源保证了应用程序与目标数据之间交互的规范和协议，它可以是数据库，也可以是 Excel 等等。&lt;/p&gt;
&lt;h1&gt;产品设计&lt;/h1&gt;
&lt;p&gt;上文介绍了什么是数据源以及在当前搭建系统中我们遇到的问题，下面我们就从需求入手，先充当起产品的角色，针对需求我们先做问题分析，然后我们再做详细设计。&lt;/p&gt;
&lt;h4&gt;问题1：大量的页面使用相同组件，运营同学经常需要重复配置一个组件，导致每天要花费了大量的时间去维护页面&lt;/h4&gt;
&lt;p&gt;分析：组件中的重复配置，其中以营销场景以及前台大厅为主，这两块承载了我司大量的业务场景，其中各个组件的配置复杂且配置项繁多，其中又会出现针对不同的区划做不同的数据项配置，一旦差异化配置过多，重复配置会不断变多，维护起来会非常困难。&lt;/p&gt;
&lt;p&gt;设计：从组件配置入手，正常业务开发中我们使用接口传参来获取差异化的数据，来做动态数据展示以及控制各项配置的开关。可视化搭建中控制配置项的开关我们已经有了，缺的是不是就是一个接口，我们能不能让组件中的配置也变成一个接口，这样即使组件数据出现差异性，我们也可以通过入参的不同来下发不同的数据来决定组件应该展示什么数据。&lt;/p&gt;
&lt;h4&gt;问题2：组件中耦合大量的特殊业务接口，导致组件复用性以及扩展性极差&lt;/h4&gt;
&lt;p&gt;分析：组件由各业务团队同学自行开发贡献，开发水平不一导致组件设计不同，有的同学喜欢把接口抽离成组件配置，有的同学又喜欢把接口直接写在组件内部，两者都有优缺点我们不做评价，时间久了，使用前者的组件使用难度会很高，一旦维护的同学离职，组件直接就变黑盒了，使用后者的不然，除了当时服务过的需求可以使用这个组件，其他即使视觉层面一致的需求，也由于组件内部耦合的特殊业务接口，让其他业务团队宁愿重新开发也不敢在用这个组件。两者最终得到的结果其实都是一样的，组件复用性降低。&lt;/p&gt;
&lt;p&gt;设计：如何提高组件复用性，从上述问题点接口入手，如果我们将可以将接口外置，动态与组件配置对接，也就是组件既可以使用外部接口做配置，也可以使用自己的静态配置，是不是就可以解决上述问题。&lt;/p&gt;
&lt;p&gt;下面是根据上述需求分析设计，产出的 PRD 简版脉络：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组件管理侧新增数据源维护入口（以组件为维度，可以绑定多个数据源-接口或 EXCEL 等数据 ）
&lt;ul&gt;
&lt;li&gt;新增、编辑、详情、删除（数据源信息维护 ）&lt;/li&gt;
&lt;li&gt;数据源使用页面（可查看当前数据源被哪些页面所使用 ）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;新增数据源管理菜单（全局数据源概览 ）
&lt;ul&gt;
&lt;li&gt;查询、复制（跨组件复制数据源，查看所有数据源与组件关系）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;搭建页（页面搭建以及配置侧）&lt;/li&gt;
&lt;li&gt;配置面板-新增数据源配置项（展示组件关联的所有数据源，无关联数据源不展示）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;数据源实现&lt;/h1&gt;
&lt;p&gt;下面我们根据上述 PRD 脉络来看数据源的详细设计。&lt;/p&gt;
&lt;h2&gt;数据源创建&lt;/h2&gt;
&lt;p&gt;前面有提到，数据源我们可以使用接口，业务侧有后端同学，不用多想，数据源直接用后端同学写的接口就完事了，但是我们的搭建平台大多用户为运营同学，业务场景基本上都无后端同学投入，这个时候问题就来了：&lt;/p&gt;
&lt;p&gt;如何不用开发同学介入创造一个接口来跟组件做绑定呢？我们继续往下看。&lt;/p&gt;
&lt;p&gt;基于内部系统神笔，我们解决了这个问题，神笔是什么，神笔是个数据投放接口管理平台，可以让不懂代码的业务一样可以写接口。神笔中有静态化这么一个定义：&lt;/p&gt;
&lt;p&gt;**静态化：**即从0到1创建一个接口，接口入参以及出参支持自由定义，数据纯静态，可以自定义高级规则来根据入参不同返回不同的数据。&lt;/p&gt;
&lt;p&gt;哎，这不就是我们想要的嘛。使用神笔静态化，业务同学可以基于自己的需求，创造自己的接口来下发不同的数据，自给自足，妈妈再也不用担心我不会写接口啦。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19ad5a90ed3444f0abeffcadc968d44d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;数据源关联&lt;/h2&gt;
&lt;p&gt;进入组件管理，选择需要关联的组件，点击数据源维护。由于组件业务属性不同，对应的数据源也会存在差异性，为了避免运营同学配置数据源时，出现选择困难症，我们以组件维度关联数据源，一个组件可以关联多个数据源，搭配数据源描述，让运营同学可以最快选到需要的数据源。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (1).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a33257a2970d4f37869f349a2a465dcb~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (2).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ad32120691f4624a08406a6f4719814~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;新增数据源，目前我们使用最多的数据源多为 API 类型，也就是我们每天都在浏览器里看到的接口，在新增弹窗内输入我们已有的接口或者神笔注册的接口信息，配置好接口地址，请求方式，请求头，请求参数，以及最重要的接口出参字段与组件数据字段之前的映射关系，输入完成后就完成了数据源与组件的关联。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (3).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/015c14a74b6a4e7c94444869b6f45315~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;维护接口与组件内部暴露字段的映射关系，输入框会自动检测映射关系是否正确。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d7c25dc42d64c5c809587e9022567de~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;数据源使用&lt;/h2&gt;
&lt;p&gt;进入我们需要搭建的页面，选择我们已绑定数据源的组件，右侧配置面板选择我们绑定的数据源，保存页面配置，即可完成在页面组件中使用数据源。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (4).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cdb54618df34ee79e9da8b927450277~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;数据源管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查看数据源使用页面&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可查看已绑定的数据源被多少页面使用，方便后续接口维护评估影响面以及进行数据分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="image (5).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d6bf37b8b644b01bebcb1e3ad3a6530~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跨团队使用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了提高数据源的复用性，我们提供了数据源管理中心，这里可以看到整个系统所有维护的数据源，方便跨组件跨业务团队数据源复制复用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="image (6).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/242bf08e1bdf45759d56995346e65618~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据源注入&lt;/h2&gt;
&lt;p&gt;这一块我们在搭建侧做统一收拢，对一个页面所有组件选择使用的数据源做统一处理。&lt;/p&gt;
&lt;p&gt;为什么这么做？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上述提到数据源可以查看被哪些页面使用，这部分数据便来自于此，在发布页面时针对当前页面所使用的数据源做页面与数据源的关系落库。&lt;/li&gt;
&lt;li&gt;当页面组件数量居多，绑定的数据源也会剧增，这时候接口并发数也会剧增。在这里无需开发者关心，我们可以统一处理，对全局的数据源请求做限流（引出一道经典面试题：&lt;a href="https://juejin.cn/post/6916317088521027598"&gt;请用 JS 实现 Ajax 并发请求控制&lt;/a&gt;），以及对重复的数据源过滤，避免重复请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他还有很多优点不再赘述，感兴趣的同学欢迎一起讨论。&lt;/p&gt;
&lt;p&gt;注入流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发布时将当前数据源详情注入组件 schema&lt;/li&gt;
&lt;li&gt;访问页面时，针对当前页面所有组件，过滤使用了数据源的组件&lt;/li&gt;
&lt;li&gt;数据源去重，标记重复项&lt;/li&gt;
&lt;li&gt;去重后的数据源并发请求数据，请求池控制并发数，最大并发10&lt;/li&gt;
&lt;li&gt;数据源返回结果后，根据各组件 schema 内存储的数据源信息中的组件字段与数据源字段的映射关系做数据映射&lt;/li&gt;
&lt;li&gt;最后通过组件的 props 统一注入（为啥用 props ？请看我们上一篇：&lt;a href="https://juejin.cn/post/6844903950508883982#heading-21"&gt;鲁班核心代码&lt;/a&gt;），最后完成整个页面的数据源注入及渲染。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b55254ed4d6d409e917d472dc782f474~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;数据源是搭建系统建设过程中重要的一环，为提效再进一步，他不仅降低了页面的重复搭建，还收拢了差异化配置的入口，并且让运营同学可以做一些研发同学才可以做的事：接口创建、引用、发布等。以上是我个人对搭建系统中数据源的一些总结，后续还会继续分享数据投放相关，如有错误，劳烦指正修改，感谢各位能看到这里。&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7119639489567260686"&gt;表单数据形式配置化设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7117042614313943070"&gt;如何将传统 Web 框架部署到 Serverless&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7114450860335169543"&gt;浅谈前端埋点 &amp;amp; 监控&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7111848825232293918"&gt;如何让 x == 1 &amp;amp;&amp;amp; x == 2 &amp;amp;&amp;amp; x == 3 等式成立&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/editor/drafts/7109126523466022948"&gt;数据统计在性能检测中的应&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 19 Jul 2022 16:12:17 GMT</pubDate></item><item><title>表单数据形式配置化设计</title><link>https://juejin.cn/post/7119639489567260686</link><description>&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4eb6a01e6564840817b127265b07edd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="二刚.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a11764e148a4c2f9ee11daa421af36b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 151 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/form-data"&gt;表单数据形式配置化设计&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;在日常的中后台系统开发中，表单是和我们打交道非常多的名词。但是在一般的表单实现中、我们会做着很多重复的工作，不停在写 FormItem...，以及为组件加上“请输入/请选择”等无脑的 placeholder 文本和“请输入xx/请选择xx”等必填提示。其次表单一般都存在编辑页和详情页，而为了代码更好的维护性通常会将编辑和详情用一套代码实现。此时我们的代码里就会出现&lt;code&gt;“isEdit ？ 表单组件 ： 纯文本”&lt;/code&gt;这样无脑且重复率高的代码。秉承着更少代码更多产出的原则，我设计了一套配置化逻辑来提升这一开发体验。&lt;/p&gt;
&lt;h4&gt;一般实现&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 一般实现
import React from 'react';
import { Form, Input, Select } from 'antd';

const Demo = (props) =&amp;gt; {
  const { form: { getFieldDecorator }, obj = {}, isEdit } = props;
  return (
    &amp;lt;&amp;gt;
      &amp;lt;FormItem label="姓名" &amp;gt;
        {isEdit ? obj.name || '-' : 
          getFieldDecorator('name', {
            initialValue: obj.name,
          })(
            &amp;lt;Input placeholder="请输入" /&amp;gt;
          )
        }
      &amp;lt;/FormItem&amp;gt;
      &amp;lt;FormItem label="性别" &amp;gt;
        {isEdit ? obj.sex || '-' : 
          getFieldDecorator('sex', {
            initialValue: obj.sex,
            rules: [{ required: true, message: '请选择性别' }],
          })(
            &amp;lt;Select placeholder="请选择" &amp;gt;
              &amp;lt;Option key="male" value="male"&amp;gt;男&amp;lt;/Option&amp;gt;            
              &amp;lt;Option key="female" value="female"&amp;gt;女&amp;lt;/Option&amp;gt;
            &amp;lt;/Select&amp;gt;
          )
        }
      &amp;lt;/FormItem&amp;gt;
       &amp;lt;FormItem label="手机号" &amp;gt;
        {isEdit ? obj.phone || '-' : 
          getFieldDecorator('phone', {
            initialValue: obj.phone,
            rules: [{ required: true, message: '请输入手机号' }],
          })(
            &amp;lt;Input placeholder="请输入" /&amp;gt;
          )
        }
      &amp;lt;/FormItem&amp;gt;
    &amp;lt;&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;配置化的实现&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 配置化的实现
import React from 'react';
import { renderDataForm } from 'src/util/renderDataForm';

const Demo = (props) =&amp;gt; {
  const { form, obj = {}, isEdit } = props;
  const conf = [{
    label: '姓名', // 表单的label
    field: 'name', // 表单字段名
    initialValue: obj.name, // 表单默认值
    required: false, // 是否必填、默认必填
  }, {
    label: '性别',
    field: 'sex',
    initialValue: obj.sex,
    formItemType: 'Select', // 表单类型默认 Input
    options: [{ value: 'male', label: '男' }, { value: 'female', label: '女' }], // 下拉选项
  }, {
    label: '手机号',
    field: 'phone',
    initialValue: obj.phone,
  }];
  const dataForm = isEdit ? 'form' : 'text';
  // 传入form，表单配置，想要的数据形式
  return renderDataForm(form, conf, dataForm));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;实现思路&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e18fd50e8a52429294102208f7d5f5ae~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
如上图所示，无论是在详情页中显示文本亦或是编辑页中的表单组件包裹的数据，其实本身所对应的都是同一个数据，只是展示形式不一样而已。在这里我们暂时将数据的形式定为表单组件形式与文本形式。其实在实际的使用中，由于数据的收集形式不同，会出现第三种数据形式。它就是表单文本形式，一种以文本展示但数据可被表单自动收集的形式，我把它定义为 FormText（如下所示）。至此，针对实现数据详情与编辑形式的方案有了这样两种，表单与文本组合或表单与表单文本组合的实现。本次我选择表单与文本组合的方案。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/**
 * 用于 Form 表单内部受控展示文本
 */
export default class FormText extends Component {
  render() {
    const { value, formatMethod = a =&amp;gt; a, defaultText = '-', ...resetProps } = this.props;
    return &amp;lt;span {...resetProps}&amp;gt;{formatMethod(value) || defaultText}&amp;lt;/span&amp;gt;;
  }
}

// 使用
&amp;lt;FormItem label="姓名"&amp;gt;
  {getFieldDecorator('name', {
      initialValue: 'egg',
  })(&amp;lt;FormText /&amp;gt;)}
&amp;lt;/FormItem&amp;gt;
   
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;具体实现&lt;/h3&gt;
&lt;p&gt;1、形式选择(表单组件 or 文本)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const renderDataForm = (form, conf = {}, dataForm = 'form') =&amp;gt; {
  // customRenderText 自定义文本形式
  const { customRenderText } = conf;
  return (
    &amp;lt;FormItem label={conf.label} {...conf.formItemProps} &amp;gt;
      {dataForm === 'form' ? renderFormItem(form, conf) : 
        customRenderText ? customRenderText(conf) : renderText(conf) }
    &amp;lt;/FormItem&amp;gt;
  );
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、表单组件选择&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;
export const renderFormItem = (form, rest) =&amp;gt; {
  const { getFieldDecorator } = form;
  const { label = '', field = '', formItemType = 'input', initialValue, required = true, rules = [], ...itemRest } = rest;
  return (getFieldDecorator(field, {
    initialValue,
    rules: [
      // 必填提示
      { required, message: renderMessage(formItemType, label) },
      ...rules,
    ],
    ...(formItemType === 'upload' ? { // Upload组件的通用配置
      getValueFromEvent: (e) =&amp;gt; {
        if (Array.isArray(e)) {
          return e;
        }
        return e &amp;amp;&amp;amp; e.fileList;
      },
      valuePropName: 'fileList' } : {}),
  })(
    renderItem(formItemType, itemRest)
  ));
};

// 选择表单组件
const renderItem = (formItemType, itemRest) =&amp;gt; {
  const { options = [], CustomFormItem } = itemRest;
  const obj = { Input, TextArea, InputNumber, Upload, Select, RadioGroup, CheckboxGroup, DatePicker };
  // 自定义的表单组件
  if (formItemType === 'CustomFormItem') {
    return &amp;lt;CustomFormItem {...itemRest} /&amp;gt;;
  }
  // 不存在对应组件时返回默认的 Input 组件
  if (!obj[formItemType]) {
    return &amp;lt;Input placeholder="请输入" {...itemRest} /&amp;gt;;
  }
  const Comp = obj[formItemType];
  // 双标签组件处理
  if (['Select', 'Upload'].includes(formItemType)) {
    return formItemType === 'Upload' ? (
      &amp;lt;Upload
        {...itemRest}
      &amp;gt;
        &amp;lt;Button&amp;gt;&amp;lt;Icon type="upload" /&amp;gt;上传&amp;lt;/Button&amp;gt;
      &amp;lt;/Upload&amp;gt;
    ) : (
      &amp;lt;Comp {...getDefaultCompProps(itemRest)} {...itemRest} &amp;gt;
        {options.map(el =&amp;gt; (
          &amp;lt;Option key={el.value} value={el.value}&amp;gt;{el.label || el.name}&amp;lt;/Option&amp;gt;))}
      &amp;lt;/Comp&amp;gt;
    );
  }
  // 单标签组件
  return &amp;lt;Comp {...getDefaultCompProps(itemRest)} {...itemRest} /&amp;gt;;
};

// 获取组件属性
const getDefaultCompProps = (conf = {}) =&amp;gt; {
  const { formItemType } = conf;
  const props = {};
  props.placeholder = renderMessage(formItemType);
  if (formItemType === 'InputNumber') {
    // zeroOmit 小数点后多余的零是否省略，limitDecimal 限制最长的小数位数
    const { zeroOmit = true, limitDecimal = 6 } = conf;
    const limitDecimalsF = (value) =&amp;gt; {
      const reg = new RegExp(`^(-)*(\\d+)\\.(\\d{${limitDecimal}}).*$`);
      return `${value}`.replace(reg, '$1$2.$3');
    };
    if (zeroOmit) {
      props.formatter = limitDecimalsF;
      props.parse = limitDecimalsF;
    }
  }
  if (formItemType === 'Input') {
    props.maxLength = 100; // 输入框的默认最大输入字符长度
  }
  if (formItemType === 'TextArea') {
    props.maxLength = 500; // 文本框的默认最大输入字符长度
  }
  return props;
};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、映射文本&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;export const renderText = (rest) =&amp;gt; {
  const { formItemType = 'Input', initialValue, selectOptions = [], selectMode = '', options = [] } = rest;
  switch (formItemType) {
  case 'RadioGroup': 
    return (options.find(item =&amp;gt; item.value === initialValue) || {}).label || '-';
  case 'DatePick': 
    const { format = 'YYYY-MM-DD HH:mm:ss' } = rest;
    // 日期组件组件值格式化为对应的 文本
    return initialValue !== undefined ? moment(initialValue).format(format) : '-';
  // ...code
  default: 
    return bizStringFormat(initialValue); // 无 值 时 默认 ‘-’
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、通用校验规则整理&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;export const postCode = /^[0-9]{6}$/;
export const phone = /^1\d{10}$/;
// ...其他正则

// form rules
export const postCodeRule = {
  pattern: postCode,
  message: '请输入6位数字',
};
export const phoneRule = { 
  pattern: phone,
  message: '请输入11位号码',
};
// ...其他表单校验规则


&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const Demo = (props) =&amp;gt; {
  const { form } = props;
  // 数据
  const obj = {
    email: '123@egg.com',
    addr: '派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星派大星',
    sort: 'up',
    birthday: '1999-01-23',
    sex: 'male',
    file: [{ fileId: '123', name: '信用承诺书', size: 1024 }],
  };
  // 因为数据的形式默认为表单，所以 dataForm: 'form' 可不配置
  const formConf = [{
    label: '邮箱',
    field: 'email',
    initialValue: obj.email,
    rules: [emailRule], // emailRule 为邮箱校验规则
  }, {
    label: '地址',
    field: 'addr',
    initialValue: obj.addr,
    formItemType: 'TextArea',
  }, {
    label: '排序',
    field: 'sort',
    initialValue: obj.sort,
    formItemType: 'Select',
    options: [{ value: 'up', label: '升序' }, { value: 'down', label: '降序' }],
  }, {
    label: '生日',
    field: 'birthday',
    initialValue: obj.birthday,
    formItemType: 'DatePicker',
    format: 'YYYY-MM-DD', // 日期组件的格式配置字段
  }, {
    label: '性别',
    field: 'sex',
    initialValue: obj.sex,
    formItemType: 'RadioGroup',
    options: [{ value: 'male', label: '男' }, { value: 'female', label: '女' }],
  }, {
    label: '信用承诺书',
    field: 'file',
    initialValue: obj.file,
    formItemType: 'Upload',
  }];
  const dataForm = isEdit ? 'form' : 'text';
  // 将配置遍历传入renderDataForm
  // 当然你也可以封装成组建，直接向组建传入 form、formConf，减少遍历的重复书写和整洁
  return formConf.map(item =&amp;gt; renderDataForm(form, item, dataForm));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终呈现如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa89ecfb595d45239195ce8eb0d09b2b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
2. 触发校验&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02b9149e679c42a6afd1e312ccd4f67e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
3. 详情&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d5eddb7c2434909880f7c23f1aa4d3f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;虽然，在目前的前端领域，关于页面配置、可视化等更加复杂的能力，已有更丰富和更全面的实现。比如我们前端团队的无相应用早已实现整个表单页的配置化能力。而本文展示的表单块的代码配置化能力接入较为轻量、内容上更容易理解。&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7117042614313943070"&gt;如何将传统 Web 框架部署到 Serverless&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7114450860335169543"&gt;浅谈前端埋点 &amp;amp; 监控&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7111848825232293918"&gt;如何让 x == 1 &amp;amp;&amp;amp; x == 2 &amp;amp;&amp;amp; x == 3 等式成立&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/editor/drafts/7109126523466022948"&gt;数据统计在性能检测中的应&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7106652838800916517"&gt;浅析 path 常用工具函数源码&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 60 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 12 Jul 2022 16:00:53 GMT</pubDate></item><item><title>如何将传统 Web 框架部署到 Serverless</title><link>https://juejin.cn/post/7117042614313943070</link><description>&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4eb6a01e6564840817b127265b07edd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="雪霁.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/781c0e37784b40aeac741101c4b1babc~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 150 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/serverless-web"&gt;如何将传统 Web 框架部署到 Serverless&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;因为 Serverless 的“无服务器架构”应用相比于传统应用有很多优点，比如：无需关心服务器、免运维、弹性伸缩、按需付费、开发可以更加关注业务逻辑等等，所以现在 Serverless 应用已经逐渐广泛起来。&lt;/p&gt;
&lt;p&gt;但是目前原生的 Serverless 开发框架还比较少，也没有那么成熟，另外主流的 Web 框架还不支持直接 Serverless 部署，但好在是现在国内各大云厂商比如阿里云、腾讯云已经提供能力能够将我们的传统框架以简单、快速、科学的方式部署到 Serverless 上，下面让我们一起研究看看它们是怎么做的吧。&lt;/p&gt;
&lt;p&gt;我们以 Node.js 的 Express 应用为例，看看如何通过阿里云函数计算，实现不用按照传统部署方式购买云主机去部署，不用自己运维，快速部署到 Serverless 平台上。&lt;/p&gt;
&lt;h1&gt;传统应用与函数计算的入口差异&lt;/h1&gt;
&lt;h3&gt;传统应用的入口文件&lt;/h3&gt;
&lt;p&gt;首先看下传统 Express 应用的入口文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;const express = require('express')
const app = express()
const port = 3000

// 监听 / 路由，处理请求
app.get('/', (req, res) =&amp;gt; {
  res.send('Hello World!')
})

// 监听 3000 端口，启动 HTTP 服务
app.listen(port, () =&amp;gt; {
  console.log(`Example app listening on port ${port}`)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到传统 Express 应用是：&lt;/p&gt;
&lt;p&gt;1.通过 app.listen() 启动了 HTTP 服务，其本质上是调用的 Node.js http 模块的 createServer() 方法创建了一个 HTTP Server&lt;/p&gt;
&lt;p&gt;2.监听了&lt;code&gt;/&lt;/code&gt;路由，由回调函数&lt;code&gt;function(request, response)&lt;/code&gt;处理请求&lt;/p&gt;
&lt;h3&gt;函数计算的入口函数&lt;/h3&gt;
&lt;p&gt;Serverless 应用中， FaaS 是基于事件触发的，触发器是触发函数执行的方式， 其中 API 网关触发器与 HTTP 触发器与均可应用于 Web应用的创建。函数计算会从指定的入口函数开始执行，其中 API 网关触发器对应的入口函数叫事件函数，HTTP 触发器对应的入口函数叫 HTTP 函数，它们的入口函数形式不同。&lt;/p&gt;
&lt;h4&gt;API 网关触发器的入口函数形式&lt;/h4&gt;
&lt;p&gt;API 网关触发器的入口函数形式如下，函数入参包括 event、context、callback，以 Node.js 为例，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;/*
* handler: 函数名 handler 需要与创建函数时的 handler 字段相对应。例如创建函数时指定的 handler 为 index.handler，那么函数计算会去加载 index.js 文件中定义的 handler 函数
*event: 您调用函数时传入的数据，其类型是 Buffer，是函数的输入参数。您在函数中可以根据实际情况对 event 进行转换。如果输入数据是一个 JSON 字符串 ，您可以把它转换成一个 Object。
* context: 包含一些函数的运行信息，例如 request Id、 临时 AK 等。您在代码中可以使用这些信息
* callback: 由系统定义的函数，作为入口函数的入参用于返回调用函数的结果，标识函数执行结束。与 Node.js 中使用的 callback 一样，它的第一个参数是 error，第二个参数 data。
*/
module.exports.handler = (event, context, callback) =&amp;gt; {

  // 处理业务逻辑
  callback(null, data);

};

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;HTTP 触发器的入口函数形式&lt;/h4&gt;
&lt;p&gt;一个简单的 Node.js HTTP 函数示例如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;module.exports.handler = function(request, response, context)  {
  response.send("hello world");
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;差异对比&lt;/h3&gt;
&lt;p&gt;对比可以看出，在传统应用中，是启动一个服务监听端口号去处理 HTTP 请求，服务处理的是 HTTP 的请求和响应参数；而在 Serverless 应用中， Faas 是基于事件触发的，触发器类型不同，参数映射和处理不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若是 API 网关触发器
&lt;ul&gt;
&lt;li&gt;当有请求到达后端服务设置为函数计算的 API 网关时，API 网关会触发函数的执行，触发器会将事件信息生成 event 参数，然后 FaaS 以 event 为参数执行入口函数，最后将执行结果返回给 API 网关。所以传统应用和 Serverless 应用在请求响应方式和参数的数据结构上都有很大差异，要想办法让函数计算的入口方法适配 express。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若是 HTTP 触发器
&lt;ul&gt;
&lt;li&gt;相对 API 网关触发器参数处理会简单些。因为 HTTP 触发器通过发送 HTTP 请求触发函数执行，会把真实的 HTTP 请求直接传递给 FaaS 平台，不需要编码或解码成 JSON 格式，不用增加转换逻辑，性能也更优。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;适配层&lt;/h1&gt;
&lt;p&gt;下面我们通过解读阿里云 FC 提供的将函数计算的请求转发给 express 应用的 npm 包 &lt;a href="https://github.com/awesome-fc/webserverless/tree/master/packages/fc-express"&gt;@webserverless/fc-express&lt;/a&gt; 源码，看看函数计算的入口方法是如何适配 express 的，如何适配 API 网关 和 HTTP 触发器这两种类型。&lt;/p&gt;
&lt;p&gt;根据上述分析，Web 应用若想 Serverless 化需要开发一个&lt;strong&gt;适配层&lt;/strong&gt;，将函数计算接收到的请求转发给 express 应用处理，最后再返回给函数计算。&lt;/p&gt;
&lt;h2&gt;API 网关触发的适配层&lt;/h2&gt;
&lt;h3&gt;实现原理&lt;/h3&gt;
&lt;p&gt;API 网关触发的情况下，通过适配层将 FaaS 函数接收到的 API 网关事件参数 event 先转化为标准的 HTTP 请求，再去让传统 Web 服务去处理请求和响应，最后再将 HTTP 响应转换为函数返回值。整体工作原理如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58071288512b4e798d3abf8deb78ea71~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适配层核心&lt;/strong&gt;就是：把 event 映射到 express 的 request 对象上， 再把 express 的 response 对象映射到 callback 的数据参数上。&lt;/p&gt;
&lt;p&gt;API 网关调用函数计算的事件函数时，会将 API 的相关数据转换为 Map 形式传给函数计算服务。函数计算服务处理后，按照下图中 Output Format 的格式返回 statusCode、headers、body 等相关数据。API 网关再将函数计算返回的内容映射到 statusCode、header、body等位置返回给客户端。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a49ac8084904030adcc7e19b0fdfc85~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;​(此图来源于阿里云)&lt;/p&gt;
&lt;h3&gt;核心过程&lt;/h3&gt;
&lt;p&gt;通过分析&lt;a href="https://github.com/awesome-fc/webserverless/tree/master/packages/fc-express"&gt;@webserverless/fc-express&lt;/a&gt;源码，我们可以抽取核心过程实现一个简易版的适配层。&lt;/p&gt;
&lt;h4&gt;1.创建一个自定义 HTTP Server，通过监听 Unix Domain Socket，启动服务&lt;/h4&gt;
&lt;p&gt;（友情链接：不清楚 Unix Domain Socket 的小伙伴可以先看下这篇文章: &lt;a href="https://www.cnblogs.com/sparkdev/p/8359028.html"&gt;Unix domain socket 简介 &lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;第一步我们若想把函数计算接收的 event 参数映射到 Express.js 的 request 对象上，就需要&lt;strong&gt;创建并启动&lt;/strong&gt;一个自定义的 HTTP 服务来代替 Express.js 的 app.listen，然后接下来就可以将函数的事件参数 event 转换为 Express.js 的 request 请求参数。&lt;/p&gt;
&lt;p&gt;首先创建一个 server.js 文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// server.js
const http = require('http');
const ApiGatewayProxy = require('./api-gateway-proxy');//&amp;nbsp;api-gateway-proxy.js 文件下一步会说明其内容

/*
* requestListener：被代理的 express 应用
* serverListenCallback： http 代理服务开始监听的回调函数
* binaryTypes: 当 express 应用的响应头 content-type 符合 binaryTypes 中定义的任意规则，则返回给 API 网关的 isBase64Encoded 属性为 true
*/
function Server(requestListener,serverListenCallback,binaryTypes) { 
  this.apiGatewayProxy = new ApiGatewayProxy(this);   // ApiGatewayProxy 核心过程 2 会介绍

  this.server = http.createServer(requestListener);// 1.1 创建一个自定义 HTTP Server

  this.socketPathSuffix = getRandomString(); // 随机生成一个字符串，作为 Unix Domain Socket 使用
  
  this.binaryTypes = binaryTypes ? binaryTypes.slice() : [];// 当 express 应用响应的 content-type 符合 Server 构造函数参数 binaryTypes 中定义的任意规则时，则函数的返回值的 isBase64Encoded 为 true，从而告诉 API 网关如何解析函数返回值的 body 参数

  this.server.on("listening", () =&amp;gt; {
    this.isListening = true;
    if (serverListenCallback) serverListenCallback();
  });

  this.server.on("close", () =&amp;gt; {
    this.isListening = false;
  }).on("error", (error) =&amp;gt; {
    // 异常处理
  });

}

// 暴露给函数计算入口函数 handler 调用的方法
Server.prototype.proxy = function (event, context, callback) {
  const e = JSON.parse(event);
  this.apiGatewayProxy.handle({
    event: e,
    context,
    callback
  });
}

// 1.2 启动服务
Server.prototype.startServer = function () {
  return this.server.listen(this.getSocketPath()); //  采用监听 Unix Domain Socket 方式启动服务，减少函数执行时间，节约成本
}

Server.prototype.getSocketPath = function () {
  /* istanbul ignore if */
  /* only running tests on Linux; Window support is for local dev only */
  if (/^win/.test(process.platform)) {
    const path = require('path');
    return path.join('\\\\?\\pipe', process.cwd(), `server-${this.socketPathSuffix}`);
  } else {
    return `/tmp/server-${this.socketPathSuffix}.sock`;
  }
}

function getRandomString() {
  return Math.random().toString(36).substring(2, 15);
}

module.exports = Server;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 server.js 中，我们定义了一个构造函数 Server 并导出。在 Server 中，我们创建了一个自定义的 HTTP 服务，然后随机生成了一个 Unix Domain Socket，采用监听该 Socket 方式启动服务来代替 Express.js 的&lt;code&gt;app.listen&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;2.将函数计算参数 event 转换为 Express.js 的 HTTP request&lt;/h4&gt;
&lt;p&gt;下面开始第 2 步，创建一个 api-gateway-proxy.js 文件，将函数计算参数 event 转换为 Express.js 的 HTTP request。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;//api-gateway-proxy.js
const http = require('http');
const isType = require('type-is');

function ApiGatewayProxy(server) {
  this.server = server;
}

ApiGatewayProxy.prototype.handle = function ({
  event,
  context,
  callback
}) {
  this.server.startServer()
    .on('listening', () =&amp;gt; {
      this.forwardRequestToNodeServer({
        event,
        context,
        callback
      });
    });
}

ApiGatewayProxy.prototype.forwardRequestToNodeServer = function ({
  event,
  context,
  callback
}) {
  const resolver = data =&amp;gt; callback(null, data);
  try {
    // 2.1将 API 网关事件转换为 HTTP request
    const requestOptions = this.mapContextToHttpRequest({
      event,
      context,
      callback
    });
    
    // 2.2 通过 http.request() 将 HTTP request 转发给 Node.js Server 处理，发起 HTTP 请求
    const req = http.request(requestOptions, response =&amp;gt; this.forwardResponse(response, resolver));
    req.on('error', error =&amp;gt; {
         //...
        });
    req.end();
  } catch (error) {
    // ...
  }
}

ApiGatewayProxy.prototype.mapContextToHttpRequest = function ({
  event,
  context,
  callback
}) {
  const headers = Object.assign({}, event.headers);
  return {
    method: event.httpMethod,
    path: event.path,
    headers,
    socketPath: this.server.getSocketPath()
    // protocol: `${headers['X-Forwarded-Proto']}:`,
    // host: headers.Host,
    // hostname: headers.Host, // Alias for host
    // port: headers['X-Forwarded-Port']
  };
}

// 核心过程 3 会介绍
ApiGatewayProxy.prototype.forwardResponse = function (response, resolver) {
  const buf = [];

  response
    .on('data', chunk =&amp;gt; buf.push(chunk))
    .on('end', () =&amp;gt; {
      const bodyBuffer = Buffer.concat(buf);
      const statusCode = response.statusCode;
      const headers = response.headers;
      const contentType = headers['content-type'] ? headers['content-type'].split(';')[0] : '';
      const isBase64Encoded = this.server.binaryTypes &amp;amp;&amp;amp; this.server.binaryTypes.length &amp;gt; 0 &amp;amp;&amp;amp; !!isType.is(contentType, this.server.binaryTypes);
      const body = bodyBuffer.toString(isBase64Encoded ? 'base64' : 'utf8');
    
      const successResponse = {
        statusCode,
        body,
        headers,
        isBase64Encoded
      };

      resolver(successResponse);
    });
}

module.exports = ApiGatewayProxy;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 api-gateway-proxy.js 中，我们定义了一个构造函数 ApiGatewayProxy 并导出。在这里我们会将 event 转换为 HTTP request，然后向 Node.js Server 发起请求，由 Node.js Server 再进行处理做出响应。&lt;/p&gt;
&lt;h4&gt;3.将 HTTP response 转换为 API 网关标准数据结构，作为 callback 的参数返回给 API 网关&lt;/h4&gt;
&lt;p&gt;接着继续对 api-gateway-proxy.js 文件中的&lt;code&gt;http.request(requestOptions, response =&amp;gt; this.forwardResponse(response, resolver))&lt;/code&gt;分析发出 HTTP 请求后的响应处理部分。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;//api-gateway-proxy.js

ApiGatewayProxy.prototype.forwardRequestToNodeServer = function ({
  event,
  context,
  callback
}) {
  const resolver = data =&amp;gt; callback(null, data); // 封装 callback 为 resolver
  //...
  // 请求、响应
  const req = http.request(requestOptions, response =&amp;gt; this.forwardResponse(response, resolver));
  //...
}

//3.Node.js Server 对 HTTP 响应进行处理，将 HTTP response 转换为 API 网关标准数据结构，作为函数计算返回值
ApiGatewayProxy.prototype.forwardResponse = function (response, resolver) {
  const buf = [];

  response
    .on('data', chunk =&amp;gt; buf.push(chunk))
    .on('end', () =&amp;gt; {
      const bodyBuffer = Buffer.concat(buf);
      const statusCode = response.statusCode;
      const headers = response.headers;
      const contentType = headers['content-type'] ? headers['content-type'].split(';')[0] : '';
      const isBase64Encoded = this.server.binaryTypes &amp;amp;&amp;amp; this.server.binaryTypes.length &amp;gt; 0 &amp;amp;&amp;amp; !!isType.is(contentType, this.server.binaryTypes);
      const body = bodyBuffer.toString(isBase64Encoded ? 'base64' : 'utf8');
    
    // 函数返回值
      const successResponse = {
        statusCode,
        body,
        headers,
        isBase64Encoded //当函数的 event.isBase64Encoded 是 true 时，会按照 base64 编码来解析 event.body，并透传给 express 应用，否则就按照默认的编码方式来解析，默认是 utf8
      };

    // 将 API 网关标准数据结构作为回调 callback 参数，执行 callback，返回给 API 网关
      resolver(successResponse);
    });
}



&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着第 2 步，Node.js Server 对 http.request() 发出的 HTTP 请求做出响应处理，将 HTTP response 转换为 API 网关标准数据结构，把它作为回调 callback 的参数，调用 callback 返回给 API 网关。&lt;/p&gt;
&lt;h4&gt;4.在入口函数中引入适配层代码并调用&lt;/h4&gt;
&lt;p&gt;以上 3 步就将适配层核心代码完成了，整个过程就是：将 API 网关事件转换成 HTTP 请求，通过本地 socket 和函数起 Node.js Server 进行通信。&lt;/p&gt;
&lt;p&gt;最后我们在入口函数所在文件 index.js 中引入 server.js，先用 Server 构建一个 HTTP 代理服务，然后在入口函数 handler 中调用&lt;code&gt;server.proxy(event, context, callback);&lt;/code&gt; 即可将函数计算的请求转发给 express 应用处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// index.js
const express = require('express');

const Server = require('./server.js'); 

const app = express();
app.all('*', (req, res) =&amp;gt; {
  res.send('express-app hello world!');
});

const server = new Server(app); // 创建一个自定义 HTTP Server

module.exports.handler = function(event, context, callback) {
  server.proxy(event, context, callback); // server.proxy 将函数计算的请求转发到 express 应用
};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们将以上代码在 FC 上部署、调用，执行成功结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74340067644b4769ac93f88cd4dd42e4~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;HTTP 触发的适配层&lt;/h2&gt;
&lt;h3&gt;实现原理&lt;/h3&gt;
&lt;p&gt;HTTP 触发的情况下，不用对请求参数做转换，其它原理与 API 网关触发器一致：通过适配层将 FaaS 函数接收到的请求参数直接转发到自定义的 Web 服务内，最后再将 HTTP 响应包装返回即可，整体工作原理如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b3c804d55034189aaefb1e75df1f198~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;核心过程&lt;/h3&gt;
&lt;p&gt;同样我们抽取核心过程简单实现一个适配层，与 API 网关触发器原理相同的部分将不再赘述 。&lt;/p&gt;
&lt;h4&gt;1.创建一个自定义 HTTP Server，通过监听 Unix Domain Socket，启动服务&lt;/h4&gt;
&lt;p&gt;server.js 代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// server.js
const http = require('http');
const HttpTriggerProxy = require('./http-trigger-proxy');

function Server(requestListener,serverListenCallback) {
  this.httpTriggerProxy = new HttpTriggerProxy(this);

  this.server = http.createServer(requestListener); // 1.1 创建一个自定义 HTTP Server

  this.socketPathSuffix = getRandomString();

  this.server.on("listening", () =&amp;gt; {
    this.isListening = true;
    if (serverListenCallback) serverListenCallback();
  });

  this.server.on("close", () =&amp;gt; {
    this.isListening = false;
  }).on("error", (error) =&amp;gt; {
    // 异常处理，例如判读 socket 是否已被监听
  });

}

// 暴露给函数计算入口函数 handler 调用的方法
Server.prototype.httpProxy = function (request, response, context) {
    this.httpTriggerProxy.handle({ request, response, context });
}

// 1.2 启动服务
Server.prototype.startServer = function () {
  return this.server.listen(this.getSocketPath());
}

Server.prototype.getSocketPath = function () {
  /* istanbul ignore if */
  /* only running tests on Linux; Window support is for local dev only */
  if (/^win/.test(process.platform)) {
    const path = require('path');
    return path.join('\\\\?\\pipe', process.cwd(), `server-${this.socketPathSuffix}`);
  } else {
    return `/tmp/server-${this.socketPathSuffix}.sock`;
  }
}

function getRandomString() {
  return Math.random().toString(36).substring(2, 15);
}

module.exports = Server;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2.将 HTTP request 直接转发给 Web Server，再将 HTTP response 包装返回&lt;/h4&gt;
&lt;p&gt;创建一个 api-trigger-proxy.js 文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// api-trigger-proxy.js
const http = require('http');
const isType = require('type-is');
const url = require('url');
const getRawBody = require('raw-body');

function HttpTriggerProxy(server) {
  this.server = server;
}

HttpTriggerProxy.prototype.handle = function ({
  request,
  response,
  context
}) {
  this.server.startServer()
    .on('listening', () =&amp;gt; {
      this.forwardRequestToNodeServer({
        request,
        response,
        context
      });
    });
}

HttpTriggerProxy.prototype.forwardRequestToNodeServer = function ({
    request,
    response,
    context
}) {
  // 封装 resolver
  const resolver = data =&amp;gt; {
    response.setStatusCode(data.statusCode);
    for (const key in data.headers) {
        if (data.headers.hasOwnProperty(key)) {
            const value = data.headers[key];
            response.setHeader(key, value);
        }
    }
    response.send(data.body); // 返回 response body
  };
  try {
    // 透传 request
    const requestOptions = this.mapContextToHttpRequest({
        request,
        context
    });
  // 2.将 HTTP request 直接转发给 Web Server，再将 HTTP response 包装返回
    const req = http.request(requestOptions, response =&amp;gt; this.forwardResponse(response, resolver));
    req.on('error', error =&amp;gt; {
         // ...
        });
    // http 触发器类型支持自定义 body：可以获取自定义 body
    if (request.body) {
        req.write(request.body);
        req.end();
    } else {
      // 若没有自定义 body：http 触发器触发函数，会通过流的方式传输 body 信息，可以通过 npm 包 raw-body 来获取
        getRawBody(request, (err, body) =&amp;gt; {
            req.write(body);
            req.end();
        });
    }
  } catch (error) {
    // ...
  }
}

HttpTriggerProxy.prototype.mapContextToHttpRequest = function ({
    request,
    context
}) {
  const headers = Object.assign({}, request.headers); 
  headers['x-fc-express-context'] = encodeURIComponent(JSON.stringify(context));
  return {
    method: request.method,
    path: url.format({ pathname: request.path, query: request.queries }),
    headers,
    socketPath: this.server.getSocketPath()
    // protocol: `${headers['X-Forwarded-Proto']}:`,
    // host: headers.Host,
    // hostname: headers.Host, // Alias for host
    // port: headers['X-Forwarded-Port']
  };
}

HttpTriggerProxy.prototype.forwardResponse = function (response, resolver) {
  const buf = [];

  response
    .on('data', chunk =&amp;gt; buf.push(chunk))
    .on('end', () =&amp;gt; {
      const bodyBuffer = Buffer.concat(buf);
      const statusCode = response.statusCode;
      const headers = response.headers;
      const contentType = headers['content-type'] ? headers['content-type'].split(';')[0] : '';
      const isBase64Encoded = this.server.binaryTypes &amp;amp;&amp;amp; this.server.binaryTypes.length &amp;gt; 0 &amp;amp;&amp;amp; !!isType.is(contentType, this.server.binaryTypes);
      const body = bodyBuffer.toString(isBase64Encoded ? 'base64' : 'utf8');
      const successResponse = {
        statusCode,
        body,
        headers,
        isBase64Encoded
      };

      resolver(successResponse);
    });
}

module.exports = HttpTriggerProxy;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;3.入口函数引入适配层代码&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// index.js
const express = require('express');
const Server = require('./server.js');

const app = express();
app.all('*', (req, res) =&amp;gt; {
  res.send('express-app-httpTrigger hello world!');
});

const server = new Server(app);



module.exports.handler  = function (req, res, context) { 
  server.httpProxy(req, res, context);
};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样地，我们将以上代码在 FC 上部署、调用，执行成功结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaa9a758fd674628b7dcfe08e65dfa1f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;看到最后，大家会发现 API 网关触发器和 HTTP触发器很多代码逻辑是可以复用的，大家可以自行阅读优秀的源码是如何实现的～&lt;/p&gt;
&lt;h1&gt;其他部署到 Serverless 平台的方案&lt;/h1&gt;
&lt;p&gt;将传统 Web 框架部署到 Serverless 除了通过适配层转换实现，还可以通过 &lt;a href="https://juejin.cn/post/6981921291980767269#heading-5"&gt;Custom Runtime 或者 Custom Container Runtime&lt;/a&gt; ，3 种方案总结如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过引入适配层，将函数计算接收的事件参数转换为 HTTP 请求交给自定义的 Web Server 处理&lt;/li&gt;
&lt;li&gt;通过 Custom Runtime
&lt;ul&gt;
&lt;li&gt;本质上也是一个 &lt;strong&gt;HTTP Server&lt;/strong&gt;，&lt;strong&gt;接管了函数计算平台的所有请求&lt;/strong&gt;，包括事件调用或者 HTTP 函数调用等&lt;/li&gt;
&lt;li&gt;开发者需要创建一个启动目标 Server 的可执行文件 bootstrap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过 Custom Container Runtime
&lt;ul&gt;
&lt;li&gt;工作原理与Custom Runtime 基本相同&lt;/li&gt;
&lt;li&gt;开发者需要&lt;strong&gt;把应用代码和运行环境打包为 Docker 镜像&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;本文介绍了传统 Web 框架如何部署到 Serverless 平台的方案：可以通过适配层和自定义（容器）运行时。其中主要以 Express.js 和阿里云函数计算为例讲解了通过适配层实现的原理和核心过程，其它 Web 框架 Serverless 化的原理也基本一致，腾讯云也提供了原理一样的 &lt;a href="https://github.com/serverless-plus/tencent-serverless-http"&gt;tencent-serverless-http&lt;/a&gt; 方便大家直接使用（但腾讯云不支持 HTTP 触发器），大家可以将自己所使用的 Web 框架对照云厂商函数计算的使用方法亲自开发一个适配层实践一下～&lt;/p&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/awesome-fc/webserverless/tree/master/packages/fc-express"&gt;Webserverless - FC Express extension&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://zhuanlan.zhihu.com/p/152391799"&gt;如何将 Web 框架迁移到 Serverless&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://developer.aliyun.com/article/790302"&gt;Serverless 工程实践 | 传统 Web 框架迁移&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://help.aliyun.com/document_detail/53102.html"&gt;阿里云-触发器简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://zhuanlan.zhihu.com/p/72076708"&gt;前端学serverless系列——WebApplication迁移实践&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7114450860335169543"&gt;浅谈前端埋点 &amp;amp; 监控&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7111848825232293918"&gt;如何让 x == 1 &amp;amp;&amp;amp; x == 2 &amp;amp;&amp;amp; x == 3 等式成立&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/editor/drafts/7109126523466022948"&gt;数据统计在性能检测中的应&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7106652838800916517"&gt;浅析 path 常用工具函数源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7104055306396631076"&gt;Web Components-LitElement实践&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 60 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 05 Jul 2022 16:02:10 GMT</pubDate></item><item><title>浅谈前端埋点 &amp; 监控</title><link>https://juejin.cn/post/7114450860335169543</link><description>&lt;h1&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4eb6a01e6564840817b127265b07edd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="北海.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d30955e687414d0eb3a1e01f1eb7a8dc~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 149 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/monitor"&gt;浅谈前端埋点&amp;amp;监控&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;一、为什么需要埋点&amp;amp;监控&lt;/h3&gt;
&lt;p&gt;在开始正文之前，我们先想想为什么需要埋点&amp;amp;监控？&lt;/p&gt;
&lt;p&gt;当我们在分析复盘一个产品是否成功的时候，不同的角色考虑的方向是不同的。&lt;/p&gt;
&lt;p&gt;站在产品的视角，经常会问如下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;产品有没有用户使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户用得怎么样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统会不会经常出现异常&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何更好地满足用户需求服务用户&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当站在技术视角时，经常会问如下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;系统出现异常的频率如何&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常出现后如何快速进行定位追踪&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何分析解决问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而当站在老板的视角时，问题可能又会变为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;我的存量用户多少，未来还有多少潜力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多少用户在系统内进行了消费&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当在回答了上述问题之后，埋点&amp;amp;监控便跃然纸上。因为要回答以上问题，只有通过对系统进行数据分析的方式才能弄清楚。&lt;/p&gt;
&lt;p&gt;其实无论是埋点亦或是监控，二者并不是独立存在，而是相互依存的关系。&lt;/p&gt;
&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62d5cb6cb27c4d47801453b6755357f8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;h3&gt;二、埋点&amp;amp;监控能做什么&lt;/h3&gt;
&lt;p&gt;从单个页面的常规数据角度出发我们可以通过埋点获取：访问次数（UV/PV）、地域数据（IP）、在线时长、区域点击次数等数据。&lt;/p&gt;
&lt;p&gt;当我们将这些单点数据按照特定的纬度进行数据聚合，就可以获得全流程视角下的数据如：用户留存率/流转率、用户转化率、用户访问深度等数据。&lt;/p&gt;
&lt;p&gt;而在埋点数据进行上报的同时，我们也可以同步收集页面基础数据/接口相关数据如：页面加载/渲染时长、页面异常、请求接口等数据。&lt;/p&gt;
&lt;p&gt;同时对于前端监控来说，大致可以分成三个方向：数据监控、性能监控、异常监控。&lt;/p&gt;
&lt;h5&gt;数据监控&lt;/h5&gt;
&lt;p&gt;数据监控即通过数据分析用户行为，常见的监控数据包括：PV/UV、页面停留时长、通过什么入口进入、在页面触发了什么行为等。统计这些数据就是为了清楚用户来源，拓宽产品的推广渠道；了解用户在页面停留的时间情况，针对停留较短的页面进行分析改进。也就是我们常说的：who(uuid)、when(time)、from where(referrer)、where(x,y)、what(自定义拓展数据)串成的用户行为路径。&lt;/p&gt;
&lt;h5&gt;性能监控&lt;/h5&gt;
&lt;p&gt;性能监控主要是针对前端进行监控，比如不同用户在不同地区使用不同机型下的首屏加载时间、页面的白屏时间、静态资源下载时间等数据。通过针对这些性能数据进行监控，可以大概反映前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能。&lt;/p&gt;
&lt;h5&gt;异常监控&lt;/h5&gt;
&lt;p&gt;前端代码在执行过程中也可能会发生异常，因此需要引入异常监控例如 sentry 等工具及时的上报异常情况，可以避免线上故障的发上。常见的异常包括：Javascript 的异常监控、css 的异常监控等。&lt;/p&gt;
&lt;h3&gt;三、目前埋点方案&amp;amp;后续演进方向&lt;/h3&gt;
&lt;h5&gt;现有方案&lt;/h5&gt;
&lt;p&gt;目前公司已经存在一套埋点 SDK 在运行，使用的是代码埋点方案，其埋点上报数据可大致分为三类：页面进入、事件触发、页面离开。&lt;/p&gt;
&lt;p&gt;(1) 页面进入(pageIn)&lt;/p&gt;
&lt;p&gt;进入页面时，同步推送页面基础信息如：当前页面的来源页面、操作系统、浏览器、页面 url，发生时间等。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{ 
   title: '政采云', // document title 
   pre: '', // referrer 
   utm-url: 'a.b.c.d.e', // url中获取的utm 
   utm-cnt: 'a.b.0.0.e', // 这个页面的utm a b值 
   scr: '1400x900', //分辨率 
   os: 'mac', // 操作系统 
   k: 'webkit', // 浏览器内核 
   b: 'chrome/70', // 浏览器及版本 
   lver: '1.0.0', // js版本 
   createTime: '', // 当前时间的时间戳（用户本地时间）
   logType: 1 // 页面进入发送数据 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2) 事件触发(Event)&lt;/p&gt;
&lt;p&gt;触发事件时，同步推送事件类型(click、hover等)、鼠标位置、附加业务参数等&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{ 
  evt: 'click', // 事件类型 
  utm-cnt: 'a.b.c.d.e', // utm值 
  bdata: '{"test": "12345" }', // 业务数据 
  mx: xx, // 鼠标点击位置x 
  my: xx, // 鼠标点击位置y 
  lver: '1.0.0', // js版本 
  logType: 2 // 数据类型 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(3) 页面离开(pageOut)&lt;/p&gt;
&lt;p&gt;离开页面时，同步推送发生时间、页面 url 等&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{ 
    title: '政采云', // document title 
    pre: '', // referrer 
    utm-url: 'a.b.c.d.e', // url中获取的utm 
    utm-cnt: 'a.b.0.0.e', // 这个页面的utm a b值 
    lver: '1.0.0', // js版本 
    createTime: '', // 当前时间的时间戳（用户本地时间）
    logType: 3 // 页面离开发送数据 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其埋点大致逻辑如下图，通过生成独有的四段值 +pvid 即可定位某个项目的某个页面在某个区块点击了某个按钮，同时生成唯一的 pvid 记录页面的 pv 数据。具体说明可翻阅往期关于政采云埋点分析系统的文章。&lt;/p&gt;
&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43ae17d076148c9a29b2ddf3923a8d5~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;h5&gt;后续演进&lt;/h5&gt;
&lt;p&gt;在现有 SDK 的基础上我们可以发现，目前的埋点 SDK 只上报了一些用户的基础信息数据，在性能数据和异常数据的上报上还存在可拓展的空间。&lt;/p&gt;
&lt;p&gt;(1) 性能数据上报&lt;/p&gt;
&lt;p&gt;在获取用户基础数据的同时，后续可以通过&lt;code&gt;window.performance&lt;/code&gt;API获取前端性能数据，在第一次进入页面时随 pageIn 一起将页面初始性能数据进行上报。&lt;/p&gt;
&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07992e597d3949cd9dcaa6aec189ab29~tplv-k3u1fbpfcp-zoom-1.image" /&gt;
&lt;p&gt;可进行上报的字段包含如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;const getPerformanceData = () =&amp;gt; {
  let performance = {}
  try {
    performance = window.performance.getEntries()[0]
  } catch (e) {}
  const {
    domainLookupEnd = 0,
    domainLookupStart = 0,
    connectStart = 0,
    connectEnd = 0,
    requestStart = 0,
    responseStart = 0,
    // etc...
  } = performance
  const dns = ~~(domainLookupEnd - domainLookupStart)
  const tcp = ~~(connectEnd - connectStart)
  const ttfb = ~~(responseStart - requestStart)
  // etc...
  return {
    // TODO...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2) 接口数据上报&lt;/p&gt;
&lt;p&gt;除了上报性能数据外，我们也可将页面内所发的所有请求通过重写&lt;code&gt;XMLHttpRequest&lt;/code&gt;进行劫持打标上报，即在当前页面下的所有请求 header 上默认加上当前页面 ID，将各个请求与当前页面的 pageId 进行绑定。&lt;/p&gt;
&lt;p&gt;通过该类数据可以进行统计分析出某一页面的请求量、请求异常等情况判断出页面级别的请求健康度；后期甚至可与 Yapi 接口系统打通，若出现异常情况可直接将实际请求参数与文档上的请求参数进行对比，排除异常是由于请求参数错误造成的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;let req = XMLHttpRequest
;(function (open, send) {
  // TODO...
  XMLHttpRequest.prototype.open = function () {
    open.apply(this, arguments)
  }
  // TODO...
  XMLHttpRequest.prototype.send = function () {
    this.setRequestHeader('XXXXX', 'XXX')
    send.apply(this, arguments)
  }
})(req.prototype.open, XMLHttpRequest.prototype.send)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;四、前端数据可视化&lt;/h3&gt;
&lt;p&gt;对于已经采集上来的数据经由数仓清洗之后的可视化玩法就千变万化了。可以针对不同元数据按不同指标纬度聚合，产生不同的数据分析侧重点。再通过各类可视化工具进行展示，例如：浑仪系统、小采BI等。&lt;/p&gt;
&lt;h5&gt;浑仪系统&lt;/h5&gt;
&lt;p&gt;浑仪系统(内部系统)主要针对埋点进行元数据后台管理，推进埋点平台的规范化建设。同时在此基础上，优化数据分析功能，为公司内部用户提供埋点数据自助分析平台，提升数据利用率和日常工作效率。&lt;/p&gt;
&lt;h5&gt;小采BI&lt;/h5&gt;
&lt;p&gt;小采BI是可视化团队内部搭建系统，分为报表搭建、大屏搭建和看板搭建等模块。通过内部这些搭建工具直接对元数据进行展示，组合成面向不同受众、不同角色的自定义数据报表或监控大屏等。&lt;/p&gt;
&lt;h3&gt;五、结语&lt;/h3&gt;
&lt;p&gt;本文只是针对埋点系统和监控系统的融合的一点简单的介绍与探索，实际操作落地上肯定会有各种问题。比如多端情况下的数据埋点&amp;amp;上报，比如手动埋点增加了工作量破坏了原有代码的可读性等一系列实操上的问题，这些都需要逐步完善优化，同时我们也希望各位读者提出自己意见和建议，一起完善埋点&amp;amp;监控的大生态。&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7111848825232293918"&gt;如何让 x == 1 &amp;amp;&amp;amp; x == 2 &amp;amp;&amp;amp; x == 3 等式成立&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/editor/drafts/7109126523466022948"&gt;数据统计在性能检测中的应&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7106652838800916517"&gt;浅析 path 常用工具函数源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7104055306396631076"&gt;Web Components-LitElement实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7101457212085633054"&gt;模块联邦浅析&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 60 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 28 Jun 2022 16:23:12 GMT</pubDate></item><item><title>你不应该依赖CSS 100vh，这就是原因!</title><link>https://juejin.cn/post/7135600743095992327</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果有一个文本和一个按钮，我们想让文本粘在上面，而按钮粘在下面！使用CSS Flex 似乎很容易做到。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// HTML
&amp;lt;div className="layout"&amp;gt;
  &amp;lt;p&amp;gt;Lorem ipsum dolor sit amet...&amp;lt;/p&amp;gt;
  &amp;lt;button&amp;gt;Sign Up&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;

// CSS
.layout {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  min-height: 100vh;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在真机检查一下效果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af2efdbdaa284a7fa34578d51cdb0ad5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;酷! Git add, git commit, git push, oh yeah!&lt;/p&gt;
&lt;h2&gt;这有什么问题吗？&lt;/h2&gt;
&lt;p&gt;当然，是有的! 要看到这个问题，你需要在真实的手机或模拟器上查看你的应用程序。在本文中使用的 iPhone 13（iOS 15.2）进行测试，下面是结果:&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81dfd42e6c564138be3ed6403a9e3e0a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;啥，底部按钮跑哪里去了？&lt;/p&gt;
&lt;p&gt;顺便说一下，它在安卓手机上甚至不能按预期工作。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0c5c004f67448f8a931390b1d52e506~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;为什么100vh问题会发生在移动设备上？&lt;/h2&gt;
&lt;p&gt;我对这个问题进行了一番调查，发现了其中的原因。简短的答案是，浏览器的工具栏高度没有被考虑在内。如果你想深入了解为什么会发生这种情况，&lt;a href="https://stackoverflow.com/questions/37112218/css3-100vh-not-constant-in-mobile-browser"&gt;Stack Overflow的这个帖子&lt;/a&gt;很有帮助。&lt;/p&gt;
&lt;h2&gt;如何修复移动设备上的100vh问题？&lt;/h2&gt;
&lt;p&gt;第一个建议是尽量少用 &lt;code&gt;vh&lt;/code&gt;。例如，在上面的代码中，你可以使用一个 sticky 按钮，避免使用&lt;code&gt;vh&lt;/code&gt;单位。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// HTML
&amp;lt;div className="layout"&amp;gt;
  &amp;lt;p&amp;gt;Lorem ipsum dolor sit amet...&amp;lt;/p&amp;gt;
  &amp;lt;button&amp;gt;Sign Up&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;

// CSS
.layout {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  min-height: 100vh;
}
.layout button {
  position: sticky;
  bottom: 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="001.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b127408ff862403c9ac04a490afd0a6e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;它在横向模式下也很好:&lt;/p&gt;
&lt;p&gt;&lt;img alt="002.gif" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84a6522035dc474b907a9a48e4edc5fb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;说实话，结果是好的，但你不能总是用 &lt;code&gt;sticky&lt;/code&gt;  元素来解决 &lt;code&gt;100vh&lt;/code&gt; 的问题。&lt;/p&gt;
&lt;h2&gt;仅使用 CSS 在移动设备上修复 100VH 问题&lt;/h2&gt;
&lt;p&gt;时，使用 &lt;code&gt;vh&lt;/code&gt; 的目的是为了简单地创建与视口高度相等的部分。例如，当你在建立登陆页面时，这很常见。在这些情况下，&lt;code&gt;position sticky&lt;/code&gt;不会有帮助，这里介绍一下 &lt;code&gt;fill-available&lt;/code&gt;属性。它用起来很简单，只要记住使用前缀和回退值就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.layout {
  min-height: 100vh;            /* fall-back */
  min-height: -moz-available;
  min-height: -webkit-fill-available;
  min-height: fill-available;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="003.gif" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85f87adc32b94fa0afba91f05b73002e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;而且，当你旋转设备时，它还会更新高度，太棒了!&lt;/p&gt;
&lt;p&gt;&lt;img alt="004.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/383f36177dba4fbd96f941e41a0c3795~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;fill-available&lt;/code&gt; 修复 100vh 的问题确实很直接，但在调查这个解决方案时，也遇到过一些问题。&lt;/p&gt;
&lt;h2&gt;1. HTML类型声明问题&lt;/h2&gt;
&lt;p&gt;页面上有  &lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt; 声明，会使 &lt;code&gt;fill-available&lt;/code&gt; 在 Chrome 浏览器上无法正常工作。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbcb4ae466f8496798b5d59587621404~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;甚至不能在安卓浏览器上工作:&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd1d2786b1844113a67beda174ee59d0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;因此，为了解决这个问题，必须从页面中删除 &lt;code&gt;doctype&lt;/code&gt; 声明。&lt;/p&gt;
&lt;h2&gt;2. Safari上的垂直 padding  问题&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;min-height&lt;/code&gt;（或 &lt;code&gt;height&lt;/code&gt;）为 &lt;code&gt;fill-available&lt;/code&gt;的元素上添加垂直 &lt;code&gt;padding&lt;/code&gt; （bottom 和  top），Safari浏览器上会导致问题，高度不会正确。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e497d58e438644a38a65dd974db1d7d9~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;要解决这个问题，只需将你的内容包在另一个 &lt;code&gt;div&lt;/code&gt; 元素内，就可以了:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// HTML
&amp;lt;div class="screen"&amp;gt;
  &amp;lt;div class="content"&amp;gt;
    ...
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

// CSS
.screen {
  background-color: mediumpurple;
  min-height: 100vh;
  min-height: -moz-available;
  min-height: -webkit-fill-available;
  min-height: fill-available;
}
.content {
  color: #fff;
  display: flex;
  flex-direction: column;
  justify-content: center;
  height: 100%;
  padding: 30px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3. fill-available 不能与 &lt;code&gt;calc()&lt;/code&gt; 一起使用&lt;/h2&gt;
&lt;p&gt;需要注意的一件事是，不能在 &lt;code&gt;fill-available&lt;/code&gt; 属性下使用 &lt;code&gt;calc()&lt;/code&gt;。所以，下面的CSS规则就不会生效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;min-height: calc(-webkit-fill-available / 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如，如果需要在元素上有一半的可用高度，必须使用JavaScript。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用JavaScript修复移动设备上的100vh问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用 window 的 &lt;code&gt;innerHeight&lt;/code&gt; 属性，将元素 &lt;code&gt;height&lt;/code&gt; （或&lt;code&gt;minHeight&lt;/code&gt;）设置为&lt;code&gt;window.innerHeight&lt;/code&gt;，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang="en"&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;style&amp;gt;
    ...
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id="intro"&amp;gt;
  &amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;
  &amp;lt;h2&amp;gt;The height of this area is equal to...&amp;lt;/h2&amp;gt;
&amp;lt;/div&amp;gt;
...
&amp;lt;script&amp;gt;
  (function () {
    const el = document.getElementById('intro');
    el.style.minHeight = window.innerHeight + 'px';
  })();
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="005.gif" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51b76c0b4e2542219b46b55ed79509ef~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;接着，再介绍一种花销的方式。 一些开发者喜欢根据窗口的内部高度定义一个&lt;strong&gt;CSS变量&lt;/strong&gt;，并使用该变量来设计他们所需的元素。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 以像素为单位计算1vh值
// 基于窗口的内部高度
var vh = window.innerHeight * 0.01;

//  将CSS变量设置为根元素
// 相当于1vh
document.documentElement.style.setProperty('--vh', vh + 'px');
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 CSS 中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;min-height: calc(var(--vh) * 100);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一件事是当窗口被调整大小或设备方向改变时，重新计算这个值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function calculateVh() {
  var vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', vh + 'px');
}

// 初始计算
calculateVh();

// 调整大小时重新计算
window.addEventListener('resize', calculateVh);

// 在设备方向改变时重新计算
window.addEventListener('orientationchange', calculateVh);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在我看来，你应该先用CSS的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者：Mehdi Namvar  译者：前端小智 来源：mediun&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>前端小智</author><pubDate>Wed, 24 Aug 2022 16:17:31 GMT</pubDate></item><item><title>Vue 状态管理未来样子</title><link>https://juejin.cn/post/7133008213301002253</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着Vue 3越来越受重视并成为默认版本，许多事情正在发生变化，生态系统逐渐完善中。直到最近，Vue3 的状态管理默认推荐的是使用 Pinia。这节课，我们根据项目的规模，探索不同的状态管理方式，并尝试预测 Vue 中状态管理的未来会是什么样子。&lt;/p&gt;
&lt;h2&gt;响应式 API&lt;/h2&gt;
&lt;p&gt;在options API中，我们可以使用 &lt;code&gt;data()&lt;/code&gt; 选项为一个组件声明响应式数据。在内部，返回的对象被包在响应式帮助器中。这个帮助器也可以作为一个公共API使用。&lt;/p&gt;
&lt;p&gt;如果是多个数据被多个实例共享的状态，那么 可以使用 &lt;code&gt;reactive()&lt;/code&gt;来创建一个 &lt;strong&gt;reactive&lt;/strong&gt; 对象，然后从多个组件中导入它。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { reactive } from "vue";

export const store = {
  state: reactive({
    heroes: ['Aragorn', 'Legolas', 'Gimli', 'Gandalf']
  }),
  addHero(hero) {
    this.state.heroes.push(hero);
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这种方法，数据被集中起来，并可以在各个组件之间重复使用。这可能是一个简单的选择，对一个小的应用程序来说占用的空间最小。&lt;/p&gt;
&lt;h2&gt;组合&lt;/h2&gt;
&lt;p&gt;一个类似的概念，即&lt;strong&gt;composition API&lt;/strong&gt;带来的概念，是使用一个&lt;strong&gt;组合&lt;/strong&gt; 。这种模式在React 那么非常流行，结合Vue强大的响应性机制，可以编写一些优雅的、可重复使用的可组合，比如下面这些：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { ref, computed } from "vue";
import fakeApiCall from "../api";

export default function useFellowship() {
  const heroes = ref([]);
  const loading = ref(false);

  async function init() {
    loading.value = true;
    heroes.value = await fakeApiCall();
    loading.value = false;
  }
  return {
    heroes: computed(() =&amp;gt; heroes.value),
    loading: computed(() =&amp;gt; loading.value),
    init
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，可以这样使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;p v-if="loading"&amp;gt;Loading...&amp;lt;/p&amp;gt;
  &amp;lt;p v-else&amp;gt;Companions: {{ heroes.join(", ") }}&amp;lt;/p&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import useFellowship from "../composables/useFellowship";
import { computed } from "vue";
export default {
  name: "MiddleEarth",
  setup() {
    const { heroes, loading, init } = useFellowship();
    init();
    return {
      heroes: computed(() =&amp;gt; heroes.value),
      loading,
    };
  },
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事例地址：https://codesandbox.io/s/composables-middle-earth-07yc6h?file=/src/composables/useFellowship.js&lt;/p&gt;
&lt;p&gt;这种模式最初是为了取代 &lt;strong&gt;mixins&lt;/strong&gt; 而引入的，因为现在的组合比继承更受欢迎。但它也可以用来在组件之间共享状态。这也是许多为取代 Vuex 而出现的库背后的主要想法。&lt;/p&gt;
&lt;h2&gt;Vuex 4&lt;/h2&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f942f91a5b74423a9c2f362a39f8ea40~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vuex是不会消失的&lt;/strong&gt;。它支持Vue 3，具有相同的API和最小的破坏性变化（这可能是其他库应该注意的）。唯一的变化是，安装必须发生在一个 Vue 实例上，而不是直接安装在 Vue 原型上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { createApp } from 'vue'
import { store } from './store'
import App from './App.vue'

const app = createApp(App)

app.use(store)

app.mount('#app')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vuex 4 仍在维护中。不过，不会再有很多新的功能被添加到它里面。如果你已经有一个使用&lt;strong&gt;Vuex 3&lt;/strong&gt;的项目，并想推迟迁移到其他东西上，这是一个不错的选择。&lt;/p&gt;
&lt;h2&gt;Pinia&lt;/h2&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad9c48ee71a244f18acf836a756624d9~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;Pinia 开始是一个实验，但很快就成为 Vue 3 的主要选择。它提供了比 Vuex 更多的 API ，有更好的架构和更直观的语法，充分利用了组合API。&lt;/p&gt;
&lt;p&gt;在开发工具的支持上（状态检查、带动作的时间线和时间旅行的能力），以及 Vuex 所提供的使用插件的扩展性，pinia 在设计上是类型安全和模块化的，这是使用Vuex时最大的两个痛点。&lt;/p&gt;
&lt;p&gt;此外，定义 story 的语法与 Vuex 模块非常相似，这使得迁移的工作量非常小，而在使用该 store 时，用到的 API，接近于 Vue3 使用组合API的方式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { defineStore } from 'pinia'

export const useFellowship = defineStore('fellowship', {
  state: () =&amp;gt; {
    return { heroes: ['Aragorn', 'Legolas', 'Gimli', 'Gandalf'] }
  },
  actions: {
    addHero(hero) {
      this.heroes.push(hero)
    },
  },
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
import { useFellowship } from '@/stores/fellowship'
export default {
  setup() {
    const fellowship = useFellowship()
    
    // 对状态的访问 
    //可以直接进行
    console.log(fellowship.heroes)
    
    // Using an action
    fellowship.addHero('Boromir')
  },
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可能已经注意到的，最大的区别是 &lt;strong&gt;mutations 完全消失了&lt;/strong&gt;。它们通常被认为是极其冗长的，而使用它们没有任何真正的好处。此外，也不再需要命名空间了。有了新的导入 store 的方式，所有的东西都被&lt;strong&gt;设计成了命名空间&lt;/strong&gt;。这意味着，在 Pinia 中，你没有一个带有多个模块的 store ，而是有多个按需导入和使用的 store 。&lt;/p&gt;
&lt;h2&gt;Pinia Setup  Store&lt;/h2&gt;
&lt;p&gt;Pinia支持另一种语法来定义 store。它使用一个定义响应式属性和方法的函数，并返回它们，与Vue Composition API的 setup 函数非常相似。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { defineStore } from 'pinia'

export const useFellowship = defineStore('fellowship', () =&amp;gt; {
  const heroes = ref([]);
  
  function addHero(hero) {
    heroes.value.push(hero)
  }
  return {
    heroes,
    addHero
  };
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Setup Stores 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ref()&lt;/code&gt; 成为 &lt;code&gt;state&lt;/code&gt; 属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;computed()&lt;/code&gt; 成为 &lt;code&gt;getters&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;function()&lt;/code&gt; 成为 &lt;code&gt;actions&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://pinia.vuejs.org/core-concepts/#setup-stores"&gt;Setup stores&lt;/a&gt; 比  &lt;a href="https://pinia.vuejs.org/core-concepts/#option-stores"&gt;Options Store&lt;/a&gt; 带来了更多的灵活性，因为可以在一个 store  内创建 watchers ，并自由使用任何可组合的。&lt;/p&gt;
&lt;h2&gt;一个更实际的例子&lt;/h2&gt;
&lt;p&gt;创建一个 fellowship store，它可以容纳一个 &lt;code&gt;heroes&lt;/code&gt; 列表，并能添加和删除对应的元素：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { defineStore } from 'pinia'

export const useFellowship = defineStore('fellowship', {
  state: () =&amp;gt; ({
    heroes: [],
    filter: 'all',
    // type will be automatically inferred to number
    id: 1
  }),
  getters: {
    aliveHeroes(state) {
      return state.heroes.filter((hero) =&amp;gt; hero.isAlive)
    },
    deadHeroes(state) {
      return state.heroes.filter((hero) =&amp;gt; !hero.isAlive)
    },
    filteredHeroes() {
      switch (this.filter) {
        case 'alive':
          return this.aliveHeroes
        case 'dead':
          return this.deadHeroes
        default:
          return this.heroes
      }
    }
  },
  actions: {
    addHero(name) {
      if (!name) return
      // Directly mutating the state!
      this.heroes.push({ name, id: this.id++, isAlive: true })
    },
    killHero(name) {
      this.heroes = this.heroes.map((hero) =&amp;gt; {
        if (hero.name === name) {
          hero.isAlive = false
        }
        return hero
      })
    },
    setActiveFilter(filter) {
      this.filter = filter
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你熟悉Vuex，那么理解这段代码应该不是什么难事。&lt;/p&gt;
&lt;p&gt;首先，每个 state 都需要一个作为命名空间的键。这里，我们使用 &lt;code&gt;fellowship&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;state&lt;/code&gt; 是一个函数，保存这个 store 的所有响应性数据，&lt;code&gt;getters&lt;/code&gt; 是访问 store 里面的数据。&lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;getters&lt;/code&gt; 都与Vuex相同。&lt;/p&gt;
&lt;p&gt;但对于 actions 来说与 Vuex 差异比较大。上下文参数已经消失了，actions 可以直接通过 &lt;code&gt;this&lt;/code&gt; 访问 state  和 getters 。你可能已经注意到的，actions 直接操作 state，这在Vuex 中是被严格禁止的。&lt;/p&gt;
&lt;p&gt;最后，由于状态操作现在是在 actions 进行的，所以 mutations  被完全删除。&lt;/p&gt;
&lt;p&gt;使用 pinia store  很简单:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
import { useFellowship } from '../store/fellowship'
import HeroFilters from './HeroFilters'
export default {
  name: 'MiddleEarth',
  components: {
    HeroFilters
  },
  setup() {
    const fellowship = useFellowship()
    return {
      fellowship
    }
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;template v-if="fellowship.heroes.length"&amp;gt;
      &amp;lt;HeroFilters /&amp;gt;
      &amp;lt;ol&amp;gt;
        &amp;lt;li v-for="hero in fellowship.filteredHeroes" :key="hero.id"&amp;gt;
          {{ hero.name }} - {{ hero.isAlive ? 'Alive' : 'Dead' }}
          &amp;lt;button v-if="hero.isAlive" @click="fellowship.killHero(hero.name)"&amp;gt;Kill&amp;lt;/button&amp;gt;
        &amp;lt;/li&amp;gt;
      &amp;lt;/ol&amp;gt;
    &amp;lt;/template&amp;gt;
    &amp;lt;p v-else&amp;gt;Your fellowship is empty&amp;lt;/p&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;input type="text" ref="heroName" /&amp;gt;
      &amp;lt;input type="button" value="Add new hero" @click="fellowship.addHero($refs.heroName.value)" /&amp;gt;
      &amp;lt;p&amp;gt;
        Sugestions:
        &amp;lt;button
          v-for="suggestion in ['Aragorn', 'Legolas', 'Gimli']"
          :key="suggestion"
          @click="fellowship.addHero(suggestion)"
        &amp;gt;
          {{ suggestion }}
        &amp;lt;/button&amp;gt;
      &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有的逻辑都发生在 &lt;code&gt;setup&lt;/code&gt; 函数中。导入的 &lt;code&gt;useFellowship&lt;/code&gt; 钩子被执行并返回。这样在 template 就可以直接。&lt;/p&gt;
&lt;p&gt;当然，这个组件应该被分解成更小的可重复使用的组件，但为了演示的目的，就先这样吧。&lt;/p&gt;
&lt;p&gt;如果一个不同的组件需要访问相同的 state，可以用类似的方式来完成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
import { useFellowship } from '../store/fellowship'
export default {
  name: 'HeroFilters',
  setup() {
    const fellowship = useFellowship()
    return {
      fellowship
    }
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    Filter:
    &amp;lt;div v-for="filter in ['all', 'dead', 'alive']" :key="filter"&amp;gt;
      &amp;lt;input
        type="radio"
        :value="filter"
        :id="filter"
        @click="fellowship.setActiveFilter(filter)"
        v-model="fellowship.filter"
      /&amp;gt;
      &amp;lt;label :for="filter"&amp;gt;{{ filter }}&amp;lt;/label&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事例地址：https://codesandbox.io/s/pinia-playground-brgy58?file=/src/components/MiddleEarth.vue&lt;/p&gt;
&lt;h2&gt;从 Vuex 迁移到 Pinia&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://pinia.vuejs.org/cookbook/migration-vuex.html"&gt;Pinia的文档很乐观&lt;/a&gt;，认为代码可以在库之间重复使用，但事实是，架构非常不同，肯定需要重构。首先，在Vuex中，我们有一个带有多个模块的 store ，而 Pinia 是围绕着多个 store  的概念建立的。将这一概念过渡到Pinia 中的最简单方法是，以前使用的每个模块现在都是一个 store 。&lt;/p&gt;
&lt;p&gt;此外，&lt;code&gt;mutations&lt;/code&gt;  不再存在。相反，这些应该转换为直接访问和改变状态的操作。&lt;/p&gt;
&lt;p&gt;Actions  不再接受上下文作为其第一个参数。它们应该被更新以直接访问状态或任何其他上下文属性。这同样适用于 &lt;code&gt;rootState&lt;/code&gt;、&lt;code&gt;rootGetters&lt;/code&gt;等，因为单一全局存储的概念并不存在。如果你想使用另一个 store，需要明确地导入它。&lt;/p&gt;
&lt;p&gt;很明显，对于大型项目来说，迁移将是复杂和耗时的，但希望大量的模板代码将被消除，store 将遵循一个更干净和模块化的架构。改造可以逐个模块进行，而不是一次性改造所有内容。实际上，在迁移过程中，可以将 Pinea 和Vuex混合在一起，这种方法对于复杂的项目来说也是不错的选择。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68444c05cd3645fba267226da322c299~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;预测未来并不容易，但就目前而言，Pinea 是最安全的赌注。它提供了一个模块化的架构，通过设计实现类型安全，并消除了模板代码。如果你要用Vue 3开始一个新的项目，Pinia 是值得推荐的选择。&lt;/p&gt;
&lt;p&gt;如果你已经在使用Vuex，你可以在迁移到Pinia之前升级到第4版，因为这个过程看起来很简单，但需要大量的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者：Fotis Adamakis  译者：前端小智 来源：mediun&lt;/p&gt;
&lt;p&gt;原文：
https://fadamakis.medium.com/the-future-of-state-management-in-vue-js-fa3f94865d1f&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>前端小智</author><pubDate>Wed, 17 Aug 2022 16:36:01 GMT</pubDate></item><item><title>Vue3中defineEmits、defineProps 是怎么做到不用引入就能直接用的</title><link>https://juejin.cn/post/7132265712780836894</link><description>&lt;p&gt;新出了一个系列：&lt;a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI0NDQ0ODU3MA==&amp;amp;action=getalbum&amp;amp;album_id=2509459125236416515&amp;amp;from_itemidx=2&amp;amp;from_msgid=2247510879&amp;amp;scene=173&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect"&gt;Vue2与Vue3 技巧小册&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近正在将一个使用单文件组件的 Options API 的 Vue2 JavaScript 项目升级为 Vue3 typescript，并利用 Composition API 的优势。&lt;/p&gt;
&lt;p&gt;比如，下面这种 &lt;strong&gt;选项API&lt;/strong&gt; 方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export default {
  props: {
    name: {
      type: String,
      required: true.
    }
  },
  emits: ['someEvent', 'increaseBy']
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们将它转成 &lt;strong&gt;组合API&lt;/strong&gt; 方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; const props = defineProps&amp;lt;{
  name: string;
 }&amp;gt;();
 const emit = defineEmits&amp;lt;{
  (event: 'someEvent): void;
  (event: 'increaseBy', value: number): void;
 }&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从 &lt;strong&gt;选项API&lt;/strong&gt; 的 &lt;code&gt;emit&lt;/code&gt; 和 &lt;code&gt;props&lt;/code&gt; 到 &lt;strong&gt;组合API&lt;/strong&gt; 的 &lt;code&gt;defineemit&lt;/code&gt; 和 &lt;code&gt;defineProps&lt;/code&gt; 函数的基于&lt;a href="https://vuejs.org/guide/typescript/composition-api.html"&gt;类型语法&lt;/a&gt;的转换并不简单。我也很好奇 Vue 是如何处理接口的。&lt;/p&gt;
&lt;p&gt;TypeScript 接口是只在设计和编译时存在的结构。它们在JavaScript运行时之前被过滤掉，那么它们是如何影响组件的行为的呢?&lt;/p&gt;
&lt;p&gt;我想知道是否有办法看到Vue如何解释传递给 &lt;code&gt;defineEmits&lt;/code&gt; 和 &lt;code&gt;defineProps&lt;/code&gt; 的通用参数。如果你注意到文档中说你不需要导入 &lt;code&gt;defineEmits&lt;/code&gt; 和 &lt;code&gt;defineProps&lt;/code&gt; 函数。这是因为它们实际上是同名的JavaScript函数的&lt;a href="https://github.com/vuejs/core/blob/a95554d35c65e5bfd0bf9d1c5b908ae789345a6d/packages/compiler-sfc/src/compileScript.ts#L58-L62"&gt;宏&lt;/a&gt;。在进行完整的 TypeScript 传递之前，Vue webpack插件使用TypeScript的 AST（抽象语法树）来推导JavaScript版本的函数选项。&lt;/p&gt;
&lt;p&gt;如果不是因为宏:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; defineProps&amp;lt;{
    prop1: string;
    prop2: number;
  }&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就会变成:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; defineProps();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就会导致参数缺失的错误。&lt;/p&gt;
&lt;p&gt;如果看一下Vue的 SFC（单文件组件）编译器源代码，有一个叫做 &lt;a href="https://github.com/vuejs/core/blob/a95554d35c65e5bfd0bf9d1c5b908ae789345a6d/packages/compiler-sfc/src/compileScript.ts#L141"&gt;compileScript&lt;/a&gt; 的函数。我开始尝试用最少的参数来调用这个函数，这样就不会出错，并模拟任何不重要的必要参数。最终发现了另一个叫 &lt;a href="https://github.com/vuejs/core/blob/a95554d35c65e5bfd0bf9d1c5b908ae789345a6d/packages/compiler-sfc/src/parse.ts#L96"&gt;parse&lt;/a&gt; 的函数。这给了我所需的大部分参数，只剩下要mock的组件 &lt;code&gt;id&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里有一个小脚本，它接收SFC的 &lt;code&gt;.vue&lt;/code&gt;文件并输出 Vue 如何解释 TypeScript。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { readFile, writeFile } from "fs";
import parseArgs from "minimist";
import { parse, compileScript } from "@vue/compiler-sfc";
const { file, out } = parseArgs(process.argv.slice(2), {
  string: ["file", "out"],
  alias: {
    file: "f",
    out: "o"
  }
});
const filename = file;
const mockId = "xxxxxxxx";
readFile(filename, "utf8", (err, data) =&amp;gt; {
  const { descriptor } = parse(data, {
    filename
  });
  const { content } = compileScript(descriptor, {
    inlineTemplate: true,
    templateOptions: {
      filename
    },
    id: mockId
  });
  if (out) {
    writeFile(out, "utf8", content);
  } else {
    process.stdout.write(content);
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;事例地址：https://stackblitz.com/edit/node-fzuykn?file=index.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如，有如以下组件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface Bar {
  prop1: string;
  prop2: number;
}

defineProps&amp;lt;{
  bar: Bar;
  bars: Bar[];
  asdf1?: boolean;
  asdf2: string[];
}&amp;gt;();

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface Bar {
  prop1: string;
  prop2: number;
}

export default /*#__PURE__*/_defineComponent({
  __name: 'demo',
  props: {
    bar: { type: Object, required: true },
    bars: { type: Array, required: true },
    asdf1: { type: Boolean, required: false },
    asdf2: { type: Array, required: true }
  },
  setup(__props: any) {
    return (_ctx: any,_cache: any) =&amp;gt; {
      return (_openBlock(), _createElementBlock("div"))
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正如上面所看到的，SFC编译器采用TypeScript类型信息，并建立了 &lt;code&gt;props&lt;/code&gt; 对象。原始类型是一对一的。接口变成对象，而 &lt;code&gt;?&lt;/code&gt; 可选语法驱动 &lt;code&gt;required&lt;/code&gt; 的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者：romaopedro  译者：前端小智 来源：logrocket
https://unicorn-utterances.com/posts/vue-composition-inspector&lt;/p&gt;</description><author>前端小智</author><pubDate>Mon, 15 Aug 2022 16:35:41 GMT</pubDate></item><item><title>试试使用 Vitest 进行组件测试，确实很香。</title><link>https://juejin.cn/post/7129667747134308389</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;什么是Vitest？&lt;/h2&gt;
&lt;p&gt;自从 &lt;strong&gt;尤大&lt;/strong&gt; 的构建工具Vite获得了巨大的人气，现在有了一个由它驱动的极快的单元测试框架。&lt;strong&gt;Vitest&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Vitest 与 Jest 兼容，具有开箱即用的 ESM、Typescript 和 JSX 支持，并且由 &lt;strong&gt;esbuild&lt;/strong&gt; 提供支持。它在测试过程中使用 Vite 开发服务器来转换你的文件，并监听你的应用程序的相同配置（通过&lt;code&gt;vite.config.js&lt;/code&gt;），从而消除了使用Jest等测试替代品所涉及的重复工作。&lt;/p&gt;
&lt;h2&gt;为什么选择Vitest？&lt;/h2&gt;
&lt;p&gt;Vite是一个构建工具，旨在为现代 web 项目提供更快、更精简的开发体验，它开箱即用，支持常见的 web  模式、&lt;code&gt;glob&lt;/code&gt;导入和 &lt;strong&gt;SSR&lt;/strong&gt; 等功能。它的许多插件和集成正在促进一个充满活力的生态系统。&lt;/p&gt;
&lt;p&gt;但这导致了一个新问题：如何在Vite上编写单元测试。&lt;/p&gt;
&lt;p&gt;将Jest等框架与Vite一起使用，导致Vite和Jest之间有很多重复的配置，而 Vitest 解决了这一问题，它消除了为我们的应用程序编写单元测试所需的额外配置。Vitest 使用与 Vite 相同的配置，并在开发、构建和测试时共享一个共同的转换管道。它还可以使用与 Vite 相同的插件API进行扩展，并与Jest的API兼容，以方便从Jest迁移，而不需要做很多重构工作。&lt;/p&gt;
&lt;p&gt;因此，Vitest 的速度也非常快。&lt;/p&gt;
&lt;h2&gt;如何使用 Vitest 来测试组件&lt;/h2&gt;
&lt;h3&gt;安装 Vitest&lt;/h3&gt;
&lt;p&gt;在项目中使用 &lt;code&gt;Vitest&lt;/code&gt; 需要 &lt;code&gt;Vite &amp;gt;=v2.7.10&lt;/code&gt; 和 &lt;code&gt;Node &amp;gt;=v14&lt;/code&gt; 才能工作。&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;npm&lt;/code&gt;、&lt;code&gt;yarn&lt;/code&gt; 或 &lt;code&gt;pnpm&lt;/code&gt; 来安装 Vitest，根据自己的喜好，在终端运行以下命令：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NPM&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -D vitest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;YARN&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yarn add -D vitest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PNPM&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pnpm add -D vitest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e83bc8229d474498882e8332db9fcf98~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;Vitest 配置&lt;/h2&gt;
&lt;p&gt;安装完 Vitest 后，需要将其添加到 &lt;code&gt;vite.config.js&lt;/code&gt; 文件中:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vite.config.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

export default defineConfig({
    plugins: [vue()],
    //add test to vite config
    test: {
        // ...
    },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为 TypeScript 配置 Vitest 是类似的，但如果从 Vite 导入 &lt;code&gt;defineConfig&lt;/code&gt;，我们需要在配置文件的顶部使用三斜线命令添加对 Vitest 类型的引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/// &amp;lt;reference types="vitest" /&amp;gt;
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
// https://vitejs.dev/config/

export default defineConfig({
    plugins: [vue()],
    test: {
        // ...
    },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值得注意的是，Vitest 也可以在项目中通过在根文件夹中添加 &lt;code&gt;vitest.config.js&lt;/code&gt; 文件来配置。如果这个文件存在，它将优先于 &lt;code&gt;vite.config.js&lt;/code&gt; 来配置Vitest。Vitest 也允许额外的配置，可以在&lt;a href="https://vitest.dev/config/#configuration"&gt;配置&lt;/a&gt;页面中找到。&lt;/p&gt;
&lt;h2&gt;事例演示：Notification&lt;/h2&gt;
&lt;p&gt;为了看看Vitest的运作情况，我们创建一个显示三种类型通知的通知组件：&lt;code&gt;info&lt;/code&gt;、&lt;code&gt;error&lt;/code&gt; &lt;code&gt;和success&lt;/code&gt;。这个组件的每个状态如下所示：&lt;/p&gt;
&lt;h3&gt;info&lt;/h3&gt;
&lt;p&gt;&lt;img alt="2397151611-62ef6b8a2c5ec.webp" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aedf37442beb45ff923c5347be5796c0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;error&lt;/h3&gt;
&lt;p&gt;&lt;img alt="433512350-62ef6ba12a0f9.webp" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51e8e9f3392f425a87f4121a00389a5d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;success&lt;/h3&gt;
&lt;p&gt;&lt;img alt="2957620330-62ef6c2cc37e3.webp" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1df8ac15b12e4063956457e691a1a553~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;notification.vue &lt;/code&gt;内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div
    :class="[
      'notification',
      type === 'error' ? 'notification--error' : null,
      type === 'success' ? 'notification--success' : null,
      type === 'info' ? 'notification--info' : null,
      message &amp;amp;&amp;amp; message.length &amp;gt; 0 ? 'notification--slide' : null,
    ]"
  &amp;gt;
    &amp;lt;img
      src="https://res.cloudinary.com/djalafcj9/image/upload/v1634261166/getequityV2/denied_sbmv0e.png"
      v-if="type === 'error'"
    /&amp;gt;
    &amp;lt;img
      src="https://res.cloudinary.com/djalafcj9/image/upload/v1656690265/getequityV2/Frame_irxz3e.png"
      v-if="type === 'success'"
    /&amp;gt;
    &amp;lt;img
      src="https://res.cloudinary.com/djalafcj9/image/upload/v1634261166/getequityV2/pending_ctj1ke.png"
      v-if="type === 'info'"
    /&amp;gt;
    &amp;lt;p class="notification__text"&amp;gt;
      {{ message }}
    &amp;lt;/p&amp;gt;
    &amp;lt;button
      ref="closeButton"
      class="notification__button"
      @click="$emit('clear-notification')"
    &amp;gt;
      &amp;lt;img
        src="https://res.cloudinary.com/djalafcj9/image/upload/v1635485821/getequityV2/close_muxdyb.png"
      /&amp;gt;
    &amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    name: "Notification",
    emits: ['clear-notification'],
    props: {
      type: {
        type: String,
        default: null,
      },
      message: {
        type: String,
        default: null,
      },
    },
  };
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
  .notification {
    transition: all 900ms ease-out;
    opacity: 0;
    z-index: 300001;
    transform: translateY(-100vh);
    box-sizing: border-box;
    padding: 10px 15px;
    width: 100%;
    max-width: 730px;
    /* margin: 0 auto; */
    display: flex;
    position: fixed;
    /* left: 0; */
    top: 20px;
    right: 15px;
    justify-content: flex-start;
    align-items: center;
    border-radius: 8px;
    min-height: 48px;
    box-sizing: border-box;
    color: #fff;
  }

  .notification--slide {
    transform: translateY(0px);
    opacity: 1;
  }

  .notification--error {
    background-color: #fdecec;
  }

  .notification__text {
    margin: 0;
    margin-left: 17px;
    margin-right: auto;
  }

  .notification--error .notification__text {
    color: #f03d3e;
  }

  .notification--success {
    background-color: #e1f9f2;
  }

  .notification--success &amp;gt; .notification__text {
    color: #146354;
  }

  .notification--info {
    background-color: #ffb647;
  }

  .notification__button {
    border: 0;
    background-color: transparent;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里，我们使用 &lt;code&gt;message&lt;/code&gt; prop创建了一个显示动态消息的组件。我们还利用 &lt;code&gt;type&lt;/code&gt; prop 来设计这个组件的背景和文本，并利用这个 &lt;code&gt;type&lt;/code&gt; prop  显示我们计划的不同图标（error, success, info）。&lt;/p&gt;
&lt;p&gt;最后，我们有一个按钮，用来通过发出一个自定义事件：&lt;code&gt;clear-notification&lt;/code&gt;来解除通知。&lt;/p&gt;
&lt;h2&gt;我们应该测试什么？&lt;/h2&gt;
&lt;p&gt;现在我们对需要测试的组件的结构有了了解，我们可以再思考一下，这个组件需要做什么，以达到预期的功能。&lt;/p&gt;
&lt;p&gt;我们的测试需要检查以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该组件根据通知类型渲染出正确的样式。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;message&lt;/code&gt;  为空时，通知就会逐渐消失。&lt;/li&gt;
&lt;li&gt;当关闭按钮被点击时，该组件会发出一个事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了测试这些功能，在项目中添加一个 &lt;code&gt;notification.test.js&lt;/code&gt; 用于测试。&lt;/p&gt;
&lt;h2&gt;安装测试依赖项&lt;/h2&gt;
&lt;p&gt;在编写单元测试时，可能会有这样的情况：我们需要用一个什么都不做的假组件来替换组件的现有实现。这被称为 &lt;strong&gt;stub(存根)&lt;/strong&gt;，为了在测试中使用存根，我们需要访问Vue Test Utils的&lt;code&gt;mount&lt;/code&gt;方法，这是Vue.js的官方&lt;a href="https://test-utils.vuejs.org/"&gt;测试工具库&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在我们来安装Vue Test Utils。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;npm install --save-dev @vue/test-utils@next

# or

yarn add --dev @vue/test-utils@next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，在我们的测试文件中，我们可以从&lt;code&gt;"@vue/test-utils"&lt;/code&gt;导入 &lt;code&gt;mount&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.test.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { mount } from "@vue/test-utils";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在测试中，我们还需要能够模拟 DOM。Vitest目前同时支持 &lt;code&gt;happy-dom&lt;/code&gt; 和 &lt;code&gt;jsdom&lt;/code&gt;。对于这个演示，我们将使用&lt;code&gt;happy-dom&lt;/code&gt;，然后安装它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yarn add happy-dom --dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装后，我们可以在测试文件的顶部添加以下注释...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.test.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @vitest-environment happy-dom
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.或者将此添加到 &lt;code&gt;vite/vitest&lt;/code&gt; 配置文件中，以避免在有多个需要 &lt;code&gt;happy-dom&lt;/code&gt; 工作的测试文件时出现重复情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vite.config.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
// https://vitejs.dev/config/
export default defineConfig({
    plugins: [vue()],
    test: {
        environment: "happy-dom",
    },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为我们只有一个测试文件，所以我们可以选择第一个选项，所以我们测试文件内容如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.test.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @vitest-environment happy-dom
 */

import { mount } from "@vue/test-utils";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这些依赖关系，我们现在可以导入我们要测试的组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.test.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @vitest-environment happy-dom
 */

import { mount } from "@vue/test-utils";
import notification from "../components/notification.vue";
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;常见的Vitest方法&lt;/h2&gt;
&lt;p&gt;为了编写测试，我们需要利用以下常见的方法，这些方法可以从 Vitest 导入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;describe&lt;/code&gt;：这个函数接受一个名字和一个函数，用于将相关的测试组合在一起。当你为一个有多个测试点（如逻辑和外观）的组件编写测试时，它就会很方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;test/it&lt;/code&gt;：这个函数代表被测试的实际代码块。它接受一个字符串，通常是测试案例的名称或描述（例如，渲染成功的正确样式）和另一个函数，所有的检查和测试在这里进行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;expect&lt;/code&gt;： 这个函数用于测试值或创建断言。它接受一个预期为实际值（字符串、数字、对象等）的参数&lt;strong&gt;x&lt;/strong&gt;，并使用任何支持的方法对其进行评估（例如&lt;code&gt;toEqual(y)&lt;/code&gt;，检查 x 是否与 y 相同）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，我们现在将这些导入我们的测试文件中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.test.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @vitest-environment happy-dom
 */

import { mount } from "@vue/test-utils";
import notification from "../components/notification.vue";
import { describe, expect, test } from "vitest";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这些函数，我们开始构建我们的单元测试。&lt;/p&gt;
&lt;h2&gt;建立 Vitest 单元测试&lt;/h2&gt;
&lt;p&gt;首先使用 &lt;code&gt;describe&lt;/code&gt;  方法将测试分组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.test.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;describe("notification.vue", () =&amp;gt; {
    
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;describe&lt;/code&gt; 块内，我们添加每个实际的测试。&lt;/p&gt;
&lt;p&gt;我们第一个要测试的用例是：&lt;strong&gt;组件根据通知类型渲染出正确的样式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.test.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;describe("notification.vue", () =&amp;gt; {
    test("renders the correct style for error", () =&amp;gt; {

    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;renders the correct style for error&lt;/code&gt; 表示 &lt;code&gt;test&lt;/code&gt; 所检查的内容的 &lt;strong&gt;name&lt;/strong&gt;。它有助于为代码块检查的内容提供上下文，这样就可以由原作者以外的人轻松维护和更新。它也使人们容易识别一个特定的失败的测试案例。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dc53c1159384e73bc06784b8032ea78~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.test.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;describe("notification.vue", () =&amp;gt; {
    test("renders the correct style for error", () =&amp;gt; {
       const type = "error";
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在我们组件中，定义了一个 &lt;code&gt;type&lt;/code&gt; 参数，它接受一个字符串，用来决定诸如背景颜色、图标类型和文本颜色在组件上的渲染。在这里，我们创建一个变量 &lt;code&gt;type&lt;/code&gt;，并将我们正在处理的类型之一，error （&lt;code&gt;error&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, 或 &lt;code&gt;success&lt;/code&gt;）分配给它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.test.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;describe("notification.vue", () =&amp;gt; {
    test("renders the correct style for error", () =&amp;gt; {
        const type = "error";
        const wrapper = mount(notification, {
            props: { type },
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里，我们使用 &lt;code&gt;mount&lt;/code&gt; 来存根我们的组件，以便进行测试。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mount&lt;/code&gt; 接受组件作为第一个参数，接受一个选项列表作为第二个参数。这些选项提供了不同的属性，目的是确保你的组件能在浏览器中正常工作。&lt;/p&gt;
&lt;p&gt;在这个列表中，我们只需要 &lt;code&gt;props&lt;/code&gt; 属性。我们使用这个属性是因为我们的 &lt;code&gt;notification.vue&lt;/code&gt;组件至少需要一个 &lt;strong&gt;prop&lt;/strong&gt; 才能有效工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.test.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;describe("notification.vue", () =&amp;gt; {
    test("renders the correct style for error", () =&amp;gt; {
        const type = "error";
        const wrapper = mount(notification, {
            props: { type },
        });
        expect(wrapper.classes()).toEqual(
            expect.arrayContaining(["notification--error"])
        );
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这一点上，剩下的就是写一个断言，或者更好的是，写出我们组件的预期行为，即：&lt;code&gt;renders the correct style for error&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了做到这一点，我们使用了 &lt;code&gt;expect&lt;/code&gt; 方法。它接受我们的存根组件和所有的选项（在我们的例子中，我们把它命名为&lt;code&gt;wrapper&lt;/code&gt;以方便参考）。&lt;/p&gt;
&lt;p&gt;这个方法可以被链接到其他一些方法上，但是对于这个特定的断言，我们要重新检查组件的类列表是否返回一个包含这个 &lt;code&gt;notification——error&lt;/code&gt; 的数组。。&lt;/p&gt;
&lt;p&gt;我们使用 &lt;code&gt;classes&lt;/code&gt; 函数来实现这一点，该函数返回包含该组件所有类的数组。在这之后，下一件事就是使用 &lt;code&gt;toEqual&lt;/code&gt; 函数进行比较，它检查一个值 &lt;strong&gt;X&lt;/strong&gt; 是否等于** Y**。在这个函数中，我们检查它是否返回一个包含我们的类的数组: &lt;code&gt;notification--error&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同样，对于 type 为 &lt;code&gt;success&lt;/code&gt; 或 &lt;code&gt;info&lt;/code&gt; 类型，测试过程也差不多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { mount } from "@vue/test-utils";
import notification from "../components/notification.vue";
import { describe, expect, test } from "vitest";
describe("notification.vue", () =&amp;gt; {
    test("renders correct style for error", () =&amp;gt; {
        const type = "error";
        const wrapper = mount(notification, {
            props: { type },
        });
        expect(wrapper.classes()).toEqual(
            expect.arrayContaining(["notification--error"])
        );
    });

    test("renders correct style for success", () =&amp;gt; {
        const type = "success";
        const wrapper = mount(notification, {
            props: { type },
        });
        expect(wrapper.classes()).toEqual(
            expect.arrayContaining(["notification--success"])
        );
    });

    test("renders correct style for info", () =&amp;gt; {
        const type = "info";
        const wrapper = mount(notification, {
            props: { type },
        });
        expect(wrapper.classes()).toEqual(
            expect.arrayContaining(["notification--info"])
        );
    });

    test("slides down when message is not empty", () =&amp;gt; {
        const message = "success";
        const wrapper = mount(notification, {
            props: { message },
        });
        expect(wrapper.classes()).toEqual(
            expect.arrayContaining(["notification--slide"])
        );
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这，我们已经写好了测试，以确保我们的通知是根据其类型来进行样式设计的。当用户点击组件上的关闭按钮时，我们会重置 &lt;code&gt;message&lt;/code&gt; 参数。根据我们的代码，我们要根据这个 &lt;code&gt;message&lt;/code&gt; 参数的值来添加或删除 &lt;code&gt;notification--slide&lt;/code&gt; 类，如下所示:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div
    :class="[
      'notification',
      type === 'error' ? 'notification--error' : null,
      type === 'success' ? 'notification--success' : null,
      type === 'info' ? 'notification--info' : null,
      message &amp;amp;&amp;amp; message.length &amp;gt; 0 ? 'notification--slide' : null,
    ]"
  &amp;gt;
//...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们要测试这个特定的断言，它的内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test("slides up when message is empty", () =&amp;gt; {
        const message = "";
        const wrapper = mount(notification, {
            props: { message },
        });
        expect(wrapper.classes("notification--slide")).toBe(false);
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这段测试代码中，我们用一个空字符串创建一个 &lt;code&gt;message&lt;/code&gt; 变量，并把它作为一个 prop 传递给我们的组件。&lt;/p&gt;
&lt;p&gt;之后，我们检查我们组件的类数组，确保它不包括 &lt;code&gt;notification--slide&lt;/code&gt; 类，该类负责使我们的组件向下/向外滑动到用户的视图。为了做到这一点，我们使用 &lt;code&gt;toBe&lt;/code&gt; 函数，它接收一个值&lt;strong&gt;A&lt;/strong&gt;，并试图检查它是否与 &lt;strong&gt;B&lt;/strong&gt; 相同。&lt;/p&gt;
&lt;p&gt;我们还想测试一下，每当组件上的按钮被点击，它就会发出一个事件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test("emits event when close button is clicked", async() =&amp;gt; {
        const wrapper = mount(notification, {
            data() {
                return {
                    clicked: false,
                };
            },
        });
        const closeButton = wrapper.find("button");
        await closeButton.trigger("click");
        expect(wrapper.emitted()).toHaveProperty("clear-notification");
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个测试块中，我们使用了一个 &lt;strong&gt;async&lt;/strong&gt;  函数，因为我们将触发一个事件，它返回一个 Promise，我们需要等待这个 Promise 的解决，以便捕捉这个事件所引起的变化。我们还使用了&lt;code&gt;data&lt;/code&gt;函数，并添加了一个 &lt;code&gt;clicked&lt;/code&gt; 属性，当点击时将被切换。&lt;/p&gt;
&lt;p&gt;到这，我们需要触发这个点击事件，我们首先通过使用 &lt;code&gt;find&lt;/code&gt; 函数来获得按钮。这个函数与&lt;code&gt;querySelector&lt;/code&gt;相同，它接受一个类、一个id或一个属性，并返回一个元素。&lt;/p&gt;
&lt;p&gt;在找到按钮后，使用 &lt;a href="https://test-utils.vuejs.org/api/#trigger"&gt;trigger&lt;/a&gt; 方法来触发一个点击事件。这个方法接受要触发的事件名称（click, focus, blur, keydown等），执行这个事件并返回一个 promise。出于这个原因，我们等待这个动作，以确保在我们根据这个事件做出断言之前，已经对我们的DOM进行了改变。&lt;/p&gt;
&lt;p&gt;最后，我们使用返回一个数组的 &lt;code&gt;[emitted](https://test-utils.vuejs.org/api/#emitted)&lt;/code&gt; 方法检查我们的组件所发出的事件列表。然后我们检查这个数组是否包括&lt;code&gt; clear-notification&lt;/code&gt; 事件。&lt;/p&gt;
&lt;p&gt;最后，我们测试以确保我们的组件渲染出正确的消息，并传递给 &lt;code&gt;message&lt;/code&gt;  prop。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test("renders message when message is not empty", () =&amp;gt; {
        const message = "Something happened, try again";
        const wrapper = mount(notification, {
            props: { message },
        });
        expect(wrapper.find("p").text()).toBe(message);
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，我们创建了一个 &lt;code&gt;message&lt;/code&gt;  变量，给它分配了一个随机字符串，并把它作为一个 prop  传递给我们的组件。&lt;/p&gt;
&lt;p&gt;然后，我们使用 &lt;code&gt;p&lt;/code&gt; 标签搜索我们的消息文本，因为这里是显示消息的地方，并检查其文本是否与 &lt;code&gt;message&lt;/code&gt;  相同。&lt;/p&gt;
&lt;p&gt;我们使用 &lt;code&gt;text&lt;/code&gt; 方法提取这个标签的内容，这和 &lt;code&gt;innerText&lt;/code&gt;很相似。最后，我们使用前面的函数 &lt;code&gt;toBe&lt;/code&gt; 来断言这个值与 &lt;code&gt;message&lt;/code&gt;  相同。&lt;/p&gt;
&lt;h2&gt;完整的测试文件&lt;/h2&gt;
&lt;p&gt;在涵盖所有这些之后，下面是完整的测试文件内容：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notification.test.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @vitest-environment happy-dom
 */

import { mount } from "@vue/test-utils";
import notification from "../components/notification.vue";
import { describe, expect, test } from "vitest";

describe("notification.vue", () =&amp;gt; {
    test("renders the correct style for error", () =&amp;gt; {
        const type = "error";
        const wrapper = mount(notification, {
            props: { type },
        });
        expect(wrapper.classes()).toEqual(
            expect.arrayContaining(["notification--error"])
        );
    });

    test("renders the correct style for success", () =&amp;gt; {
        const type = "success";
        const wrapper = mount(notification, {
            props: { type },
        });
        expect(wrapper.classes()).toEqual(
            expect.arrayContaining(["notification--success"])
        );
    });

    test("renders the correct style for info", () =&amp;gt; {
        const type = "info";
        const wrapper = mount(notification, {
            props: { type },
        });
        expect(wrapper.classes()).toEqual(
            expect.arrayContaining(["notification--info"])
        );
    });

    test("slides down when message is not empty", () =&amp;gt; {
        const message = "success";
        const wrapper = mount(notification, {
            props: { message },
        });
        expect(wrapper.classes()).toEqual(
            expect.arrayContaining(["notification--slide"])
        );
    });

    test("slides up when message is empty", () =&amp;gt; {
        const message = "";
        const wrapper = mount(notification, {
            props: { message },
        });
        expect(wrapper.classes("notification--slide")).toBe(false);
    });

    test("emits event when close button is clicked", async() =&amp;gt; {
        const wrapper = mount(notification, {
            data() {
                return {
                    clicked: false,
                };
            },
        });
        const closeButton = wrapper.find("button");
        await closeButton.trigger("click");
        expect(wrapper.emitted()).toHaveProperty("clear-notificatioon");
    });

    test("renders message when message is not empty", () =&amp;gt; {
        const message = "Something happened, try again";
        const wrapper = mount(notification, {
            props: { message },
        });
        expect(wrapper.find("p").text()).toBe(message);
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有几件事需要注意:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们利用 &lt;code&gt;mount&lt;/code&gt; 来存根我们要测试的组件，它是由Vue Test Utils提供的。 (&lt;code&gt;yarn add --dev @vue/test-utils@next&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;运行测试&lt;/h2&gt;
&lt;p&gt;现在已经完成了测试的编写，需要运行它们。要实现这一点，我们去 &lt;code&gt;package.json&lt;/code&gt;，&lt;code&gt;在我们的scripts&lt;/code&gt; 部分添加以下几行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;"scripts": {
    "test": "vitest",
    "coverage": "vitest run --coverage"
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在终端运行 &lt;code&gt;yarn vitest&lt;/code&gt; 或 &lt;code&gt;yarn test&lt;/code&gt;，我们的测试文件就会被运行，我们应该看到测试结果和故障。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6877580ad7784356a82914c0c99bf4d1~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;到这，我们已经成功地使用Vitest运行了我们的第一次测试。从结果中需要注意的一点是，由于Vitest的智能和即时观察模式，这个命令只需要运行一次，并在我们对测试文件进行更新和修改时被重新运行。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;使用 Vitest 对我们的应用程序进行单元测试是无缝的，与Jest等替代品相比，需要更少的步骤来启动和运行。Vitest 还可以很容易地将现有的测试从 Jest 迁移到Vitest，而不需要进行额外的配置。&lt;/p&gt;
&lt;p&gt;作者：Timi Omoyeni  译者：前端小智  来源：vuemastery&lt;/p&gt;
&lt;p&gt;原文：https://www.vuemastery.com/blog/getting-started-with-vitest&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  https://github.com/qq449245884/xiaozhi 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>前端小智</author><pubDate>Mon, 08 Aug 2022 16:32:18 GMT</pubDate></item><item><title>type="module" 你了解，但 type="importmap" 你知道吗</title><link>https://juejin.cn/post/7127449194389831716</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当ES模块第一次在ECMAScript 2015中被引入，作为在JavaScript中标准化模块系统的一种方式时，它是通过在&lt;code&gt;import&lt;/code&gt;语句中指定相对或绝对路径来实现的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import dayjs from "https://cdn.skypack.dev/dayjs@1.10.7"; // ES modules

console.log(dayjs("2019-01-25").format("YYYY-MM-DDTHH:mm:ssZ[Z]"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这与模块在其他通用模块系统中的工作方式略有不同，例如CommonJS，以及在使用webpack这样的模块捆绑器时，使用的是更简单的语法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const dayjs = require('dayjs') // CommonJS

import dayjs from 'dayjs'; // webpack
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这些系统中，通过Node.js运行时或相关的构建工具，导入指定器被映射到一个特定（和版本）的文件。用户只需要在导入语句中应用裸露的模块指定符（通常是包名），围绕模块解析的问题就会被自动解决。&lt;/p&gt;
&lt;p&gt;由于开发者已经熟悉了这种从&lt;code&gt;npm&lt;/code&gt;导入包的方式，所以需要一个构建步骤来确保以这种方式编写的代码能够在浏览器中运行。这个问题由&lt;a href="https://github.com/WICG/import-maps"&gt;import maps&lt;/a&gt;解决了。从本质上讲，它允许将导入指定器映射到相对或绝对的URL上，这有助于控制模块的解析，而不需要应用构建步骤。&lt;/p&gt;
&lt;h2&gt;import maps 是怎么工作的&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type="importmap"&amp;gt;
{
  "imports": {
    "dayjs": "https://cdn.skypack.dev/dayjs@1.10.7",
  }
}
&amp;lt;/script&amp;gt;
&amp;lt;script type="module"&amp;gt;
  import dayjs from 'dayjs';

  console.log(dayjs('2019-01-25').format('YYYY-MM-DDTHH:mm:ssZ[Z]'));
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;import map 是通过HTML document中的 &lt;code&gt;&amp;lt;script type="importmap"&amp;gt;&lt;/code&gt;标签指定的。这个script  标签必须放在 document 中的中第一个 &lt;code&gt;&amp;lt;script type="module"&amp;gt;&lt;/code&gt;标签之前（最好是在&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;中），以便在进行模块解析之前对它进行解析。此外，目前每个 document 只允许有一个 &lt;code&gt;import map&lt;/code&gt;，未来可能会取消这一限制。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;script&lt;/code&gt; 标签内，一个JSON对象被用来指定document中 script 所需的所有必要的模块映射。一个典型的 import map 的结构如下所示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type="importmap"&amp;gt;
{
  "imports": {
    "react": "https://cdn.skypack.dev/react@17.0.1",
    "react-dom": "https://cdn.skypack.dev/react-dom",
    "square": "./modules/square.js",
    "lodash": "/node_modules/lodash-es/lodash.js"
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的 &lt;code&gt;imports&lt;/code&gt; 对象中，每个属性都对应着一个映射。映射的左边是 &lt;code&gt;import&lt;/code&gt; 指定器的名称，而右边是指定器应该映射到的相对或绝对URL。&lt;/p&gt;
&lt;p&gt;当在映射中指定相对URL时，确保它们总是以&lt;code&gt;/&lt;/code&gt;、&lt;code&gt;./&lt;/code&gt;或&lt;code&gt;./&lt;/code&gt;开头。请注意，在 import map 中出现包并不意味着它一定会被浏览器加载。任何没有被页面上的 &lt;code&gt;script&lt;/code&gt; 使用的模块都不会被浏览器加载，即使它存在于&lt;strong&gt;import map&lt;/strong&gt;中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type="importmap" src="importmap.json"&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你也可以在一个外部文件中指定你的映射，然后使用&lt;code&gt;src&lt;/code&gt;属性链接到该文件（如上所示）。如果决定使用这种方法，请确保在发送文件时将其&lt;code&gt;Content-Type&lt;/code&gt;标头设置为&lt;code&gt;application/importmap+json&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意，出于性能方面的考虑，推荐使用内联方式，本文的其余部分的事例，也会使用内联方式。&lt;/p&gt;
&lt;p&gt;一旦指定了映射，就可以在&lt;code&gt;import&lt;/code&gt;语句中使用&lt;code&gt;import&lt;/code&gt;说明符，如下所示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type="module"&amp;gt;
  import { cloneDeep } from 'lodash';

  const objects = [{ a: 1 }, { b: 2 }];

  const deep = cloneDeep(objects);
  console.log(deep[0] === objects[0]);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，导入映射中的映射不会影响诸如&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签的 &lt;code&gt;src&lt;/code&gt; 属性之类的位置。因此，如你的使用&lt;code&gt;&amp;lt;script src="/app.js"&amp;gt;&lt;/code&gt;之类的内容，浏览器将试图在该路径上下载一个字面上的&lt;code&gt;app.js&lt;/code&gt;文件，而不管 import map 中的内容如何。&lt;/p&gt;
&lt;h2&gt;将指定者映射到整个包中&lt;/h2&gt;
&lt;p&gt;除了将一个指定器映射到一个模块，你也可以将一个指定器映射到一个包含多个模块的包。这是通过使用指定器键和以尾部斜线结尾的路径来实现的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type="importmap"&amp;gt;
{
  "imports": {
    "lodash/": "/node_modules/lodash-es/"
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法允许我们导入指定路径中的任何模块，而不是整个主模块，这会导致所有组件模块由浏览器下载。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type="module"&amp;gt;
  import toUpper from 'lodash/toUpper.js';
  import toLower from 'lodash/toLower.js';

  console.log(toUpper('hello'));
  console.log(toLower('HELLO'));
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;动态地构建 import map&lt;/h2&gt;
&lt;p&gt;映射也可以基于任意条件在 script  中动态构造，这种能力可以用来根据特征检测有条件地导入模块。下面的例子根据&lt;code&gt;IntersectionObserver API&lt;/code&gt;是否被支持，在&lt;code&gt;lazyload&lt;/code&gt;指定器下选择正确的文件进行导入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  const importMap = {
    imports: {
      lazyload: 'IntersectionObserver' in window
        ? './lazyload.js'
        : './lazyload-fallback.js',
    },
  };

  const im = document.createElement('script');
  im.type = 'importmap';
  im.textContent = JSON.stringify(importMap);
  document.currentScript.after(im);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你想使用这种方法，请确保在创建和插入 import map 脚本标签之前进行（如上所述），因为修改一个已经存在的导入地图对象不会有任何效果。&lt;/p&gt;
&lt;h2&gt;通过对哈希值的映射来提高脚本的可缓存性&lt;/h2&gt;
&lt;p&gt;实现静态文件长期缓存的常见技术是在文件名中使用文件内容的哈希值，这样文件就会一直在浏览器的缓存中，直到文件内容发生变化。当这种情况发生时，文件将得到一个新的名字，以便最新的更新立即反映在应用程序中。&lt;/p&gt;
&lt;p&gt;在传统的 bundling scripts,的方式下，如果一个被多个模块依赖的依赖关系被更新，这种技术就会出现问题。这将导致所有依赖该依赖的文件被更新，迫使浏览器重新下载它们，即使只有一个字符的代码被改变。&lt;/p&gt;
&lt;p&gt;import map 为这个问题提供了一个解决方案，它允许通过重映射技术单独更新每个依赖关系。假设你需要从一个名为&lt;code&gt;post.bundle.8cb615d12a121f6693aa.js&lt;/code&gt;的文件中导入一个方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type="importmap"&amp;gt;
  {
    "imports": {
      "post.js": "./static/dist/post.bundle.8cb615d12a121f6693aa.js",
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而不是这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { something } from './static/dist/post.bundle.8cb615d12a121f6693aa.js'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以这么写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { something } from 'post.js'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当更新文件的时候，只有 &lt;code&gt;import map&lt;/code&gt; 需要更新。由于对其导出的引用没有更改，它们将保持在浏览器中的缓存，同时由于更新的哈希值，更新的脚本将再次被下载。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type="importmap"&amp;gt;
  {
    "imports": {
      "post.js": "./static/dist/post.bundle.6e2bf7368547b6a85160.js",
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;使用同一模块的多个版本&lt;/h2&gt;
&lt;p&gt;在 import map 中很容易实现一个包对应多个版本，所需要做的就是在映射中使用不同的导入指定符，如下图所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;script type="importmap"&amp;gt;
      {
        "imports": {
          "lodash@3/": "https://unpkg.com/lodash-es@3.10.1/",
          "lodash@4/": "https://unpkg.com/lodash-es@4.17.21/"
        }
      }
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过使用作用域，也可以用同一个导入指定符来指代同一个包的不同版本。这允许我们在一个给定的作用域内改变导入指定符的含义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type="importmap"&amp;gt;
  {
    "imports": {
      "lodash/": "https://unpkg.com/lodash-es@4.17.21/"
    },
    "scopes": {
      "/static/js": {
        "lodash/": "https://unpkg.com/lodash-es@3.10.1/"
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这种映射，在&lt;code&gt;/static/js&lt;/code&gt;路径下的任何模块，在导入语句中引用lodash/指定器时，将使用&lt;code&gt;https://unpkg.com/lodash-es@3.10.1/&lt;/code&gt;，而其他模块将使用&lt;code&gt;https://unpkg.com/lodash-es@4.17.21/&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;使用带有 import map 的 NPM 包&lt;/h2&gt;
&lt;p&gt;正如在本文中所展示的，任何使用ES Modules的NPM包的生产版本都可以通过ESM、Unpkg和Skypack等CDN在 import map中使用。&lt;/p&gt;
&lt;p&gt;即使NPM上的包不是为ES模块系统和本地浏览器导入行为设计的，像Skypack和ESM这样的服务也可以将它们转化为可在导入地图中使用的包。可以使用Skypack主页上的搜索栏来寻找浏览器优化的NPM包，这些包可以立即使用，而无需摆弄构建步骤。&lt;/p&gt;
&lt;h2&gt;检测 import map支持&lt;/h2&gt;
&lt;p&gt;只要支持&lt;code&gt;HTMLScriptElement.supports()&lt;/code&gt;方法，就可以在浏览器中检测 import map的支持:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (HTMLScriptElement.supports &amp;amp;&amp;amp; HTMLScriptElement.supports('importmap')) {
  // import maps is supported
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;支持旧的浏览器&lt;/h2&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/696ce1e135b9419c9d6628639f7fca16~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;Import map 使得在浏览器中使用裸模块指定器成为可能，而无需依赖目前在JavaScript生态系统中普遍存在的复杂的构建系统，但目前网络浏览器中并不广泛支持它。&lt;/p&gt;
&lt;p&gt;在整理本文时，Chrome和Edge浏览器的89版及以后的版本提供了全面支持，但Firefox、Safari和一些移动浏览器不支持这项技术。为了在这些浏览器中保留对 import map的使用，必须采用一个合适的 polyfill 。&lt;/p&gt;
&lt;p&gt;一个可以使用的polyfill的例子是&lt;a href="https://github.com/guybedford/es-module-shims"&gt;ES Module Shims polyfil&lt;/a&gt;l，它为任何支持ES模块基线的浏览器(约94%的浏览器)添加了 import map 和其他新模块特性的支持。我们所需要做的就是在 import map 脚本之前在HTML文件中包含&lt;code&gt;es-module-shim&lt;/code&gt;脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script async src="https://unpkg.com/es-module-shims@1.3.0/dist/es-module-shims.js"&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在包括polyfill之后，可能会在你的控制台中得到一个&lt;strong&gt;JavaScript TypeError&lt;/strong&gt;。这个错误可以被安全地忽略，因为它不会产生任何面向用户的后果。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;import map提供了一种更理智的方式来在浏览器中使用ES模块，而不局限于从相对或绝对的URL中导入。这使得我们可以很容易地移动代码，而不需要调整 import语句，并使个别模块的更新更加无缝，而不影响依赖这些模块的脚本的缓存能力。总的来说，import map为ES模块在服务器和浏览器中的使用方式带来了平等性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;作者：romaopedro199  译者：前端小智 来源：dev 原文：https://www.honeybadger.io/blog/import-maps/&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>前端小智</author><pubDate>Tue, 02 Aug 2022 17:03:17 GMT</pubDate></item><item><title>Vue3 中还处在实验性阶段 Suspense 是个啥？</title><link>https://juejin.cn/post/7125214169632096270</link><description>&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Suspense&lt;/strong&gt; 不是你想的那样。是的，它帮助我们处理异步组件，但它的作用远不止于此。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Suspense&lt;/strong&gt; 允许我们协调整个应用程序的加载状态，包括所有深度嵌套的组件。而不是像一个爆米花用户界面一样，到处都是 loading，组件突然奔的一下到位&lt;/p&gt;
&lt;p&gt;&lt;img alt="001.webp" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec4e0afa0a5f4de7a4d37df23fa99a09~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;有了 Suspense， 我们可以有一个单一的、有组织的系统，一次性加载所有东西。&lt;/p&gt;
&lt;p&gt;&lt;img alt="002.webp" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977385f1910b42f6991c2ce9189ce7a9~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;而且，Suspense 也给我们提供了细粒度的控制，所以如果需要的话，我们可以在两者之间实现一些东西。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将学到很多关于 Suspense 的知识--它是什么，能干什么，以及如何使用它。&lt;/p&gt;
&lt;p&gt;首先，我们将仔细看看这些爆米花界面。然后，在看看如何使用Suspense来解决这些问题。之后，尝试通过在整个应用程序中嵌套Suspense来获得更精细的控制。最后，简单看看如何使用占位符来丰富我们的用户界面。&lt;/p&gt;
&lt;h3&gt;爆米花UI-- Suspense 之前&lt;/h3&gt;
&lt;p&gt;事例地址：https://codesandbox.io/s/uncoordinated-loading-before-suspense-srh8ll?file=/src/App.vue&lt;/p&gt;
&lt;p&gt;如果没有 Suspense，每个组件都必须单独处理其加载状态。&lt;/p&gt;
&lt;p&gt;&lt;img alt="003.webp" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f93afb1f8ae44e7981e5b76ae9e4b36~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这可能导致一些相当糟糕的用户体验，多个加载按钮和内容突然出现在屏幕上，就像你在制作爆米花一样。&lt;/p&gt;
&lt;p&gt;虽然，我们可以创建抽象组件来处理这些加载状态，但这比使用Suspense要困难得多。有一个单一的点来管理加载状态，比每个组件做自己的事情要容易维护得多。&lt;/p&gt;
&lt;p&gt;在事例中，我们使用&lt;code&gt;BeforeSuspense&lt;/code&gt;组件来模拟一个内部处理加载状态的组件。把它命名为&lt;code&gt;BeforeSuspense&lt;/code&gt;，因为一旦我们实现了Suspense，我们就会把它重构为&lt;code&gt;WithSuspense&lt;/code&gt;组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BeforeSuspense.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;div class="async-component" :class="!loading &amp;amp;&amp;amp; 'loaded'"&amp;gt;
      &amp;lt;Spinner v-if="loading" /&amp;gt;
      &amp;lt;slot /&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from 'vue'
import Spinner from './Spinner.vue'

const loading = ref(true)
const { time } = defineProps({
  time: {
    type: Number,
    default: 2000
  }
})

setTimeout(() =&amp;gt; (loading.value = false), time)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一开始设置 loading 为 &lt;code&gt;true&lt;/code&gt;，所以显示 &lt;code&gt;Spinner&lt;/code&gt; 组件。然后，当&lt;code&gt;setTimeout&lt;/code&gt;完成后，将 loading 设置为 &lt;code&gt;false&lt;/code&gt;，隐藏 &lt;code&gt;Spinner&lt;/code&gt;  并使组件的背景为绿色。&lt;/p&gt;
&lt;p&gt;在这个组件中，还包括一个 &lt;code&gt;slot&lt;/code&gt; ，这样其它组件就可以套在 &lt;code&gt;BeforeSuspense&lt;/code&gt; 组件中了:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;button @click="reload"&amp;gt;Reload page&amp;lt;/button&amp;gt;
    &amp;lt;BeforeSuspense time="3000"&amp;gt;
      &amp;lt;BeforeSuspense time="2000" /&amp;gt;
      &amp;lt;BeforeSuspense time="1000"&amp;gt;
        &amp;lt;BeforeSuspense time="500" /&amp;gt;
        &amp;lt;BeforeSuspense time="4000" /&amp;gt;
      &amp;lt;/BeforeSuspense&amp;gt;
    &amp;lt;/BeforeSuspense&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有什么太花哨的东西。只是一些嵌套的组件，有不同的时间值传递给它们。&lt;/p&gt;
&lt;p&gt;下面，我们来看看怎么通过使用 &lt;code&gt;Suspense&lt;/code&gt; 组件来改进这个爆米花用户界面。&lt;/p&gt;
&lt;h2&gt;Suspense&lt;/h2&gt;
&lt;p&gt;事例地址：https://codesandbox.io/s/coordinated-loading-with-suspense-b6dcbi?file=/src/App.vue&lt;/p&gt;
&lt;p&gt;现在，我们使用&lt;code&gt;Suspense&lt;/code&gt;来处理这些乱七八糟的东西，并将其变成一个更好的用户体验。&lt;/p&gt;
&lt;p&gt;不过，首先我们需要快速了解一下Suspense到底是什么&lt;/p&gt;
&lt;h4&gt;Suspense 基础知识&lt;/h4&gt;
&lt;p&gt;以下是 Suspense 部分的基本结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Suspense&amp;gt;
  &amp;lt;!-- Async component here --&amp;gt;

  &amp;lt;template #fallback&amp;gt;
      &amp;lt;!-- Sync loading state component here --&amp;gt;
  &amp;lt;/template&amp;gt;
&amp;lt;/Suspense&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了使用Suspense，把异步组件放入 &lt;code&gt;default&lt;/code&gt; 槽，把回退加载状态放入 &lt;code&gt;fallback&lt;/code&gt; 槽。&lt;/p&gt;
&lt;p&gt;异步组件是以下两种情况之一:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个带有&lt;code&gt;async setup&lt;/code&gt;函数的组件，该组件返回一个Promise，或者在&lt;code&gt;script setup&lt;/code&gt;中使用顶级&lt;code&gt;await&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;defineAsyncComponent&lt;/code&gt; 异步加载的组件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论哪种方式，我们最终都会得到一个开始未解决 的 Promise ，然后最终得到解决。&lt;/p&gt;
&lt;p&gt;当该 Promise 未被解决时，Suspense 组件将显示 &lt;code&gt;fallback&lt;/code&gt;  槽中的内容。然后，当Promise 被解决时，它会在 &lt;code&gt;default&lt;/code&gt;  槽中显示该异步组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这里没有错误处理路基。起初我以为有，但这是对悬念的一个常见误解。如果想知道是什么导致了错误。可以使用&lt;code&gt;onErrorCaptured&lt;/code&gt;钩子来捕捉错误，但这是一个独立于Suspense的功能。&lt;/p&gt;
&lt;p&gt;现在我们对Suspense有了一些了解，让我们回到我们的演示应用程序。&lt;/p&gt;
&lt;h2&gt;管理异步依赖关系&lt;/h2&gt;
&lt;p&gt;为了让&lt;code&gt;Suspense&lt;/code&gt;管理我们的加载状态，首先需要将&lt;code&gt;BeforeSuspense&lt;/code&gt;组件转换成一个异步组件&lt;/p&gt;
&lt;p&gt;我们将它命名为 WithSuspense，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class="async-component loaded"&amp;gt;
    &amp;lt;!-- 这里不需要一个 Spiner 了，因为加载是在根部处理的 --&amp;gt;
    &amp;lt;slot /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
const { time } = defineProps({
  time: {
    type: Number,
    required: true
  }
})
// 加入一个延迟，以模拟加载数据
await new Promise(resolve =&amp;gt; {
  setTimeout(() =&amp;gt; {
    resolve()
  }, time)
})
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们已经完全删除了加载状态的Spinner，因为这个组件不再有加载状态了。&lt;/p&gt;
&lt;p&gt;因为这是一个异步组件，&lt;code&gt;setup&lt;/code&gt; 函数直到它完成加载才会返回。该组件只有在 setup 函数完成后才会被加载。因此，与&lt;code&gt;BeforeSuspense&lt;/code&gt;组件不同，&lt;code&gt;WithSuspense&lt;/code&gt;组件内容在加载完毕之前不会被渲染。&lt;/p&gt;
&lt;p&gt;这对任何异步组件来说都是如此，不管它是如何被使用的。在setup函数返回（如果是同步的）或解析（如果是异步的）之前，它不会渲染任何东西。&lt;/p&gt;
&lt;p&gt;有了&lt;strong&gt;WithSuspense&lt;/strong&gt;组件，我们仍然需要重构我们的&lt;code&gt;App&lt;/code&gt;组件，以便在&lt;code&gt;Suspense&lt;/code&gt;组件中使用这个组件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;button @click="reload"&amp;gt;Reload page&amp;lt;/button&amp;gt;
  &amp;lt;Suspense&amp;gt;
    &amp;lt;WithSuspense :time="2000"&amp;gt;
      &amp;lt;WithSuspense :time="1500" /&amp;gt;
      &amp;lt;WithSuspense :time="1200"&amp;gt;
        &amp;lt;WithSuspense :time="1000" /&amp;gt;
        &amp;lt;WithSuspense :time="5000" /&amp;gt;
      &amp;lt;/WithSuspense&amp;gt;
    &amp;lt;/WithSuspense&amp;gt;

    &amp;lt;template #fallback&amp;gt;
      &amp;lt;Spinner /&amp;gt;
    &amp;lt;/template&amp;gt;
  &amp;lt;/Suspense&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结构和之前一样，但这次是在 Suspense 组件的默认槽中。我们还加入了 fallback  槽，在加载时渲染我们的Spinner组件。&lt;/p&gt;
&lt;p&gt;在演示中，你会看到它显示加载按钮，直到所有的组件都加载完毕。只有在那时，它才会显示现在完全加载的组件树。&lt;/p&gt;
&lt;h2&gt;异步瀑布&lt;/h2&gt;
&lt;p&gt;如果你仔细注意，你会注意到这些组件并不像你想象的那样是并联加载的。&lt;/p&gt;
&lt;p&gt;总的加载时间不是基于最慢的组件（5秒）。相反，这个时间要长得多。这是因为Vue只有在父异步组件完全解析后才会开始加载子组件。&lt;/p&gt;
&lt;p&gt;你可以通过把日志放到&lt;code&gt;WithSuspense组&lt;/code&gt;件中来测试这一点。一个在安装开始跟踪安装，一个在我们调用解决之前。&lt;/p&gt;
&lt;p&gt;最初使用&lt;code&gt;BeforeSuspense&lt;/code&gt;组件的例子中，整个组件树被挂载，无需等待，所有的 "异步 "操作都是并行启动的。这意味着&lt;code&gt;Suspense&lt;/code&gt;有可能通过引入这种异步瀑布而影响性能。所以请记住这一点。&lt;/p&gt;
&lt;h2&gt;嵌套 Suspense  以隔离子树&lt;/h2&gt;
&lt;p&gt;事例地址：https://codesandbox.io/s/nesting-suspense-wt0q7k?file=/src/App.vue&lt;/p&gt;
&lt;p&gt;这里有一个深度嵌套的组件，它需要整整5秒来加载，阻塞了整个UI，尽管大多数组件加载完成的时间要早得多。&lt;/p&gt;
&lt;p&gt;但对我们来说有一个解决方案😅&lt;/p&gt;
&lt;p&gt;通过进一步嵌套第二个Suspense组件，我们可以在等待这个组件完成加载时显示应用程序的其他部分。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;button @click="reload"&amp;gt;Reload page&amp;lt;/button&amp;gt;
  &amp;lt;Suspense&amp;gt;
    &amp;lt;WithSuspense :time="2000"&amp;gt;
      &amp;lt;WithSuspense :time="1500" /&amp;gt;
      &amp;lt;WithSuspense :time="1200"&amp;gt;
        &amp;lt;WithSuspense :time="1000" /&amp;gt;

                &amp;lt;!-- Nest a second Suspense component --&amp;gt;
        &amp;lt;Suspense&amp;gt;
          &amp;lt;WithSuspense :time="5000" /&amp;gt;
          &amp;lt;template #fallback&amp;gt;
            &amp;lt;Spinner /&amp;gt;
          &amp;lt;/template&amp;gt;
        &amp;lt;/Suspense&amp;gt;
      &amp;lt;/WithSuspense&amp;gt;
    &amp;lt;/WithSuspense&amp;gt;

    &amp;lt;template #fallback&amp;gt;
      &amp;lt;Spinner /&amp;gt;
    &amp;lt;/template&amp;gt;
  &amp;lt;/Suspense&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将其包裹在第二个&lt;code&gt;Suspense&lt;/code&gt;组件中，使其与应用程序的其他部分隔离。Suspense组件本身是一个同步组件，所以当它的父级组件被加载时，它就会被加载。&lt;/p&gt;
&lt;p&gt;然后它将显示它自己的 fallback 内容，直到5秒结束。&lt;/p&gt;
&lt;p&gt;&lt;img alt="004.webp" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b9f093276fb431f9b85b319cedcf4d5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;通过这样做，我们可以隔离应用程序中加载较慢的部分，减少我们的首次交互时间。在某些情况下，这可能是必要的，特别是当你需要避免异步瀑布时。&lt;/p&gt;
&lt;p&gt;从功能的角度来看，这也是有意义的。你的应用程序的每个功能或 "部分"都可以被包裹在它自己的&lt;code&gt;Suspense&lt;/code&gt;组件中，所以每个功能的加载都是一个单一的逻辑单元。&lt;/p&gt;
&lt;p&gt;当然，如果你用 "Suspense" 包装每一个组成部分，我们就会回到我们开始的地方。我们可以选择以任何最合理的方式来批处理我们的加载状态。&lt;/p&gt;
&lt;h2&gt;使用占位符的 Suspense&lt;/h2&gt;
&lt;p&gt;事例地址： https://codesandbox.io/s/placeholders-and-suspense-k5uzw0?&lt;/p&gt;
&lt;p&gt;与其使用单一的 spinner，占位符组件往往可以提供更好的体验。&lt;/p&gt;
&lt;p&gt;&lt;img alt="006.webp" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a28f568bb87457fa69bb04378228084~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这种方式向用户展示将要展示的内容，并让他们在界面渲染前有一种期待的感觉。这是 spinner 无法做到的。&lt;/p&gt;
&lt;p&gt;可以说--它们很时髦，看起来很酷。因此，我们重构代码，使用占位符方式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;button @click="reload"&amp;gt;Reload page&amp;lt;/button&amp;gt;
  &amp;lt;Suspense&amp;gt;
    &amp;lt;WithSuspense :time="2000"&amp;gt;
      &amp;lt;WithSuspense :time="1500" /&amp;gt;
      &amp;lt;WithSuspense :time="1200"&amp;gt;
        &amp;lt;WithSuspense :time="1000" /&amp;gt;

        &amp;lt;Suspense&amp;gt;
          &amp;lt;WithSuspense :time="5000" /&amp;gt;
          &amp;lt;template #fallback&amp;gt;
            &amp;lt;Placeholder /&amp;gt;
          &amp;lt;/template&amp;gt;
        &amp;lt;/Suspense&amp;gt;
      &amp;lt;/WithSuspense&amp;gt;
    &amp;lt;/WithSuspense&amp;gt;
    &amp;lt;template #fallback&amp;gt;
      &amp;lt;!-- 这里，复制实际数据的形状  --&amp;gt;
      &amp;lt;Placeholder&amp;gt;
        &amp;lt;Placeholder /&amp;gt;
        &amp;lt;Placeholder&amp;gt;
          &amp;lt;Placeholder /&amp;gt;
          &amp;lt;Placeholder /&amp;gt;
        &amp;lt;/Placeholder&amp;gt;
      &amp;lt;/Placeholder&amp;gt;
    &amp;lt;/template&amp;gt;
  &amp;lt;/Suspense&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们安排了这些Placeholder组件，并对它们进行了风格化处理，使它们看起来与&lt;code&gt;WithSuspense&lt;/code&gt;组件完全一样。这提供了一个在加载和装载状态之间的无缝过渡。&lt;/p&gt;
&lt;p&gt;在演示中，&lt;code&gt;Placeholder&lt;/code&gt;组件在背景上给我们提供了一个CSS动画，以创造一个脉动的效果:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.fast-gradient {
  background: linear-gradient(
    to right,
    rgba(255, 255, 255, 0.1),
    rgba(255, 255, 255, 0.4)
  );
  background-size: 200% 200%;
  animation: gradient 2s ease-in-out infinite;
}

@keyframes gradient {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;爆米花的加载状态是非常明显的，会伤害用户体验。&lt;/p&gt;
&lt;p&gt;幸运的是，Suspense 是一个很棒的新特性，它为我们在Vue应用程序中协调加载状态提供了很多选择。&lt;/p&gt;
&lt;p&gt;然而，在写这篇文章的时候，Suspense仍然被认为是实验性的，所以要谨慎行事。关于它的状态的最新信息，请参考文档。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;编辑中可能存在的bug没法实时知道，事后为了解决这些bug,花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者：Michael Thiessen 译者：小智  来源：vueschool&lt;/p&gt;
&lt;p&gt;原文：https://vueschool.io/articles/vuejs-tutorials/suspense-everything-you-need-to-know/&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>前端小智</author><pubDate>Wed, 27 Jul 2022 16:31:11 GMT</pubDate></item><item><title>我常用的几个 VueUse 最佳组合，推荐给你们!</title><link>https://juejin.cn/post/7122245068534054943</link><description>&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vueuse拥有大量出色的组合。但是量太大，要把它们全部看完可能会让人抓不到重点。下面来介绍一些有用到的组合，它们如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;onClickOutside&lt;/li&gt;
&lt;li&gt;useFocusTrap&lt;/li&gt;
&lt;li&gt;useHead&lt;/li&gt;
&lt;li&gt;useStorage&lt;/li&gt;
&lt;li&gt;useVModel&lt;/li&gt;
&lt;li&gt;useImage&lt;/li&gt;
&lt;li&gt;useDark&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;1. onClickOutside&lt;/h2&gt;
&lt;p&gt;&lt;img alt="001.webp" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb5f8c82970946f8a53186019797bf4d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;检测点击非常简单。但是，当点击发生在一个元素之外时，如何检测？那就有点棘手了。但使用VueUse中的 onClickOutside 组件就很容易能做到这点。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref } from 'vue'
import { onClickOutside } from '@vueuse/core'

const container = ref(null)
onClickOutside(container, () =&amp;gt; alert('Good. Better to click outside.'))
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hey there, here's some text.&amp;lt;/p&amp;gt;
    &amp;lt;div class="container" ref="container"&amp;gt;
      &amp;lt;p&amp;gt;Please don't click in here.&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为想要追踪的 &lt;code&gt;container&lt;/code&gt;  元素创建一个 &lt;code&gt;ref&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const container = ref(null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们用元素上的&lt;code&gt;ref&lt;/code&gt;属性把它变成一个模板&lt;code&gt;ref&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class="container" ref="container"&amp;gt;
  &amp;lt;p&amp;gt;Please don't click in here.&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了容器的&lt;code&gt;ref&lt;/code&gt; 之后，我们把它和一个处理程序一起传递给&lt;code&gt;onClickOutside&lt;/code&gt;组合。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;onClickOutside(
  container,
  () =&amp;gt; alert('Good. Better to click outside.')
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种可组合对于管理窗口或下拉菜单很有用。当用户点击下拉菜单以外的地方时，你可以关闭它。&lt;/p&gt;
&lt;p&gt;模态框也通常表现出这种行为。&lt;/p&gt;
&lt;p&gt;事例地址：https://stackblitz.com/edit/vue3-script-setup-with-vite-18scsl?file=src%2FApp.vue&lt;/p&gt;
&lt;h2&gt;2.useFocusTrap&lt;/h2&gt;
&lt;p&gt;&lt;img alt="002.webp" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/926183596df4451eb855a93ab7ce9a98~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为了拥有可访问的应用程序，正确地管理焦点非常重要。&lt;/p&gt;
&lt;p&gt;没有什么比不小心在模态后面加tab，并且无法将焦点返回到模态更糟糕的了。这就是焦点陷阱的作用。&lt;/p&gt;
&lt;p&gt;将键盘焦点锁定在一个特定的DOM元素上，不是在整个页面中循环，而是在浏览器本身中循环，键盘焦点只在该DOM元素中循环。&lt;/p&gt;
&lt;p&gt;下面是一个使用VueUse的&lt;code&gt;useFocusTrap&lt;/code&gt;的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref } from 'vue'
import { useFocusTrap } from '@vueuse/integrations/useFocusTrap'

const container = ref(null)
useFocusTrap(container, { immediate: true })
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;button tab-index="-1"&amp;gt;Can't click me&amp;lt;/button&amp;gt;
    &amp;lt;div class="container" ref="container"&amp;gt;
      &amp;lt;button tab-index="-1"&amp;gt;Inside the trap&amp;lt;/button&amp;gt;
      &amp;lt;button tab-index="-1"&amp;gt;Can't break out&amp;lt;/button&amp;gt;
      &amp;lt;button tab-index="-1"&amp;gt;Stuck here forever&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;button tab-index="-1"&amp;gt;Can't click me&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将&lt;code&gt;immediate&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;，页面加载时，焦点将被放置在 &lt;code&gt;container&lt;/code&gt; 元素中。然后，就不可能在该容器之外的地方做标签。&lt;/p&gt;
&lt;p&gt;到达第三个按钮后，再次点击&lt;code&gt;tab&lt;/code&gt;键将回到第一个按钮。&lt;/p&gt;
&lt;p&gt;就像&lt;code&gt;onClickOutside&lt;/code&gt;一样，我们首先为 &lt;code&gt;container&lt;/code&gt; 设置了模板&lt;code&gt;ref&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const container = ref(null)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class="container" ref="container"&amp;gt;
  &amp;lt;button tab-index="-1"&amp;gt;Inside the trap&amp;lt;/button&amp;gt;
  &amp;lt;button tab-index="-1"&amp;gt;Can't break out&amp;lt;/button&amp;gt;
  &amp;lt;button tab-index="-1"&amp;gt;Stuck here forever&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们把这个模板引用传递给&lt;code&gt;useFocusTrap&lt;/code&gt;组合。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;useFocusTrap(container, { immediate: true });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;immediate&lt;/code&gt; 选项将自动把焦点设置到容器内第一个可关注的元素上。&lt;/p&gt;
&lt;p&gt;事例地址：https://stackblitz.com/edit/vue3-script-setup-with-vite-eocc6w?file=src%2FApp.vue&lt;/p&gt;
&lt;h2&gt;3. useHead&lt;/h2&gt;
&lt;p&gt;&lt;img alt="003.webp" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/700ad347a685490ea670f5203926833c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;VueUse为我们提供了一种简单的方法来更新我们应用程序的 head 部分--页面 title、scripts和其他可能放在这里的的东西。&lt;/p&gt;
&lt;p&gt;useHead 组合要求我们首先设置一个插件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { createApp } from 'vue'
import { createHead } from '@vueuse/head'
import App from './App.vue'

const app = createApp(App)
const head = createHead()

app.use(head)
app.mount('#app')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦我们使用了这个插件，我们就可以随心所欲地更新标题部分。在这个例子中，我们将在一个按钮上注入一些自定义样式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref } from 'vue'
import { useHead } from '@vueuse/head'

const styles = ref('')
useHead({
  // Inject a style tag into the head
  style: [{ children: styles }],
})

const injectStyles = () =&amp;gt; {
  styles.value = 'button { background: red }'
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;button @click="injectStyles"&amp;gt;Inject new styles&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，我们创建一个&lt;code&gt;ref&lt;/code&gt;来表示我们要注入的样式，默认为空：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const styles = ref('');
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二，设置 &lt;code&gt;useHead&lt;/code&gt; 将样式注入到页面中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;useHead({
  // Inject a style tag into the head
  style: [{ children: styles }],
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，添加注入这些样式的方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const injectStyles = () =&amp;gt; {
  styles.value = 'button { background: red }'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，我们并不局限于注入样式。我们可以在我们的&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;中添加任何这些内容:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;title&lt;/li&gt;
&lt;li&gt;meta tags&lt;/li&gt;
&lt;li&gt;link tags&lt;/li&gt;
&lt;li&gt;base tag&lt;/li&gt;
&lt;li&gt;style tags&lt;/li&gt;
&lt;li&gt;script tags&lt;/li&gt;
&lt;li&gt;html attributes&lt;/li&gt;
&lt;li&gt;body attributes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事例地址：https://stackblitz.com/edit/vue3-script-setup-with-vite-szhedp?file=src%2FApp.vue&lt;/p&gt;
&lt;h2&gt;4. useStorage&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;useStorage&lt;/code&gt;真的很酷，因为它会自动将 &lt;code&gt;ref&lt;/code&gt; 同步到  localstorage，事例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { useStorage } from '@vueuse/core'
const input = useStorage('unique-key', 'Hello, world!')
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;input v-model="input" /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次加载时， &lt;code&gt;input&lt;/code&gt; 显示 'Hello, world!'，但最后，它会显示你最后在 &lt;code&gt;input&lt;/code&gt; 中输入的内容，因为它被保存在localstorage中。&lt;/p&gt;
&lt;p&gt;除了 localstorage，我们也可以指定  &lt;code&gt;sessionstorage&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const input = useStorage('unique-key', 'Hello, world!', sessionStorage)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，也可以自己实现存储系统，只要它实现了&lt;code&gt;StorageLike&lt;/code&gt;接口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export interface StorageLike {
  getItem(key: string): string | null
  setItem(key: string, value: string): void
  removeItem(key: string): void
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;5. useVModel&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v-model&lt;/code&gt;指令是很好的语法糖，使双向数据绑定更容易。&lt;/p&gt;
&lt;p&gt;但&lt;code&gt;useVModel&lt;/code&gt;更进一步，摆脱了一堆没有人真正想写的模板代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { useVModel } from '@vueuse/core'

const props = defineProps({
  count: Number,
})
const emit = defineEmits(['update:count'])

const count = useVModel(props, 'count', emit)
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;button @click="count = count - 1"&amp;gt;-&amp;lt;/button&amp;gt;
    &amp;lt;button @click="count = 0"&amp;gt;Reset to 0&amp;lt;/button&amp;gt;
    &amp;lt;button @click="count = count + 1"&amp;gt;+&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，我们首先定义了要附加到&lt;code&gt;v-model&lt;/code&gt;上的 props:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const props = defineProps({
  count: Number,
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们发出一个事件，使用&lt;code&gt;v-model&lt;/code&gt;的命名惯例&lt;code&gt;update:&amp;lt;propName&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const emit = defineEmits(['update:count'])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们可以使用&lt;code&gt;useVModel&lt;/code&gt;组合来将 &lt;code&gt;prop&lt;/code&gt;和事件绑定到一个&lt;code&gt;ref&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const count = useVModel(props, 'count', emit)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每当 prop 发生变化时，这个 &lt;code&gt;count&lt;/code&gt; 就会改变。但只要它从这个组件中被改变，它就会发出&lt;code&gt;update:count&lt;/code&gt;事件，通过&lt;code&gt;v-model&lt;/code&gt;指令触发更新。&lt;/p&gt;
&lt;p&gt;我们可以像这样使用这个 &lt;code&gt;Input&lt;/code&gt; 组件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref } from 'vue'
import Input from './components/Input.vue'

const count = ref(50)
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;Input v-model:count="count" /&amp;gt;
    {{ count }}
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;count  ref&lt;/code&gt;是通过&lt;code&gt;v-model&lt;/code&gt;绑定与 &lt;code&gt;Input&lt;/code&gt;组件内部的&lt;code&gt;count ref&lt;/code&gt;同步的。&lt;/p&gt;
&lt;p&gt;事例地址：https://stackblitz.com/edit/vue3-script-setup-with-vite-ut5ap8?file=src%2FApp.vue&lt;/p&gt;
&lt;h2&gt;6. useImage&lt;/h2&gt;
&lt;p&gt;&lt;img alt="004.webp" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d592d83d4c8f4f12a74bc355477f6884~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;随着时间的推移，web应用中的图像变得越来越漂亮。我们已经有了带有&lt;code&gt;srcset&lt;/code&gt;的响应式图像，渐进式加载库，以及只有在图像滚动到视口时才会加载的库。&lt;/p&gt;
&lt;p&gt;但你知道吗，我们也可以访问图像本身的加载和错误状态？&lt;/p&gt;
&lt;p&gt;我以前主要通过监听每个HTML元素发出的&lt;code&gt;onload&lt;/code&gt;和&lt;code&gt;onerror&lt;/code&gt;事件来做到这一点，但VueUse给我们提供了一个更简单的方法，那就是&lt;code&gt;useImage&lt;/code&gt;组合。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { useImage } from '@vueuse/core'

// Change this to a non-existent URL to see the error state
const url = 'https://source.unsplash.com/random/400x300'
const { isLoading, error } = useImage(
  {
    src: url,
  },
  {
    // Just to show the loading effect more clearly
    delay: 2000,
  }
)
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div v-if="isLoading" class="loading gradient"&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div v-else-if="error"&amp;gt;Couldn't load the image :(&amp;lt;/div&amp;gt;
    &amp;lt;img v-else :src="url" /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一步，通过&lt;code&gt;useImage&lt;/code&gt; 设置图片的&lt;code&gt;src&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const { isLoading, error } = useImage({ src: url })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取它返回的&lt;code&gt;isLoading&lt;/code&gt;和&lt;code&gt;error&lt;/code&gt;引用，以便跟踪状态。这个组合在内部使用&lt;code&gt;useAsyncState&lt;/code&gt;，因此它返回的值与该组合的值相同。&lt;/p&gt;
&lt;p&gt;安排好后，&lt;code&gt;useImage&lt;/code&gt; 就会加载我们的图像并将事件处理程序附加到它上面。&lt;/p&gt;
&lt;p&gt;我们所要做的就是在我们的模板中使用相同的URL来使用该图片。由于浏览器会重复使用任何缓存的图片，它将重复使用由&lt;code&gt;useImage&lt;/code&gt;加载的图片。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div v-if="isLoading" class="loading gradient"&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div v-else-if="error"&amp;gt;Couldn't load the image :(&amp;lt;/div&amp;gt;
    &amp;lt;img v-else :src="url" /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里，我们设置了一个基本的加载和错误状态处理程序。当图片正在加载时，我们显示一个带有动画渐变的占位符。如果有错误，我们显示一个错误信息。否则我们可以渲染图像。&lt;/p&gt;
&lt;p&gt;UseImage 还有其他一些很棒的特性!如果想让它成为响应式图像，那么它支持&lt;code&gt;srcset&lt;/code&gt;和&lt;code&gt;sizes&lt;/code&gt;属性，这些属性在幕后传递给&lt;code&gt;img&lt;/code&gt;元素。&lt;/p&gt;
&lt;p&gt;如果你想把所有内容都放在模板中，还有一个无渲染组件。它的工作原理与组合的相同:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
&amp;lt;UseImage src="https://source.unsplash.com/random/401x301"&amp;gt;
    &amp;lt;template #loading&amp;gt;
&amp;lt;div class="loading gradient"&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
    &amp;lt;template #error&amp;gt;
Oops!
&amp;lt;/template&amp;gt;
  &amp;lt;/UseImage&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事例：https://stackblitz.com/edit/vue3-script-setup-with-vite-d1jsec?file=src%2FApp.vue&lt;/p&gt;
&lt;h2&gt;7. 暗黑模式 useDark&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="https://juejin.cn/img/bVc09yk" /&gt;&lt;/p&gt;
&lt;p&gt;最近，每个网站和应用程序似乎都有暗黑模式。最难的部分是造型的改变。但是一旦你有了这些，来回切换就很简单了。&lt;/p&gt;
&lt;p&gt;如果你使用的是Tailwind，你只需要在html元素中添加dark类，就可以在整个页面中启用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html class="dark"&amp;gt;&amp;lt;!-- ... --&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，在黑暗模式和光明模式之间切换时，有几件事需要考虑。首先，我们要考虑到用户的系统设置。第二，我们要记住他们是否已经推翻了这个选择。&lt;/p&gt;
&lt;p&gt;VueUse的&lt;code&gt;useDark&lt;/code&gt;组合性为我们把所有这些东西都包起来。默认情况下，它查看系统设置，但任何变化都会被持久化到&lt;code&gt;localStorage&lt;/code&gt;，所以设置会被记住。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { useDark, useToggle } from '@vueuse/core'

const isDark = useDark()
const toggleDark = useToggle(isDark)
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class="container"&amp;gt;
    Changes with dark/light mode.

    &amp;lt;button @click="toggleDark()"&amp;gt;
Enable {{ isDark ? 'Light' : 'Dark' }} Mode
&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;黑暗模式的样式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.dark .container {
  background: slategrey;
  color: white;
  border-color: black;
}

.dark button {
  background: lightgrey;
  color: black;
}

.dark body {
  background: darkgrey;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你没有使用Tailwind，你可以通过传入一个选项对象来完全定制黑暗模式的应用方式。下面是默认的Tailwind:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const isDark = useDark({
  selector: 'html',
  attribute: 'class',
  valueDark: 'dark',
  valueLight: '',
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以提供一个onChanged处理程序，这样你就可以编写任何你需要的Javascript。这两种方法使你可以使它与你已有的任何造型系统一起工作。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;Vueuse 拥有一个巨大的库，其中包含出色的组合，而我们在这里只涵盖了其中的一小部分。我强烈建议你花些时间去探索这些文档，看看所有可用的东西。这是一个非常好的资源，它将使你免于大量的模板代码和不断地重新发明车轮。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;编辑中可能存在的bug没法实时知道，事后为了解决这些bug,花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者：Noveo 译者：小智  来源：vuemastery&lt;/p&gt;
&lt;p&gt;原文：https://www.vuemastery.com/blog/best-vueue-composables&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>前端小智</author><pubDate>Tue, 19 Jul 2022 16:30:18 GMT</pubDate></item><item><title>Vue3 $emit指南--包含选项API、组合API以及 setup 语法糖</title><link>https://juejin.cn/post/7120020532711391239</link><description>&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;许多Vue模式涉及使用&lt;code&gt;props&lt;/code&gt;将数据从父组件传递到子组件。但如果我们需要一个子组件将数据传给它的父组件呢？&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;emit&lt;/code&gt;，我们可以触发事件并将数据传递到组件的层次结构中。这对下面几种情况很有用，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 input 中发出数据&lt;/li&gt;
&lt;li&gt;从 modal 本身内部关闭 modal&lt;/li&gt;
&lt;li&gt;父组件响应子组件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Vue Emit是如何工作的？&lt;/h2&gt;
&lt;p&gt;当我们 emit 一个事件时，我们用一个或多个参数调用一个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eventName: string - 事件的名称&lt;/li&gt;
&lt;li&gt;values: any - 通过事件传递的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是一个内联 emit的例子，&lt;code&gt;&amp;lt;button @click="$emit('add', Math.random())"&amp;gt;&lt;/code&gt;。emit一个名为&lt;code&gt;add&lt;/code&gt;的事件，并将&lt;code&gt;Math.random()&lt;/code&gt;的值作为参数传递出去。&lt;/p&gt;
&lt;p&gt;然后，在父组件使用&lt;code&gt;v-on&lt;/code&gt;或&lt;code&gt;@&lt;/code&gt;指令可以监听我们的自定义添加事件并接收该参数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Child.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;button @click="$emit('add', Math.random())"&amp;gt;
    Add Math.random()
  &amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在** Parent.vue **中监听：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref } from 'vue'
const count = ref(0)
// 也可以从我们的模板中调用一个函数 `&amp;lt;ChildComponent @add="add" /&amp;gt;
// const add = (i) =&amp;gt; count.value += i
&amp;lt;/script&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;ChildComponent @add="(i) =&amp;gt; count += i" /&amp;gt; 
  &amp;lt;p&amp;gt;Count: {{ count }}&amp;lt;/p&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="001.webp" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f0ec489c6434733a5fcb44c9940afd9~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;每次我们点击按钮，&lt;code&gt;Child.vue&lt;/code&gt; 都会 emit 一个 &lt;code&gt;add&lt;/code&gt; 事件，并带有一个0到1之间的随机值。 然后，&lt;code&gt;Parent.vue&lt;/code&gt; 捕捉到这个事件，并将这个值添加到计数中。&lt;/p&gt;
&lt;p&gt;可以传递任意多的参数，监听器也会收到所有的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Child -&lt;code&gt; $emit('add', Math.random(), 44, 50)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Parent - &lt;code&gt;@add="(i, j, k) =&amp;gt; count += i + j + k"&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，我们知道如何在我们的模板中 emit 内联事件，但在更复杂的例子中，如果我们从SFC的&lt;code&gt;script&lt;/code&gt; 中 emit 一个事件会更好。特别是当我们想在 emit 事件之前执行一些逻辑时，这很有用。&lt;/p&gt;
&lt;p&gt;在Vue 3中，我们有2种不同的方法来做到这一点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选项API -&lt;code&gt; this.$emit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;带有&lt;code&gt;setup()&lt;/code&gt;的组合API -&lt;code&gt; context.emit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;带有&lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt;的组合API - &lt;code&gt;defineEmits()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们一个一个来看。&lt;/p&gt;
&lt;h2&gt;选项API -&lt;code&gt; this.$emit&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在 Vue3 中，我人可以选择使用选项API或组合API。&lt;/p&gt;
&lt;p&gt;在选项API中，我们可以调用&lt;code&gt;this.$emit&lt;/code&gt;来 emit一个自定义事件。&lt;/p&gt;
&lt;p&gt;看下面这个例子在 &lt;code&gt;MyTextInput.vue&lt;/code&gt; 中，它包含一个 &lt;code&gt;label&lt;/code&gt; 和 &lt;code&gt;input&lt;/code&gt;。每当 &lt;code&gt;input&lt;/code&gt; 改变时，我们会 emit 一个事件，并将输入的值转成大写作为参数传递出去。&lt;/p&gt;
&lt;p&gt;我们可以不从模板中调用&lt;code&gt;$emit&lt;/code&gt;，而是调用一个组件方法。在该方法中调用&lt;code&gt;this.$emit&lt;/code&gt;并把我们的值传给它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyTextInput.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  export default {
      methods: {
          handleChange (event) {
              this.$emit("customChange", event.target.value.toUpperCase())
          }
      }
  }
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;label&amp;gt;My Custom Input&amp;lt;/label&amp;gt;
    &amp;lt;input type="text" placeholder="Custom input!" @input="handleChange" /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;strong&gt;Parent.vue&lt;/strong&gt; 中接收：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  export default {
      methods: {
          handleChange (event) {
              this.$emit("customChange", event.target.value.toUpperCase())
          }
      }
  }
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;label&amp;gt;My Custom Input&amp;lt;/label&amp;gt;
    &amp;lt;input type="text" placeholder="Custom input!" @input="handleChange" /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="002.webp" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbead1ce1f254a81b4e6326103edbe52~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;带有&lt;code&gt;setup()&lt;/code&gt;的组合API -&lt;code&gt; context.emit&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在 组合API中，如果使用&lt;code&gt;setup&lt;/code&gt;函数，就不能在用 &lt;code&gt;this&lt;/code&gt;,也就是不能调用&lt;code&gt;this.$emit()&lt;/code&gt;方法了。&lt;/p&gt;
&lt;p&gt;相反，可以使用 setup 方法中的第二个参数 &lt;code&gt;context&lt;/code&gt; 来访问 &lt;code&gt;emit&lt;/code&gt;  方法。我们可以用之前使用的事件名称和值调用&lt;code&gt;context.emit&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyTextInput.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  export default {
    // can use the entire context object
    setup (props, context) {
        const handleChange = (event) =&amp;gt; {
            context.emit("customChange", event.target.value)
        }
        return {
            handleChange
        }
    },
    // or we can destructure it and get `emit`
    setup (props, { emit }) { 
        const handleChange = (event) =&amp;gt; {
            emit("customChange", event.target.value)
        }
        return {
            handleChange
        }
    }
  }
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;label&amp;gt;My Custom Input&amp;lt;/label&amp;gt;
    &amp;lt;input type="text" placeholder="Custom input!" @input="handleChange" /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="003.webp" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddf3f97add3840e1a7beb4c80506b2f5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;在 &lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt; 中的用法&lt;/h2&gt;
&lt;p&gt;当我们使用&lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt;时，我们无法访问组件实例或 &lt;code&gt;context&lt;/code&gt; 上下文参数。那我们怎么获得 &lt;code&gt;emit&lt;/code&gt; ?&lt;/p&gt;
&lt;p&gt;在这种情况下，我们可以使用 &lt;code&gt;defineEmits&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定组件要 emit 事件&lt;/li&gt;
&lt;li&gt;为每个事件添加验证信息&lt;/li&gt;
&lt;li&gt;可以访问与context.emit相同的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在最简单的情况下，&lt;code&gt;defineEmits&lt;/code&gt;是一个字符串数组，每个字符串是一个事件的名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyTextInput.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
const emit = defineEmits(['customChange'])

const handleChange = (event) =&amp;gt; {
  emit('customChange', event.target.value.toUpperCase())
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="004.webp" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7278ba7110e14c5eb876b30c716607cb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;然而，如果我们传递一个对象，我们可以为每个事件添加一个验证器函数，我们可以在里面检查值是否是我们所需要的格式。&lt;/p&gt;
&lt;p&gt;像事件监听器一样，验证器接受我们传入所有参数。&lt;/p&gt;
&lt;p&gt;这与prop  validation 类似，如果我们的验证器返回 &lt;code&gt;false&lt;/code&gt;，会在控制台得到一个警告，这为我们提供了一些有用的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyTextInput.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
const emit = defineEmits({
  unvalidatedEvent: null, // if we want an event without validation
  customChange: (s) =&amp;gt; {
    if (s &amp;amp;&amp;amp; typeof s === 'string') {
      return true
    } else {
      console.warn(`Invalid submit event payload!`)
      return false
    }
  },
})

const handleChange = (event) =&amp;gt; {
  // no console warning
  emit('customChange', event.target.value.toUpperCase())
}

onMounted(() =&amp;gt; {
  emit('customChange', 1) // not a string, warning!
})
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;最佳实践&lt;/h2&gt;
&lt;h4&gt;使用 emits 定义自定义事件。&lt;/h4&gt;
&lt;p&gt;如果我们不使用&lt;code&gt;defineEmits&lt;/code&gt;，我们仍然可以通过&lt;code&gt;export default&lt;/code&gt;中定义&lt;code&gt;emits&lt;/code&gt;选项来跟踪一个组件的自定义事件。&lt;/p&gt;
&lt;p&gt;这对保持良好的组件文档很重要，如果我们试图使用一个没有在 emits 中声明的事件，也会从Vue那里得到错误。&lt;/p&gt;
&lt;p&gt;当在 emits 选项中定义了原生事件 (如 change) 时，将使用组件中的事件替代原生事件侦听器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  export default {
      emits: ["change"] // or can pass object with validators
  }
&amp;lt;/script&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;label&amp;gt;My Custom Input&amp;lt;/label&amp;gt;
    &amp;lt;input
      type="text"
      placeholder="Custom input!"
      @input='$emit("change", $event.target.value)'
    /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;


&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;正确的事件命令&lt;/h3&gt;
&lt;p&gt;在 vue3 中，与组件和 prop 一样，事件名提供了自动的大小写转换。如果在子组件中触发一个以 camelCase (驼峰式命名) 命名的事件，你将可以在父组件中添加一个 kebab-case (短横线分隔命名) 的监听器。&lt;/p&gt;
&lt;p&gt;然而，如果你使用的是Vue 2，事件名称没有自动的大小写转换，由于&lt;code&gt;v-on&lt;/code&gt;指令会自动将你的事件名称转换为小写，所以camelCase命名的事件不可能被监听到。&lt;/p&gt;
&lt;p&gt;例如，如果我们发出了一个名为&lt;code&gt;myEvent&lt;/code&gt;的事件，监听&lt;code&gt;my-event&lt;/code&gt;将无法工作。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;编辑中可能存在的bug没法实时知道，事后为了解决这些bug,花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者：Noveo 译者：小智  来源：learnvue&lt;/p&gt;
&lt;p&gt;原文：https://learnvue.co/tutorals/vue-emit-guide&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>前端小智</author><pubDate>Wed, 13 Jul 2022 16:36:14 GMT</pubDate></item><item><title>围绕Vue 3 Composition API构建一个应用程序，包含一些最佳实践！</title><link>https://juejin.cn/post/7119276428872384542</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: juejin&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1. Vue 3和Composition API的状况&lt;/h2&gt;
&lt;p&gt;Vue 3已经发布了一年，它的主要新功能是：Composition API。从2021年秋季开始，推荐新项目使用Vue 3的 &lt;code&gt;script setup &lt;/code&gt;语法，所以希望我们能看到越来越多的生产级应用程序建立在Vue 3上。&lt;/p&gt;
&lt;p&gt;这篇文章旨在展示一些有趣的方法来利用Composition API，以及如何围绕它来构造一个应用程序。&lt;/p&gt;
&lt;h2&gt;2. 可组合函数和代码重用&lt;/h2&gt;
&lt;p&gt;新的组合API释放了许多有趣的方法来重用跨组件的代码。复习一下：以前我们根据组件选项API分割组件逻辑：data、methods、created 等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//  选项API风格
data: () =&amp;gt; ({
    refA: 1,
    refB: 2,
  }),
// 在这里，我们经常看到500行的代码。
computed: {
  computedA() {
    return this.refA + 10;
  },
  computedB() {
    return this.refA + 10;
  },
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了Composition API，我们就不会受限于这种结构，可以根据功能而不是选项来分离代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setup() {
    const refA = ref(1);
const computedA = computed(() =&amp;gt; refA.value + 10);
/* 
这里也可能是500行的代码。
    但是，这些功能可以保持在彼此附近!
*/
    const computedB = computed(() =&amp;gt; refA.value + 10);
const refB = ref(2);

    return {
      refA,
      refB,
      computedA,
      computedB,
    };
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vue 3.2引入了&lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt;语法，这只是&lt;code&gt;setup()&lt;/code&gt;函数的语法糖，使代码更加简洁。从现在开始，我们将使用 script setup  语法，因为它是最新的语法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref, computed } from 'vue'

const refA = ref(1);
const computedA = computed(() =&amp;gt; refA.value + 10);

const refB = ref(2);
const computedB = computed(() =&amp;gt; refA.value + 10);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在我看来，这是一个比较大想法。我们可以把这些功能分成自己的文件，而不是用通过放置 在script setup中的位置来保持它们的分离。下面是同样的逻辑，把文件分割开来的做法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Component.vue
&amp;lt;script setup&amp;gt;
import useFeatureA from "./featureA";
import useFeatureB from "./featureB";

const { refA, computedA } = useFeatureA();
const { refB, computedB } = useFeatureB();
&amp;lt;/script&amp;gt;

// featureA.js 
import { ref, computed } from "vue";

export default function () {
  const refA = ref(1);
  const computedA = computed(() =&amp;gt; refA.value + 10);
  return {
    refA,
    computedA,
  };
}

// featureB.js 
import { ref, computed } from "vue";

export default function () {
  const refB = ref(2);
  const computedB = computed(() =&amp;gt; refB.value + 10);
  return {
    refB,
    computedB,
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，&lt;code&gt;featureA.js&lt;/code&gt;和&lt;code&gt;featureB.js&lt;/code&gt;导出了&lt;code&gt;Ref&lt;/code&gt;和&lt;code&gt;ComputedRef&lt;/code&gt;类型，因此所有这些数据都是响应式的。&lt;/p&gt;
&lt;p&gt;然而，这个特定的片段可能看起来有点矫枉过正。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想象一下，这个组件有500多行代码，而不是10行。通过将逻辑分离&lt;code&gt;到use__.js&lt;/code&gt;文件中，代码变得更加可读。&lt;/li&gt;
&lt;li&gt;我们可以在多个组件中自由地重复使用&lt;code&gt;.js&lt;/code&gt;文件中的可组合函数 不再有无渲染组件与作用域槽的限制，也不再有混合函数的命名空间冲突。因为可组合函数直接使用了Vue的&lt;code&gt;ref&lt;/code&gt;和 &lt;code&gt;computed&lt;/code&gt;，所以这段代码可以与你项目中的任何&lt;code&gt;.vue&lt;/code&gt;组件一起使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;陷阱1：setup 中的生命周期钩子&lt;/h2&gt;
&lt;p&gt;如果生命周期钩子（&lt;code&gt;onMounted&lt;/code&gt;，&lt;code&gt;onUpdated&lt;/code&gt;等）可以在&lt;code&gt;setup&lt;/code&gt;里面使用，这也意味着我们也可以在我们的可组合函数里面使用它们。甚至可以这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Component.vue
&amp;lt;script setup&amp;gt;
import { useStore } from 'vuex';

const store = useStore();
store.dispatch('myAction');
&amp;lt;/script&amp;gt;


// store/actions.js
import { onMounted } from 'vue'
// ...
actions: {
  myAction() {
    onMounted(() =&amp;gt; {
console.log('its crazy, but this onMounted will be registered!')
})
  }
}
// ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且Vue甚至会在vuex内部注册生命周期钩子! (问题是：你应该🤨🙂)&lt;/p&gt;
&lt;p&gt;有了这种灵活性，了解如何以及何时注册这些钩子就很重要了。请看下面的片段。哪些&lt;code&gt;onUpdated&lt;/code&gt;钩子将被注册？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang="ts"&amp;gt;
import { ref, onUpdated } from "vue";

// 这个钩子将被注册。我们在 setup 中正常调用它
onUpdated(() =&amp;gt; {
  console.log('✅')
});

class Foo {
  constructor() {
    this.registerOnMounted();
  }

  registerOnMounted() {
     //它也会注册! 它是在一个类方法中，但它是在 
     //在 setup 中同步执行
    onUpdated(() =&amp;gt; { 
      console.log('✅')
    });
  }
}
new Foo();

// IIFE also works
(function () {
  onUpdated(() =&amp;gt; {
    state.value += "✅";
  });
})();


const onClick = () =&amp;gt; {
/* 
这不会被注册。这个钩子是在另一个函数里面。
Vue不可能在setup 初始化中达到这个方法。
最糟糕的是，你甚至不会得到一个警告，除非这个 
函数被执行! 所以要注意这一点。
*/ 
  onUpdated(() =&amp;gt; {
    console.log('❌')
  });
};

// 异步IIFE也会不行 :(
(async function () {
  await Promise.resolve();
  onUpdated(() =&amp;gt; {
    state.value += "❌";
  });
})();
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结论：在声明生命周期方法时，应使其在&lt;code&gt;setup&lt;/code&gt;初始化时同步执行。否则，它们在哪里被声明以及在什么情况下被声明并不重要。&lt;/p&gt;
&lt;h2&gt;陷阱2：setup 中的异步函数&lt;/h2&gt;
&lt;p&gt;我们经常需要在我们的逻辑中使用&lt;code&gt;async/await&lt;/code&gt;。天真的做法是尝试这样做:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang="ts"&amp;gt;
import { myAsyncFunction } from './myAsyncFunction.js
const data = await myAsyncFunction();
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  Async data: {{ data }}
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，如果我们尝试运行&lt;a href="https://sfc.vuejs.org/#eNp9j01qw0AMha8yaNVCPLN3k0Ju0APMZuqo6QTPD5LsUIzvXk1TQkggO70nvY+nBfa12nlC6GHLA8UqhlGmasaQjzsPwh7efR5KZjGHIMHsTDiHKOaDSoqMlpDLOOPL65vPW3dhaEKFYKpjEFRlzJ5/8vBH6M2yXFDr2iLXM9hATLWQdClUe+KStdXSwv5/oWU03Zzmae2mPXyLVO6d46+h/XJiW+jodLI0ZYkJLXLqPqmcGUnBHjY3DKfmjNQR5gMS0jPm3ekDt2H1qRXWX8CneR8="&gt;这段代码&lt;/a&gt;，组件根本不会被渲染。为什么?因为 Promise 不跟踪状态。我们给 data  变量赋了一个 promise，但是Vue不会主动更新它的状态。幸运的是，有一些变通办法：&lt;/p&gt;
&lt;h4&gt;解决方案1：使用&lt;code&gt;.then&lt;/code&gt;语法的&lt;code&gt;ref&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;为了渲染该组件，我们可以使用&lt;code&gt;.then&lt;/code&gt;语法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref } from "vue";
import { myAsyncFunction } from './myAsyncFunction.js

const data = ref(null);
myAsyncFunction().then((res) =&amp;gt;
  data.value = fetchedData
);
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  Async data: {{ data }}
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;一开始时，创建一个等于null的响应式&lt;code&gt;ref&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用了异步函数script setup 的上下文是同步的，所以该组件会渲染&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;myAsyncFunction()&lt;/code&gt; promise 被解决时，它的结果被赋值给响应性 data ref，结果被渲染&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方式有自己优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点是：可以使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：语法有点过时，当有多个&lt;code&gt;.then&lt;/code&gt;和&lt;code&gt;.catch&lt;/code&gt;链时，会变得很笨拙。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;解决方案2：IIFE&lt;/h4&gt;
&lt;p&gt;如果我们把这个逻辑包在一个异步IIFE里面，我们就可以使用 &lt;code&gt;async/await&lt;/code&gt;的语法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { ref } from "vue";
import { myAsyncFunction } from './myAsyncFunction.js'

const data = ref(null);
(async function () {
    data.value = await myAsyncFunction()
})();
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  Async data: {{ data }}
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式也有自己优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：async/await语法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：可以说看起来不那么干净，仍然需要一个额外的引用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;解决方案3：Suspense （实验性的）&lt;/h4&gt;
&lt;p&gt;如果我们在父组件中用&lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;包装这个组件，我们就可以自由在setup 中自由使用&lt;code&gt;async/await&lt;/code&gt;!&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;// Parent.vue
&amp;lt;script setup lang="ts"&amp;gt;
import { Child } from './Child.vue
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;Suspense&amp;gt;
&amp;lt;Child /&amp;gt;
&amp;lt;/Suspense&amp;gt;
&amp;lt;/template&amp;gt;

// Child.vue
&amp;lt;script setup lang="ts"&amp;gt;
import { myAsyncFunction } from './myAsyncFunction.js
const data = await myAsyncFunction();
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  Async data: {{ data }}
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：到目前为止，最简明和直观的语法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：截至2021年12月，这仍然是一个实验性的功能，它的语法可能会改变。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 组件在子组件 setup 中有更多的可能性，而不仅仅是异步。使用它，我们还可以指定加载和回退状态。我认为这是创建异步组件的前进方向。Nuxt 3已经使用了这个特性，对我来说，一旦这个特性稳定下来，它可能是首选的方式&lt;/p&gt;
&lt;h3&gt;解决方案4：单独的第三方方法，为这些情况量身定做（见下节）。&lt;/h3&gt;
&lt;p&gt;优点。最灵活&lt;/p&gt;
&lt;p&gt;缺点：对package.json的依赖&lt;/p&gt;
&lt;h2&gt;3. VueUse&lt;/h2&gt;
&lt;p&gt;VueUse库依靠Composition API解锁的新功能，给出了各种辅助函数。就像我们写的&lt;code&gt;useFeatureA&lt;/code&gt;和&lt;code&gt;useFeatureB&lt;/code&gt;一样，这个库可以让我们导入预制的实用函数，以可组合的风格编写。下面是它的工作原理的一个片段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang="ts"&amp;gt;
import {
  useStorage,
useDark
} from "@vueuse/core";
import { ref } from "vue";

/* 
    一个实现localStorage的例子。 
这个函数返回一个Ref，所以可以立即用`.value`语法来编辑它。
用.value语法编辑，而不需要单独的getItem/setItem方法。
*/
const localStorageData = useStorage("foo", undefined);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我无法向你推荐这个库，在我看来，它是任何新的Vue 3项目的必备品。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个库有可能为你节省很多行代码和大量的时间。&lt;/li&gt;
&lt;li&gt;不影响包的大小&lt;/li&gt;
&lt;li&gt;源代码很简单，容易理解。如果你发现该库的功能不够，你可以扩展该功能。这意味在选择使用这个库时，不会有太大的风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是这个库如何解决前面提到的异步调用执行问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
import { useAsyncState } from "@vueuse/core";
import { myAsyncFunction } from './myAsyncFunction.js';

const { state, isReady } = useAsyncState(
// the async function we want to execute
  myAsyncFunction,

  // Default state:
  "Loading...",

  // UseAsyncState options:
  {
    onError: (e) =&amp;gt; {
      console.error("Error!", e);
      state.value = "fallback";
    },
  }
);
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  useAsyncState: {{ state }}
  Is the data ready: {{ isReady }}
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法可以让你在&lt;code&gt;setup&lt;/code&gt;里面执行异步函数，并给你回退选项和加载状态。现在，这是我处理异步的首选方法。&lt;/p&gt;
&lt;h2&gt;4. 如果你的项目使用Typescript&lt;/h2&gt;
&lt;h4&gt;新的&lt;code&gt;defineProps&lt;/code&gt;和&lt;code&gt;defineEmits&lt;/code&gt;语法&lt;/h4&gt;
&lt;p&gt;script setup  带来了一种在Vue组件中输入 props 和 emits 的更快方式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang="ts"&amp;gt;
import { PropType } from "vue";

interface CustomPropType {
  bar: string;
  baz: number;
}
//  defineProps的重载。
// 1. 类似于选项API的语法
defineProps({
  foo: {
    type: Object as PropType&amp;lt;CustomPropType&amp;gt;,
    required: false,
    default: () =&amp;gt; ({
      bar: "",
      baz: 0,
    }),
  },
});

// 2. 通过一个泛型。注意，不需要PropType!
defineProps&amp;lt;{ foo: CustomPropType }&amp;gt;();

// 3.默认状态可以这样做。
withDefaults(
  defineProps&amp;lt;{
    foo: CustomPropType;
  }&amp;gt;(),
  {
    foo: () =&amp;gt; ({
      bar: "",
      baz: 0,
    }),
  }
);

// // Emits也可以用defineEmits进行简单的类型化
defineEmits&amp;lt;{ (foo: "foo"): string }&amp;gt;();
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就个人而言，我会选择通用风格，因为它为我们节省了一个额外的导入，并且对null和 undefined  的类型更加明确，而不是Vue 2风格语法中的&lt;code&gt;{ required: false }&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;💡 注意，不需要手动导入 &lt;code&gt;defineProps&lt;/code&gt; 和 &lt;code&gt;defineEmits&lt;/code&gt;。这是因为这些是Vue使用的特殊宏。这些在编译时被处理成 "正常 的选项API语法。我们可能会在未来的&lt;code&gt;Vue版本&lt;/code&gt;中看到越来越多的宏的实现。&lt;/p&gt;
&lt;h3&gt;可组合函数的类型化&lt;/h3&gt;
&lt;p&gt;因为typescript要求默认输入模块的返回值，所以一开始我主要是用这种方式写TS组合物。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { ref, Ref, SetupContext, watch } from "vue";

export default function ({
  emit,
}: SetupContext&amp;lt;("change-component" | "close")[]&amp;gt;): 
// 下面的代码真的有必要吗？
{
  onCloseStructureDetails: () =&amp;gt; void;
  showTimeSlots: Ref&amp;lt;boolean&amp;gt;;
  showStructureDetails: Ref&amp;lt;boolean&amp;gt;;
  onSelectSlot: (arg1: onSelectSlotArgs) =&amp;gt; void;
  onBackButtonClick: () =&amp;gt; void;
  showMobileStepsLayout: Ref&amp;lt;boolean&amp;gt;;
  authStepsComponent: Ref&amp;lt;string&amp;gt;;
  isMobile: Ref&amp;lt;boolean&amp;gt;;
  selectedTimeSlot: Ref&amp;lt;null | TimeSlot&amp;gt;;
  showQuestionarireLink: Ref&amp;lt;boolean&amp;gt;;
} {
  const isMobile = useBreakpoints().smaller("md");
  const store = useStore();
// and so on, and so on
// ... 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式，我认为这是个错误。其实没有必要对函数返回进行类型化，因为在编写可组合的时候可以很容易地对它进行隐式类型化。它可以为我们节省大量的时间和代码行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { ref, Ref, SetupContext, watch } from "vue";

export default function ({
  emit,
}: SetupContext&amp;lt;("change-component" | "close")[]&amp;gt;) {
  const isMobile = useBreakpoints().smaller("md");
  const store = useStore();
// The return can be typed implicitly in composables
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;💡 如果EsLint将此标记为错误，将&lt;code&gt;'@typescript-eslint/explicit-module-boundary-types': 'error'&lt;/code&gt;，放入EsLint配置（&lt;code&gt;.eslintrc&lt;/code&gt;）。&lt;/p&gt;
&lt;h2&gt;Volar extension&lt;/h2&gt;
&lt;p&gt;Volar是作为VsCode和WebStorm的Vue扩展来取代Vetur的。现在它被正式推荐给Vue 3使用。对我来说，它的主要特点是：&lt;strong&gt;typing props and emits out of the bo&lt;/strong&gt;x。这很好用，特别是使用Typescript的话。&lt;/p&gt;
&lt;p&gt;现在，我总是会选择Vue 3项目中使用Volar。对于Vue 2, Volar仍然适用，因为它需要更少的配置 。&lt;/p&gt;
&lt;h2&gt;5. 围绕组合API的应用架构&lt;/h2&gt;
&lt;h4&gt;将逻辑从**.vue**组件文件中移出&lt;/h4&gt;
&lt;p&gt;以前，有一些例子，所有的逻辑都是在script setup 中完成的。还有一些例子是使用从&lt;code&gt;.vue&lt;/code&gt;文件导入的可组合函数的组件。&lt;/p&gt;
&lt;p&gt;大代码设计问题是：我们应该把所有的逻辑写在&lt;code&gt;.vue&lt;/code&gt;文件之外吗？有利有弊。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;所有的逻辑都放在 setup中&lt;/th&gt;
&lt;th&gt;移到专用的.js/.ts文件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不需要写一个可组合的，方便直接修改&lt;/td&gt;
&lt;td&gt;可扩展更强&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;重用代码时需要重构&lt;/td&gt;
&lt;td&gt;不需要重构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;更多模板&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我是这样选择的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在小型/中型项目中使用混合方法。一般来说，把逻辑写在setup里面。当组件太大时，或者当很清楚这些代码会被重复使用时，就把它放在单独的&lt;code&gt;js/ts&lt;/code&gt;文件中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于大型项目，只需将所有内容编写为可组合的。只使用setup来处理模板名称空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;作者：Noveo 译者：小智  来源：noveogroup&lt;/p&gt;
&lt;p&gt;原文：https://blog.noveogroup.com/2022/02/building-app-around-vue-3-composition-api&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>前端小智</author><pubDate>Mon, 11 Jul 2022 16:29:14 GMT</pubDate></item><item><title>Vue3.2 中新出的 expose 是做啥用的？</title><link>https://juejin.cn/post/7117420761739952159</link><description>&lt;blockquote&gt;
&lt;p&gt;作者：Marina Mosti
译者：前端小智
来源：vuemastery&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着Vue 3.2的发布，一个新的组合工具提供给我们，叫做 &lt;code&gt;expose&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你是否曾经创建过一个需要向模板提供一些方法和属性的组件，但又希望这些方法对组件是私有的，不能被父类调用？&lt;/p&gt;
&lt;p&gt;如果你在开发一个开源的组件或库，你有可能想保持一些内部方法的私有性。在Vue 3.2之前，这并不容易实现，因为所有在选项API中声明的方法或数据等都是公开的，所以模板可以访问它。&lt;/p&gt;
&lt;p&gt;组合API也是如此。我们从&lt;code&gt;setup&lt;/code&gt;方法中返回的所有东西都可以被父类直接访问。&lt;/p&gt;
&lt;h2&gt;组合 API&lt;/h2&gt;
&lt;p&gt;让我们看一个实际的例子。想象一下，我们有一个组件，它创建了一个计数器，每一秒都会更新这个计数器。&lt;/p&gt;
&lt;p&gt;** MyCounter.vue**&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;p&amp;gt;Counter: {{ counter }}&amp;lt;/p&amp;gt;

    &amp;lt;button @click="reset"&amp;gt;Reset&amp;lt;/button&amp;gt;
    &amp;lt;button @click="terminate"&amp;gt;☠️&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import { ref } from 'vue'

export default {
  setup () {
    const counter = ref(0)

    const interval = setInterval(() =&amp;gt; {
      counter.value++
    }, 1000)

    const reset = () =&amp;gt; {
      counter.value = 0
    }

    const terminate = () =&amp;gt; {
      clearInterval(interval)
    }

    return {
      counter,
      reset,
      terminate
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从组合的角度来看，我希望父级组件能够在需要时直接调用&lt;code&gt;reset&lt;/code&gt;方法--但我希望保持&lt;code&gt;terminate&lt;/code&gt; 函数和 &lt;code&gt;counter&lt;/code&gt; 的引用只对组件可用。&lt;/p&gt;
&lt;p&gt;如果我们把这个组件实例化到一个父类中，例如 App.vue，并给它附加一个 ref 引用，我们可以很容易地让父类调用 &lt;code&gt;reset&lt;/code&gt; 方法，因为当我们从 &lt;code&gt;setup&lt;/code&gt; 中返回它时，它已经和 &lt;code&gt;terminate&lt;/code&gt; 一起被暴露了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;App.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;MyCounter ref="counter" /&amp;gt;

  &amp;lt;button @click="reset"&amp;gt;Reset from parent&amp;lt;/button&amp;gt;
  &amp;lt;button @click="terminate"&amp;gt;Terminate from parent&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import MyCounter from '@/components/MyCounter.vue'

export default {
  name: 'App',
  components: {
    MyCounter
  },
  methods: {
    reset () {
      this.$refs.counter.reset()
    },
    terminate () {
      this.$refs.counter.terminate()
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果现在运行这个，并单击重置或终止按钮，两者都可以工作。&lt;/p&gt;
&lt;p&gt;让我们明确说明我们要向父类暴露(&lt;code&gt;expose&lt;/code&gt;)的内容，以便只有 &lt;code&gt;reset&lt;/code&gt; 函数可用。&lt;/p&gt;
&lt;p&gt;** MyCounter.vue**&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
import { ref } from 'vue'

export default {
  setup (props, context) {
    const counter = ref(null)

    const interval = setInterval(() =&amp;gt; {
      counter.value++
    }, 1000)

    const reset = () =&amp;gt; {
      counter.value = 0
    }

    const terminate = () =&amp;gt; {
      console.log(interval)
      clearInterval(interval)
    }

    context.expose({ reset })

    return {
      counter,
      reset,
      terminate
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，我们在&lt;code&gt;setup&lt;/code&gt;函数中加入了 &lt;code&gt;props&lt;/code&gt; 和 &lt;code&gt;context&lt;/code&gt; 参数。我们需要有可用的上下文，因为这是 &lt;code&gt;expose&lt;/code&gt; 函数的位置。我们也可以像这样使用重构: &lt;code&gt;{ expose }&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来，我们使用 &lt;code&gt;context.expose&lt;/code&gt; 来声明一个我们想要向实例化这个组件的父类公开的元素对象；在这个例子中，我们只打算让 &lt;code&gt;reset&lt;/code&gt; 功能可用。&lt;/p&gt;
&lt;p&gt;如果我们再次运行这个例子，并点击 "Terminate from parent" 按钮，我们会得到一个错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Uncaught TypeError: this.$refs.counter.terminate is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;terminate&lt;/code&gt; 功能不再可用，我们的私有API现在也无法访问了。&lt;/p&gt;
&lt;h2&gt;选项API&lt;/h2&gt;
&lt;p&gt;上面我们在 &lt;code&gt;composition API&lt;/code&gt; 使用 &lt;code&gt;exponse&lt;/code&gt;，但在options API中也可以使用这个方法。我们可以把它改写成如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//  MyCounter.vue


export default {
  created () { ... },
  data: () =&amp;gt; ({ counter: null }),
  methods: {
    reset () { ... },
    terminate () { ... }
  },
  expose: ['reset']
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，我们添加了一个新的选项API属性&lt;code&gt;expose&lt;/code&gt;，允许我们传入一个数组，其中字符串&lt;code&gt;'reset'&lt;/code&gt;是我们公开的函数的名称。&lt;/p&gt;
&lt;h3&gt;组合API 渲染功能&lt;/h3&gt;
&lt;p&gt;创建一个强大脸灵活的组件的方法是利用渲染函数的力量。这对Vue 3来说并不新鲜，但是随着composition API的建立，我们现在可以灵活地从&lt;code&gt;setup&lt;/code&gt;方法中直接返回组合API &lt;code&gt;h&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;这就产生了一个问题，因为在我们的&lt;code&gt;setup&lt;/code&gt;函数中，整个&lt;code&gt;return&lt;/code&gt;语句只是包含组件正在创建的节点的 &lt;code&gt;h&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;如果在这个时候我们选择向父类 expose 一些东西，我们就会遇到与我们之前看到的相反的问题。没有任何东西被暴露，因为除了DOM元素，没有任何东西被返回。&lt;/p&gt;
&lt;p&gt;让我们重写 &lt;code&gt;MyCounter.vue&lt;/code&gt; 组件来使用这个方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
// The template has been deleted
import { ref, h } from 'vue'

export default {
  setup (props, context) {
    const counter = ref(0)

    const interval = setInterval(() =&amp;gt; {
      counter.value++
    }, 1000)

    const reset = () =&amp;gt; {
      counter.value = 0
    }

    const terminate = () =&amp;gt; {
      clearInterval(interval)
    }

    // context.expose({ reset })

    return () =&amp;gt; h('div', [
      h('p', `Counter: ${counter.value}`),
      h('button', { onClick: reset }, 'Reset'),
      h('button', { onClick: terminate }, 'Terminate')
    ])
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，我们在顶部从Vue导入了 &lt;code&gt;h&lt;/code&gt;，因为我们需要用它来创建我们的DOM元素。&lt;/p&gt;
&lt;p&gt;为了说明问题，暂时注释了&lt;code&gt;context.expose&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;现在的 return 语句复制了我们之前的 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 的DOM结构，如果我们运行这个例子，我们能够正确点击元素上的重置和终止按钮。&lt;/p&gt;
&lt;p&gt;然而，如果我们现在点击 "Reset from parent"按钮，我们会遇到一个错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Uncaught TypeError: this.$refs.counter.reset is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;reset&lt;/code&gt;方法不再被暴露，因为它没有被&lt;code&gt;setup&lt;/code&gt;函数返回。为了解决这个问题，我们需要取消对&lt;code&gt;context.expose&lt;/code&gt;的调用，使其再次可用。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;新的 &lt;code&gt;expose&lt;/code&gt; 方法是非常直观的，而且很容易在我们的组件中实现。它清除了一些非常重要的组成问题，这些问题在过去甚至需要重写一个完整的组件，所以即使它不是你日常使用的API，它也是值得收藏在我们文件夹中吃灰。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原文：https://www.vuemastery.com/blog/understanding-vue-3-expose/&lt;/p&gt;</description><author>前端小智</author><pubDate>Wed, 06 Jul 2022 16:28:49 GMT</pubDate></item><item><title>any 和 unknown 傻傻分不清楚？</title><link>https://juejin.cn/post/7108496183298883597</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;13.5W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1WR4y1P7dw"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1WR4y1P7dw/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在你刚学 TypeScript 的时候，是不是遇到了很多令人抓狂的问题，最终你用上 any 大招把问题解决了。如果后期你没有系统的学习 TypeScript 的类型系统，你会发现你可能把 TypeScript 学成了 &lt;strong&gt;AnyScript&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 TypeScript 中，any 类型被称为 top type。所谓的 top type 可以理解为通用父类型，也就是能够包含所有值的类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: any;
​
value = true; // OK
value = 42; // OK
value = "Hello World"; // OK
value = []; // OK
value = {}; // OK
value = Math.random; // OK
value = null; // OK
value = undefined; // OK
value = new TypeError(); // OK
value = Symbol("type"); // OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在 TypeScript 3.0 时，又引入一个新的 top type —— &lt;strong&gt;unknown 类型&lt;/strong&gt;。同样，你也可以把任何值赋给 unknown 类型的变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: unknown;
​
value = true; // OK
value = 42; // OK
value = "Hello World"; // OK
value = []; // OK
value = {}; // OK
value = Math.random; // OK
value = null; // OK
value = undefined; // OK
value = new TypeError(); // OK
value = Symbol("type"); // OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d375fa3373d84f4d8c491166931a3cb5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么现在问题来了，any 类型和 unknown 类型之间有什么区别呢？any 类型可以理解成我不在乎它的类型，而unknown 类型可以理解成我不知道它的类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0823149987214d7698ee39103d52c1d7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其实 any 类型本质上是类型系统的一个逃生舱口，&lt;strong&gt;TypeScript 允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: any;
​
value.foo.bar; // OK
value.trim(); // OK
value(); // OK
new value(); // OK
value[0][1]; // OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会带来什么问题呢？下面我们来举一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function invokeCallback(callback: any) {
 &amp;nbsp; &amp;nbsp;try {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;callback();
 &amp;nbsp;  } catch (err) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.error(err)
 &amp;nbsp;  }
}
​
invokeCallback(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于以上的 TS 代码，在编译期不会提示任何错误，但在运行期将会抛出运行时错误。作为开发人员，any 类型给了我们很大的自由度，但同时也带来了一些隐患。&lt;strong&gt;为了解决 any 类型存在的安全隐患，TypeScript 团队在 3.0 版本时，引入了 unknown 类型，你可以把它理解成类型安全的 any 类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么 unknown 类型是类型安全的体现在哪里呢？这里我们把 invokeCallback 函数参数的类型改为 unknown 类型，之后 TS 编译器就会提示相应的错误信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function invokeCallback(callback: unknown) {
 &amp;nbsp; &amp;nbsp;try {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// Object is of type 'unknown'.(2571)
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;callback(); // Error
 &amp;nbsp;  } catch (err) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.error(err)
 &amp;nbsp;  }
}
​
invokeCallback(1); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相比 any 类型，TypeScript 会对 unknown 类型的变量执行类型检查，从而避免出现 callback 参数非函数类型。要解决上述问题，我们需要缩小 callback 参数的类型，即可以通过 typeof 操作符来确保传入的 callback 参数是函数类型的对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function invokeCallback(callback: unknown) {
 &amp;nbsp; &amp;nbsp;try {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;if (typeof callback === 'function') {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;callback();
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  }
 &amp;nbsp;  } catch (err) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.error(err)
 &amp;nbsp;  }
}
​
invokeCallback(1); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在实际工作中，你还可以通过 instanceof 或用户自定义类型守卫等方式来缩窄变量的类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;declare function isFunction(x: unknown): x is Function;
​
function f20(x: unknown) {
 &amp;nbsp; &amp;nbsp;if (x instanceof Error) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;x; &amp;nbsp;// Error
 &amp;nbsp;  }
 &amp;nbsp; &amp;nbsp;if (isFunction(x)) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;x; &amp;nbsp;// Function
 &amp;nbsp;  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与 any 类型不同，因为 TypeScript 会对 unknown 类型的变量执行类型检查，所以当我们把之前代码中 value 变量的类型改成 unknown 类型时，使用 value 变量的多个语句将出现错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: unknown;
​
// Object is of type 'unknown'.(2571)
value.foo.bar; // Error
value.trim(); // Error
value(); // Error
new value(); // Error
value[0][1]; // Error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，需要注意的是，unknown 类型的变量只能赋值给 any 类型和 unknown 类型本身。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: unknown;
​
let value1: unknown = value; // OK
let value2: any = value; // OK
let value3: boolean = value; // Error
let value4: number = value; // Error
let value5: string = value; // Error
let value6: object = value; // Error
let value7: any[] = value; // Error
let value8: Function = value; // Error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/333580eee6664b01aac61a5a43ddf473~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在往期文章中我们已经介绍过了 keyof 操作符和映射类型。any 类型和 unknown 类型在这些场合中的表现也是不一样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T40 = keyof any; &amp;nbsp;// string | number | symbol
type T41 = keyof unknown; &amp;nbsp;// never
​
type T50&amp;lt;T&amp;gt; = { [P in keyof T]: number };
type T51 = T50&amp;lt;any&amp;gt;; &amp;nbsp;// { [x: string]: number }
type T52 = T50&amp;lt;unknown&amp;gt;; &amp;nbsp;// {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，T50 类型被称为映射类型，在映射过程中，如果 key 的类型是 never 类型，则当前 key 将会被过滤掉，所以 T52 的类型是空对象类型。&lt;/p&gt;
&lt;p&gt;关于 any 类型和 unknown 类型的区别就介绍到这里，现在我们来做个总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可以把任何值赋给 any 类型的变量，并对该变量执行任何操作；&lt;/li&gt;
&lt;li&gt;你可以把任何值赋给 unknown 类型的变量，但你必须进行类型检查或类型断言才能对变量进行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2886ef1f92242239a363cfa23685866~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在平时工作中，为了保证类型安全，我们应该尽可能使用 &lt;strong&gt;unknown&lt;/strong&gt; 类型。最后我们来看一下 unknown 类型与不同类型进行类型运算的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T00 = unknown &amp;amp; null; &amp;nbsp;// null
type T01 = unknown &amp;amp; undefined; &amp;nbsp;// undefined
type T02 = unknown &amp;amp; null &amp;amp; undefined; &amp;nbsp;// null &amp;amp; undefined
type T03 = unknown &amp;amp; string; &amp;nbsp;// string
type T04 = unknown &amp;amp; string[]; &amp;nbsp;// string[]
type T05 = unknown &amp;amp; unknown; &amp;nbsp;// unknown
type T06 = unknown &amp;amp; any; &amp;nbsp;// any
​
type T10 = unknown | null; &amp;nbsp;// unknown
type T11 = unknown | undefined; &amp;nbsp;// unknown
type T12 = unknown | null | undefined; &amp;nbsp;// unknown
type T13 = unknown | string; &amp;nbsp;// unknown
type T14 = unknown | string[]; &amp;nbsp;// unknown
type T15 = unknown | unknown; &amp;nbsp;// unknown
type T16 = unknown | any; &amp;nbsp;// any
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a3a896dfbf4435b6f0eb510f2e7c87~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;any 类型比较特殊，该类型与任意类型进行交叉或联合运算时，都会返回 any 类型。阅读完本文之后，相信你已经了解 any 类型和 unknown 类型之间的区别了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你知道如何检测 any 类型和 unknown 类型么？&lt;/strong&gt; 如果知道的话，可以在评论区提交你的答案。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Sun, 12 Jun 2022 15:30:43 GMT</pubDate></item><item><title>用了模板字面量类型，同事直呼太强了！</title><link>https://juejin.cn/post/7106647263321325605</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;12.7W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1B34y1E7tm/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1B34y1E7tm/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你了解过模板字面量类型么？你想知道如何利用模板字面量类型，来减少 TypeScript 项目中的重复代码么？如果想的话，阅读完本文之后，也许你就懂了。假设我们想要定义一种类型来描述 CSS padding 规则，如果你了解 TypeScript 类型别名和联合类型的话，能很容易定义出 CssPadding 类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4e4a1d85bc945f993589d95fb6ab92a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type CssPadding =
 &amp;nbsp;| "padding-left"
 &amp;nbsp;| "padding-right"
 &amp;nbsp;| "padding-top"
 &amp;nbsp;| "padding-bottom";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但如果我们想要继续定义一种新的类型来描述 CSS margin 规则，你是不是立马想到与定义 CssPadding 类型一样的方式。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MarginPadding =
 &amp;nbsp;| "margin-left"
 &amp;nbsp;| "margin-right"
 &amp;nbsp;| "margin-top"
 &amp;nbsp;| "margin-bottom";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30da3e73d57540968784e22187fa6398~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;对于以上定义的两种类型来说，虽然它们都能满足我们的需求。但在定义这两种类型的过程中，仍然存在一些重复的代码。那么如何解决这个问题呢？这时我们可以使用 TypeScript 4.1 版本引入了新的模板字面量类型，具体的使用方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Direction = "left" | "right" | "top" | "bottom";
​
type CssPadding = `padding-${Direction}`;
type MarginPadding = `margin-${Direction}`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/507a39d3df82491f90e14cbb80251a87~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;看完以上代码，是不是觉得简洁很多。与 JavaScript 中的模板字符串类似，模板字面量类型被括在反引号中，同时可以包含 &lt;code&gt;${T}&lt;/code&gt; 形式的占位符，其中类型变量 T 的类型可以是 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt; 或 &lt;code&gt;bigint&lt;/code&gt; 类型。&lt;/p&gt;
&lt;p&gt;模板字面量类型不仅为我们提供了连接字符串字面量的能力，而且还可以把非字符串基本类型的字面量转换为对应的字符串字面量类型。下面我们来举一些具体的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type EventName&amp;lt;T extends string&amp;gt; = `${T}Changed`;
type Concat&amp;lt;S1 extends string, S2 extends string&amp;gt; = `${S1}-${S2}`;
type ToString&amp;lt;T extends string | number | boolean | bigint&amp;gt; = `${T}`;
​
type T0 = EventName&amp;lt;"foo"&amp;gt;; // 'fooChanged'
type T1 = Concat&amp;lt;"Hello", "World"&amp;gt;; // 'Hello-World'
type T2 = ToString&amp;lt;"阿宝哥" | 666 | true | -1234n&amp;gt;; // "阿宝哥" | "true" | "666" | "-1234"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/346480799b014bc7b43094017053916c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;对于上述的例子来说，其实并不复杂。但现在问题来了，如果传入 EventName 或 Concat 工具类型的实际类型是联合类型的话，那么结果又会是怎样呢？接下来，我们来验证一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T3 = EventName&amp;lt;"foo" | "bar" | "baz"&amp;gt;; 
// "fooChanged" | "barChanged" | "bazChanged"
type T4 = Concat&amp;lt;"top" | "bottom", "left" | "right"&amp;gt;;
// "top-left" | "top-right" | "bottom-left" | "bottom-right"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/433d409800344e288edda8a3d0a9cef6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为什么会生成这样的类型呢？这是因为对于模板字面量类型来说，当类型占位符的实际类型是联合类型（A ｜B ｜C）的话，就会被自动展开：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;`[${A|B|C}]` =&amp;gt; `[${A}]` | `[${B}]` | `[${C}]`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da6ad7f256604ebf83914356f244b33f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;而对于包含多个类型占位符的情形，比如 &lt;code&gt;Concat&lt;/code&gt; 工具类型。多个占位符中的联合类型解析为叉积：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;`${A|B}-${C|D}` =&amp;gt; `${A}-${C}` | `${A}-${D}` | `${B}-${C}` | `${B}-${D}`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23822d8edc648d1b8fb41addcec3014~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;了解完上述的运算规则，你应该就能理解生成的 T3 和 T4 类型了。在使用模板字面量类型的过程中，我们还可以使用 TypeScript 提供的，用于处理字符串类型的内置工具类型，比如 &lt;strong&gt;Uppercase&lt;/strong&gt;、&lt;strong&gt;Lowercase&lt;/strong&gt;、&lt;strong&gt;Capitalize&lt;/strong&gt; 和 &lt;strong&gt;Uncapitalize&lt;/strong&gt;。具体的使用方式是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type GetterName&amp;lt;T extends string&amp;gt; = `get${Capitalize&amp;lt;T&amp;gt;}`;
type Cases&amp;lt;T extends string&amp;gt; = `${Uppercase&amp;lt;T&amp;gt;} ${Lowercase&amp;lt;T&amp;gt;} ${Capitalize&amp;lt;T&amp;gt;} ${Uncapitalize&amp;lt;T&amp;gt;}`;
​
type T5 = GetterName&amp;lt;'foo'&amp;gt;; &amp;nbsp;// "getFoo"
type T6 = Cases&amp;lt;'bar'&amp;gt;; &amp;nbsp;// "BAR bar Bar bar"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实，模板字面量类型的能力是很强大的，结合 TypeScript 的条件类型和 infer 关键字我们还可以实现类型推断。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Direction = "left" | "right" | "top" | "bottom";
type InferRoot&amp;lt;T&amp;gt; = T extends `${infer R}${Capitalize&amp;lt;Direction&amp;gt;}` ? R : T;
​
type T7 = InferRoot&amp;lt;"marginRight"&amp;gt;; // "margin"
type T8 = InferRoot&amp;lt;"paddingLeft"&amp;gt;; // "padding"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，InferRoot 工具类型除了利用模板字面量类型之外，还使用了 TypeScript 条件类型和 infer。如果你对这两个知识点，还不了解的话，可以观看 “用了 TS 条件类型，同事直呼 YYDS” 和 “学会 TS infer，写起泛型真香！” 这两期的视频。&lt;/p&gt;
&lt;p&gt;此外，TypeScript 4.1 版本允许我们使用 as 子句对映射类型中的键进行重新映射。它的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MappedTypeWithNewKeys&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T as NewKeyType]: T[K]
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  ^^^^^^^^^^^^^
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  This is the new syntax!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce1d6a2bbf14c92afb8a938e4b1093b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其中 NewKeyType 的类型必须是 string | number | symbol 联合类型的子类型。在重新映射的过程中，结合模板字面量类型所提供的能力，我们就可以实现一些有用的工具类型。比如，我们可以定义一个 Getters 工具类型，用于为对象类型生成对应的 Getter 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Getters&amp;lt;T&amp;gt; = {
  [K in keyof T as `get${Capitalize&amp;lt;string &amp;amp; K&amp;gt;}`]: () =&amp;gt; T[K]
};
​
interface Person {
 &amp;nbsp; &amp;nbsp;name: string;
 &amp;nbsp; &amp;nbsp;age: number;
 &amp;nbsp; &amp;nbsp;location: string;
}
​
type LazyPerson = Getters&amp;lt;Person&amp;gt;;
// {
// &amp;nbsp; getName: () =&amp;gt; string;
// &amp;nbsp; getAge: () =&amp;gt; number;
// &amp;nbsp; getLocation: () =&amp;gt; string;
// }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2b1d6b3ea74a5c9e96e8c77ff0d38e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，因为 keyof T 返回的类型可能会包含 symbol 类型，而 Capitalize 工具类型要求处理的类型需要是 string 类型的子类型，所以需要通过交叉运算符进行类型过滤。除了实现简单的工具类型之外，我们还可以实现比较复杂的工具类型。比如，用于获取对象类型中，任意层级属性的类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type PropType&amp;lt;T, Path extends string&amp;gt; = string extends Path
 &amp;nbsp;? unknown
  : Path extends keyof T
 &amp;nbsp;? T[Path]
  : Path extends `${infer K}.${infer R}`
 &amp;nbsp;? K extends keyof T
 &amp;nbsp; &amp;nbsp;? PropType&amp;lt;T[K], R&amp;gt;
 &amp;nbsp;  : unknown
  : unknown;
​
declare function getPropValue&amp;lt;T, P extends string&amp;gt;(
 &amp;nbsp;obj: T,
 &amp;nbsp;path: P
): PropType&amp;lt;T, P&amp;gt;;
​
const obj = { a: { b: { c: 666, d: "阿宝哥" } } };
let a = getPropValue(obj, "a"); // { b: {c: number, d: string } }
let ab = getPropValue(obj, "a.b"); // {c: number, d: string }
let abd = getPropValue(obj, "a.b.d"); // string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/640e69f0eb7647249c27c215528dea1b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，PropType 工具类型涉及 TypeScript 中的多个核心知识点。除了递归类型之外，条件类型、条件链和 infer 类型推断这些知识点，阿宝哥在往期的文章中都已经介绍了。而关于递归类型的知识点，阿宝哥将在后续的文章中介绍，感兴趣的话记得关注阿宝哥。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Tue, 07 Jun 2022 15:42:46 GMT</pubDate></item><item><title>type 和 interface 傻傻分不清楚？</title><link>https://juejin.cn/post/7098491203443752974</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;7.1 W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8776a0d30114fda90da2b96b6560d04~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1HB4y1y7KG"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1HB4y1y7KG&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你简历上的技能有写 TypeScript，那么面试官可能会问你 type 和 interface 之间有什么区别？你知道怎么回答这个问题么？如果不知道的话，那看完本文也许你就懂了。&lt;/p&gt;
&lt;p&gt;类型别名 type 可以用来给一个类型起个新名字，当命名基本类型或联合类型等非对象类型时非常有用：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MyNumber = number;
type StringOrNumber = string | number;
type Text = string | string[];
type Point = [number, number];
type Callback = (data: string) =&amp;gt; void;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95381b09336d425586700d28acfaf093~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在 TypeScript 1.6 版本，类型别名开始支持泛型。我们工作中常用的 Partial、Required、Pick、Record 和 Exclude 等工具类型都是以 type 方式来定义的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;// lib.es5.d.ts
type Partial&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [P in keyof T]?: T[P];
};
​
type Required&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [P in keyof T]-?: T[P];
};
​
type Pick&amp;lt;T, K extends keyof T&amp;gt; = {
 &amp;nbsp;  [P in K]: T[P];
};
​
type Record&amp;lt;K extends keyof any, T&amp;gt; = {
 &amp;nbsp;  [P in K]: T;
};
​
type Exclude&amp;lt;T, U&amp;gt; = T extends U ? never : T;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而接口 interface 只能用于定义对象类型，Vue 3 中的 App 对象就是使用 interface 来定义的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;// packages/runtime-core/src/apiCreateApp.ts
export interface App&amp;lt;HostElement = any&amp;gt; {
 &amp;nbsp;version: string
 &amp;nbsp;config: AppConfig
 &amp;nbsp;use(plugin: Plugin, ...options: any[]): this
 &amp;nbsp;mixin(mixin: ComponentOptions): this
 &amp;nbsp;component(name: string): Component | undefined // Getter
 &amp;nbsp;component(name: string, component: Component): this // Setter
 &amp;nbsp;directive(name: string): Directive | undefined
 &amp;nbsp;directive(name: string, directive: Directive): this
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上代码可知，在定义接口时，我们可以同时声明对象类型上的属性和方法。了解 type 和 interface 的作用之后，我们先来介绍一下它们的相似之处。&lt;/p&gt;
&lt;p&gt;1、类型别名和接口都可以用来描述对象或函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型别名&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Point = {
 &amp;nbsp;x: number;
 &amp;nbsp;y: number;
};
​
type SetPoint = (x: number, y: number) =&amp;gt; void;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们通过 type 关键字为对象字面量类型和函数类型分别取了一个别名，从而方便在其他地方使用这些类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface Point {
 &amp;nbsp;x: number;
 &amp;nbsp;y: number;
}
​
interface SetPoint {
  (x: number, y: number): void;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、类型别名和接口都支持扩展&lt;/p&gt;
&lt;p&gt;类型别名通过 &amp;amp;（交叉运算符）来扩展，而接口通过 extends 的方式来扩展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型别名扩展&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Animal = {
 &amp;nbsp;name: string
}
​
type Bear = Animal &amp;amp; { 
 &amp;nbsp;honey: boolean 
}
​
const bear: Bear = getBear() 
bear.name
bear.honey
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;接口扩展&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface Animal {
 &amp;nbsp;name: string
}
​
interface Bear extends Animal {
 &amp;nbsp;honey: boolean
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/032e6bb259724d1faf144e70a9f3ea72~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;此外，接口也可以通过 extends 来扩展类型别名定义的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Animal = {
 &amp;nbsp;name: string
}
​
interface Bear extends Animal {
 &amp;nbsp;honey: boolean
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，类型别名也可以通过 &amp;amp;（交叉运算符）来扩展已定义的接口类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface Animal {
 &amp;nbsp;name: string
}
​
type Bear = Animal &amp;amp; { 
 &amp;nbsp;honey: boolean 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3d9ebb1515b4a108a1b96abbbadb641~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;了解完 type 和 interface 的相似之处之后，接下来我们来介绍它们之间的区别。&lt;/p&gt;
&lt;p&gt;1、类型别名可以为基本类型、联合类型或元组类型定义别名，而接口不行&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MyNumber = number;
type StringOrNumber = string | number;
type Point = [number, number];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、同名接口会自动合并，而类型别名不会&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同名接口合并&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface User {
 &amp;nbsp;name: string;
}
​
interface User {
 &amp;nbsp;id: number;
}
​
let user: User = { id: 666, name: "阿宝哥" };
user.id; // 666
user.name; // "阿宝哥"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;同名类型别名会冲突&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type User = {
 &amp;nbsp;name: string;
};
​
// 标识符“User”重复。ts(2300)
type User = {
 &amp;nbsp;id: number;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e3634daa7704b62a8b845ac6c43ee54~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;利用同名接口自动合并的特性，在开发第三方库的时候，我们就可以为使用者提供更好的安全保障。比如 &lt;a href="https://github.com/antfu/webext-bridge"&gt;webext-bridge&lt;/a&gt; 这个库，使用 interface 定义了 ProtocolMap 接口，从而让使用者可自由地扩展 ProtocolMap 接口。之后，在利用该库内部提供的 &lt;code&gt;onMessage&lt;/code&gt; 函数监听自定义消息时，我们就可以推断出不同消息对应的消息体类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展 ProtocolMap 接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;import { ProtocolWithReturn } from 'webext-bridge'
​
declare module 'webext-bridge' {
 &amp;nbsp;export interface ProtocolMap {
 &amp;nbsp; &amp;nbsp;foo: { title: string }
 &amp;nbsp; &amp;nbsp;bar: ProtocolWithReturn&amp;lt;CustomDataType, CustomReturnType&amp;gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;监听自定义消息&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;import { onMessage } from 'webext-bridge'
​
onMessage('foo', ({ data }) =&amp;gt; {
 &amp;nbsp;// type of `data` will be `{ title: string }`
 &amp;nbsp;console.log(data.title)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62f570dafdab4662b32a23c41017b4cd~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你感兴趣的话，可以看一下该项目的源码。若遇到问题，可以跟阿宝哥交流。最后我们来总结一下类型别名和接口的一些使用场景。&lt;/p&gt;
&lt;p&gt;使用类型别名的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义基本类型的别名时，使用 type&lt;/li&gt;
&lt;li&gt;定义元组类型时，使用 type&lt;/li&gt;
&lt;li&gt;定义函数类型时，使用 type&lt;/li&gt;
&lt;li&gt;定义联合类型时，使用 type&lt;/li&gt;
&lt;li&gt;定义映射类型时，使用 type&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用接口的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要利用接口自动合并特性的时候，使用 interface&lt;/li&gt;
&lt;li&gt;定义对象类型且无需使用 type 的时候，使用 interface&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阅读完本文，相信你已经了解 type 和 interface 之间的区别了。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Mon, 16 May 2022 16:12:28 GMT</pubDate></item><item><title>用了 TS 条件类型，同事直呼 YYDS！</title><link>https://juejin.cn/post/7096265620445986823</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;5.2W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1HR4y1N7ea/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1HR4y1N7ea/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你用过 Exclude、Extract、NonNullable、Parameters 和 ReturnType 这些工具类型吗？&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Exclude&amp;lt;T, U&amp;gt; = T extends U ? never : T;
type Extract&amp;lt;T, U&amp;gt; = T extends U ? T : never;
type NonNullable&amp;lt;T&amp;gt; = T extends null | undefined ? never : T;
type Parameters&amp;lt;T extends (...args: any) =&amp;gt; any&amp;gt; = T extends (...args: infer P) =&amp;gt; any ? P : never;
type ReturnType&amp;lt;T extends (...args: any) =&amp;gt; any&amp;gt; = T extends (...args: any) =&amp;gt; infer R ? R : any;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你知道它们内部是如何工作的吗？&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18becb1cec4f4d63a8ac836a2f093f7a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你想彻底掌握它们且实现自己的工具类型，那么本文千万不要错过。前面看到的那些内置工具类型，它们内部使用了 TypeScript 2.8 版本引入的条件类型（Conditional Types）。该类型的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;T extends U ? X : Y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 T、U、X 和 Y 这些都是类型占位符。你可以这样理解该语法，当类型 T 可以赋值给类型 U 时，那么返回类型 X，否则返回类型 Y。看到这里你是不是也想到了 JavaScript 中的三元表达式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31c4ef5f3a864df4967d552fa22d06d5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么条件类型有什么用呢？这里我们来举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type IsString&amp;lt;T&amp;gt; = T extends string ? true : false;
​
type I0 = IsString&amp;lt;number&amp;gt;; &amp;nbsp;// false
type I1 = IsString&amp;lt;"abc"&amp;gt;; &amp;nbsp;// true
type I2 = IsString&amp;lt;any&amp;gt;; &amp;nbsp;// boolean
type I3 = IsString&amp;lt;never&amp;gt;; &amp;nbsp;// never
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c121684a93604a3290ee25bd257c1eb8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，我们定义了 IsString 工具类型。使用该工具类型，我们可以判断传给类型参数 T 的实际类型是否为字符串类型。除了判断单一类型之外，利用条件类型和条件链，我们还可以同时判断多种类型。&lt;/p&gt;
&lt;p&gt;接下来，我们来看一下如何实现该功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type TypeName&amp;lt;T&amp;gt; =
 &amp;nbsp; &amp;nbsp;T extends string ? "string" :
 &amp;nbsp; &amp;nbsp;T extends number ? "number" :
 &amp;nbsp; &amp;nbsp;T extends boolean ? "boolean" :
 &amp;nbsp; &amp;nbsp;T extends undefined ? "undefined" :
 &amp;nbsp; &amp;nbsp;T extends Function ? "function" :
 &amp;nbsp; &amp;nbsp;"object";
​
type T0 = TypeName&amp;lt;string&amp;gt;; &amp;nbsp;// "string"
type T1 = TypeName&amp;lt;"a"&amp;gt;; &amp;nbsp;// "string"
type T2 = TypeName&amp;lt;true&amp;gt;; &amp;nbsp;// "boolean"
type T3 = TypeName&amp;lt;() =&amp;gt; void&amp;gt;; &amp;nbsp;// "function"
type T4 = TypeName&amp;lt;string[]&amp;gt;; &amp;nbsp;// "object"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们定义了一个新的 TypeName 工具类型，在该工具类型中，我们使用了条件链。为了便于大家理解条件链，我们以 JavaScript 三元表达式为例，来演示一下它的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function example(…) {
 &amp;nbsp; &amp;nbsp;return condition1 ? value1
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : condition2 ? value2
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : condition3 ? value3
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : value4;
}
​
// 等价于
function example(…) {
 &amp;nbsp; &amp;nbsp;if (condition1) { return value1; }
 &amp;nbsp; &amp;nbsp;else if (condition2) { return value2; }
 &amp;nbsp; &amp;nbsp;else if (condition3) { return value3; }
 &amp;nbsp; &amp;nbsp;else { return value4; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在问题来了，对于前面定义的 TypeName 工具类型来说，如果传入的类型是联合类型的话，那么将返回什么结果？下面我们来验证一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T10 = TypeName&amp;lt;string | (() =&amp;gt; void)&amp;gt;; &amp;nbsp;// "string" | "function"
type T11 = TypeName&amp;lt;string | string[] | undefined&amp;gt;; &amp;nbsp;// "string" | "object" | "undefined"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96ce7f75210f42aea55f3cd2a4266c71~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为什么 T10 和 T11 类型返回的是联合类型呢？这是因为 TypeName 属于分布式条件类型。在条件类型中，如果被检查的类型是一个 “裸” 类型参数，即没有被数组、元组或 Promise 等包装过，则该条件类型被称为分布式条件类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0377755c894548e6b03c9b5ed42b1acb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;对于分布式条件类型来说，当传入的被检查类型是联合类型的话，在运算过程中会被分解成多个分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;T extends U ? X : Y 
T =&amp;gt; A | B | C 
A | B | C extends U ? X : Y &amp;nbsp;=&amp;gt; 
(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dd1ef3fea6f464992e875c18d6d03e6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为了便于大家理解，我们来举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Naked&amp;lt;T&amp;gt; = T extends boolean ? "Y" : "N";
​
type WrappedTuple&amp;lt;T&amp;gt; = [T] extends [boolean] ? "Y" : "N";
type WrappedArray&amp;lt;T&amp;gt; = T[] extends boolean[] ? "Y" : "N";
type WrappedPromise&amp;lt;T&amp;gt; = Promise&amp;lt;T&amp;gt; extends Promise&amp;lt;boolean&amp;gt; ? "Y" : "N";
​
type T0 = Naked&amp;lt;number | boolean&amp;gt;; // "N" | "Y"
type T1 = WrappedTuple&amp;lt;number | boolean&amp;gt;; // "N"
type T2 = WrappedArray&amp;lt;number | boolean&amp;gt;; // "N"
type T3 = WrappedPromise&amp;lt;number | boolean&amp;gt;; // "N"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上结果可知，如果条件类型中的类型参数 T 被包装过，该条件类型就不属于分布式条件类型，所以在运算过程中就不会被分解成多个分支。了解完条件类型和分布式条件类型的知识点，我们来举例演示一下 TypeScript 内置工具类型 Exclude 的执行流程。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Exclude&amp;lt;T, U&amp;gt; = T extends U ? never : T;
type T4 = Exclude&amp;lt;"a" | "b" | "c", "a" | "b"&amp;gt;
​
("a" extends "a" | "b" ? never : "a") // =&amp;gt; never
| ("b" extends "a" | "b" ? never : "b") // =&amp;gt; never
| ("c" extends "a" | "b" ? never : "c") // =&amp;gt; "c"
​
never | never | "c" // =&amp;gt; "c"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/281bb2aff49f4194b7a263e58050b169~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;掌握了条件类型之后，再结合往期文章中介绍的&lt;a href="https://juejin.cn/post/7089943758543781896"&gt;映射类型&lt;/a&gt;，我们就可以实现一些有用的工具类型。比如实现 FunctionProperties 和 NonFunctionProperties 等工具类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9091804aa8fb4f308e2149d01d0e3f6d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17ceace0ab244401b4e9a6afcf9e4906~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type FunctionPropertyNames&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];
type FunctionProperties&amp;lt;T&amp;gt; = Pick&amp;lt;T, FunctionPropertyNames&amp;lt;T&amp;gt;&amp;gt;;
​
type NonFunctionPropertyNames&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];
type NonFunctionProperties&amp;lt;T&amp;gt; = Pick&amp;lt;T, NonFunctionPropertyNames&amp;lt;T&amp;gt;&amp;gt;;
​
interface User {
 &amp;nbsp; &amp;nbsp;id: number;
 &amp;nbsp; &amp;nbsp;name: string;
 &amp;nbsp; &amp;nbsp;age: number;
 &amp;nbsp; &amp;nbsp;updateName(newName: string): void;
}
​
type T5 = FunctionPropertyNames&amp;lt;User&amp;gt;; // "updateName"
type T6 = FunctionProperties&amp;lt;User&amp;gt;; // { updateName: (newName: string) =&amp;gt; void; }
type T7 = NonFunctionPropertyNames&amp;lt;User&amp;gt;; // "id" | "name" | "age"
type T8 = NonFunctionProperties&amp;lt;User&amp;gt;; // { id: number; name: string; age: number; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，利用上述的工具类型，我们就可以轻松地提取 User 对象类型中函数类型和非函数类型的属性及相关的对象类型。&lt;/p&gt;
&lt;p&gt;阅读完本文之后，相信你已经了解条件类型和分布式条件类型的作用了，也知道 TS 内部一些工具类型是如何实现的。关于在条件类型中如何利用 infer 实现类型推断，阿宝哥将在后续的文章中介绍。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Tue, 10 May 2022 16:18:52 GMT</pubDate></item><item><title>14.4W 播放量的 TS 动画版进阶教程合集来了！</title><link>https://juejin.cn/post/7095547569777934367</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: orange&lt;/h2&gt;
&lt;p&gt;阿宝哥精心准备的 &lt;strong&gt;&lt;a href="https://space.bilibili.com/406258607"&gt;《轻松学 TypeScript》&lt;/a&gt;&lt;/strong&gt; 视频教程来咯，强烈推荐！通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！目前已更新到第 &lt;strong&gt;19&lt;/strong&gt; 期，其中 1 期的观看量已破 2 W，该合集的播放量目前已达 14.4W+🔥🔥🔥。&lt;/p&gt;
&lt;p&gt;👇 新的一期已经发布了，感兴趣的小伙伴一起学起来。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cfbfe60f59748a7884fbeb96e916674~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你已掌握 TS 的话，那就来做做这 &lt;strong&gt;48&lt;/strong&gt; 道 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247495521&amp;amp;idx=1&amp;amp;sn=dd26b5b4f2cd2c78dcbcc9fd15b27df7&amp;amp;scene=21#wechat_redirect"&gt;TS 练习题&lt;/a&gt;。如果还没开始学 TS 的话，可以先看看 &lt;a href="https://juejin.cn/post/6872111128135073806"&gt;「1.8W字」不可多得的 TS 入门教程&lt;/a&gt;（4347个👍）&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk/"&gt;TypeScript 泛型中的 T、K、V 等到底是个啥？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/d5XUpAA_hG4TL8sBTCPlog"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TypeScript 泛型中的 K、T、V 等变量！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1040d61451f4b89b7a18a9267386fee~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1Wr4y1J7x3/"&gt;用了 TS 映射类型，同事直呼内行！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1Wr4y1J7x3/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/uhL9VZuKg1-CtnGlI0YO7A"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过生动形象的动画，让你搞清楚 TS 内置工具类型的工作原理，同时掌握 TS 映射类型相关语法及重要的知识点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f61f13585fc437fa0ee1c9eed159dfb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1JS4y1Y7Jy/"&gt;Vue 3 中使用的函数重载有啥用？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1JS4y1Y7Jy/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/kyOff_lCrKXWhyAamm-Prw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 Vue3 响应式模块 ref 函数所使用的重载技术，同时了解函数重载和方法重载相关的知识点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d192edf3a4fc48cd9ce7d894fa0d4d92~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1HB4y1y7KG/"&gt;type 和 interface 傻傻分不清楚？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1HB4y1y7KG/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/C-n1vkfv2pATT2fjdNLjmQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TypeScript type 和 interface 之间的区别，还有一个开发 TS 库时，值得学习的 “黑科技”。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0ecd507f53448329e2ee6bd7d5fb2e0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1WR4y1P7dw/"&gt;TypeScript 你还只会用 any？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1WR4y1P7dw/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/-83tlUcG2mOm79nVI2pu3g"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让你轻松搞懂 any 类型和 unknown 类型的区别及在不同场景中的表现。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6564211db2e94d83aa56dbfb6cc757f4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1HR4y1N7ea/"&gt;用了 TS 条件类型，同事直呼 YYDS！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1HR4y1N7ea/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/y-N265ULBluzwnmRGNs2Xg"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以后看到 T extends U ? X : Y 再也不怕了。精心设计设计的动画，让你轻松掌握条件类型、分布式条件类型和 TS 内置工具类型的工作原理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72fd06c2e4a94b36b05fb8162c7698fd~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1qv4y1P7D2/"&gt;学了 TS infer，我也会类型推断了！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1qv4y1P7D2/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/3QlkoSWyPrsNj1Sc8DvzJQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看完本期视频，你就可以轻松地使用条件类型和 infer 来开发各种工具类型实现类型推断。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afbbc8d141b9446dbba202105b3d66a4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1QY411T7Vn"&gt;TS 4.7 版本新特性，让 infer 更简单&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1QY411T7Vn"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/68iX9xt9QbBXzeP4QKF1mQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看完本期视频之后，让你写的 infer 类型推断更加简洁。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44df990ac3fd4be0b9795de230b5ed86~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1B34y1E7tm"&gt;用了模板字面量类型，同事直呼太强了！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1B34y1E7tm"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/Q8MpOTB77SdipwUVrc3Jyw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;模板字面量类型减少重复代码的利器，结合条件类型、映射类型和infer类型推断，你就能轻松应对工作中遇到的问题！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a330e5207c2444e3bbbfa4987d0c28bc~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1RF411T7zu/"&gt;搞懂 TypeScript 交叉类型的多个知识点！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1RF411T7zu/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/OnLXfjpnR9guQbROINIaag"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让你轻松理解交叉类型并掌握其核心知识点，学完后结合映射类型就可以根据工作需要实现一些自定义工具类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34997d985eec49d89dbf44fbea3236ab~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1jY4y1i7Lh/"&gt;搞懂 TypeScript 联合类型的多个知识点！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1jY4y1i7Lh/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/C_sD6oHwngJ-dU4tev5MQw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞懂 TypeScript 联合类型的多个知识点及应用场景！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2150a24e4f040a89c99c085a3cd5733~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1Zq4y1a79K/"&gt;TypeScript 中的类型到底是个啥？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1Zq4y1a79K/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/dL-G-BypnUMHE9e-MAlQwg"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过形象生动的动画，让你搞懂 TypeScript 的类型，打好进阶 TS 的基础！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0358dc1403b9423da920ac054f337a85~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1RY411A7YS/"&gt;仅知道键和值的类型，如何定义 TS 对象类型？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1RY411A7YS/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/L2sIMye6fo5-VnRccMWXqA"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚索引签名、Record 内置工具类型的使用场景和区别。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e6bb3363f84e6ca31651c5e508ac35~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1nT4y1a7AR/"&gt;TS 内置工具类型中的 keyof 操作符有啥用？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1nT4y1a7AR/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/QPAKjiYamib6HPItgqZEsw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TS 内置工具类型中 keyof 操作符的作用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ecd075b0ca44a26be4abb78a3d9733b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1P94y127pd"&gt;TS typeof 操作符，原来有这五种用途！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1P94y127pd/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/ptqYjU_0CQO-J88LsULcRQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TS 内置工具类型中 typeof 操作符的 5 大应用场景。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f89ac4a46634920af534ec42cd39506~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1254y1Z7BL/"&gt;减少 TS 重复代码，Omit 用起来真香！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1254y1Z7BL/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/sty4oaMCCbmjWAcrAOAJmA"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看完之后让你一次搞懂 TS 内置工具类型 Omit 的应用场景和内部实现原理！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8672c2253e3c4df483a79f24b048aa7a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1Da411J7jj/"&gt;听说你熟悉 Pick，那就来手写一个 MyPick！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1Da411J7jj/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/fGWen-uWviauRxF0zmseLw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类型体操开始热身了，看完之后让你一次搞懂 TS 内置工具类型 Pick 的内部实现原理！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eb7eb148f914b9c9b88f6437b33a06d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;《轻松学 TypeScript》 已发布 &lt;strong&gt;19 期&lt;/strong&gt; ，肝视频不易，如果对你有帮助的话，欢迎&lt;strong&gt;点赞与分享&lt;/strong&gt;，谢谢大家！你对 TS 哪方面比较感兴趣，可以给我留言呀！&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Sun, 08 May 2022 17:48:51 GMT</pubDate></item><item><title>用了 TS 映射类型，同事直呼内行！</title><link>https://juejin.cn/post/7089943758543781896</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1Wr4y1J7x3/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1Wr4y1J7x3/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你用过&amp;nbsp;Partial、Required、Pick 和 Readonly 这些工具类型吗？&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9e45e9defd947fe8d3da222adb9b54c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;你知道它们内部是如何工作的吗？&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb55806af6834dbe87d7844753821da7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你想彻底掌握它们且实现自己的工具类型，那么本文介绍的内容千万不要错过。&lt;/p&gt;
&lt;p&gt;在日常工作中，用户注册是一个很常见的场景。这里我们可以使用 TS 定义一个 User 类型，在该类型中所有的键都是必填的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type User = {
 &amp;nbsp;name: string; // 姓名
 &amp;nbsp;password: string; // 密码
 &amp;nbsp;address: string; // 地址
 &amp;nbsp;phone: string; // 联系电话
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常情况下，对于已注册的用户，我们是允许用户只修改部分用户信息。这时我们就可以定义一个新的 UserPartial 类型，表示用于更新的用户对象的类型，在该类型中所有的键都是可选的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type UserPartial = {
 &amp;nbsp;name?: string; // 姓名
 &amp;nbsp;password?: string; // 密码
 &amp;nbsp;address?: string; // 地址
 &amp;nbsp;phone?: string; // 联系电话
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53c621d50d3b4c62a493ab1a67387fb2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;而对于查看用户信息的场景，我们希望该用户对象所对应的对象类型中所有的键都是只读。针对这种需求，我们可以定义 ReadonlyUser 类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type ReadonlyUser = {
 &amp;nbsp;readonly name: string; // 姓名
 &amp;nbsp;readonly password: string; // 密码
 &amp;nbsp;readonly address: string; // 地址
 &amp;nbsp;readonly phone: string; // 联系电话
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d10197e269d54e49a5b1d3856eab1382~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;回顾前面已定义的与用户相关的 3 种类型，你会发现它们中含有很多重复的代码。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21c4f436353d4523bf32379ffcf6f6a2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么如何减少以上类型中的重复代码呢？&lt;/p&gt;
&lt;p&gt;答案是可以使用映射类型，&lt;strong&gt;它是一种泛型类型，可用于把原有的对象类型映射成新的对象类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74cb5f53f5974c8e8216910671f7a446~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a042030efe54889beabc03ec2d55f68~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;映射类型的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;{ [ P in K ] : T }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0f423e206294a7a9d3fb94b16182869~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其中 P in K 类似于 JavaScript 中的 &lt;code&gt;for...in&lt;/code&gt; 语句，用于遍历 K 类型中的所有类型，而 T 类型变量用于表示 TS 中的任意类型。&lt;/p&gt;
&lt;p&gt;在映射的过程中，你还可以使用 &lt;code&gt;readonly&lt;/code&gt; 和问号这两个额外的修饰符。通过添加加号和减号前缀，来增加和移除对应的修饰符。如果没有添加任何前缀的话，默认是使用加号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87caca9a43644334aefadb47adc1a700~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;现在我们就可以总结出常见的映射类型语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;{ [ P in K ] : T }
{ [ P in K ] ?: T }
{ [ P in K ] -?: T }
{ readonly [ P in K ] : T }
{ readonly [ P in K ] ?: T }
{ -readonly [ P in K ] ?: T }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;介绍完映射类型的语法，我们来看一些具体的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type Item = { a: string; b: number; c: boolean };

type T1 = { [P in "x" | "y"]: number }; // { x: number, y: number }
type T2 = { [P in "x" | "y"]: P }; // { x: "x", y: "y" }
type T3 = { [P in "a" | "b"]: Item[P] }; // { a: string, b: number }
type T4 = { [P in keyof Item]: Item[P] }; // { a: string, b: number, c: boolean }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们来看一下如何利用映射类型来重新定义 UserPartial 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type MyPartial&amp;lt;T&amp;gt; = {
  [P in keyof T]?: T[P];
};

type UserPartial = MyPartial&amp;lt;User&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们定义了 MyPartial 映射类型，然后利用该类型把 User 类型映射成 UserPartial 类型。其中 keyof 操作符用于获取某种类型中的所有键，其返回类型是联合类型。而类型变量 P 会随着每次遍历改变成不同的类型，&lt;code&gt;T[P]&lt;/code&gt; 该语法类似于属性访问的语法，用于获取对象类型某个属性对应值的类型。&lt;/p&gt;
&lt;p&gt;下面我们来演示一下 MyPartial 映射类型的完整执行流程，如果不清楚的话，可以多看几遍加深对 TS 映射类型的理解。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f61f13585fc437fa0ee1c9eed159dfb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;TypeScript 4.1 版本允许我们使用 as 子句对映射类型中的键进行重新映射。它的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type MappedTypeWithNewKeys&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T as NewKeyType]: T[K]
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  ^^^^^^^^^^^^^
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  这是新的语法！
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b502a3a628ca40a6baef42699d5950b2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其中 NewKeyType 的类型必须是 string | number | symbol 联合类型的子类型。使用 as 子句，我们可以定义一个 Getters 工具类型，用于为对象类型生成对应的 Getter 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type Getters&amp;lt;T&amp;gt; = {
  [K in keyof T as `get${Capitalize&amp;lt;string &amp;amp; K&amp;gt;}`]: () =&amp;gt; T[K]
};

interface Person {
 &amp;nbsp; &amp;nbsp;name: string;
 &amp;nbsp; &amp;nbsp;age: number;
 &amp;nbsp; &amp;nbsp;location: string;
}

type LazyPerson = Getters&amp;lt;Person&amp;gt;;
// {
// &amp;nbsp; getName: () =&amp;gt; string;
// &amp;nbsp; getAge: () =&amp;gt; number;
// &amp;nbsp; getLocation: () =&amp;gt; string;
// }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc4109e65fb4c96ac64975f9884f2c9~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，因为 keyof T 返回的类型可能会包含 symbol 类型，而 Capitalize 工具类型要求处理的类型需要是 string 类型的子类型，所以需要通过交叉运算符进行类型过滤。&lt;/p&gt;
&lt;p&gt;此外，在对键进行重新映射的过程中，我们可以通过返回 never 类型对键进行过滤：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;// Remove the 'kind' property
type RemoveKindField&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T as Exclude&amp;lt;K, "kind"&amp;gt;]: T[K]
};

interface Circle {
 &amp;nbsp; &amp;nbsp;kind: "circle";
 &amp;nbsp; &amp;nbsp;radius: number;
}

type KindlessCircle = RemoveKindField&amp;lt;Circle&amp;gt;;
// &amp;nbsp; type KindlessCircle = {
// &amp;nbsp; &amp;nbsp; &amp;nbsp; radius: number;
// &amp;nbsp; };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8018d739e8a4521b5121d1b7a5a9cea~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;看完本文之后，相信你已经了解映射类型的作用了，也知道 TS 内部一些工具类型是如何实现的。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c424563ccc6941f7b7c43771e36fe5c0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk"&gt;TypeScript 泛型中的 K、T、V 等到底是个啥？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://space.bilibili.com/406258607"&gt;轻松学 TypeScript&lt;/a&gt; 视频教程已更新了 7 集，本专题将会以形象生动的动画，带你一起学习 TypeScript 核心知识点，感兴趣的小伙伴一起学起来呀！&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Sat, 23 Apr 2022 15:26:03 GMT</pubDate></item><item><title>【动画演示】TypeScript 泛型中的 K、T、V 等到底是个啥？</title><link>https://juejin.cn/post/7084410879223005215</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1sY4y1H7vk/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你首次看到 TypeScript 泛型中的 &lt;strong&gt;T&lt;/strong&gt; 会感到陌生么？&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-1.gif" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdb08f75963b4b53af2973cbc7a29123~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;图中的 T 被称为&lt;strong&gt;泛型变量&lt;/strong&gt;，它是我们希望传递给 identity 函数的&lt;strong&gt;类型占位符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就像传递参数一样，我们把用户指定的实际类型，链式传递给参数类型和返回值类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-2.gif" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1040d61451f4b89b7a18a9267386fee~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么 T 是什么意思呢？图中的泛型变量 T 表示 Type，实际上 T 可以用任何有效的名称代替。除了 T 之外，常见的泛型变量还有 K、V 和 E 等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K 全称 &lt;strong&gt;Key&lt;/strong&gt; 表示对象中键的类型；&lt;/li&gt;
&lt;li&gt;V 全称 &lt;strong&gt;Value&lt;/strong&gt; 表示对象中值的类型；&lt;/li&gt;
&lt;li&gt;E 全称 &lt;strong&gt;Element&lt;/strong&gt; 表示元素类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="泛型变量-3.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/674dbfa8db5144b3ab94df084a2519e8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;当然你并不是只能定义一个类型变量，你可以引入任何数量的类型变量。这里我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数。&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-4.gif" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dec767a1a264da18b105830d8068714~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在调用 identity 函数时，我们可以显式指定泛型变量的实际类型。
当然你也可以不指定泛型变量的类型，让 TypeScript 自动帮我们完成类型推断。&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-5.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05c1a7120f49447f9d90966ae256b469~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;看完以上动画，你是不是已经理解泛型变量了？如果看懂的话，欢迎在评论区留言。看完觉得意犹未尽，那你可以继续阅读阿宝哥之前写的 &lt;a href="https://mp.weixin.qq.com/s/jF0ZEGM9BRQgyKPZ9W9MpA"&gt;你不知道的 TypeScript 泛型&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;p&gt;最后你喜欢以这种形式学 &lt;strong&gt;TS&lt;/strong&gt; 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Fri, 08 Apr 2022 17:32:45 GMT</pubDate></item><item><title>又一个基于 Esbuild 的神器！</title><link>https://juejin.cn/post/7065465955987488776</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 并不支持直接执行 TS 文件，如果要执行 TS 文件的话，我们就可以借助 &lt;a href="https://github.com/TypeStrong/ts-node"&gt;ts-node&lt;/a&gt; 这个库。相信有些小伙伴在工作中也用过这个库，关于 &lt;a href="https://github.com/TypeStrong/ts-node"&gt;ts-node&lt;/a&gt; 这个库的相关内容我就不展开介绍了，因为本文的主角是由 &lt;strong&gt;antfu&lt;/strong&gt; 大佬开源的 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 项目，接下来我将带大家一起来揭开这个项目背后的秘密。&lt;/p&gt;
&lt;p&gt;阅读完本文后，你将了解 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 项目是如何执行 TS 文件。此外，你还会了解如何劫持 Node.js 的 require 函数、如何为 ES Module 的 import 语句添加钩子及如何自定义 https 加载器，以支持 &lt;code&gt;import React from "https://esm.sh/react"&lt;/code&gt; 导入方式。&lt;/p&gt;
&lt;h3&gt;esno 是什么&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 是基于 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 的 TS/ESNext node 运行时。该库会针对不同的模块化标准，采用不同的方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;esno&lt;/code&gt; - Node in CJS mode - by &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;esmo&lt;/code&gt; - Node in ESM mode - by &lt;a href="https://github.com/antfu/esbuild-node-loader"&gt;esbuild-node-loader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 的方式很简单，你可以以全局或局部的方式来安装它：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局安装&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ npm i -g esno
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在安装成功后，你就可以通过以下方式来直接执行 TS 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ esno index.ts
$ esmo index.ts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;局部安装&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ npm i esno
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而对于局部安装的方式来说，一般情况下，我们会以 &lt;strong&gt;npm scripts&lt;/strong&gt; 的方式来使用它：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  "scripts": {
    "start": "esno index.ts"
  },
  "dependencies": {
    "esno": "0.14.0"
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;esno 是如何工作的&lt;/h3&gt;
&lt;p&gt;在开始分析 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 的工作原理之前，我们先来熟悉一下该项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;├── LICENSE
├── README.md
├── esmo.mjs
├── esno.js
├── package.json
├── pnpm-lock.yaml
├── publish.ts
└── tsconfig.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上的项目结构可知，该项目并不会复杂。在项目根目录下的 &lt;strong&gt;package.json&lt;/strong&gt; 文件中，我们看到了前面介绍的 &lt;strong&gt;esno&lt;/strong&gt; 和 &lt;strong&gt;esmo&lt;/strong&gt; 命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  "bin": {
    "esno": "esno.js",
    "esmo": "esmo.mjs"
  },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，在 &lt;strong&gt;package.json&lt;/strong&gt; 的 &lt;strong&gt;scripts&lt;/strong&gt; 字段中，我们发现了 &lt;strong&gt;release&lt;/strong&gt; 命令。顾名思义，该命令用来发布版本。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  "scripts": {
    "release": "npx bumpp --tag --commit --push &amp;amp;&amp;amp; node esmo.mjs publish.ts"
  },
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，在 &lt;code&gt;publish.ts&lt;/code&gt; 文件中，使用到了 2021 年度 Github 上最耀眼的项目 &lt;a href="https://github.com/google/zx"&gt;zx&lt;/a&gt;，利用该项目我们可以轻松地编写命令行脚本。写作本文时，它的 Star 数已经高达 &lt;strong&gt;27.5K&lt;/strong&gt;，强烈推荐感兴趣的小伙伴关注一下该项目。&lt;/p&gt;
&lt;p&gt;简单介绍了 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 项目之后，接下来我们来分析 &lt;code&gt;esno.js&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;#!/usr/bin/env node

const spawn = require('cross-spawn')
const spawnSync = spawn.sync

const register = require.resolve('esbuild-register')

const argv = process.argv.slice(2)

process.exit(spawnSync('node', ['-r', register, ...argv], 
  { stdio: 'inherit' }).status)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上代码可知，当执行 &lt;code&gt;esno index.ts&lt;/code&gt; 命令后，会通过 &lt;code&gt;spawnSync&lt;/code&gt; 来启动 &lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 程序执行脚本。需要注意的是，在执行时使用了 &lt;code&gt;-r&lt;/code&gt; 选项，该选项的作用是预加载模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; -r, --require = ... module to preload (option can be repeated)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里预加载的模块是 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt;，该模块就是 &lt;strong&gt;esno&lt;/strong&gt; 命令执行 TS 文件的幕后英雄。&lt;/p&gt;
&lt;h3&gt;esbuild-register 是什么&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 是一个基于 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 来转换 JSX、TS 和 esnext 特性的工具。你可以通过以下多种方式来安装它：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ npm i esbuild esbuild-register -D
# Or Yarn
$ yarn add esbuild esbuild-register --dev
# Or pnpm
$ pnpm add esbuild esbuild-register -D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在成功安装该模块之后，就可以在命令行中，直接通过 &lt;code&gt;node&lt;/code&gt; 应用程序来执行 ts 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node -r esbuild-register file.ts
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;-r, --require  =  ... module to preload (option can be repeated)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-r&lt;/code&gt; 用于指定预加载的文件，即在执行 &lt;code&gt;file.ts&lt;/code&gt; 文件前，提前加载 &lt;code&gt;esbuild-register&lt;/code&gt; 模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它将会使用 &lt;code&gt;tsconfig.json&lt;/code&gt; 中的 &lt;code&gt;jsxFactory&lt;/code&gt;, &lt;code&gt;jsxFragmentFactory&lt;/code&gt; 和 &lt;code&gt;target&lt;/code&gt; 配置项来执行转换操作。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 不仅可以在命令行中使用，而且还可以通过 API 的方式进行使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const { register } = require('esbuild-register/dist/node')

const { unregister } = register({
  // ...options
})

// Unregister the require hook if you don't need it anymore
unregister()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;了解完 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 的基本使用之后，接下来我们来分析它内部是如何工作的。&lt;/p&gt;
&lt;h3&gt;esbuild-register 是如何工作的&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 内部利用了 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库来劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数，从而让你可以在命令行中，直接执行 &lt;code&gt;ts&lt;/code&gt; 文件。下面我们来看一下 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 模块中定义的 &lt;code&gt;register&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;// esbuild-register/src/node.ts
import { transformSync, TransformOptions } from 'esbuild'
import { addHook } from 'pirates'

export function register(esbuildOptions: RegisterOptions = {}) {
  const {
    extensions = DEFAULT_EXTENSIONS,
    hookIgnoreNodeModules = true,
    hookMatcher,
    ...overrides
  } = esbuildOptions

  // 利用 transformSync 
  const compile: COMPILE = function compile(code, filename, format) {
    const dir = dirname(filename)
    const options = getOptions(dir)
    format = format ?? inferPackageFormat(dir, filename)

    const {
      code: js,
      warnings,
      map: jsSourceMap,
    } = transformSync(code, {
      sourcefile: filename,
      sourcemap: 'both',
      loader: getLoader(filename),
      target: options.target,
      jsxFactory: options.jsxFactory,
      jsxFragment: options.jsxFragment,
      format,
      ...overrides,
    })
// 省略部分代码
  }

  const revert = addHook(compile, {
    exts: extensions,
    ignoreNodeModules: hookIgnoreNodeModules,
    matcher: hookMatcher,
  })

  return {
    unregister() {
      revert()
    },
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上的代码可知，在 &lt;code&gt;register&lt;/code&gt; 函数内部是利用 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 模块提供的 &lt;code&gt;transformSync&lt;/code&gt; API 来实现 &lt;strong&gt;ts -&amp;gt; js&lt;/strong&gt; 代码的转换。其实最关键的环节，还是通过调用 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库提供的 &lt;code&gt;addHook&lt;/code&gt; 函数来注册编译 ts 文件的钩子。
那么 &lt;code&gt;addHook&lt;/code&gt; 函数内部到底做了哪些处理呢？下面我们来看一下它的实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// pirates-4.0.5/src/index.js
export function addHook(hook, opts = {}) {
  let reverted = false;
  const loaders = []; // 存放新的loader
  const oldLoaders = []; // 存放旧的loader
  let exts;

  const originalJSLoader = Module._extensions['.js']; // 原始的JS Loader 
  // 省略部分代码
  exts.forEach((ext) =&amp;gt; {
    // 获取已注册的loader，若未找到，则默认使用JS Loader
    const oldLoader = Module._extensions[ext] || originalJSLoader;
    oldLoaders[ext] = Module._extensions[ext];

    loaders[ext] = Module._extensions[ext] = function newLoader(
  mod, filename) {
      let compile;
      if (!reverted) {
        if (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {
          compile = mod._compile;
          mod._compile = function _compile(code) {
// 这里需要恢复成原来的_compile函数，否则会出现死循环
            mod._compile = compile;
// 在编译前先执行用户自定义的hook函数
            const newCode = hook(code, filename);
            if (typeof newCode !== 'string') {
              throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);
            }

            return mod._compile(newCode, filename);
          };
        }
      }

       oldLoader(mod, filename);
     };
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实 &lt;code&gt;addHook&lt;/code&gt; 函数的实现并不会复杂，该函数内部就是通过替换 &lt;code&gt;mod._compile&lt;/code&gt; 方法来实现钩子的功能。即在调用原始的 &lt;code&gt;mod._compile&lt;/code&gt; 方法进行编译前，会先调用 &lt;code&gt;hook(code, filename)&lt;/code&gt; 函数来执行用户自定义的 &lt;code&gt;hook&lt;/code&gt; 函数，从而对代码进行预处理。&lt;/p&gt;
&lt;p&gt;而对于 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 库中的 &lt;code&gt;register&lt;/code&gt; 函数来说，当 &lt;code&gt;hook&lt;/code&gt; 函数执行时，就会调用该函数内部定义的 &lt;code&gt;compile&lt;/code&gt; 函数来编译 ts 代码，然后再调用 &lt;code&gt;mod._compile&lt;/code&gt; 方法编译生成的 &lt;code&gt;js&lt;/code&gt; 代码。&lt;/p&gt;
&lt;p&gt;关于 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 和 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这两个库的内容就先介绍到这里，如果你想详细了解 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库是如何工作的，可以阅读 &lt;a href="https://mp.weixin.qq.com/s/BFu4SouMdXFYLELRjHhUyg"&gt;如何为 Node.js 的 require 函数添加钩子？&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;p&gt;现在我们已经分析完 &lt;code&gt;esno.js&lt;/code&gt; 文件，接下来我们来分析 &lt;code&gt;esmo.mjs&lt;/code&gt; 文件。&lt;/p&gt;
&lt;h3&gt;esmo 是如何工作的&lt;/h3&gt;
&lt;p&gt;esmo 命令对应的是 esmo.mjs 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;#!/usr/bin/env node

import spawn from 'cross-spawn'
import { resolve } from 'import-meta-resolve'
const spawnSync = spawn.sync

const argv = process.argv.slice(2)
resolve('esbuild-node-loader', import.meta.url).then((path) =&amp;gt; {
  process.exit(spawnSync('node', ['--loader', path, ...argv], 
{ stdio: 'inherit' }).status)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上代码可知，当使用 node 应用程序执行 ES Module 文件时，会通过 &lt;code&gt;--loader&lt;/code&gt; 选项来指定自定义的 ES Module 加载器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; --loader, --experimental-loader = ... use the specified module as a custom loader
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，通过 &lt;code&gt;--loader&lt;/code&gt; 选项指定的自定义加载器只适用于 ES Module 的 import 调用，并不适用于 CommonJS 的 require 调用。&lt;/p&gt;
&lt;p&gt;那么自定义加载器有什么作用呢？在当前最新的 Node.js v17.4.0 版本中，还不支持以 &lt;code&gt;https://&lt;/code&gt; 开头的说明符。我们可以在自定义加载器中，利用 Node.js 提供的钩子机制，让 Node.js 可以使用 &lt;code&gt;import&lt;/code&gt; 导入以 &lt;code&gt;https://&lt;/code&gt; 协议开头的 ES 模块。&lt;/p&gt;
&lt;p&gt;在分析如何自定义 &lt;code&gt;https&lt;/code&gt; 资源加载器前，我们需要先介绍一下 import 说明符的概念。&lt;/p&gt;
&lt;h4&gt;import 说明符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 语句的说明符是 &lt;code&gt;from&lt;/code&gt; 关键字之后的字符串，例如 &lt;code&gt;import { sep } from 'path'&lt;/code&gt; 中的 &lt;code&gt;'path'&lt;/code&gt;。 说明符也用于 &lt;code&gt;export from&lt;/code&gt; 语句，并作为 &lt;code&gt;import()&lt;/code&gt; 表达式的参数。&lt;/p&gt;
&lt;p&gt;有三种类型的说明符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相对说明符，如 &lt;code&gt;'./startup.js'&lt;/code&gt; 或 &lt;code&gt;'../config.mjs'&lt;/code&gt;。它们指的是相对于导入文件位置的路径。对于这种类型，文件扩展名是必须的。&lt;/li&gt;
&lt;li&gt;裸说明符，如 &lt;code&gt;'some-package'&lt;/code&gt; 或 &lt;code&gt;'some-package/shuffle'&lt;/code&gt;。它们可以通过包名来引用包的主入口点。当包没有 &lt;code&gt;exports&lt;/code&gt; 字段的时候，才需要包含文件扩展名。&lt;/li&gt;
&lt;li&gt;绝对说明符，如 &lt;code&gt;file:///opt/nodejs/config.js&lt;/code&gt;。它们直接且明确地引用完整路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;裸说明符解析由 &lt;a href="https://nodejs.org/api/esm.html#resolver-algorithm-specification"&gt;Node.js 模块解析算法&lt;/a&gt;处理，所有其他说明符解析始终仅使用标准的相对&lt;a href="https://url.spec.whatwg.org/"&gt;URL&lt;/a&gt; 解析语义进行解析。&lt;/p&gt;
&lt;p&gt;和 CommonJS 一样，包内的模块文件可以通过在包名上添加路径来访问，除非包的 package.json 包含一个 "exports " 字段，在这种情况下，包中的文件只能通过 "exports " 中定义的路径访问。&lt;/p&gt;
&lt;p&gt;介绍完 import 说明符之后，接下来我们来看一下如何自定义 https 加载器。&lt;/p&gt;
&lt;h4&gt;自定义 https 加载器&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;resolve 钩子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resolve&lt;/code&gt; 钩子用于根据模块的说明符和 &lt;code&gt;parentURL&lt;/code&gt; 生成导入目标的绝对路径，调用该钩子后会返回一个包含 &lt;code&gt;format&lt;/code&gt;（可选） 和 &lt;code&gt;url&lt;/code&gt; 属性的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// https-loader.mjs
import { get } from 'https';

export function resolve(specifier, context, defaultResolve) {
  const { parentURL = null } = context;

  if (specifier.startsWith('https://')) {
    return {
      url: specifier
    };
  } else if (parentURL &amp;amp;&amp;amp; parentURL.startsWith('https://')) {
    return {
      url: new URL(specifier, parentURL).href
    };
  }

  // 让 Node.js 处理其它的说明符
  return defaultResolve(specifier, context, defaultResolve);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，会先判断 &lt;code&gt;specifier&lt;/code&gt; 字符串是否以 &lt;code&gt;'https://'&lt;/code&gt; 开头，如果条件满足的话，该字符串的值直接作为 &lt;code&gt;url&lt;/code&gt; 属性的值，直接返回 &lt;code&gt;{ url: specifier }&lt;/code&gt; 对象。否则，会判断 &lt;code&gt;parentURL&lt;/code&gt; 是否以 &lt;code&gt;'https://'&lt;/code&gt; 开头，如果条件满足的话，则会调用 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/URL"&gt;URL&lt;/a&gt; 构造函数，创建 URL 对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;parentURL&lt;/code&gt; 是从 &lt;code&gt;context&lt;/code&gt; 对象上获取的，那它什么时候会有值呢？假设在 ES 模块 A 中，以相对路径的形式导入 ES 模块 B。在导入 ES 模块 B 时，也会调用 &lt;code&gt;resolve&lt;/code&gt; 钩子，此时 &lt;code&gt;context&lt;/code&gt; 对象上的 &lt;code&gt;parentURL&lt;/code&gt; 就会有值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;load 钩子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;load&lt;/code&gt; 钩子用于定义应该如何解释、检索和解析 URL 的方法，调用该方法后，会返回包含 &lt;code&gt;format&lt;/code&gt; 和 &lt;code&gt;source&lt;/code&gt; 属性的对象。其中 &lt;code&gt;format&lt;/code&gt; 属性值只能是 &lt;code&gt;'builtin'&lt;/code&gt;、&lt;code&gt;'commonjs'&lt;/code&gt;、&lt;code&gt;'json'&lt;/code&gt;、&lt;code&gt;'module'&lt;/code&gt; 和 &lt;code&gt;'wasm'&lt;/code&gt; 中的一种。而 &lt;code&gt;source&lt;/code&gt; 属性值的类型可以为 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;ArrayBuffer&lt;/code&gt; 或 &lt;code&gt;TypedArray&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;import { get } from 'https';

export function load(url, context, defaultLoad) {
  if (url.startsWith('https://')) {
    return new Promise((resolve, reject) =&amp;gt; {
      get(url, (res) =&amp;gt; {
        let data = '';
        res.on('data', (chunk) =&amp;gt; data += chunk);
        res.on('end', () =&amp;gt; resolve({
          format: 'module',
          source: data,
        }));
      }).on('error', (err) =&amp;gt; reject(err));
    });
  }

  // 让 Node.js 加载其它类型的文件
  return defaultLoad(url, context, defaultLoad);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，会通过 &lt;code&gt;https&lt;/code&gt; 模块中的 &lt;code&gt;get&lt;/code&gt; 函数来加载 &lt;code&gt;https://&lt;/code&gt; 协议的 ES 模块。如果不是以 &lt;code&gt;'https://'&lt;/code&gt; 开头，则会使用默认的加载器来加载其它类型的文件。&lt;/p&gt;
&lt;p&gt;创建完 &lt;code&gt;https-loader&lt;/code&gt; 之后，我们来测试一下该加载器。首先创建一个 &lt;code&gt;main.mjs&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// main.mjs
import React from "https://esm.sh/react@17.0.2"

console.dir(React);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在命令行输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node --experimental-loader ./https-loader.mjs ./main.mjs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  Fragment: Symbol(react.fragment),
  StrictMode: Symbol(react.strict_mode),
  Profiler: Symbol(react.profiler),
  Suspense: Symbol(react.suspense),
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;了解完以上的内容后，我们回过头来看一下 &lt;code&gt;esmo.mjs&lt;/code&gt; 文件中所使用的 &lt;a href="https://github.com/antfu/esbuild-node-loader"&gt;esbuild-node-loader&lt;/a&gt; 模块。下面我们来简单分析一下 &lt;code&gt;load&lt;/code&gt; 钩子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// loader.mjs（esbuild-node-loader v0.6.4）
export function load(url, context, defaultLoad) {
  if (extensionsRegex.test(new URL(url).pathname)) {
    const { format } = context;

    let filename = url;
    if (!isWindows) filename = fileURLToPath(url);

    const rawSource = fs.readFileSync(new URL(url), { encoding: "utf8" });
    const { js } = esbuildTransformSync(rawSource, filename, url, format);

    return {
      format: "module",
      source: js,
    };
  }

  // Let Node.js handle all other format / sources.
  return defaultLoad(url, context, defaultLoad);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过观察以上代码，我们可知 &lt;code&gt;load&lt;/code&gt; 钩子的核心处理流程，可以分为两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：使用 &lt;code&gt;fs.readFileSync&lt;/code&gt; 方法读取文件资源的内容；&lt;/li&gt;
&lt;li&gt;步骤二：使用 &lt;code&gt;esbuildTransformSync&lt;/code&gt; 函数对源代码进行转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在 &lt;code&gt;esbuildTransformSync&lt;/code&gt; 函数中，使用了 &lt;code&gt;esbuild&lt;/code&gt; 模块提供的 &lt;code&gt;transformSync&lt;/code&gt; 函数来实现代码的转换。该函数的相关代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// loader.mjs（esbuild-node-loader v0.6.4）
function esbuildTransformSync(rawSource, filename, url, format) {
  const {
    code: js,
    warnings,
    map: jsSourceMap,
  } = transformSync(rawSource.toString(), {
    sourcefile: filename,
    sourcemap: "both",
    loader: new URL(url).pathname.match(extensionsRegex)[1],
    target: `node${process.versions.node}`, 
    format: format === "module" ? "esm" : "cjs",
  });

  // 省略部分代码
  return { js, jsSourceMap };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于 &lt;code&gt;transformSync&lt;/code&gt; 函数的使用方式，我就不展开介绍了。感兴趣的小伙伴可以自行阅读一下 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 官网上的相关文档。&lt;/p&gt;
&lt;p&gt;好的，&lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 这个项目就介绍到这里。如果你对 Node.js 平台下的 &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; hook 机制感兴趣的话，可以详细阅读一下 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt;、&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 和 &lt;a href="https://github.com/antfu/esbuild-node-loader"&gt;esbuild-node-loader&lt;/a&gt; 这几个项目的源码。若有遇到问题的话，欢迎跟阿宝哥交流哟。&lt;/p&gt;
&lt;h3&gt;参考资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://esbuild.github.io/"&gt;esbuild 官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nodejs.org/api/esm.html#loaders"&gt;Node.js 官网 - ESM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/BFu4SouMdXFYLELRjHhUyg"&gt;如何为 Node.js 的 require 函数添加钩子？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><author>阿宝哥</author><pubDate>Wed, 16 Feb 2022 16:22:34 GMT</pubDate></item><item><title>如何为 Node.js 的 require 函数添加钩子？</title><link>https://juejin.cn/post/7062536831664914463</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 是一个基于 &lt;a href="https://v8.dev/"&gt;Chrome V8 引擎&lt;/a&gt;的 JavaScript 运行时环境。早期的 Node.js 采用的是 CommonJS 模块规范，从 &lt;a href="https://nodejs.org/de/blog/release/v13.2.0/"&gt;Node v13.2.0&lt;/a&gt; 版本开始正式支持 ES Modules 特性。直到 v15.3.0 版本 ES Modules 特性才稳定下来并与 NPM 生态相兼容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="nodejs-esm-history.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b651f355770d4f1db87a30cc6d0c3289~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;（图片来源：https://nodejs.org/api/esm.html）&lt;/p&gt;
&lt;p&gt;本文将介绍 Node.js 中 &lt;code&gt;require&lt;/code&gt; 函数的工作流程、如何让 Node.js 直接执行 ts 文件及如何正确地劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数，从而实现钩子的功能。接下来，我们先来介绍 &lt;code&gt;require&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h3&gt;require 函数&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 应用由模块组成，每个文件就是一个模块。对于 CommonJS 模块规范来说，我们通过 &lt;code&gt;require&lt;/code&gt; 函数来导入模块。那么当我们使用 &lt;code&gt;require&lt;/code&gt; 函数来导入模块的时候，该函数内部发生了什么？这里我们通过调用堆栈来了解一下 &lt;code&gt;require&lt;/code&gt; 的过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="how-node-require-work.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ac592857e6842ef83f94570238d09e0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;由上图可知，在使用 &lt;code&gt;require&lt;/code&gt; 导入模块时，会调用 &lt;code&gt;Module&lt;/code&gt; 对象的 &lt;code&gt;load&lt;/code&gt; 方法来加载模块，该方法的实现如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module.prototype.load = function(filename) {
  this.filename = filename;
  this.paths = Module._nodeModulePaths(path.dirname(filename));

  const extension = findLongestRegisteredExtension(filename);

  Module._extensions[extension](this, filename);
  this.loaded = true;
  // 省略部分代码
};
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：本文所引用 Node.js 源码所对应的版本是 &lt;strong&gt;v16.13.1&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在以上代码中，重要的两个步骤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：根据文件名找出扩展名；&lt;/li&gt;
&lt;li&gt;步骤二：通过解析后的扩展名，在 &lt;code&gt;Module._extensions&lt;/code&gt; 对象中查找匹配的加载器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 中内置了 3 种不同的加载器，用于加载 &lt;code&gt;node&lt;/code&gt;、&lt;code&gt;json&lt;/code&gt; 和 &lt;code&gt;js&lt;/code&gt; 文件。
&lt;strong&gt;node 文件加载器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module._extensions['.node'] = function(module, filename) {
  return process.dlopen(module, path.toNamespacedPath(filename));
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;json 文件加载器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module._extensions['.json'] = function(module, filename) {
 const content = fs.readFileSync(filename, 'utf8');
 try {
    module.exports = JSONParse(stripBOM(content));
 } catch (err) {
   err.message = filename + ': ' + err.message;
   throw err;
 }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;js 文件加载器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module._extensions['.js'] = function(module, filename) {
  // If already analyzed the source, then it will be cached.
  const cached = cjsParseCache.get(module);
  let content;
  if (cached?.source) {
    content = cached.source;
    cached.source = undefined;
  } else {
    content = fs.readFileSync(filename, 'utf8');
  }
  // 省略部分代码
  module._compile(content, filename);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们来分析比较重要的 &lt;strong&gt;js 文件加载器&lt;/strong&gt;。通过观察以上代码，我们可知 &lt;code&gt;js&lt;/code&gt; 加载器的核心处理流程，也可以分为两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：使用 &lt;code&gt;fs.readFileSync&lt;/code&gt; 方法加载 &lt;code&gt;js&lt;/code&gt; 文件的内容；&lt;/li&gt;
&lt;li&gt;步骤二：使用 &lt;code&gt;module._compile&lt;/code&gt; 方法编译已加载的 &lt;code&gt;js&lt;/code&gt; 代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么了解以上的知识之后，对我们有什么用处呢？其实在了解 &lt;code&gt;require&lt;/code&gt; 函数的工作流程之后，我们就可以扩展 Node.js 的加载器。比如让 Node.js 能够运行 &lt;code&gt;ts&lt;/code&gt; 文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// register.js
const fs = require("fs");
const Module = require("module");
const { transformSync } = require("esbuild");

Module._extensions[".ts"] = function (module, filename) {
  const content = fs.readFileSync(filename, "utf8");
  const { code } = transformSync(content, {
    sourcefile: filename,
    sourcemap: "both",
    loader: "ts",
    format: "cjs",
  });
  module._compile(code, filename);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们引入了内置的 &lt;code&gt;module&lt;/code&gt; 模块，然后利用该模块的 &lt;code&gt;_extensions&lt;/code&gt; 对象来注册我们的自定义 ts 加载器。&lt;/p&gt;
&lt;p&gt;其实，加载器的本质就是一个函数，在该函数内部我们利用 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 模块提供的 &lt;code&gt;transformSync&lt;/code&gt; API 来实现 &lt;strong&gt;ts -&amp;gt; js&lt;/strong&gt; 代码的转换。当完成代码转换之后，会调用 &lt;code&gt;module._compile&lt;/code&gt; 方法对代码进行编译操作。&lt;/p&gt;
&lt;p&gt;看到这里相信有的小伙伴，也想到了 Webpack 中对应的 loader，想深入学习的话，可以阅读 &lt;a href="https://mp.weixin.qq.com/s/2v1uhw2j7yKsb1U5KE2qJA"&gt;多图详解，一次性搞懂Webpack Loader&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;p&gt;篇幅有限，具体的编译过程，我们就不展开介绍了。下面我们来看一下如何让自定义的 ts 加载器生效。要让 Node.js 能够执行 ts 代码，我们就需要在执行 ts 代码前，先完成自定义 ts 加载器的注册操作。庆幸的是，Node.js 为我们提供了模块的预加载机制：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt; $ node --help | grep preload
   -r, --require=... module to preload (option can be repeated)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即利用 &lt;code&gt;-r, --require&lt;/code&gt; 命令行配置项，我们就可以预加载指定的模块。了解完相关知识之后，我们来测试一下自定义 ts 加载器。首先创建一个 &lt;code&gt;index.ts&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;// index.ts
const add = (a: number, b: number) =&amp;gt; a + b;

console.log("add(a, b) = ", add(3, 5));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在命令行输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node -r ./register.js index.ts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;add(a, b) =  8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很明显我们自定义的 ts 文件加载器生效了，这种扩展机制还是值得我们学习的。另外，需要注意的是在 &lt;code&gt;load&lt;/code&gt; 方法中，&lt;code&gt;findLongestRegisteredExtension&lt;/code&gt; 函数会判断文件的扩展名是否已经注册在 &lt;code&gt;Module._extensions&lt;/code&gt; 对象中，若未注册的话，默认会返回 &lt;code&gt;.js&lt;/code&gt; 字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module.prototype.load = function(filename) {
  this.filename = filename;
  this.paths = Module._nodeModulePaths(path.dirname(filename));

  const extension = findLongestRegisteredExtension(filename);

  Module._extensions[extension](this, filename);
  this.loaded = true;
  // 省略部分代码
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就意味着只要文件中包含有效的 &lt;code&gt;js&lt;/code&gt; 代码，&lt;code&gt;require&lt;/code&gt; 函数就能正常加载它。比如下面的 &lt;strong&gt;a.txt&lt;/strong&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;  module.exports = "hello world";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到这里相信你已经了解 &lt;code&gt;require&lt;/code&gt; 函数是如何加载模块及如何自定义 Node.js 文件加载器。那么，让 Node.js 支持加载 &lt;code&gt;ts&lt;/code&gt;、&lt;code&gt;png&lt;/code&gt; 或 &lt;code&gt;css&lt;/code&gt; 等其它类型的文件，有更优雅、更简单的方案么？答案是有的，我们可以使用 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个第三方库。&lt;/p&gt;
&lt;h3&gt;pirates 是什么&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库让我们可以正确地劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数。利用这个库，我们就可以很容易扩展 Node.js 加载器的功能。&lt;/p&gt;
&lt;h4&gt;pirates 的用法&lt;/h4&gt;
&lt;p&gt;你可以使用 npm 来安装 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;npm install --save pirates
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在成功安装 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库之后，就可以利用该模块导出提供的 &lt;code&gt;addHook&lt;/code&gt; 函数来添加钩子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// register.js
const addHook = require("pirates").addHook;

const revert = addHook(
  (code, filename) =&amp;gt; code.replace("@@foo", "console.log('foo');"),
  { exts: [".js"] }
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是调用 &lt;code&gt;addHook&lt;/code&gt; 之后会返回一个 &lt;code&gt;revert&lt;/code&gt; 函数，用于取消对 &lt;code&gt;require&lt;/code&gt; 函数的劫持操作。下面我们来验证一下 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库是否能正常工作，首先新建一个 &lt;code&gt;index.js&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// index.js
console.log("@@foo")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在命令行输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node -r ./register.js index.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;console.log('foo');
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上结果可知，我们通过 &lt;code&gt;addHook&lt;/code&gt; 函数添加的钩子生效了。是不是觉得挺神奇的，接下来我们来分析一下 pirates 的工作原理。&lt;/p&gt;
&lt;h3&gt;pirates 是如何工作的&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 底层是利用 Node.js 内置 &lt;code&gt;module&lt;/code&gt; 模块提供的扩展机制来实现 &lt;code&gt;Hook&lt;/code&gt; 功能。前面我们已经介绍过了，当使用 &lt;code&gt;require&lt;/code&gt; 函数来加载模块时，Node.js 会根据文件的后缀名来匹配对应的加载器。
其实 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 的源码并不会复杂，我们来重点分析 &lt;code&gt;addHook&lt;/code&gt; 函数的核心处理逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// src/index.js
export function addHook(hook, opts = {}) {
  let reverted = false;
  const loaders = []; // 存放新的loader
  const oldLoaders = []; // 存放旧的loader
  let exts;

  const originalJSLoader = Module._extensions['.js']; // 原始的JS Loader 

  const matcher = opts.matcher || null;
  const ignoreNodeModules = opts.ignoreNodeModules !== false;
  exts = opts.extensions || opts.exts || opts.extension || opts.ext 
    || ['.js'];
  if (!Array.isArray(exts)) {
    exts = [exts];
  }
  exts.forEach((ext) { 
    // ... 
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了提高执行效率，&lt;code&gt;addHook&lt;/code&gt; 函数提供了 &lt;code&gt;matcher&lt;/code&gt; 和 &lt;code&gt;ignoreNodeModules&lt;/code&gt; 配置项来实现文件过滤操作。在获取到 &lt;code&gt;exts&lt;/code&gt; 扩展名列表之后，就会使用新的加载器来替换已有的加载器。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;exts.forEach((ext) =&amp;gt; {
    if (typeof ext !== 'string') {
      throw new TypeError(`Invalid Extension: ${ext}`);
    }
    // 获取已注册的loader，若未找到，则默认使用JS Loader
    const oldLoader = Module._extensions[ext] || originalJSLoader;
    oldLoaders[ext] = Module._extensions[ext];

    loaders[ext] = Module._extensions[ext] = function newLoader(
  mod, filename) {
      let compile;
      if (!reverted) {
        if (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {
          compile = mod._compile;
          mod._compile = function _compile(code) {
// 这里需要恢复成原来的_compile函数，否则会出现死循环
            mod._compile = compile;
// 在编译前先执行用户自定义的hook函数
            const newCode = hook(code, filename);
            if (typeof newCode !== 'string') {
              throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);
            }

            return mod._compile(newCode, filename);
          };
        }
      }

      oldLoader(mod, filename);
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上代码可知，在 &lt;code&gt;addHook&lt;/code&gt; 函数内部是通过替换 &lt;code&gt;mod._compile&lt;/code&gt; 方法来实现钩子的功能。即在调用原始的 &lt;code&gt;mod._compile&lt;/code&gt; 方法进行编译前，会先调用 &lt;code&gt;hook(code, filename)&lt;/code&gt; 函数来执行用户自定义的 &lt;code&gt;hook&lt;/code&gt; 函数，从而对代码进行处理。&lt;/p&gt;
&lt;p&gt;好的，至此本文的主要内容都介绍完了，在实际工作中，如果你想让 Node.js 直接执行 ts 文件，可以利用 &lt;a href="https://github.com/TypeStrong/ts-node"&gt;ts-node&lt;/a&gt; 或 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 这两个库。其中 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 这个库内部就是使用了 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 提供的 Hook 机制来实现对应的功能。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Tue, 08 Feb 2022 18:50:17 GMT</pubDate></item><item><title>问卷还可以这样开发，效率提升 150%</title><link>https://juejin.cn/post/7028793777875582984</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;工作了一天，终于到了最 “鸡冻” 的时刻，等待下班铃声的响起...&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f4aa77df01e4a9ea039dcf32a0d0b64~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;不过没过多久，就听到了那既熟悉而又抗拒的消息提示声。临近下班前的消息，感觉就不太妙。不过还是硬着头皮打开了公司运营妹纸发的消息 —— “宝哥，帮帮忙，明天下午我们有一个新版的 PC 知识库的推广活动，想在我们的知识库模块中添加一个问卷入口，收集一下用户的使用体验”。&lt;/p&gt;
&lt;p&gt;看完以上的消息之后，当时我的心情是这样的👇&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f0e08a748b34809a993b910d32c4eb7~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;本想装作没看见，奈何消息已变成已读。所以我只能强装镇定，给妹纸回了消息，让她把问卷要收集的信息发给我，过了一会儿妹纸把信息发了过来。看完后，发现表单并不会复杂，松了一口气。&lt;/p&gt;
&lt;p&gt;之后，立马让妹纸去协调一下服务端的资源。没想到妹纸却回我说：“宝哥，这个功能不会太复杂，以你的技术能力，应该一个人就可以搞定吧”。既然妹纸都这样说了，我只能委屈的说没问题。接着，跟妹纸大致沟通了需求，确认说表单的数据，可以不用提交到我们的系统。&lt;/p&gt;
&lt;p&gt;既然需求已经明确了，剩下的就是如何快速开发这个功能了。思考了一会儿，一个便捷的开发方案就涌现在脑海中。刚好之前有了解过在线的表单设计器和朋友公司的 Bass 产品 ——  &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 。我就想利用在线表单设计器来快速生成表单代码，然后利用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的服务来存储数据。大致方案已经有了，为了能早点下班，我立马行动起来。&lt;/p&gt;
&lt;h3&gt;一、拖拽生成表单&lt;/h3&gt;
&lt;p&gt;我司新版的 PC 知识库是基于 Vue 2 开发的，使用了 Element UI 组件库。经过一番搜索，我找到了 &lt;a href="https://github.com/JakHuang/form-generator"&gt;form-generator&lt;/a&gt; 这个开源项目。该项目是一款基于 Element UI 表单设计及代码生成器，目前 Github 上的 Star 数是 5.2K，是一个挺不错的开源项目。&lt;/p&gt;
&lt;p&gt;不得不说以拖拽的方式设计表单，使用起来还是很 “香” 的。一顿操作后，表单就生成了，具体效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee165d6f94e54e5380cdfa7a097298a9~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是，该在线工具还允许我们为表单的每个字段配置正则校验&lt;/strong&gt;。在完成表单设计之后，我通过点击 &lt;strong&gt;导出vue文件&lt;/strong&gt; 的按钮，就下载到对应的 Vue 文件。此时，问卷表单的功能已经完成一大半了，就差对接数据提交的功能。所以接下来我们将利用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的能力，来快速生成 API。&lt;/p&gt;
&lt;h3&gt;二、快速生成 API&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 为应用开发者提供高可用、自动弹性伸缩的后端云服务。前端通过统一的 SDK 和 API 连接后端服务（云数据库、云存储、云函数、用户管理、统计分析等），加速移动/Web/IoT/游戏等应用的开发，并降低运维成本。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d16e33d2fc47409a94f8c1c541dc3311~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;（图片来源：https://docs.memfiredb.com/）&lt;/p&gt;
&lt;p&gt;简单介绍了 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 的功能之后，下面我们来介绍如何使用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台快速生成 API。&lt;/p&gt;
&lt;h4&gt;2.1 创建数据库账号&lt;/h4&gt;
&lt;p&gt;首先要使用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台服务提供的服务，我们需要先注册一个账号。在账号注册成功后，我们就能登录 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台的管理后台。在创建表单应用前，我们需要先创建一个数据库账号，具体的操作方式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bf9d2aabc1c4a19bda4fd6fdf4cb8ff~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;2.2 创建表单应用&lt;/h4&gt;
&lt;p&gt;在创建完账号之后，我们就可以创建表单应用了。首先点击左侧 &lt;strong&gt;我的应用&lt;/strong&gt; 菜单，然后点击 &lt;strong&gt;创建应用&lt;/strong&gt; 按钮，在弹出的对话框中输入应用名称并选择前面新增的数据库账号，最后点击 &lt;strong&gt;创建按钮&lt;/strong&gt; 就会开始创建表单应用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47567b1cbb59430c9be881b553a2290a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;2.3 新建数据表&lt;/h4&gt;
&lt;p&gt;在成功创建完表单应用之后，我们就可以新建问卷表了，用于保存表单的数据。首先点击刚新建的表单应用，进入表单应用编辑页面，然后点击左侧 &lt;strong&gt;数据表&lt;/strong&gt; 菜单，接着继续点击 &lt;strong&gt;新建数据表&lt;/strong&gt; 按钮，具体步骤如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea830eea1b84f68a41fa20937aadf0a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;在点击 &lt;strong&gt;新建数据表&lt;/strong&gt; 按钮后，在当前页面右侧会以 Drawer（抽屉）的形式，显示新建数据表的表单。接着我们根据已生成 Vue 表单文件中的字段来创建 &lt;strong&gt;feedbacks&lt;/strong&gt; 数据表的字段，具体的过程如以下动图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c3bcab9c7734af5b5216b0fb93ed07d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;以上动图只演示了添加 &lt;code&gt;name&lt;/code&gt; 字段的过程，通过 &lt;strong&gt;添加字段&lt;/strong&gt; 按钮，我们陆续添加了 &lt;strong&gt;mobile、post、score 和 suggestion&lt;/strong&gt; 等字段。最后每个字段的详细配置信息如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88da9001dfcf49df86dc640652c1e774~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：上图中的 &lt;code&gt;id&lt;/code&gt; 字段是默认生成的，它的值会不断自增。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过一番配置之后，我们问卷的 API 就已经创建好了，整体操作起来还是挺方便的。下面我们只要对接一下客户端 SDK 就可以提交表单数据了。&lt;/p&gt;
&lt;h3&gt;三、集成 JS 客户端 SDK&lt;/h3&gt;
&lt;p&gt;在集成 JS 客户端 SDK 的时候，可以通过 &lt;code&gt;npm&lt;/code&gt; 或 &lt;code&gt;CDN&lt;/code&gt; 的方式来安装 SDK。这里我们使用 &lt;code&gt;npm&lt;/code&gt; 的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;npm install @supabase/supabase-js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在成功安装了 &lt;code&gt;@supabase/supabase-js&lt;/code&gt; 模块之后，我们需要在表单页面中引入该模块，然后使用表单项目总览页面中的信息来创建 JS 客户端对象，需获取的 JS 客户端对象初始化信息如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9210fd811aeb4809a9f5b152d7783fba~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;在获取初始化信息之后，我们就可以创建  JS 客户端对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;import { createClient } from "@supabase/supabase-js";

const supabase = createClient(
  "https://c5s0hnq5g6heb3j9g3gg.baseapi.memfiredb.com", // baseURL
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYW" // 公开的密钥（仅截取部分内容）
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了 &lt;code&gt;supabase&lt;/code&gt; 客户端对象之后，我们就可以利用该对象提供的方法来提交表单数据了，具体的使用方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// src/components/FeedbackForm.vue
export default {
  data() {
    return {
      // 省略其他属性
      submitting: false
    };
  },
  methods: {
    submitForm() {
      this.$refs["elForm"].validate(async (valid) =&amp;gt; {
        if (!valid || this.submitting) return;
        this.submitting = true; // 避免快速点击，重复提交数据
        const { error } = await supabase
          .from("feedbacks") // 数据表的表名
          .insert(this.formData);  
        const msg = error == null ? "感谢您的反馈!" : "服务器开小差，请稍后再试";
        alert(msg);
        if(!error) this.$refs["elForm"].resetFields(); // 复位表单
        this.submitting = false;
      });
    },
    resetForm() {
      this.$refs["elForm"].resetFields();
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，&lt;code&gt;supabase.from&lt;/code&gt; 方法用于指定数据表的表名，而 &lt;code&gt;insert&lt;/code&gt; 方法用来插入新增的数据。需要注意的是，&lt;code&gt;insert&lt;/code&gt; 方法的参数也可以是数组，即可以批量插入多条数据。在插入数据时，也可以配置 &lt;code&gt; { upsert: true }&lt;/code&gt; 选项来执行 &lt;code&gt;upsert&lt;/code&gt; 操作。&lt;/p&gt;
&lt;p&gt;其实除了 &lt;code&gt;insert&lt;/code&gt; 方法之外，该 SDK 也为我们提供了 &lt;code&gt;select（获取数据）&lt;/code&gt;、&lt;code&gt;update（修改数据）&lt;/code&gt;、&lt;code&gt;delete（删除数据）&lt;/code&gt; 等方法。同时，也提供了强大的修改器（limit、order、range 等）和过滤器（filter、or、not、eq 等），感兴趣的小伙伴可以阅读 &lt;a href="https://docs.memfiredb.com/base/javascript/select.html"&gt;MemFire Cloud JS 客户端文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在完成以上三个步骤之后，我们调查问卷功能就已经开发完成了。成功收集的问卷数据，我们可以在 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台管理后台中进行查看：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a70610745e2248fa8b5ce00e9755ea65~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;四、总结&lt;/h3&gt;
&lt;p&gt;利用 &lt;a href="https://github.com/JakHuang/form-generator"&gt;form-generator&lt;/a&gt; 表单设计器和 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的简单易用、功能强大的数据存储功能，我快速完成了公司运营妹纸的调查问卷功能，成功逃过加班的 “厄运”。其实后期还可以考虑对这两个工具做进一步的整合，即可以根据表单设计器生成的字段信息，自动创建对应的表结构，同时自动生成客户端 SDK 的调用代码。&lt;/p&gt;
&lt;p&gt;在日常生活中，利用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的数据库即服务的功能，我们还可以快速开发一些小的工具。比如网页书签收集器，感兴趣的小伙伴可以参考 &lt;a href="https://github.com/d2-projects/d2-daily-chrome-extension"&gt;d2-daily-chrome-extension&lt;/a&gt; 这个项目，只需把 &lt;code&gt;axios&lt;/code&gt; 替换成 &lt;code&gt;@supabase/supabase-js&lt;/code&gt; 客户端，你就可以快速开发一个网页书签收集器的 Chrome 插件。如果你还有其它更好玩的想法，欢迎给我留言哟。&lt;/p&gt;
&lt;h3&gt;五、参考资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.memfiredb.com/base/javascript/installing.html"&gt;MemFire Cloud 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/JakHuang/form-generator"&gt;Github — form-generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/d2-projects/d2-daily-chrome-extension"&gt;Github — d2-daily-chrome-extension&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><author>阿宝哥</author><pubDate>Tue, 09 Nov 2021 20:30:13 GMT</pubDate></item><item><title>推荐 7 个本周 yyds 的开源项目</title><link>https://juejin.cn/post/7126458144833667108</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. Web 是如何工作的？&lt;/p&gt;
&lt;p&gt;2. 发现好教程&lt;/p&gt;
&lt;p&gt;3. FastAPI&lt;/p&gt;
&lt;p&gt;4. 编程大学&lt;/p&gt;
&lt;p&gt;5. 全栈 Web 框架：Remix&lt;/p&gt;
&lt;p&gt;6. 用户身份访问管理&lt;/p&gt;
&lt;p&gt;7. 科技爱好者周刊&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. Web 是如何工作的？&lt;/h3&gt;
&lt;p&gt;当我们在浏览器中输入 www.google.com 后会发生什么事？&lt;/p&gt;
&lt;p&gt;这个开源项目详细的解释了这一操作背后的原理，从计算机网络、服务器响应、解析渲染，把每一个细节都做了解释。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/vasanthk/how-web-works"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bd0208915f84ee9be202cc3e409e10c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 发现好教程&lt;/h3&gt;
&lt;p&gt;这个开源项目搜集了 YouTube 上优质的机器学习教程，方向包括机器学习、深度学习、计算机视觉、自然语言处理、无监督学习等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/dair-ai/ML-YouTube-Courses"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93b3d40887084214bcc4cf3ae87ce5a3~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee85841541b9473dbe3649cd86a01dd2~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. FastAPI&lt;/h3&gt;
&lt;p&gt;FastAPI 框架：一个快速（高性能）的 Web 框架，是最快的 Python 框架之一。这个开源项目有 47.5K 的 Star。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/tiangolo/fastapi"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc59e43c8ecd44d6acdaf84e28aaf833~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 编程大学&lt;/h3&gt;
&lt;p&gt;这个开源项目记录了一个亚马逊的工程师从零到一学习编程的计划，这位开发者每天学习 8 小时，大约进行了 8 个月的学习，如愿以偿的从零到一，拿到了亚马逊的 Offer！&lt;/p&gt;
&lt;p&gt;这是软件工程的学习计划，而不是 Web 开发。谷歌、亚马逊、Facebook 和微软等大型软件公司将软件工程视为与 Web 开发不同。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/jwasham/coding-interview-university"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eb474e42c8c49049d73f1b4f86f6c1d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;05. 全栈 Web 框架：Remix&lt;/h3&gt;
&lt;p&gt;Remix 是一个全栈 Web 框架，可让你专注于用户界面并通过 Web 基础知识进行工作，以提供快速、流畅且有弹性的用户体验，可部署到任何 Node.js 服务器。该开源项目已经斩获 18.1k 的 Star！&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/remix-run/remix"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86c1a7bf66194bc08672569e0afcb0eb~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;06. 用户身份访问管理&lt;/h3&gt;
&lt;p&gt;Logto 是针对登陆的解决方案，通过多平台 SDK 可将应用程序与 Logto 快速集成，可在几分钟内建立用户身份和不错的登录体验。&lt;/p&gt;
&lt;p&gt;该开源项目提供基于 OIDC 的身份服务，支持集成多社交平台登陆，比如 GitHub、谷歌、微信、支付宝等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/logto-io/logto"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b92bd9330fa49a3ad3e8323e86a73e6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;07. 科技爱好者周刊&lt;/h3&gt;
&lt;p&gt;科技爱好者周刊，记录每周值得分享的科技内容，周五发布。本开源项目由 阮一峰 维护，从 2019 年起，已经持续更新两年多。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ruanyf/weekly"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b97bcb3e15344a4a6db41b4978de977~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/p&gt;
&lt;p&gt;https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/910279204e4f480585c35393872946a7~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 31 Jul 2022 00:59:25 GMT</pubDate></item><item><title>粉丝推荐的 GitHub 项目 yyds</title><link>https://juejin.cn/post/7126456742409568269</link><description>&lt;p&gt;本期盘点的开源项目由逛逛 GitHub 的读者投稿，如果你或者所在的组织开源了高质量的项目，希望被更多人看到，你可以关注逛逛 GitHub 后在底部菜单栏找到投稿入口。&lt;/p&gt;
&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 小游戏收集器&lt;/p&gt;
&lt;p&gt;2. 云原生的开源分布式存储系统&lt;/p&gt;
&lt;p&gt;3. 整理常见的国内镜像&lt;/p&gt;
&lt;p&gt;4. 跨平台跨框架 Web 解决方案&lt;/p&gt;
&lt;p&gt;5. 基于Go+Vue实现的openLDAP后台管理项目&lt;/p&gt;
&lt;p&gt;6. 跨平台的文件搜索引擎&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;小游戏收集器&lt;/p&gt;
&lt;p&gt;小游戏收集器，一键解析下载 Flash 和 Unity3D Web 小游戏，支持进度管理，希望能帮助你收集到来自童年的一份快乐。&lt;/p&gt;
&lt;p&gt;开发者 @Cnotech 今年大四，写毕业论文的时候无聊顺手做的小玩具。零零碎碎写了几个月感觉功能已经基本完善，自测也遇不到新的 bug 了，开发者来逛逛 GitHub 投稿希望有更多人看到，最好能帮忙一起完善。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/Cnotech/flash-collector&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aacf50b21be4dc1b62ce64b23c6b935~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;云原生的开源分布式存储系统&lt;/p&gt;
&lt;p&gt;网易开源的分布式存储系统：Curve ，由云原生计算基金会 (CNCF) 作为沙盒项目托管，对标 Ceph 性能缺陷，主打性能，已经有落地用户。本开源项目累计 Star 有 1.3K，由 @opencurve 开源。&lt;/p&gt;
&lt;p&gt;编程语言：C++&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/opencurve/curve&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/003b843cf84f4f46a20ba7d4d6574be1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;整理常见的国内镜像&lt;/p&gt;
&lt;p&gt;由于国内网络原因，下载依赖包或者软件，对于不少互联网从业者来说，都有不小的挑战，时间浪费在这上边，实在可惜。这个项目介绍了常见依赖，软件的国内镜像，助力大家畅爽编码。&lt;/p&gt;
&lt;p&gt;这是一个归纳梳理类的项目，由开发者 @eryajf 创建，整理了常见的包管理工具，软件，系统的国内镜像，以助力运维同学自建企业私服，开发同学直接上手使用。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/eryajf/Thanks-Mirror&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6148b9a307d421d9d53041ac77de75f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;跨平台跨框架 Web 解决方案&lt;/p&gt;
&lt;p&gt;Elux：基于“微模块”和“模型驱动”的跨平台、跨框架同构方案，由开发者 @hiisea 开源。&lt;/p&gt;
&lt;p&gt;用同一个工程模式开发 Web（浏览器页面）SSR（服务器渲染）Micro（微前端）MP（小程序）APP（手机应用），更可以把 Redux 当 vuex 用，也可以把 vuex 当 redux 用。、&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/hiisea/elux&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d249646840c42aa98672e365d1087e5~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;基于Go+Vue实现的openLDAP后台管理项目&lt;/p&gt;
&lt;p&gt;基于 Go + Vue 实现的 openLDAP 后台管理项目。现代化 openLDAP 管理后台，设计简洁，交互简单，助力运维人员快速简单地应用并管理 openLDAP。本项目由开发者 @eryajf 创建。&lt;/p&gt;
&lt;p&gt;支持钉钉，企业微信，飞书的组织架构，以及员工信息自动同步到平台，一座打通 IM 与常见支持 ldap 认证的应用的桥梁。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/eryajf/go-ldap-admin&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a7edc123e9c423fbe84234eeaedb1b0~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;06&lt;/h1&gt;
&lt;p&gt;跨平台的文件搜索引擎&lt;/p&gt;
&lt;p&gt;Orange是一款跨平台的文件搜索引擎。由开发者 @naaive 创建该项目。使用简单，自带中文简繁体分词、拼音、补全、高亮，支持毫秒级搜索响应。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/naaive/orange&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d83af5e3e864259abb5fc67ca8944d6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55de0f41aa26439fb8e11c00628ffbfd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 31 Jul 2022 00:53:55 GMT</pubDate></item><item><title>盘点 6 月 yyds 的开源项目！</title><link>https://juejin.cn/post/7113563869296984078</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. Nginx 可视化神器&lt;/p&gt;
&lt;p&gt;2. Elastic UI 框架&lt;/p&gt;
&lt;p&gt;3. 新一代建站工具&lt;/p&gt;
&lt;p&gt;4. 前端测试工具&lt;/p&gt;
&lt;p&gt;5. 30 天 JavaScript 编程挑战&lt;/p&gt;
&lt;p&gt;6. 使用 Go + HTML + CSS + JS 构建漂亮的跨平台桌面应用&lt;/p&gt;
&lt;p&gt;7. 适用于 Android 的魔法面具&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;Nginx 可视化神器&lt;/p&gt;
&lt;p&gt;一款可以一键生成 Nginx 配置的神器，相当给力。&lt;/p&gt;
&lt;p&gt;先来看看它都支持什么功能的配置：反向代理、HTTPS、HTTP/2、IPv6, 缓存、WordPress、CDN、Node.js 支持、 Python (Django) 服务器等等。&lt;/p&gt;
&lt;p&gt;如果你想在线进行配置，只需要打开网站：https://nginxconfig.io/，按照自己的需求进行操作就行了。选择你的场景，填写好参数，系统就会自动生成配置文件。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/digitalocean/nginxconfig.io&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eabdb2adf5a40cc91ffcaaad0506c37~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;Elastic UI 框架&lt;/p&gt;
&lt;p&gt;Elastic UI 框架是一组 React UI 组件，用于在 Elastic 中快速构建用户界面。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/elastic/eui&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f4b660824ff41deb212f5d5cf6821e6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;新一代建站工具&lt;/p&gt;
&lt;p&gt;VitePress 是 VuePress 的精神继承者，建立在 vite 之上。VitePress 在写博客网站，技术文档，面试题网站等方面，就有着它先天的优势。&lt;/p&gt;
&lt;p&gt;不仅如此，它还有极易上手、构建速度快等优点。目前，它开箱即用，由于正处于 alpha 阶段，配置和 API 可能可能会在次要版本之间发生变化。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/vuejs/vitepress&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c635ce8627d4210b69e464e1c2cd176~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;前端测试工具&lt;/p&gt;
&lt;p&gt;Cypress 可以对在浏览器中运行的任何东西进行快速、简单和可靠的测试。&lt;/p&gt;
&lt;p&gt;Cypress 是为现代网络而构建的下一代前端测试工具，用于解决开发者和 QA 工程师在测试现代应用程序时面临的关键难题。&lt;/p&gt;
&lt;p&gt;Cypress 简化了设置测试、编写测试、运行测试和调试测试，支持端到端测试、集成测试和单元测试，支持测试在浏览器中运行的任意内容。支持 Mac OS、Linux 和 Windows 平台。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/cypress-io/cypress&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbedef26becd4cada5050bb9133546e5~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;30 天 JavaScript 编程挑战&lt;/p&gt;
&lt;p&gt;30 天 JavaScript 编程挑战是在 30 天内学习 JavaScript 编程语言的分步指南。此挑战可能需要100多天，请按照自己的节奏进行。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/Asabeneh/30-Days-Of-JavaScript&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/128f605dc4e7436c9e98250e98d45eaf~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;06&lt;/h1&gt;
&lt;p&gt;构建漂亮的跨平台桌面应用&lt;/p&gt;
&lt;p&gt;使用 Go 和 Web 技术构建桌面应用程序。为 Go 程序提供 Web 界面的传统方法是通过内置 Web 服务器。&lt;/p&gt;
&lt;p&gt;Wails 提供了一种不同的方法：它提供了将 Go 代码和 Web 前端一起打包成单个二进制文件的能力。通过提供的工具，可以很轻松的完成项目的创建、编译和打包。你所要做的就是发挥想象力！&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/wailsapp/wails&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0bb7f1b9ef4f8d99f6649b8fb0ed06~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;07&lt;/h1&gt;
&lt;p&gt;适用于 Android 的魔法面具&lt;/p&gt;
&lt;p&gt;Magisk 是当前 Android 社区用来获取 root 权限的主流方式。同时，Magisk 特殊的运作机制还赋予了它 systemless 的特质。&lt;/p&gt;
&lt;p&gt;systemless 让 Magisk 一方面可以有针对性地隐藏 root，甚至暂时隐藏 Magisk 本身。另一方面，挂载系统的存在，也让 Magisk 拥有了多样的模块化生态系统。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/topjohnwu/Magisk&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b56f8a0af1b44809003afebcaeb0be6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de1c360b7ec448eab4b45b4261103a1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 26 Jun 2022 07:01:45 GMT</pubDate></item><item><title>盘点最近 火火火火 的 GitHub 项目</title><link>https://juejin.cn/post/7111331196948185101</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 文章同步插件&lt;/p&gt;
&lt;p&gt;2. 读书笔记插件&lt;/p&gt;
&lt;p&gt;3. 在线简历排版工具&lt;/p&gt;
&lt;p&gt;4. 表情包生成器&lt;/p&gt;
&lt;p&gt;5. 开源的在线文档&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;文章同步插件&lt;/p&gt;
&lt;p&gt;还在为一次编辑，N 个平台需多次排版上传脑壳疼吧？为广大自媒体朋友撸了个提高生产力的小工具、可以做到的在多个内容平台无缝同步。&lt;/p&gt;
&lt;p&gt;一键同步文章到多个内容平台，支持今日头条、WordPress、知乎、简书、掘金、CSDN、typecho各大平台，一次发布，多平台同步发布。解放个人生产力。&lt;/p&gt;
&lt;p&gt;编程语言：JavaScript&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/wechatsync/Wechatsync&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e55ad130e20c42deab5f6873b8d00158~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;读书笔记插件&lt;/p&gt;
&lt;p&gt;一个还不错的微信读书笔记工具，方便你导出书本标注等内容，对常使用 Markdown 做笔记的用户比较有帮助，可以 一键导出标注、热门标注、书评、想法、目录。&lt;/p&gt;
&lt;p&gt;编程语言：Typescript&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/Higurashi-kagome/wereader&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10f93edbd294c168a03c818e6806826~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;在线简历排版工具&lt;/p&gt;
&lt;p&gt;这是一个支持 Markdown 和富文本的在线简历排版工具，如下图所示，你可以通过 Markdown 语法或者富文本编辑的方式编辑一个美观的简历。&lt;/p&gt;
&lt;p&gt;编程语言：JavaScript&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/mdnice/markdown-resume&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b8afa14f2145d09d1db77103047d9e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;表情包生成器&lt;/p&gt;
&lt;p&gt;Sorry 是一个很有意思的项目，源自"Sorry，有钱事真的能为所欲为" 这梗 … 而这个开源项目是一个可以将自己的梗生成 GIF 的表情包生成器。&lt;/p&gt;
&lt;p&gt;编程语言：CSS &amp;nbsp;HTML&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/xtyxtyx/sorry&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18f551ba07da4d648f1b16aca3b45e68~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;开源的在线文档&lt;/p&gt;
&lt;p&gt;云策文档是一款开源知识管理工具。通过独立的知识库空间，结构化地组织在线协作文档，实现知识的积累与沉淀，促进知识的复用与流通。该项目基于 next.js、nest.js、MySQL 等技术栈。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/fantasticit/think&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba02f55ed58d40f283ba086662bbac2a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b18eeaef0f85464693178855cdf9a40c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b802bbd5caa4e1eb61ef76a239392ff~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Mon, 20 Jun 2022 06:37:30 GMT</pubDate></item><item><title>Google 有哪些牛逼的开源项目？</title><link>https://juejin.cn/post/7107144360013398029</link><description>&lt;p&gt;本文盘点 Google 开源项目中 Star 最多的 6 个开源项目。@逛逛GitHub 历史还盘点过百度、阿里、腾讯等互联网大厂的开源成果，可以查看历史文章翻阅。&lt;/p&gt;
&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 核心 Java 库&lt;/p&gt;
&lt;p&gt;2. 使用 Node.js 高效编写脚本&lt;/p&gt;
&lt;p&gt;3. 谷歌开源项目风格指南&lt;/p&gt;
&lt;p&gt;4. 高效的 KV 数据库&lt;/p&gt;
&lt;p&gt;5. Python Fire&lt;/p&gt;
&lt;p&gt;6. Gson&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. 核心 Java 库&lt;/h3&gt;
&lt;p&gt;Guava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、图形库以及用于并发、I/O、缓存、字符串等的实用程序！它广泛用于 Google 内部的大多数 Java 项目，也被许多其他公司广泛使用。&lt;/p&gt;
&lt;p&gt;开源项目：https://github.com/google/guava&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bddd492577e4217bf131d459f18f732~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 使用 Node.js 高效编写脚本&lt;/h3&gt;
&lt;p&gt;如果你尝试编写一个在 Node.js 下运行的 Shell 脚本，你可能会发现它并不像你希望的那样流畅。而Google 的 zx 库有助于使用 Node.js 高效且愉快地编写 Shell 脚本。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/zx&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/034a91a8075b4c44b2af25db83ae5788~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. 谷歌开源项目风格指南&lt;/h3&gt;
&lt;p&gt;每个开源项目都有自己的风格指南：一组关于如何为该项目编写代码的约定。当其中的所有代码都采用一致的样式时，理解大型代码库会容易得多。&lt;/p&gt;
&lt;p&gt;“风格”涵盖了很多方面，从“使用驼峰式命名变量名”到“从不使用全局变量”到“从不使用异常”。这个开源项目是一个索引页，可以帮你快速了解 Google 开源项目的风格规范。&lt;/p&gt;
&lt;p&gt;开源地点：https://github.com/google/styleguide&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/463786f1fafb49f8928f3822a05733ba~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 高效的 KV 数据库&lt;/h3&gt;
&lt;p&gt;Leveldb 是一个 Google 实现的非常高效的 KV 数据库，版本 1.2 能够支持 Billion 级别的数据量了。在这个数量级别下还有着非常高的性能，主要归功于它的良好的设计。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/leveldb&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d4261fc6f7544318472abd6b58bca18~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;05. Python Fire&lt;/h3&gt;
&lt;p&gt;Python Fire 是一个 Python 库，只需对 Fire 进行一次调用即可将任何 Python 组件转变为命令行界面。不需要做任何额外的工作，只需要从主模块中调用 fire.Fire()，它会自动将你的代码转化为 CLI，Fire() 的参数可以说任何的 Python 对象。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/python-fire&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4ce913e648c400c8082189d4e256304~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;06. Gson&lt;/h3&gt;
&lt;p&gt;Google Gson 是一个简单的基于 Java 的库，用于将 Java 对象序列化为 JSON，反之亦然。它是由 Google 开发的一个开源库。&lt;/p&gt;
&lt;p&gt;以下几点说明为什么应该使用这个库，Gson是一个由Google管理的标准化库、这是对 Java 标准库的可靠，快速和高效的扩展、Gson 库经过高度优化、它为泛型提供了广泛的支持、它支持具有深度继承层次结构的复杂对象。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/gson&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d975d9217394d77833e83cf60860b1f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a80ced5396314208a49057768d881e16~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;</description><author>逛逛GitHub</author><pubDate>Wed, 08 Jun 2022 23:50:27 GMT</pubDate></item><item><title>推荐 4 个视频自动生成器</title><link>https://juejin.cn/post/7106394465580875784</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 编程生成视频的库&lt;/p&gt;
&lt;p&gt;2. 半佛风格视频生成器&lt;/p&gt;
&lt;p&gt;3. 快速高效的生成短视频&lt;/p&gt;
&lt;p&gt;4. 知乎文章转视频乞丐版&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. 编程生成视频的库&lt;/h3&gt;
&lt;p&gt;Remotion 是一套使用编程生成视频的库，为使用 React 以编程方式创建视频奠定了基础。&lt;/p&gt;
&lt;p&gt;有很多方法可以使用编程的方式创建视频，比如：利用网络技术，使用 CSS、Canvas、SVG、WebGL 等，也可以使用变量、函数、API、数学和算法来创造新的效果。但是利用 React，可重用组件、有强大的组合、快速刷新、包含包生态系统。&lt;/p&gt;
&lt;p&gt;开源地址：开源地址：https://github.com/remotion-dev/remotion&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a75cb81cd11d40e181eb9bc6574f122d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 半佛风格视频生成器&lt;/h3&gt;
&lt;p&gt;半佛在 2020 年凭借众多沙雕表情包视频 + 魔性的文案迅速出圈。这个开源项目会爬取半佛的公众号文案，然后进行断句，将文案根据短句分割，每句作为一条字幕，根据字幕搜索表情包并选择设置。&lt;/p&gt;
&lt;p&gt;利用语音合成手段合成配音，直到所有的字幕均完成表情包设定、字幕设定、配音设定，合成视频并加入背景音乐，就能导出成品了。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/WithHades/banfoStyle&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f82ced5799b14bb2b122c4e2b1f73f4f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. 快速高效的生成短视频&lt;/h3&gt;
&lt;p&gt;一种基于 Python 编写的视频自动生成程序。这个小项目实现了文字转视频和音频转视频的功能。&lt;/p&gt;
&lt;p&gt;任意输入或者利用爬虫爬取一段文字语料，首先将其生成音频，然后将这段音频生成视频并添加字幕。音频中可加入各种声效，视频可换任意背景图。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/qihao123/GenVIdeo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7592045accdb4e929964e6418eef33d4~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 知乎文章转视频乞丐版&lt;/h3&gt;
&lt;p&gt;这个开源项目是开发者写的一个小 Demo，实现文字转视频功能。在实现文章转视频需要解决的几个问题：文字分割、文字生成图片、文字转语言等。&lt;/p&gt;
&lt;p&gt;这个开源项目都是使用的比较基础和简单的手段解决这些问题。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/leoython/text-to-video&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b0c3e66bc6402abcccec0a7ff6219c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;历史盘点：https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22f40a9c3a6845dda8b1066ef06d77dc~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Mon, 06 Jun 2022 23:20:14 GMT</pubDate></item><item><title>推荐 8 个 GitHub 开源项目</title><link>https://juejin.cn/post/7106020139799150629</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. App ideas&lt;/p&gt;
&lt;p&gt;2. 中国程序员容易发音错误的单词&lt;/p&gt;
&lt;p&gt;3. 新型冠状病毒数据库&lt;/p&gt;
&lt;p&gt;4. 全新的构建 &amp;nbsp;Web 界面的方法&lt;/p&gt;
&lt;p&gt;5. Vite &amp;amp; Vue 支持的静态站点生成器。&lt;/p&gt;
&lt;p&gt;6. 视频制作机器人&lt;/p&gt;
&lt;p&gt;7. 50 天 50 个项目&lt;/p&gt;
&lt;p&gt;8. 北京买房攻略&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;App ideas&lt;/p&gt;
&lt;p&gt;这个项目是一个项目列表，该列表会根据开发者的水平提供一些练手项目，帮助你提升编程技巧。&lt;/p&gt;
&lt;p&gt;这个开源项目可以帮助你：提高编程能力;助你尝试新技术;增加你的项目经验。这个列表中提到的小项目，易于完成，易于扩展。&lt;/p&gt;
&lt;p&gt;这不仅是一个简单的列表，每个项目都描述的足够详细，有明确的描述性目标和应当实施的用户故事列表，以方便你从头开始进行开发。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/florinpop17/app-ideas&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c09b5aa66294178958d78ab804f0e2e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;中国程序员容易发音错误的单词&lt;/p&gt;
&lt;p&gt;本开源项目收集了技术栈相关的容易发音错误的单词。本着简单的原则，又为了避免程序猿们出现选择困难症， '正确音标'采用了最接近有道词典音频的英式 DJ 音标,，不代表其唯一性。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/shimohq/chinese-programmer-wrong-pronunciation&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c91a47a9bf8040ee97876ae229283ecd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;新型冠状病毒数据库&lt;/p&gt;
&lt;p&gt;这是由约翰霍普金斯大学系统科学与工程中心 (JHU CSSE) 运营的 2019 年新型冠状病毒可视化仪表板的数据存储库。此外，由 ESRI Living Atlas 团队和约翰霍普金斯大学应用物理实验室 (JHU APL) 提供支持。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/CSSEGISandData/COVID-19&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2bd52588a8c4f5d9709374e93579abe~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;全新的构建 &amp;nbsp;Web 界面的方法&lt;/p&gt;
&lt;p&gt;Svelte 是一种全新的构建用户界面的方法。传统框架如 React 和 Vue 在浏览器中需要做大量的工作，而 Svelte 将这些工作放到构建应用程序的编译阶段来处理。&lt;/p&gt;
&lt;p&gt;与使用虚拟（virtual）DOM 差异对比不同。Svelte 编写的代码在应用程序的状态更改时就能像做外科手术一样更新 DOM。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/sveltejs/svelte&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1b4d99a2c9249808df7ea4469c49004~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;Vite &amp;amp; Vue 支持的静态站点生成器。&lt;/p&gt;
&lt;p&gt;Vite 和 Vue 支持的静态站点生成器，简单、强大且高性能。满足您一直想要的现代 SSG 框架。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/vuejs/vitepress&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87872f04c67c4fc581d11139c488c002~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cae6d5c5c0904e4f8beaf6091d9b21a8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;06&lt;/h1&gt;
&lt;p&gt;视频制作机器人&lt;/p&gt;
&lt;p&gt;有些在抖音、快手上的视频获得了数百万的观看次数，你仔细分析他们的视频，他们唯一做的原创事情收集材料、然后拼接在一起。尤其是一些新闻类的视频，本开源项目就是把这个过程自动化了。&lt;/p&gt;
&lt;p&gt;你只需要准备好视频材料，就能自动生成一个视频。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/elebumm/RedditVideoMakerBot&lt;/p&gt;
&lt;h1&gt;07&lt;/h1&gt;
&lt;p&gt;50 天 50 个项目&lt;/p&gt;
&lt;p&gt;50 多个使用 HTML、CSS 和 JS 搭建的迷你 Web 项目。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/bradtraversy/50projects50days&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a5b491e50354aefb7b9d222cbba07a0~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;08&lt;/h1&gt;
&lt;p&gt;北京买房攻略&lt;/p&gt;
&lt;p&gt;本文总结了北京买房的一些基础知识与经验，由于市场和房贷政策随时间会发生变化，并不保证所有信息的真实有效性，也不构成任何投资建议。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/facert/beijing_house_knowledge&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32f2772167b74cc1a8d8da345036547d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10c2258575141029daab7e4ab11ca0e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 05 Jun 2022 23:08:06 GMT</pubDate></item><item><title>盘点最近 yyds 的开源项目</title><link>https://juejin.cn/post/7104110370645606430</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 一个清新文艺的微社区&lt;/p&gt;
&lt;p&gt;2. 30 天学会 React&lt;/p&gt;
&lt;p&gt;3. 零配置 API 样板&lt;/p&gt;
&lt;p&gt;4. 系统设计资源&lt;/p&gt;
&lt;p&gt;5. Wiki 应用程序&lt;/p&gt;
&lt;p&gt;6. 即时通讯项目&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. 一个清新文艺的微社区&lt;/h3&gt;
&lt;p&gt;一个美观清新的微社区开源项目，整套系统使用 Go + Zinc 的架构，前端由 Vue3 构建，采用小清新风格，布局类似 Twitter 的三栏设计。用 Go 写的后端服务运行内存仅 8MB，在单实例 100QPS 时，内存也能稳定在 20MB 左右，资源占用极低。&lt;/p&gt;
&lt;p&gt;全文检索用 Zinc &amp;nbsp;替代了笨重的ElasticSearch，10 万条数据运行内存在 10MB 左右。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/rocboss/paopao-ce"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/295a34338a214bf3bcd5fe73fced4ce6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44b3016d0fbc4e6584cf15322244058d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 30 天学会 React&lt;/h3&gt;
&lt;p&gt;这个项目是《30 天 React 挑战》，是在 30 天内学习 React 的分步指南。它需要你学习 React 之前具备 HTML、CSS 和 JavaScript 知识储备。&lt;/p&gt;
&lt;p&gt;除了 30 天学会 React，开发者还发布过 30 天学会 JavaScript 等项目。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Asabeneh/30-Days-Of-React"&gt;开源地址&lt;/a&gt;
&lt;a href="https://github.com/Asabeneh/30-Days-Of-HTML"&gt;开源地址&lt;/a&gt;
&lt;a href="https://github.com/Asabeneh/30-Days-Of-JavaScript"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afee9b85ab3949bf90336d9593f64e67~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. 零配置 API 样板&lt;/h3&gt;
&lt;p&gt;Hydra 是 Laravel Sanctum 的零配置 API 样板，并带有开箱即用的优秀用户和角色管理 API。使用 Hydra 开始您的下一个大型 API 项目，专注于构建业务逻辑，并节省无数时间一次又一次地编写无聊的用户和角色管理 API。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/hasinhayder/hydra"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d03cbaf82aa349e4835fbe8dfa2118ef~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 系统设计资源&lt;/h3&gt;
&lt;p&gt;开源项目收集了网上优秀的系统设计的资源，包括视频处理、集群、消息队列、系统设计、分布式、数据等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/InterviewReady/system-design-resources"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2dc1e20261742f6815bb47665265a6f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;05. Wiki 应用程序&lt;/h3&gt;
&lt;p&gt;这个 14.7 K Star 的开源项目是基于 Node.js 构建的现代且强大的 wiki 应用程序。使用 Wiki.js 漂亮而直观的界面让编写文档成为一种乐趣！&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/requarks/wiki"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44a1de6d640a470889c9ce1ce09a0dcc~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;06. 即时通讯项目&lt;/h3&gt;
&lt;p&gt;由 IM 技术专家打造的基于 Go 实现的即时通讯（IM）项目。从服务端到客户端 SDK 开源即时通讯（IM）整体解决方案，可以轻松替代第三方 IM 云服务，打造具备聊天、社交功能的 App。&lt;/p&gt;
&lt;p&gt;支持 Andorid、iOS 原生开发，支持 Flutter、uni-app 跨端开发，支持小程序、React 等所有主流 web 前端技术框架， PC 支持 Electron，Flutter、iOS、uni-app 已有成熟 demo 可以体验。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/OpenIMSDK/Open-IM-Server"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/100485c8f2df45fc985f8a9e4be6806f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1520242baac444e3a80d24a75cbaad66~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Tue, 31 May 2022 19:37:54 GMT</pubDate></item><item><title>两天标星 2K Star！程序员人体系统调优指南</title><link>https://juejin.cn/post/7103378856341405726</link><description>&lt;p&gt;这个 repo 火了，两天在 GitHub 获得了 2000 + Star。这个开源项目教你"如何健康学习到 150 岁”，堪称人体系统调优指南。&lt;/p&gt;
&lt;p&gt;睡眠、饮食、心态与动力、学习等方便给出实操建议，开发者将学习 huberman 斯坦福教师的课程做了详细笔记，形成了这么一篇调优指南。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c30da7f085f943bba1a3d5c6e41dcec7~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;huberman 是斯坦福的神经学教授，看完他的课程感觉像调优软件程序那样来“调优”我们自身的人体系统是有可能的。老逛就将指南中比能落地的部分摘要一下。想弄清楚原因的可以去原文看一看。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;开源项目：HumanSystemOptimization&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;教授网站：https://hubermanlab.com/&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;睡眠&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 起床后应该到外面去接触阳光，持续 2-10 分钟&lt;/p&gt;
&lt;p&gt;2.&amp;nbsp;在晚上要尽量减少光源的接触&lt;/p&gt;
&lt;p&gt;3. 午睡可以缓解一天中的精神状态的低谷&lt;/p&gt;
&lt;p&gt;4. 建议的锻炼时间：醒来后 30 分钟，3 小时和 11 小时这三个时间点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;饮食&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&amp;nbsp;间歇性禁食状态对于身体有非常多的好处&lt;/p&gt;
&lt;p&gt;2.&amp;nbsp;何时进食，与吃什么东西，其实是同等重要的&lt;/p&gt;
&lt;p&gt;3. 起床后至少 1 小时内不要吃东西，同时睡前的 2-3 小时不要吃任何东西。&lt;/p&gt;
&lt;p&gt;4.&amp;nbsp;最理想的进食窗口是 8 小时，保证这个窗口时间的稳定性&lt;/p&gt;
&lt;p&gt;5.&amp;nbsp;摄入发酵类食品有好处&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;心态与动力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;了解人体的多巴胺系统原理，帮助你调节心态和情绪。&lt;/p&gt;
&lt;p&gt;1.&amp;nbsp;当你持续做一件喜欢的事情时，你感受到快乐的阈值也会不断提高&lt;/p&gt;
&lt;p&gt;2.&amp;nbsp;半夜睡不着刷手机是很有害的&lt;/p&gt;
&lt;p&gt;3.&amp;nbsp;间歇性且随机的奖励机制&lt;/p&gt;
&lt;p&gt;4.&amp;nbsp;通过自我暗示，把努力过程本身当作一种“奖励”&lt;/p&gt;
&lt;p&gt;4. 影响多巴胺释放的各类因素&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7352795fd2d946d5b9958b5d6bd12f27~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习与专注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 犯错是我们进入学习状态的重要前提&lt;/p&gt;
&lt;p&gt;2. 心流是一种精神高度集中且接近于自动化的状态，是在做我们已经知道怎么做的事情，而不是在学习新的知识技能。推荐一本书《心流》&lt;/p&gt;
&lt;p&gt;3. 成年人对于小幅度的增量学习是完全可以适应与掌握的&lt;/p&gt;
&lt;p&gt;4. 尽可能广泛的学习各种知识和技能&lt;/p&gt;
&lt;p&gt;4.&amp;nbsp;就是让你的身体有一些“新颖的重力体验”，如倒立，瑜伽，体操，滑板，任何让身体会失去平衡的一些状态等，会快速激发“我犯错了”的信号，进入学习状态，甚至可以在之后去做别的任务的学习&lt;/p&gt;
&lt;p&gt;5.&amp;nbsp;不能太放松以至于有些昏昏欲睡，也不能太紧张激动，无法控制自己拥有清晰的思考&lt;/p&gt;
&lt;p&gt;6. 减少睡眠对长期的学习与记忆效果可能并没有提升作用&lt;/p&gt;
&lt;p&gt;7.&amp;nbsp;限制视野范围，能够提升专注度&lt;/p&gt;
&lt;p&gt;8. 视线往下看会让神经系统偏向镇静，放松，甚至困倦，而视线向上则会让系统提升警惕。工作时一般至少把显示器放置在鼻子位置之上。&lt;/p&gt;
&lt;p&gt;9.&amp;nbsp;17 分钟的冥想，能够对大脑中的神经元做重新连接，永久地改善注意力&lt;/p&gt;
&lt;p&gt;10.&amp;nbsp;对大脑直接帮助最大的是有氧运动&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd329a1149f340338a9812a800760a2c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 29 May 2022 20:20:01 GMT</pubDate></item><item><title>盘点 6 个开源的音乐播放器！</title><link>https://juejin.cn/post/7098919562975903775</link><description>&lt;p&gt;盘点几个开源的音乐播放器，在这些项目中你可以学习到 React、Vue、Kotlin等相关的技术栈。有的是仿当前比较火的音乐应用，而有的是开发者自主开发。&lt;/p&gt;
&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 仿 QQ 音乐&lt;/p&gt;
&lt;p&gt;2. 网易云音乐&lt;/p&gt;
&lt;p&gt;3. Material 主题音乐播放器&lt;/p&gt;
&lt;p&gt;4. 不太现代的音乐播放器&lt;/p&gt;
&lt;p&gt;5. 专注于免费流媒体资源的桌面音乐播放器&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. 仿 QQ 音乐&lt;/h3&gt;
&lt;p&gt;模仿 QQ 音乐网页版界面，采用 flexbox 和 position 布局，支持响应式。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/maomao1996/Vue-mmPlayer"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f664eb72ecfb483b88b16698df0e4068~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 网易云音乐&lt;/h3&gt;
&lt;p&gt;基于 React 的在线音乐播放器，这个开源项目是高仿移动端安卓的网易云音乐。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/maomao1996/react-music"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c808bfea3994db09ce381ed00fe69e8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. Material 主题音乐播放器&lt;/h3&gt;
&lt;p&gt;Material 主题音乐播放器，适用于手机端、穿戴设备端、汽车端等。该项目基于最新的开发工具和设计模式构建，用 Kotlin 编写、Android 架构组件、数据绑定等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/naman14/TimberX"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25bd59e0009d4ccabf3d5fe30e2cd77b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86e3ac78655348bcae8738bc7785769c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff4aded2c0b6432a91b2af3d328299f1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 不太现代的音乐播放器&lt;/h3&gt;
&lt;p&gt;Clementine 是适用于 Windows、Linux 和 macOS 的现代音乐播放器和库管理器。虽然开发者标榜现代，但是看了它的 UI，发觉没那么现代。&lt;/p&gt;
&lt;p&gt;它的灵感来源于 Amarok 1.4, 致力于开发一个易于使用的界面，令你能够快速地搜索和播放音乐。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/clementine-player/Clementine"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c635d87922a447ad82c1088226cf93fd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;05. 专注于免费流媒体资源的桌面音乐播放器&lt;/h3&gt;
&lt;p&gt;nuclear 是一个从互联网的各个角落拉取免费的资源的免费流媒体播放器。&lt;/p&gt;
&lt;p&gt;如果你知道 mps-youtube 这个项目,该项目与之类似，但是我们提供了一个美观、强大的图形用户界面。nuclear 更加的专注于音频。想象一下Spotify，你无须为音乐付费，而且你比Spotify有更多的音库来源的选择。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nukeop/nuclear"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5346034c90864a5d9fcc1cf51385c63c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo"&gt;历史盘点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23c5c07805964910bfc5dcf5e4cc1b80~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;</description><author>逛逛GitHub</author><pubDate>Tue, 17 May 2022 19:54:17 GMT</pubDate></item></channel></rss>