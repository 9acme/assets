<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>掘金</title><link>https://juejin.cn/</link><description>代码不止,掘金不停</description><lastBuildDate>Sun, 23 Oct 2022 22:53:16 GMT</lastBuildDate><generator>PyRSS2Gen-1.1.0</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>前端食堂技术周刊第 55 期：Rollup v3.0.0、Volar 1.0 Nika、TypeScript 十年、2022 Web 网络年鉴</title><link>https://juejin.cn/post/7155435611619328036</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：桂花秋梨&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Rollup v3.0.0&lt;/li&gt;
&lt;li&gt;Volar 1.0 Nika&lt;/li&gt;
&lt;li&gt;TypeScript 十年，不忘初心&lt;/li&gt;
&lt;li&gt;2022 Web 网络年鉴&lt;/li&gt;
&lt;li&gt;Resumable vs. Hydration&lt;/li&gt;
&lt;li&gt;JavaScript 框架的新浪潮&lt;/li&gt;
&lt;li&gt;用 Sandpack 打造世界级 Playground&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://github.com/rollup/rollup/releases/tag/v3.0.0"&gt;Rollup v3.0.0&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Rollup 发布 v3.0.0，带来了大量更新。其中 Breaking Change 包括最低支持 Node 14.18.0、浏览器构建拆成单独的包 @rollup/browse、Node 构建使用 &lt;code&gt;node:&lt;/code&gt; 前缀导入内置模块、移除一些以前被废弃的功能，使用时提示警告等。还有包括 Options 配置、插件 API、以及一系列的新特性。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://blog.vuejs.org/posts/volar-1.0.html"&gt;Volar 1.0 Nika&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Volar 发布 1.0，代号 Nika，此次更新主要改进了 UX/DX、性能、包体积、Plugin API v1，将核心代码重构使其与框架无关。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://devblogs.microsoft.com/typescript/ten-years-of-typescript/"&gt;TypeScript 十年，不忘初心&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;祝 TypeScript 10 周年生日快乐 🎂。&lt;/p&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://almanac.httparchive.org/en/2022/"&gt;2022 Web 网络年鉴&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2022 Web 网络年鉴，共计 23 个小章节，包含页面内容、用户体验、内容发布和内容分发等方面，从这些调研数据中可以窥探出各个技术的真实现状。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0b215758bb14610805de8ab1f28692c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://qwik.builder.io/docs/concepts/resumable/"&gt;Resumable vs. Hydration&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文介绍了 Qwik 框架可恢复性的实现原理以及与常规补水相比具有的优势。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://frontendmastery.com/posts/the-new-wave-of-javascript-web-frameworks/"&gt;JavaScript 框架的新浪潮&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;新浪潮这个词今年特别流行，又是一篇“新浪潮”的好文，本文把从古至今各个时代 JavaScript 的典型框架和遇到的痛点问题进行梳理，从而还原出一篇极简的 JavaScript 框架演进史。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc467ce0117f40829e3e4a55f9256e3b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://www.joshwcomeau.com/react/next-level-playground/"&gt;用 Sandpack 打造世界级 Playground&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;CodeSandbox 开源了 Sandpack，本文教你使用 Sandpack 打造出一个功能齐全的 Playground。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85005a156a694f71a132cf67eff0ec3a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/oven-sh/bun/releases/tag/bun-v0.2.0"&gt;Bun v0.2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://storybook.js.org/blog/first-class-vite-support-in-storybook/"&gt;Storybook 7.0 中 Vite 成为内置选项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://astro.build/blog/astro-150/"&gt;Astro 1.5.0 Release&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deno.com/blog/v1.26"&gt;Deno 1.26 Release&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zhuanlan.zhihu.com/p/569763868"&gt;Ant Design 5.0 Alpha&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/lerna/lerna/releases/tag/v6.0.0"&gt;Lerna v6.0.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vitejs/vite/blob/v3.1.8/packages/vite/CHANGELOG.md"&gt;Vite 3.1.8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://mp.weixin.qq.com/s/kibQedZ09TCU2nxJG_v4pQ"&gt;（可能是）最硬核的色彩系统总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://supercodepower.com/fontend-target"&gt;前端版本兼容问题的探索&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 17 Oct 2022 03:05:48 GMT</pubDate></item><item><title>前端食堂技术周刊第 54 期：TS 4.9 Beta、Monorepo Handbook、第 92 次 TC39 会议、将 StoryBook Stories</title><link>https://juejin.cn/post/7147660762519961631</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：芒芒生打椰&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript 4.9 Beta&lt;/li&gt;
&lt;li&gt;Monorepo Handbook 新鲜出炉&lt;/li&gt;
&lt;li&gt;第 92 次 TC39 会议&lt;/li&gt;
&lt;li&gt;将 StoryBook Stories 转换为 Figma 组件&lt;/li&gt;
&lt;li&gt;Playwright 组件测试入门&lt;/li&gt;
&lt;li&gt;垃圾代码书写准则&lt;/li&gt;
&lt;li&gt;React 我爱你，但是你让我失望了&lt;/li&gt;
&lt;li&gt;希望能早点知道的 Chrome Devtools 调试技巧&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-9-beta/"&gt;TypeScript 4.9 Beta&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;TypeScript 4.9 Beta 带着新的 satisfies 操作符来了，主要特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新的 satisfies 操作符；&lt;/li&gt;
&lt;li&gt;增强 in 操作符；&lt;/li&gt;
&lt;li&gt;更严格的 NaN 检查；&lt;/li&gt;
&lt;li&gt;优化 File-Watching，使用文件系统事件，减少轮询；&lt;/li&gt;
&lt;li&gt;为 Promise.resolve 提供更好的类型；&lt;/li&gt;
&lt;li&gt;保留 JS 文件中的导入；&lt;/li&gt;
&lt;li&gt;修正 Exports 和 typeVersions 的优先级；&lt;/li&gt;
&lt;li&gt;优化 Substitution 类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://turborepo.org/docs/handbook/what-is-a-monorepo"&gt;Monorepo Handbook 新鲜出炉&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;TurboRepo 团队近日发布了 Monorepo 手册，包含关于 Monorepo 你需要知道的一切，并提供了详尽的配置示例，内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是 Monorepo？&lt;/li&gt;
&lt;li&gt;安装包 (npm、pnpm、Yarn 1、Yarn &amp;gt;=2)&lt;/li&gt;
&lt;li&gt;Workspaces 工作区&lt;/li&gt;
&lt;li&gt;迁移到 Monorepo&lt;/li&gt;
&lt;li&gt;任务编排&lt;/li&gt;
&lt;li&gt;构建&lt;/li&gt;
&lt;li&gt;Docker 部署&lt;/li&gt;
&lt;li&gt;共享代码&lt;/li&gt;
&lt;li&gt;Lint&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;发布 (Changesets)&lt;/li&gt;
&lt;li&gt;@manypkg/cli 处理包版本依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4cdb1abbba547cd9767a064a0b5ef01~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://dev.to/hemanth/updates-from-the-92nd-tc39-meeting-5fi6"&gt;第 92 次 TC39 会议&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;此次会议进展如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stage3：&lt;a href="https://github.com/tc39/proposal-array-from-async"&gt;Array.fromAsync&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Stage2：&lt;a href="https://github.com/tc39/proposal-is-usv-string"&gt;Well-Formed Unicode Strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;State1：&lt;a href="https://github.com/tc39/proposal-extractors"&gt;Extractors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://divriots.com/blog/story-to-design-is-open/"&gt;将 StoryBook Stories 转换为 Figma 组件&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;‹div›RIOTS&lt;/code&gt; 团队开发的 &lt;code&gt;story.to.design&lt;/code&gt; Figma 插件可以将 StoryBook 的 Strories 转换为 Figma 中的组件。他们同时发布了博文 &lt;a href="https://story.to.design/blog/reasons-every-design-team-needs-story-to-design"&gt;每个设计团队都需要 story.to.design 的 5 个理由&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少代码和设计之间的差异；&lt;/li&gt;
&lt;li&gt;在设计中使用与生产中完全一样的组件；&lt;/li&gt;
&lt;li&gt;设计和原型制作提速；&lt;/li&gt;
&lt;li&gt;跨工具的设计系统更新起来更加便捷；&lt;/li&gt;
&lt;li&gt;与开发人员说同样的（组件）语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc5b7ebb8993427eacea7bef41dcadaa~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://blog.logrocket.com/getting-started-playwright-component-testing/"&gt;Playwright 组件测试入门&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Playwright 现在实验性支持组件测试，本文提供了有关 React、Vue、Svelte 框架组件测试的示例。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://github.com/trekhleb/state-of-the-art-shitcode"&gt;垃圾代码书写准则&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;请把这个仓库转发给写出令你头疼代码的同事，并告诉他：&lt;code&gt;你写的每一行代码都是你的名片。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果他看懂了，他会真诚的谢谢你，并请你吃个饭。&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://marmelab.com/blog/2022/09/20/react-i-love-you.html"&gt;React 我爱你，但是你让我失望了&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Marmelab 的 CEO François Zaninotto 发布了这篇长文，提出了 React 框架现存的一些痛点问题，并坦言 React 社区和生态系统的质量盖过了 React 本身。&lt;/p&gt;
&lt;p&gt;React 团队成员 &lt;a href="https://twitter.com/dan_abramov/status/1572592813363306496"&gt;Dan 随后做出了回应&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb074afbfd0e4100be478022971b9b8a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://javascript.plainenglish.io/11-cool-chrome-devtools-tips-and-tricks-i-wish-i-knew-already-a9e2e078f78"&gt;希望能早点知道的 Chrome Devtools 调试技巧&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;添加条件断点；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;$i('name')&lt;/code&gt; 在控制台安装 npm 包；&lt;/li&gt;
&lt;li&gt;重新发送 XHR 请求；&lt;/li&gt;
&lt;li&gt;快速切换主题颜色；&lt;/li&gt;
&lt;li&gt;在控制台中快速发送请求；&lt;/li&gt;
&lt;li&gt;复制 JavaScript 变量；&lt;/li&gt;
&lt;li&gt;在控制台中获取选定的 DOM 元素；&lt;/li&gt;
&lt;li&gt;捕获全尺寸的屏幕截图；&lt;/li&gt;
&lt;li&gt;展开所有子节点；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;$&lt;/code&gt; 来获取上一次执行的结果；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;$&lt;/code&gt; 和 &lt;code&gt;$$&lt;/code&gt; 来快速选择 DOM 元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/denoland/deno/releases/tag/v1.25.4"&gt;Deno v1.25.4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html"&gt;Rust 1.64.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.mozilla.org/en-US/firefox/105.0/releasenotes/"&gt;Firefox 105.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.chrome.com/en/blog/new-in-devtools-107/"&gt;What's New In DevTools (Chrome 107)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/parcel-bundler/lightningcss"&gt;Lightning CSS v1.16.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://mp.weixin.qq.com/s/Xur4s28bmqGsxV7f4d2GZQ"&gt;Remesh 介绍：用以开发大型复杂 Web App 的 DDD 框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://mp.weixin.qq.com/s/KKU_V5nRHuMeFjBXwbDReQ"&gt;从 0 到 1000 万：哔哩哔哩直播架构演进史&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 26 Sep 2022 04:16:18 GMT</pubDate></item><item><title>前端食堂技术周刊第 53 期：React Router 6.4、VS Code August 2022、2022 Google 谷歌开发者大会、Meta 开源</title><link>https://juejin.cn/post/7145061375994724389</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：劲浓芝士薯片&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;React Router 6.4&lt;/li&gt;
&lt;li&gt;VS Code August 2022&lt;/li&gt;
&lt;li&gt;2022 Google 谷歌开发者大会&lt;/li&gt;
&lt;li&gt;Meta 开源 MemLab&lt;/li&gt;
&lt;li&gt;WAI-ARIA 指南&lt;/li&gt;
&lt;li&gt;《Vue.js 技术内幕》&lt;/li&gt;
&lt;li&gt;Remix 基础知识&lt;/li&gt;
&lt;li&gt;创建现代 npm 包的最佳实践&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://remix.run/blog/react-router-v6.4"&gt;React Router 6.4&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;随着 React Router 6.4 正式发布，React Router 也加入到了远程状态管理的阵营，开发团队将 Remix 中的功能带入到 React Router 中。&lt;/p&gt;
&lt;p&gt;特性总览可以移步 &lt;a href="https://beta.reactrouter.com/en/main/start/overview"&gt;What's New in 6.4?&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://code.visualstudio.com/updates/v1_71"&gt;VS Code August 2022&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;VS Code 近期发布 2022 年 8 月的版本，下面摘出来一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合并编辑器优化(改为手动打开，可以和旧版合并编辑器同时使用、实验性开启优化的 diff 算法)&lt;/li&gt;
&lt;li&gt;FFmpeg 编解码器支持(支持更多格式)&lt;/li&gt;
&lt;li&gt;资源管理器重命名选择改进(F2 快捷键选择文件名、扩展名和全部)&lt;/li&gt;
&lt;li&gt;全部按钮添加圆角 (看来谁也逃不过圆角。。)&lt;/li&gt;
&lt;li&gt;粘性滚动正式发布&lt;/li&gt;
&lt;li&gt;终端优化(平滑滚动、优化渲染)&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.&lt;a href="https://mp.weixin.qq.com/s/K5V91yZojijWiR801fNkRg"&gt;2022 Google 谷歌开发者大会&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;错过直播的同学可以在这里看亮点回顾啦～&lt;/p&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://engineering.fb.com/2022/09/12/open-source/memlab/"&gt;Meta 开源 MemLab&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;MemLab 是一个自动检测内存泄漏的 JavaScript 内存测试工具。工作原理是通过在预定义的测试场景中运行无头浏览器并对 JavaScript 堆快照进行差异分析来发现内存泄漏。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://www.smashingmagazine.com/2022/09/wai-aria-guide/"&gt;WAI-ARIA 指南&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一篇关于无障碍综合指南的博文，总结了一些常见的错误场景，教你用正确的姿势使用它。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://book.douban.com/subject/36092368/"&gt;《Vue.js技术内幕》&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;黄轶老师的新书，厚实的 474 页，昨天刚收到还没读，先领读个目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：Vue.js 的整体设计&lt;/li&gt;
&lt;li&gt;第二部分：组件&lt;/li&gt;
&lt;li&gt;第三部分：响应式原理&lt;/li&gt;
&lt;li&gt;第四部分：编译和优化&lt;/li&gt;
&lt;li&gt;第五部分：实用特性&lt;/li&gt;
&lt;li&gt;第六部分：内置组件&lt;/li&gt;
&lt;li&gt;第七部分：官方生态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a46ee85ae184e018bda09436bda709b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://css-tricks.com/the-basics-of-remix/"&gt;Remix 基础知识&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一篇关于 Remix 基础知识的入门博客。&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://snyk.io/blog/best-practices-create-modern-npm-package/"&gt;创建现代 npm 包的最佳实践&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Snyk 团队的一篇博文，包括如下方面：初始化项目、创建 npm 账户、发布 npm 包、支持 TypeScript、CJS 和 ESM 的打包配置、单元测试及 Pipeline 配置、本地调试、使用 GitHub Actions 和 Snyk 进行安全检查、自动化版本管理和发布，使用 Snyk 进行持续安全监控。&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/preactjs/preact/releases/tag/10.11.0"&gt;Preact v10.11.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/npm/cli/releases/tag/v9.0.0-pre.0"&gt;npm v9.0.0-pre.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://webkit.org/blog/13152/webkit-features-in-safari-16-0/"&gt;WebKit Features in Safari 16.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.iviewui.com/resource"&gt;View Design 设计资源免费上线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/oven-sh/bun/releases"&gt;Bun v0.1.12&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://www.smashingmagazine.com/2022/09/javascript-api-guide/"&gt;你不知道的 JavaScript API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://olivernguyen.io/s/js2022/"&gt;2022 年最新的 JavaScript 功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 19 Sep 2022 04:07:43 GMT</pubDate></item><item><title>前端食堂技术周刊第 52 期：Babel 7.19.0、Fresh 1.1、React Native 0.70、新的 Web 性能指标 INP</title><link>https://juejin.cn/post/7143094170108821540</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：西瓜挖球冰&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Babel 7.19.0&lt;/li&gt;
&lt;li&gt;Fresh 1.1&lt;/li&gt;
&lt;li&gt;React Native 0.70&lt;/li&gt;
&lt;li&gt;Node.js 工作原理解析&lt;/li&gt;
&lt;li&gt;JSON Crack&lt;/li&gt;
&lt;li&gt;新的 Web 性能指标 INP&lt;/li&gt;
&lt;li&gt;React 为什么重新渲染&lt;/li&gt;
&lt;li&gt;JavaScript 历史的时间轴&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://babeljs.io/blog/2022/09/05/7.19.0"&gt;Babel 7.19.0&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;该版本包括对如下内容的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/tc39/proposal-decorators"&gt;decorators proposal&lt;/a&gt;  5 年了，终于要定下来了，不过功能砍了很多；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tc39/proposal-duplicate-named-capturing-groups"&gt;Duplicate named capturing groups&lt;/a&gt; 正则支持重复命名捕获。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://deno.com/blog/fresh-1.1"&gt;Fresh 1.1&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Fresh 1.1 近期发布，更新了好多特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认支持 JSX；&lt;/li&gt;
&lt;li&gt;支持插件，提供官方 twind 插件；&lt;/li&gt;
&lt;li&gt;支持 &lt;a href="https://preactjs.com/blog/introducing-signals/"&gt;Preact Signals&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;支持 Preact DevTools；&lt;/li&gt;
&lt;li&gt;ctx.renderNotFound() 渲染 404 页面；&lt;/li&gt;
&lt;li&gt;支持多个中间件；&lt;/li&gt;
&lt;li&gt;实验性支持 Deno.serve；&lt;/li&gt;
&lt;li&gt;Showcase 展示区和 Made with Fresh 徽章。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.&lt;a href="https://reactnative.dev/blog/2022/09/05/version-070"&gt;React Native 0.70&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;React Native 0.70 主要更新如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文档更新“新的架构“部分；&lt;/li&gt;
&lt;li&gt;使用 Hermes 作为默认引擎；&lt;/li&gt;
&lt;li&gt;统一配置 iOS 和 Android 的 Codegen Config；&lt;/li&gt;
&lt;li&gt;在新架构下 Android 支持库的 Auto-linking ；&lt;/li&gt;
&lt;li&gt;Android 构建时支持 CMake；&lt;/li&gt;
&lt;li&gt;等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://2ality.com/2022/09/nodejs-overview.html#the-node.js-platform"&gt;Node.js 工作原理解析&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Axel Rauschmayer 博士的这篇博文概述了 Node.js 的工作原理，包含如下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;架构；&lt;/li&gt;
&lt;li&gt;API；&lt;/li&gt;
&lt;li&gt;全局变量和内置模块的亮点；&lt;/li&gt;
&lt;li&gt;事件循环；&lt;/li&gt;
&lt;li&gt;并发方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;年底前，他将发布新书&lt;a href="https://buttondown.email/rauschma"&gt;《Shell scripting with Node.js》&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://jsoncrack.com/"&gt;JSON Crack&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;JSON 可视化工具。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b354acaca295439e984cee415704787a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://web.dev/inp/"&gt;新的 Web 性能指标 INP&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;INP 通过测量用户与页面的所有交互事件的延迟，来得出代表页面整体响应能力的实验性指标。INP 测量的范围包括鼠标/触摸屏点击事件、键盘事件，不包括悬停和滚动事件。当用户离开页面时计算，结果是一个单一的值，越低越好。&lt;/p&gt;
&lt;p&gt;与 FID 的区别：INP 综合考虑了页面的所有交互，得出更全面的指标，而 FID 只是首次。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92e523ee11a84ce1b87d83bfee7b64c6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://blog.skk.moe/post/react-re-renders-101/"&gt;React 为什么重新渲染&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;你认为 React 组件更新有几个原因？&lt;/p&gt;
&lt;p&gt;是因为它的 prop 发生了改变吗？还是 Context.Provider 的 value 发生了更新？当一个状态发生改变时，整棵 React 树都会更新吗？&lt;/p&gt;
&lt;p&gt;上面的问题如果你不能保证你能完全回答正确，那就去这篇博文一探究竟吧～&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ba82534668e4ad4886cbe3f64427a00~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://blog.risingstack.com/history-of-javascript-on-a-timeline/"&gt;JavaScript 历史的时间轴&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个站点整理了 JavaScript 历史上的关键事件节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1994-1998: 网景时代；&lt;/li&gt;
&lt;li&gt;1999-2007: IE 大战 Firefox；&lt;/li&gt;
&lt;li&gt;2008-2012: 网景终结，Chrome 诞生；&lt;/li&gt;
&lt;li&gt;2013-2014: 从 ASM.js 到 WebAssembly；&lt;/li&gt;
&lt;li&gt;2015-2020: Node.js 崛起；&lt;/li&gt;
&lt;li&gt;2020-2022年：Deno 诞生，IE 退休。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b8ce032ceb42c79820a87bff8db529~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/nuxt-modules/icon"&gt;Nuxt Icon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nextjs.org/blog/next-12-3"&gt;Next.js 12.3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/TypeScript/issues/50457"&gt;TypeScript 4.9 Iteration Plan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://w3cplus.medium.com/%E5%88%9B%E6%84%8F%E6%80%A7%E7%9A%84css%E5%B8%83%E5%B1%80%E5%92%8C%E7%81%B5%E6%B4%BBweb-eb7e83e99575"&gt;创意性的 CSS 布局和灵活 Web&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://meticulous.ai/blog/react-error-boundaries-complete-guide/"&gt;React Error Boundary 指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Tue, 13 Sep 2022 20:54:16 GMT</pubDate></item><item><title>前端食堂技术周刊第 51 期：pnpm v7.10.0、8 月登陆网络平台的新内容、重新思考流行的 Node.js 模式和工具、打包 JavaScript 库的</title><link>https://juejin.cn/post/7140216695834017822</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：青提好椰拿铁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;pnpm v7.10.0&lt;/li&gt;
&lt;li&gt;8 月登陆网络平台的新内容&lt;/li&gt;
&lt;li&gt;重新思考流行的 Node.js 模式和工具&lt;/li&gt;
&lt;li&gt;打包 JavaScript 库的现代化指南&lt;/li&gt;
&lt;li&gt;Chrome DevTools 中的现代 Web 调试&lt;/li&gt;
&lt;li&gt;当 React Query 遇见 React Router&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://github.com/pnpm/pnpm/releases/tag/v7.10.0"&gt;pnpm v7.10.0&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;Time-based 依赖解析模式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;直接依赖将安装其最低版本，比如 foo@^1.1.0，将会安装 1.1.0。&lt;/li&gt;
&lt;li&gt;间接依赖只会安装被选中的直接依赖在其发布时间点之前的版本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;据作者说，这种模式是为了减少供应链攻击导致项目“噶”的风险，因为它能保证间接依赖不会比直接依赖更加新。这样如果间接依赖被攻击，也不会安装被攻击的版本。不过这种解析模式需要拿到 npm 的完整元数据，所以速度会很慢。解法是自建 Verdaccio，并将 registry-supports-time-field 设置为 true。&lt;/p&gt;
&lt;p&gt;能减少供应链攻击的风险是好事，但是感觉这种模式本身存在很多问题，比如不遵守 semver 语义，虽然社区里很多项目都没有好好遵守 :)、或者当旧的间接依赖修复了某个 bug，但是有 bug 的版本还是会被安装。&lt;/p&gt;
&lt;p&gt;啊，我要这铁棒(功能)有何用？&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://web.dev/web-platform-08-2022/"&gt;8 月登陆网络平台的新内容&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/104"&gt;Firefox 104&lt;/a&gt;、&lt;a href="https://developer.chrome.com/blog/new-in-chrome-104/"&gt;Chrome 104&lt;/a&gt;、&lt;a href="https://developer.chrome.com/blog/new-in-chrome-105/"&gt;Chrome 105&lt;/a&gt; 发布稳定版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Chrome 104 新增 &lt;a href="https://web.dev/css-individual-transform-properties/"&gt;CSS transform 属性单独定义&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;Chrome 104 新增 &lt;a href="https://developer.chrome.com/blog/media-query-range-syntax/"&gt;媒体查询的新语法&lt;/a&gt;，支持比较运算符，更加符合人体工程学；&lt;/li&gt;
&lt;li&gt;Chrome 105 新增 &lt;a href="https://developer.chrome.com/blog/has-with-cq-m105/"&gt;容器查询和 :has()&lt;/a&gt;，响应式的最佳拍档；&lt;/li&gt;
&lt;li&gt;Chrome 105 新增 &lt;a href="https://developer.chrome.com/blog/new-in-chrome-105/#sanitizer-api"&gt;Sanitizer API&lt;/a&gt;，防止 XSS 攻击的灭菌武器；&lt;/li&gt;
&lt;li&gt;Chrome 105 新增 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:modal"&gt;:modal 伪类&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;Firefox 104 支持 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:modal"&gt;The findLast() 和 findLastIndex() &lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://practica.dev/blog/popular-nodejs-pattern-and-tools-to-reconsider/"&gt;重新思考流行的 Node.js 模式和工具&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;你习以为常的工具不一定是最佳选择。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/goldbergyoni/nodebestpractices"&gt;Node.js 最佳实践&lt;/a&gt;、&lt;a href="https://github.com/goldbergyoni/javascript-testing-best-practices"&gt;JavaScript 和 Node.js 测试最佳实践&lt;/a&gt; 的作者 Yoni Goldberg 对 Node.js 中的流行工具发出了灵魂拷问，并给出了他的思考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/mozilla/node-convict"&gt;Node-convict&lt;/a&gt; 比 &lt;a href="https://github.com/motdotla/dotenv"&gt;Dotenv&lt;/a&gt; 更好；&lt;/li&gt;
&lt;li&gt;从 Controller 调用 Service 时，要尽量抽象 Service 的内容(多用心封装封装)，尽可能屏蔽掉技术细节和复杂性，让看你代码的同学赏心悦目一些；&lt;/li&gt;
&lt;li&gt;Nest.js 中万物皆可依赖注入，但简单点也许世界会更美好；&lt;/li&gt;
&lt;li&gt;不一定要用 &lt;a href="https://github.com/jaredhanson/passport"&gt;Passport.js&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.npmjs.com/package/supertest"&gt;SuperTest&lt;/a&gt; 的三合一语法有时候并没有那么好用；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/fastify/fastify"&gt;Fastify&lt;/a&gt; 装饰器错误姿势&lt;/li&gt;
&lt;li&gt;catch 子句的正确姿势；&lt;/li&gt;
&lt;li&gt;避免重复使用日志工具 &lt;a href="https://www.npmjs.com/package/morgan"&gt;Morgan&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;减少使用 process.env.NODE_ENV 当作判断条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://github.com/frehner/modern-guide-to-packaging-js-library/blob/main/README-zh_CN.md"&gt;打包 JavaScript 库的现代化指南&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个仓库记录了一些通用的现代化 JavaScript 打包指南，该指南不局限于某一个特定的打包工具，而且包含很多扩展资料，适合入门学习。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://developer.chrome.com/blog/devtools-modern-web-debugging/"&gt;Chrome DevTools 中的现代 Web 调试&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chrome DevTools 团队与 Angular 团队合作，对 Chrome DevTools 中的调试体验进行了改进。&lt;/p&gt;
&lt;p&gt;真正做到给开发者看他们最想看的东西，调试体验终于要起飞了？&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://tkdodo.eu/blog/react-query-meets-react-router"&gt;当 React Query 遇见 React Router&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://beta.reactrouter.com/en/dev"&gt;React Router 6.4&lt;/a&gt; 即将正式发布，React Router 也加入了远程状态管理的数据获取游戏。本文将带你了解 React Router 和现有的远程状态管理库(如：React Query)之间的竞争和关联，作者认为他们是天造地设的一对。&lt;/p&gt;
&lt;p&gt;隔壁家 Vue Router 的数据获取相关提案 &lt;a href="https://github.com/vuejs/rfcs/discussions/460"&gt;Vue Router Data Loaders&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://nextjs.org/conf"&gt;Next.js Conf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#310-beta2-2022-09-02"&gt;Vite v3.1.0-beta.2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://heroicons.com/"&gt;Heroicons v2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vitest-dev/vitest/releases/tag/v0.23.0"&gt;Vitest v0.23.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ant-design/ant-design/releases/tag/4.23.0"&gt;Ant Design v4.23.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://webkit.org/blog/13140/webkit-on-github/"&gt;WebKit on GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://mp.weixin.qq.com/s/d0N1BFtVn0uWVqj-lf0FOA"&gt;玉伯的产品思考：技术人如何做产品&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://www.joshwcomeau.com/react/usememo-and-usecallback/"&gt;深入理解 useMemo 和 useCallback&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Tue, 06 Sep 2022 02:51:52 GMT</pubDate></item><item><title>前端食堂技术周刊第 50 期：TypeScript 4.8、Deno 1.25、Terminal Gif Maker、CSS :has() 伪类、Deno ch</title><link>https://juejin.cn/post/7137289926441173029</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：草莓生乳酪蛋糕&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PC 端在仓库里看体验更好，顺手赏个 Star 是对食堂最大的支持。&lt;/p&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript 4.8&lt;/li&gt;
&lt;li&gt;Deno 1.25&lt;/li&gt;
&lt;li&gt;Terminal Gif Maker&lt;/li&gt;
&lt;li&gt;CSS :has() 伪类&lt;/li&gt;
&lt;li&gt;用 Rust 实现的数据结构与算法合辑&lt;/li&gt;
&lt;li&gt;Deno cheat sheet&lt;/li&gt;
&lt;li&gt;Explain Shell&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-8/"&gt;TypeScript 4.8&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;自 Beta 版和 RC 版以来的新进展&lt;/h3&gt;
&lt;p&gt;自 Beta 版发布以来，稳定版现在支持了从自动导入中排除特定文件的编辑器选项。此外，本次发布公告中也补充了 Beta 版和 RC 版的发布公告中没有记录到的内容(绑定模式中的类型推断、装饰器的语法修改)。&lt;/p&gt;
&lt;h3&gt;主要更新&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;改进交叉类型、联合类型和类型缩窄；&lt;/li&gt;
&lt;li&gt;改进模板字符串类型中 infer 的类型推断；&lt;/li&gt;
&lt;li&gt;--build, --watch, 和 --incremental 性能改进；&lt;/li&gt;
&lt;li&gt;改进比较对象和数组字面量时的错误提示；&lt;/li&gt;
&lt;li&gt;改进绑定模式的类型推断；&lt;/li&gt;
&lt;li&gt;修复文件监测(特别是 git checkout 场景)；&lt;/li&gt;
&lt;li&gt;Find-All-Reference 性能改进；&lt;/li&gt;
&lt;li&gt;从自动导入中排除特定文件；&lt;/li&gt;
&lt;li&gt;正确性修复和破坏性更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://deno.com/blog/v1.25"&gt;Deno 1.25&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;主要更新&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;添加 deno init 初始化子命令；&lt;/li&gt;
&lt;li&gt;实验性 npm 支持；&lt;/li&gt;
&lt;li&gt;新的 HTTP Server API；&lt;/li&gt;
&lt;li&gt;改进启动时间；&lt;/li&gt;
&lt;li&gt;改进 FFI API。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://www.terminalgif.com/"&gt;Terminal Gif Maker&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Terminal 终端 Gif 图生成器，支持自定义命令、字体、显示时间等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5165fc038b2444bb5b882e06ffcf6c1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://www.zhangxinxu.com/wordpress/2022/08/css-has-pseudo-class/"&gt;CSS :has() 伪类&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;:has() 伪类规范制定的很早，但是因为浏览器厂商顾忌性能的影响，一直没有得到支持，这一等就是 24 年。直到 &lt;a href="https://www.igalia.com/"&gt;Igalia&lt;/a&gt; 公司搞定了这个浏览器几十年都无法解决的性能问题。&lt;/p&gt;
&lt;p&gt;Safari 15.4 、Chrome 105 目前均已支持，Firefox 也已经开启实验性支持。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://github.com/TheAlgorithms/Rust"&gt;用 Rust 实现的数据结构与算法合辑&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个仓库总结并记录了用 Rust 实现的数据结构与算法。&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://oscarotero.com/deno/"&gt;Deno cheat sheet&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Deno 备忘录，从 Deno runtime API、Web API 以及标准库三类 API 进行分类并标注了 API 状态，点击后可前往该 API 的详细文档。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/411b170fa59d451282c79937e69de6c5~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://explainshell.com/"&gt;Explain Shell&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;提供参数的详细信息来帮助你理解整个命令。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08597a8a9c0a43b8ae4c2954462d6987~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://code.visualstudio.com/blogs/2022/08/16/markdown-language-server"&gt;Introducing the Markdown Language Server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/book/7127092198096502822/section/7127192279898390567"&gt;2022 稀土开发者大会 PPT 合辑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://viteconf.org/speakers/"&gt;ViteConf 演讲者列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://jestjs.io/blog/2022/08/25/jest-29"&gt;Jest 29&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://heroicons.com/"&gt;Heroicons v2.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://mp.weixin.qq.com/s/8qNI4a-3P2KId9WRAnz2dw"&gt;深入解读新一代全栈框架 Fresh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://medium.com/tap-to-dismiss/a-better-segmented-control-9e662de2ef57"&gt;如何选择控件？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 29 Aug 2022 05:31:42 GMT</pubDate></item><item><title>前端食堂技术周刊第 49 期：Deno即将迎来重大变革、Blitz 2.0 Beta、Chrome删除HTTP/2服务端推送</title><link>https://juejin.cn/post/7134661235454246948</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：茉莉花拌海蜇&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PC 端在仓库里看体验更好，顺手赏个 Star 是对食堂最大的支持。&lt;/p&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Deno 即将迎来重大变革&lt;/li&gt;
&lt;li&gt;StackBlitz 2022 年 7 月更新&lt;/li&gt;
&lt;li&gt;Announcing Blitz 2.0 BETA&lt;/li&gt;
&lt;li&gt;从 Chrome 中删除 HTTP/2 服务器推送&lt;/li&gt;
&lt;li&gt;Web Image 最佳实践&lt;/li&gt;
&lt;li&gt;Vite Rollup Plugins&lt;/li&gt;
&lt;li&gt;TypeScript Collections&lt;/li&gt;
&lt;li&gt;Code Golfing Tips &amp;amp; Tricks&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://deno.com/blog/changes"&gt;Deno 即将迎来重大变革&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;随着 &lt;a href="https://bun.sh/"&gt;Bun&lt;/a&gt; 的发布，Deno 明显感受到压力，先是&lt;a href="https://deno.com/blog/v1.24#improved-ffi-call-performance"&gt;将 FFI 性能提升了约 200 倍&lt;/a&gt;。近期 Deno 官方又宣布一系列的大新闻：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未来三个月，Deno 支持导入 80%-90% 的 npm 包；&lt;/li&gt;
&lt;li&gt;将最快的 JavaScript 运行时作为发展目标，HTTP 服务器正在重构；&lt;/li&gt;
&lt;li&gt;支持企业用户：提供办公时段专属套餐；&lt;/li&gt;
&lt;li&gt;提升 DX：所有第三方 Deno 代码的全文符号搜索、自动生成 JavaScript 和 TypeScript 项目的文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5774c6edd444b4cb99886248fcf49ca~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://blog.stackblitz.com/posts/update-2022-07/"&gt;StackBlitz 2022 年 7 月更新&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;StackBlitz 2022 年 7 月更新动态汇总，包含如下几个方面，对此关注的堂友可以移步链接阅读。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;社区的新动态；&lt;/li&gt;
&lt;li&gt;DX 提升和兼容性改进；&lt;/li&gt;
&lt;li&gt;快餐资讯。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.&lt;a href="https://github.com/blitz-js/blitz/releases/tag/v2.0.0-beta.1"&gt;Announcing Blitz 2.0 BETA&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Blitz 不再是一个一体化的框架，而是一个用于 Next.js 的全栈工具包。这意味着 Blitz 从对 Next.js 的抽象转变为模块化的工具包，支持插入任何新的或者现有的 Next.js 应用。&lt;/p&gt;
&lt;p&gt;Blitz 2.0 包含如下六个包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;blitz：核心包，提供实用的工具函数、插件机制和脚手架；&lt;/li&gt;
&lt;li&gt;@blitzjs/next：暴露特定于 Next.js 框架 functions &amp;amp; components；&lt;/li&gt;
&lt;li&gt;@blitzjs/auth：提供身份验证和授权；&lt;/li&gt;
&lt;li&gt;@blitzjs/rpc：Zero-API 数据层；&lt;/li&gt;
&lt;li&gt;@blitzjs/codemod：为升级提供的 codemod。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4.&lt;a href="https://developer.chrome.com/blog/removing-push/"&gt;从 Chrome 中删除 HTTP/2 服务器推送&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在 Chrome 106 和其他基于 Chromium 的浏览器的下一个版本中，对 HTTP/2 服务器推送的支持将被默认禁用。原因及替代方案如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际使用中没有明显的性能提升；&lt;/li&gt;
&lt;li&gt;采用 HTTP2 的站点从 1.25% 下降到 0.7%；&lt;/li&gt;
&lt;li&gt;替代方案：&lt;a href="https://developer.chrome.com/blog/early-hints/"&gt;Early Hints&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://github.com/nucliweb/image-element"&gt;Web Image 最佳实践&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个仓库收集了 Web Image 的最佳实践。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9c8d0f8cc6847dcb20dd12f2c424034~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://vite-rollup-plugins.patak.dev/"&gt;Vite Rollup Plugins&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Vite3 中使用 Rollup 插件的兼容性列表，我猜作者 patak 一定是个贴心暖男。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0cdb6254e1341d58d1d8a8e69ebdf02~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://github.com/basarat/typescript-collections"&gt;TypeScript Collections&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用 TypeScript 编写的数据结构合集，包含如图所示的数据结构。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/012c7506667a497cac0fb14aa3826046~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://getbutterfly.com/code-golfing-tips-tricks-how-to-minify-your-javascript-code/"&gt;Code Golfing Tips &amp;amp; Tricks&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这篇博文整理了一系列关于 JavaScript 编码的技巧，包括如何用更少的编码实现同样的功能。在一些比赛，如 &lt;a href="https://js13kgames.com/"&gt;JS13KGames&lt;/a&gt;、&lt;a href="https://js1024.fun/"&gt;js1024&lt;/a&gt; 中这些技巧很实用。但是在真实世界中，我们需要给可读性更多关注，毕竟代码是写给人看的。&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/reduxjs/redux-toolkit/releases/tag/v1.9.0-alpha.0"&gt;redux-toolkit v1.9.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pmndrs/valtio/releases/tag/v1.6.4"&gt;Valtio v1.6.4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pmndrs/zustand/releases/tag/v4.1.0"&gt;Zustand v4.1.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pmndrs/jotai/releases/tag/v1.8.0"&gt;Jotai v1.8.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.blog/changelog/2022-08-03-introducing-the-new-npm-dependency-selector-syntax/"&gt;新的 npm 依赖选择器语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://storybook.js.org/blog/7-0-design-alpha/"&gt;Figma 7.0 design alpha&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://mp.weixin.qq.com/s/ZO40uAkH0jCXqVO3bBZ6YQ"&gt;闲鱼宗心：这一年，我对终端组织与技术架构的思考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://www.joshwcomeau.com/react/why-react-re-renders/"&gt;Why React Re-Renders&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 22 Aug 2022 03:29:40 GMT</pubDate></item><item><title>前端食堂技术周刊第 48 期：ESLint 新配置系统、Vue3 中文文档正式上线、Astro 1.0、小程序新渲染引擎</title><link>https://juejin.cn/post/7131776058528890911</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：青提椰汁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PC 端在仓库里看体验更好，顺手赏个 Star 是对食堂最大的支持。&lt;/p&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;ESLint 推出新的配置系统&lt;/li&gt;
&lt;li&gt;新版 Vue 3 中文文档正式上线&lt;/li&gt;
&lt;li&gt;Astro 1.0&lt;/li&gt;
&lt;li&gt;小程序新渲染引擎 Skyline Beta&lt;/li&gt;
&lt;li&gt;NodeParty 分享 PPT &amp;amp; 回顾视频&lt;/li&gt;
&lt;li&gt;使用 Vue 组件构建命令行界面应用&lt;/li&gt;
&lt;li&gt;React re-render 指南&lt;/li&gt;
&lt;li&gt;React TypeScript 备忘录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://eslint.org/blog/2022/08/new-config-system-part-1/"&gt;ESLint 推出新的配置系统&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;回顾当前的 eslintrc 配置系统演进史，每一步的演化在当时来看都是不错的选择，比如 extends、Personal configs、多种配置文件格式、可共享的配置和依赖项(npm 背锅)、root、overrides、添加 extends 到 overrides 等等。&lt;/p&gt;
&lt;p&gt;然而时至今日，随着 JavaScript 项目越来越庞大，从整体上再来看这些配置就太复杂了。为了简化配置，ESLint 团队经过 18 个月的修订和讨论，决定着手构建一个全新的配置系统 flat config，现在可以在 &lt;a href="https://eslint.org/blog/2022/08/eslint-v8.21.0-released/"&gt;ESLint v8.21.0&lt;/a&gt; 中通过 API 使用。&lt;/p&gt;
&lt;p&gt;可以通过如下链接了解更多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://eslint.org/blog/2022/08/new-config-system-part-1/"&gt;ESLint's new config system, Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://eslint.org/blog/2022/08/new-config-system-part-2/"&gt;ESLint's new config system, Part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://eslint.org/blog/2022/08/new-config-system-part-3/"&gt;ESLint's new config system, Part 3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://cn.vuejs.org/"&gt;新版 Vue 3 中文文档正式上线&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://zhuanlan.zhihu.com/p/551326037"&gt;尤大亲自官宣&lt;/a&gt; 新版 Vue 3 中文文档正式上线。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://astro.build/blog/astro-1/"&gt;Astro 1.0&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2022 年 &lt;a href="https://jasonformat.com/islands-architecture/"&gt;Islands Architecture 孤岛架构&lt;/a&gt; 发展十分迅猛，代表框架如：&lt;a href="https://astro.build/"&gt;Astro&lt;/a&gt;、&lt;a href="https://github.com/BuilderIO/qwik"&gt;Qwik&lt;/a&gt;、&lt;a href="https://elderguide.com/tech/elderjs/"&gt;Elder.js&lt;/a&gt;、&lt;a href="https://fresh.deno.dev/"&gt;Fresh&lt;/a&gt; 等。&lt;/p&gt;
&lt;p&gt;Astro 1.0 近期正式发布，文档写的很不错，如下是核心理念部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.astro.build/en/concepts/why-astro/"&gt;Why Astro?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.astro.build/zh-cn/concepts/mpa-vs-spa/"&gt;MPA vs SPA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.astro.build/zh-cn/concepts/islands/"&gt;Astro Islands&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4.&lt;a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html"&gt;小程序新渲染引擎 Skyline Beta&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;为了使小程序的性能接近原生的用户体验，小程序推出了新的渲染引擎 Skyline。&lt;/p&gt;
&lt;p&gt;新的架构相比原有的 WebView 架构，有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;界面更不容易被逻辑阻塞，进一步减少卡顿；&lt;/li&gt;
&lt;li&gt;无需为每个页面新建一个 JS 引擎实例（WebView），减少了内存、时间开销；&lt;/li&gt;
&lt;li&gt;框架可以在页面之间共享更多的资源，进一步减少运行时内存、时间开销；&lt;/li&gt;
&lt;li&gt;框架的代码之间无需再通过 JSBridge 进行数据交换，减少了大量通信时间开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新的渲染流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e07a197446c4962a5d254f8a454d70a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://www.yuque.com/antfe/featured/gi7ker"&gt;NodeParty 分享 PPT &amp;amp; 回顾视频&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;没看直播的堂友们可以看视频回放了，如下是 NodeParty 的四大主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Node.js - What's Next&lt;/li&gt;
&lt;li&gt;企业级包管理服务 cnpmcore&lt;/li&gt;
&lt;li&gt;cnpm rapid 极速模式，正式开源&lt;/li&gt;
&lt;li&gt;从 Egg 到 Artus，谈谈框架的框架的初心&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://github.com/webfansplz/temir"&gt;用 Vue 组件构建命令行界面应用&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Temir 可以让你使用 Vue 组件构建出命令行界面应用。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://www.developerway.com/posts/react-re-renders-guide"&gt;React re-render 指南&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;关于 React 重渲染的系列指南，图文并茂，同时提供了代码示例和扩展资料。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d8995a99a63423f9c59f7b7051fcabd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://react-typescript-cheatsheet.netlify.app/"&gt;React TypeScript 备忘录&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一份很全面的 React TypeScript 备忘录。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/904f072c6f5145499fb5038b52ed5531~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-8-rc/"&gt;Announcing TypeScript 4.8 RC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.chrome.com/en/blog/new-in-devtools-105/"&gt;What's New In DevTools (Chrome 105)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/VrFVxGK60gC98j_sp8pr7Q"&gt;Electron 20 值得关注的变化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://turborepo.org/blog/turbo-1-4-0"&gt;Turborepo 1.4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/prisma/prisma/releases/tag/4.2.0"&gt;Prisma v4.2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/histoire-dev/histoire/releases/tag/v0.10.0"&gt;histoire v0.10.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://juejin.cn/post/7129334955380834311"&gt;Vitest: 现代前端测试框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://mp.weixin.qq.com/s/dGQqm4JwlKwAKiKcUtZSqg"&gt;5 亿用户如何高效沟通？钉钉首次对外揭秘即时消息服务 DTIM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Sun, 14 Aug 2022 08:57:46 GMT</pubDate></item><item><title>前端食堂技术周刊第 47 期：Docusaurus 2.0 、7 月登陆网络平台的新内容 、Nuxt.js 团队的轮子库</title><link>https://juejin.cn/post/7129910422525706247</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：碳烤羊排&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PC 端在仓库里看体验更好，顺手赏个 Star 是对食堂最大的支持。&lt;/p&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Docusaurus 2.0&lt;/li&gt;
&lt;li&gt;7 月登陆网络平台的新内容&lt;/li&gt;
&lt;li&gt;Nuxt.js 团队的轮子库&lt;/li&gt;
&lt;li&gt;React 的一些最佳安全实践&lt;/li&gt;
&lt;li&gt;业务中的前端组件化体系&lt;/li&gt;
&lt;li&gt;DNS 查询原理详解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://docusaurus.io/blog/2022/08/01/announcing-docusaurus-2.0"&gt;Docusaurus 2.0&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c583ced199ae443999996ef1721549a8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;你可能没用过 Docusaurus，但是你一定看过基于它搭建的网站，比如：Prettier、Babel、React-Native、Jest、Gulp、Redux、Tauri、Taro 等。&lt;/p&gt;
&lt;p&gt;近期 Docusaurus 2.0 发布，核心功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持用于客户端；&lt;/li&gt;
&lt;li&gt;插件系统，核心功能由单独插件提供支持，也方便社区贡献插件；&lt;/li&gt;
&lt;li&gt;更加灵活的主题定制，如：自定义 CSS 变量、提供用户自己的样式表、从头实现主题、覆盖内置组件；&lt;/li&gt;
&lt;li&gt;文档版本基于快照，更加容易理解；&lt;/li&gt;
&lt;li&gt;MDX；&lt;/li&gt;
&lt;li&gt;约定式文件系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://web.dev/web-platform-07-2022/"&gt;7 月登陆网络平台的新内容&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;该系列博文会收集每个月登陆 stable(稳定) 和 beta(测试) 版本浏览器的有趣功能，如下是 stable 版本浏览器的部分：&lt;/p&gt;
&lt;p&gt;Firfox 103 和 Safari 15.6 发布稳定版，在几个不错的 CSS 功能上获得了互操作性，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/backdrop-filter"&gt;backdrop-filter&lt;/a&gt;，可以实现毛玻璃效果；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/842b73be53934473bc5abfe1ea0eea37~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"&gt;scroll-snap-stop&lt;/a&gt;，更加良好的滚动体验。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://unjs.io/"&gt;Nuxt.js 团队的轮子库&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个页面汇总了 Nuxt.js 团队创造的各种轮子。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ced6cd6717404c56b4fd1869f36dcc74~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;2.&lt;a href="https://mp.weixin.qq.com/s/KNbOa19OOnP6Rh1Uk2iotw"&gt;React 的一些最佳安全实践&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;为了保证 React 应用的安全性，值得遵循的最佳实践。&lt;/p&gt;
&lt;p&gt;包含如下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dangerouslySetInnerHTML；&lt;/li&gt;
&lt;li&gt;避免直接操作 DOM 注入 HTML；&lt;/li&gt;
&lt;li&gt;服务端渲染；&lt;/li&gt;
&lt;li&gt;JSON 注入；&lt;/li&gt;
&lt;li&gt;URL 注入；&lt;/li&gt;
&lt;li&gt;避免有漏洞的 React 版本；&lt;/li&gt;
&lt;li&gt;避免有漏洞的其他依赖；&lt;/li&gt;
&lt;li&gt;ESLint React 安全配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.&lt;a href="https://zhuanlan.zhihu.com/p/383129585"&gt;业务中的前端组件化体系&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在一个业务体系中，组件化到底应该如何去做？&lt;/p&gt;
&lt;p&gt;这篇博文试图围绕这个主题，给出一些可能的解决思路，包括如下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;组件的实现：状态与渲染、使用上下文管控依赖项、状态的可组合性、分层复用、多级子树、状态的依赖关系；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工程链路：组件依赖形态、跨技术栈集成、测试与分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4.&lt;a href="https://www.ruanyifeng.com/blog/2022/08/dns-query.html"&gt;DNS 查询原理详解&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使用 dig 命令手把手带你跑通整个 DNS 查询过程。&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://github.com/hackergrrl/art-of-readme/blob/master/README-zh.md"&gt;README 的艺术&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;README 的正式命名日期可以追溯到至少 1970 年和 &lt;a href="http://pdp-10.trailing-edge.com/decuslib10-04/01/43,50322/read.me.html"&gt;PDP-10&lt;/a&gt;，拥有高质量 README 的项目使用起来也非常舒适和安心，本文讨论了高质量的 README 应该包含哪些内容。&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.chrome.com/en/blog/new-in-chrome-104/"&gt;New in Chrome 104&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.dev/css-individual-transform-properties/"&gt;CSS transform 属性支持合并&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://code.visualstudio.com/updates/v1_70"&gt;VS Code July 2022 (version 1.70)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tc39/proposal-record-tuple"&gt;JavaScript Records &amp;amp; Tuples Proposal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.stackblitz.com/posts/introducing-collections-and-social-previews/"&gt;StackBlitz 支持收藏和社交预览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.chrome.com/en/blog/has-with-cq-m105/"&gt;@container and :has(): two powerful new responsive APIs landing in Chromium 105&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/README-CN.md"&gt;区块链 Dapp 开发教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://mp.weixin.qq.com/s/8xGS2n59S1WQ1d2yfB3OyQ"&gt;语雀 App 跨端技术架构实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://zhuanlan.zhihu.com/p/527437146"&gt;面向微前端，谈谈 JavaScript 隔离沙箱机制的古往今来&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Tue, 09 Aug 2022 08:14:55 GMT</pubDate></item><item><title>前端食堂技术周刊第 46 期：Chrome 三方 cookie 计划、npm 引入更多安全增强功能、Awesome Bun</title><link>https://juejin.cn/post/7126921039098937357</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy
highlight: github-gist&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美味值：🌟🌟🌟🌟🌟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;口味：过油肉拌面&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Geekhyt/weekly"&gt;食堂技术周刊仓库地址：https://github.com/Geekhyt/weekly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PC 端在仓库里看体验更好，顺手赏个 Star 是对食堂最大的支持。&lt;/p&gt;
&lt;h1&gt;本期摘要&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Expanding Privacy Sandbox testing&lt;/li&gt;
&lt;li&gt;为 npm 引入更多安全增强功能&lt;/li&gt;
&lt;li&gt;Lotion&lt;/li&gt;
&lt;li&gt;Awesome Bun&lt;/li&gt;
&lt;li&gt;像小说一样品读 Linux 0.11 核心代码&lt;/li&gt;
&lt;li&gt;HypeScript&lt;/li&gt;
&lt;li&gt;Roll your own JavaScript runtime&lt;/li&gt;
&lt;li&gt;跟着我，从 0 实现 React18&lt;/li&gt;
&lt;li&gt;构建自己的 Web 框架&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家好，我是童欧巴。欢迎来到本期的前端食堂技术周刊，我们先来看下上周的技术资讯。&lt;/p&gt;
&lt;h1&gt;技术资讯&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://developer.chrome.com/en/blog/expanding-privacy-sandbox-testing/"&gt;Expanding Privacy Sandbox testing&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Chrome 团队近期分享了他们的隐私保护计划和时间表，以及逐步淘汰第三方 cookie 的路径。预计在 2023 年开始交付 API 以实现普遍的可用性，于 2024 年下半年开始逐步淘汰 Chrome 中的第三方 cookie，博文主要包括如下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新 cookie 行为、独立分区存储(CHIPS)。 First-Party Sets 第一方集(允许由同一实体拥有和运营的相关域名声明属于同一个第一方)&lt;/li&gt;
&lt;li&gt;削弱 User-Agent，减少 UA 中可用于被动指纹识别的信息&lt;/li&gt;
&lt;li&gt;Storage 分区，包含 IndexedDB、localStorage、communication API(BroadcastChannel、SharedWorker)、ServiceWorker&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://github.blog/2022-07-26-introducing-even-more-security-enhancements-to-npm/"&gt;为 npm 引入更多安全增强功能&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;近期 npm 推出了一些新的安全增强功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 npm CLI 简化登录和发布体验&lt;/li&gt;
&lt;li&gt;将 GitHub 和 Twitter 帐户连接到 npm 的能力&lt;/li&gt;
&lt;li&gt;npm 上的所有包都已重新签名，添加一个新的 npm CLI 命令来审核包的完整性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看技术资料。&lt;/p&gt;
&lt;h1&gt;技术资料&lt;/h1&gt;
&lt;h2&gt;1.&lt;a href="https://github.com/Dashibase/lotion"&gt;Lotion：使用 Vue 3 构建的开源 Notion UI&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bdc8fa439a94edba680dea906c69783~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;目前支持的 Features：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于块的编辑器&lt;/li&gt;
&lt;li&gt;拖拽重新排列区块&lt;/li&gt;
&lt;li&gt;基本的 Markdown 解析，包括粗体、斜体、标题和分隔符&lt;/li&gt;
&lt;li&gt;输入'/'以获得命令菜单和快捷方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;技术栈：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拖放组件 vue-draggable-next&lt;/li&gt;
&lt;li&gt;编辑器 tiptap 和 ProseMirror&lt;/li&gt;
&lt;li&gt;图标 oh-vue-icons&lt;/li&gt;
&lt;li&gt;Vue3 + Vite3 + TailwindCSS + TypeScript&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.&lt;a href="https://github.com/apvarun/awesome-bun"&gt;Awesome Bun&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;包子的 Awesome 仓库，让包子飞一会儿。&lt;/p&gt;
&lt;h2&gt;3.&lt;a href="https://github.com/sunym1993/flash-linux0.11-talk"&gt;像小说一样品读 Linux 0.11 核心代码&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一个不会写小说的作家不是一个好的程序员。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/818e504335ca482daa903b26b3096834~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;4.&lt;a href="https://github.com/ronami/HypeScript"&gt;用 TS 的类型系统实现一个 TS 类型系统&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;TypeScript 类型系统的简化实现，而且是自己实现自己。&lt;/p&gt;
&lt;p&gt;使用方式如下图所示，将 TypeScript 代码作为字符串传递给 TypeCheck 泛型，会返回可能的类型错误。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/994af62fa62841699fe62f187768385c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;5.&lt;a href="https://deno.com/blog/roll-your-own-javascript-runtime"&gt;Roll your own JavaScript runtime&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Deno 官方发布，跟着这篇文章，你可以创建一个自定义的 JavaScript 运行时(简化的 Deno)。并实现执行本地 JS 文件、读写文件、删除文件以及简化的 console API 等功能。相比 Node.js 的定制开发，Deno 的定制门槛很低了。&lt;/p&gt;
&lt;p&gt;主要用到了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;deno_core：抽象出了与 V8 JavaScript 引擎的交互&lt;/li&gt;
&lt;li&gt;tokio：异步 Rust 运行时，用作事件循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;6.&lt;a href="https://github.com/BetaSu/big-react"&gt;跟着我，从 0 实现 React18&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;实现一个 mini-xxx 已经不够卷了，卡颂宝贝的 Big-React 才够卷。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;极简实现的同时保证功能完备，标准是跑通官方测试用例。&lt;/li&gt;
&lt;li&gt;同时贴心的按 Git Tag 划分迭代步骤，记录从 0 实现的每个功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前已经实现了 7 个版本，值得喜欢研究 React 源码的同学追更。&lt;/p&gt;
&lt;h2&gt;7.&lt;a href="https://vercel.com/blog/build-your-own-web-framework"&gt;构建自己的 Web 框架&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这篇文章解释了如何构建基于 React 的简易 Web 框架，并使用 Vercel 的 Build Output API 进行部署。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://vercel.com/docs/build-output-api/v3"&gt;Build Output API&lt;/a&gt; 是一个基于文件系统的规范，用于生成 Vercel 部署的目录结构。框架作者可以将此目录结构实现为他们构建命令的输出，以便框架可以利用所有 Vercel 的平台功能(Serverless Functions，Edge Functions，路由，缓存等)，&lt;a href="https://github.com/withastro/astro/tree/main/packages/integrations/vercel"&gt;Astro&lt;/a&gt;已经成功与 Vercel 集成。&lt;/p&gt;
&lt;h1&gt;其他信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/nrwl/nx/releases/tag/14.5.0"&gt;Nx v14.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blueboat.io/"&gt;Blueboat：All-in-one serverless JavaScript runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pmndrs/zustand/releases/tag/v4.0.0"&gt;Zustand v4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vueuse/vueuse/releases/tag/v9.0.0"&gt;VueUse v9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/evanw/esbuild/releases/tag/v0.14.51"&gt;esbuild v0.14.51&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nodejs.org/en/blog/release/v18.7.0/"&gt;Node v18.7.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.risingstack.com/redwoodjs-vs-blitzjs-comparison/"&gt;RedwoodJS vs. BlitzJS：全栈元框架的未来&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;好文推荐&lt;/h1&gt;
&lt;p&gt;下面来看一下好文推荐，本周推荐的好文是：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://mp.weixin.qq.com/s/ORqdfZZ8qFyJdYTRwEULgQ"&gt;ToB 前端构建效率优化之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;冷启动时间从 4min 到 2s。&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://mp.weixin.qq.com/s/-NQBuAo0ykStwG9zInPpxg"&gt;来自 NPM 联合创始人的预言：前端未来会这样&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;太阳底下无新鲜事，我们都在循环里。&lt;/p&gt;
&lt;p&gt;好了，以上就是本期的食堂周刊，观众老爷们如果觉得还不错，一键三连是对食堂老板最大的支持。&lt;/p&gt;
&lt;p&gt;你的前端食堂，吃好每一顿饭，我们下期见。&lt;/p&gt;
&lt;h2&gt;❤️爱心三连击&lt;/h2&gt;
&lt;p&gt;1.如果你觉得食堂酒菜还合胃口，就点个赞支持下吧，你的&lt;strong&gt;赞&lt;/strong&gt;是我最大的动力。&lt;/p&gt;
&lt;p&gt;2.关注&lt;a href="https://github.com/Geekhyt/front-end-canteen/blob/master/images/new-qrcode.jpg"&gt;公众号前端食堂&lt;/a&gt;，&lt;strong&gt;吃好每一顿饭！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.点赞、评论、转发 === 催更！&lt;/p&gt;
&lt;p&gt;&lt;img alt="透明footer.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c1796074d64d1aa9c78087f4463969~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;</description><author>童欧巴</author><pubDate>Mon, 01 Aug 2022 06:54:26 GMT</pubDate></item><item><title>「程序人生」在腾讯工作是怎么样的体验</title><link>https://juejin.cn/post/6976896524198346760</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: condensed-night-purple&lt;/h2&gt;
&lt;h2&gt;在腾讯工作是怎么样的体验&lt;/h2&gt;
&lt;p&gt;大家好，我是&lt;strong&gt;TianTian&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最近有读者私信我说，腾讯工作体验如何，有幸是一名腾讯人，借此回答一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首发文章，&lt;a href="https://mp.weixin.qq.com/s/ouZcSyZfIMMyGnG8A7yGRA"&gt;点这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;我是21届毕业的，4月拿到腾讯offer，提前来实习了。对我之前的经历感兴趣的话，推荐大家阅读这篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6945625394154307592"&gt;&amp;lt;阿里腾讯面试梳理&amp;amp;个人成长经历分享&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过也有人问我，&lt;strong&gt;怎么进的腾讯？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嗯，我只能说&lt;strong&gt;更多是运气，现在的我，肯定进不了腾讯了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;20年下半年还在&lt;strong&gt;网易实习&lt;/strong&gt;，那个时候盯着巨大的压力。你可以想象很多同龄人都斩获满意offer，而我刚刚入门。&lt;/p&gt;
&lt;p&gt;在网易的半年，下班会去补知识，周末去公司静下心来做总结，写博客。好在一直危机感蛮强的，特别是在网易这样的大环境中。 我蛮感激那会的自己，因为热爱，努力希望进更好的公司。&lt;/p&gt;
&lt;p&gt;努力的意义何在，共勉：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;拼着一切代价，奔你的前程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;从哪里说起&lt;/h2&gt;
&lt;p&gt;前段时间腾讯上了一波微博热搜，相信大家都看到了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="热搜" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/190c7df6effe46d6805a8575dc8f2092~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那我们从加班开始说起吧，正好也是大家关心的点。&lt;/p&gt;
&lt;p&gt;从网上流出的加班管理机制表上看，&lt;strong&gt;“双休”确实是双休，但“不加班”却不是通常理解的不加班。只有周三是6点下班，其他工作日则是最晚9点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很多人存在质疑，其他部门我不敢保证，但是在我们组，&lt;strong&gt;已经落实了！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每周双休，一日六点。&lt;/p&gt;
&lt;p&gt;其实很爽了，很多外人觉得不已为然，那我们来看看其他大厂加班情况。&lt;/p&gt;
&lt;p&gt;还是拿数据来说话吧，去年的这统计数据，腾讯连前十都进不去。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SpringBoot+Prometheus+Grafana实现应用监控和报警&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="互联网加班排名-1" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0fc96fe62a348d0ba374977f01b4fbb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;再看看另外的一份互联网大厂的加班排名：&lt;/p&gt;
&lt;p&gt;&lt;img alt="互联网加班排名-2" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47c216e0ba5a4a8abd9e984c3a8f8030~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;也许有人说，这个事情不值得称赞，他们做了本应该的事情。不可否认从某种意义上来说，确实是这样子。但是在当下的互联网趋势下，其实真的不多，毕竟对比其他大厂后，大家都明白xxxxx&lt;/p&gt;
&lt;p&gt;&lt;img alt="你懂吧" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d823a287c5b465680dc1dd71e20da90~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;说到这里，提一句，可以来我们组看看机会，投了简历，我会随时跟进&lt;strong&gt;面试反馈&lt;/strong&gt;以及后续结果的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于团队：&lt;a href="http://www.alloyteam.com/"&gt;AlloyTeam 腾讯文档前端团队&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;一天是如何度过的&lt;/h2&gt;
&lt;p&gt;最近开始养成一个习惯，做好每天规划，类似于：&lt;/p&gt;
&lt;p&gt;&lt;img alt="每日ToDo" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a88af111230a4bd1a6d81970d7ba3536~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;会按照每日清单，做好时间上的规划，尽可能执行，晚上做好复盘。可能这是提高效率的一种途径吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;上午&lt;/h3&gt;
&lt;p&gt;基本上8点起床，有时候睡个懒觉，出门的时间会在9点左右。&lt;/p&gt;
&lt;p&gt;去公司的路上，基本上需要50分钟，一般会&lt;strong&gt;听课&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="最近听得课" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b406b0608e7e4d278c2ee0b2badad53e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;一般我会听类似于这样子课程，&lt;strong&gt;理论知识多一些&lt;/strong&gt;。要是状态不好的话，会选择听歌，看会儿知乎。&lt;/p&gt;
&lt;p&gt;基本上深圳9点以后的一号线，应该人很多的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="赶地铁的同志" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81d37bf0f2f048dfbb216ee06803b0b3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="9.jpeg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77fbd39475e042a2a76b456273dd681d~tplv-k3u1fbpfcp-watermark.image" /&gt;
偷拍无礼，还望原谅。&lt;/p&gt;
&lt;p&gt;可能今天下雨的缘故，人不多。公司早些时候发了邮件，可以居家办公（&lt;strong&gt;挺人性化&lt;/strong&gt;），估计大家都在家工作吧。&lt;/p&gt;
&lt;p&gt;到公司第一件事情，&lt;strong&gt;干饭&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;腾讯的食堂很不错，好吃又便宜。早餐是免费自助，很多种类什么都有，热干面，虎皮鸡爪，肠粉，等等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="早餐" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/029440db85ef4a6e9a2120b2ec7990a7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;吃完早餐，到工位的话，基本上都10：30。&lt;/p&gt;
&lt;p&gt;打开电脑，开始计划今天的任务。&lt;/p&gt;
&lt;p&gt;&lt;img alt="工位" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5b76c1a8f6f4babbd4c460d61c49748~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;当时没有申请iMac，期待正式入职的&lt;strong&gt;iMac办公&lt;/strong&gt;。不过我感觉现在办公设备还不错，要是能再有一个4k显示屏，那体验更加棒。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;中午&lt;/h3&gt;
&lt;p&gt;上午的任务完成后，接下来就是午饭时间啦～&lt;/p&gt;
&lt;p&gt;一般选择在公司食堂吃，偶尔跟同事出去吃顿好的。个人感觉，口味还是挺多的，暂时还没有忌口的，都还吃的习惯，就放张留在相册里面的照片吧：&lt;/p&gt;
&lt;p&gt;&lt;img alt="牛肉蛋包饭" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76508f3ed4054a0c920d677dece8fe06~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;吃完饭后，偶尔散下步，回到工位基本上12:50，这个时候会&lt;strong&gt;写写文章&lt;/strong&gt;，看看公众号文章，准备明天的推文。&lt;/p&gt;
&lt;p&gt;不过计划也会变，有时候会跟&lt;strong&gt;同事开黑&lt;/strong&gt;，打两把游戏，当午休的一个环节。&lt;/p&gt;
&lt;p&gt;打完后，接下来会午休，有行军床，睡起来很爽，比趴着桌子上舒服很多。&lt;/p&gt;
&lt;p&gt;一般我们组午休的时间，都会在14:10左右结束。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;下午&lt;/h3&gt;
&lt;p&gt;主要工作就是跟进技术需求，把今天任务完成。有些时候会被会议突然打断。&lt;/p&gt;
&lt;p&gt;下午个人觉得效率是很高的时间段，基本上会充分利用好，尽量不被打扰。&lt;/p&gt;
&lt;p&gt;当然啦，与同事讨论问题，是一个互相学习一起进步的过程。&lt;/p&gt;
&lt;p&gt;&lt;img alt="debug" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbc1bc2ead5a45bab5efc5c39217a0a1~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;旁边来了位实习生，是个女孩子，挺厉害的。&lt;/p&gt;
&lt;p&gt;有时候，会一起讨论下遇到的bug，讨论下一些技术问题，还是挺愉快的，可以互相交流学习下。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;晚上&lt;/h3&gt;
&lt;p&gt;晚上有夜宵卷，基本上吃饭不花钱或者你也可以拿着夜宵卷去麦当劳。&lt;/p&gt;
&lt;p&gt;吃完饭，会出去散步，绕公司走一圈。不同人可能选择是不一样的，有些人会选择去健身。&lt;/p&gt;
&lt;p&gt;腾讯还是会提供健身的地方的，滨海大厦就有不错的场所。不过我基本上还没有健身的习惯：&lt;/p&gt;
&lt;p&gt;&lt;img alt="滨海大厦健身房" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5fec26224cc4d20a38dec06572975ae~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;有些人，会选择去打球。比如我们提供对应的&lt;strong&gt;打球场地&lt;/strong&gt;。（虽然我还没有去过）&lt;/p&gt;
&lt;p&gt;我基本上回工位，继续把今日任务完成。&lt;/p&gt;
&lt;p&gt;晚上10点后打滴滴回家公司报销，体验过几次10点回去，基本上整层楼，数得过来为数不多的人，主要我不是卷，我是想在公司搞完任务，回去可以写自己的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不是卷！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深圳的夜晚怎么样？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候，觉得很璀璨，有时间觉得到一丝丝的艰难。&lt;/p&gt;
&lt;p&gt;&lt;img alt="滨海大厦" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e0b3a8777e4d429ec96314b48d56d6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;一切取决于你，是否选择&lt;strong&gt;躺平划水&lt;/strong&gt;，还是奋勇前进。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;感受&lt;/h2&gt;
&lt;p&gt;平淡的描述我大致一天的做的事情，可能你会觉得真的忙，无聊。&lt;/p&gt;
&lt;p&gt;其实我想说，不是这样子的，腾讯的福利也很多，有很多游戏福利，包括XXXXX，很爽。&lt;/p&gt;
&lt;p&gt;小组里或者整个团队还会不定时组织团建，而且大多都是工作日去团建哈哈哈。&lt;/p&gt;
&lt;p&gt;上次整个大组一起去团建滑雪了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="朋友拍的" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/399cac86dc5c459f869e36ce65354bd5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;不仅玩的好，吃得好，住的也是挺不错的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="朋友拍的" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01b81e59827f4a23aaa8a0f9a9c80098~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;是啊，我们的生活并不只有&lt;strong&gt;coding&lt;/strong&gt;。这么有意思的一个团队，不值得你加入吗！！！&lt;/p&gt;
&lt;p&gt;静下心来思考，在腾讯上班，可以用几个点来表达：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、太拼命了，自己要多主动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是我的第一印象，大家都很努力。&lt;/p&gt;
&lt;p&gt;第一天入职，想着稍微表现下，等大家一起，后来发现有些同事会很晚走。&lt;/p&gt;
&lt;p&gt;为了和大家步伐一致，需要自己多主动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、自豪感。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这点是有切身体会的，跟亲戚朋友说你在腾讯工作，还挺有面的。他们第一反应，可能是“哇，腾讯啊，大公司”。&lt;/p&gt;
&lt;p&gt;前女友知道我去腾讯了，后续也找过我好几次。&lt;/p&gt;
&lt;p&gt;隔三差五的小福利让你在朋友圈&lt;strong&gt;赚足虚荣心&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、福利待遇好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这点对比国内互联网大厂来说，综合性价比来说，还是挺好的。无息贷款90W，各种其他的福利，这里保密了。&lt;/p&gt;
&lt;p&gt;如果你部门是很得力的，比如游戏部门。年终奖还真的很可观，10个月以上的还是有的。&lt;/p&gt;
&lt;p&gt;再加上可以搞点期权的话，挺有有盼头的，毕竟这些年腾讯股票已经涨了若干若干倍了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、身边人越来越优秀。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;竞争还是蛮激烈的，不管是校招生，还是社招，进来的牛人大把，都是高智商，竞争和比拼的压力还是蛮大的。&lt;/p&gt;
&lt;p&gt;同事们的做事能力，抗压能力，管理能力以及与人沟通能力，都是让我挺欣赏的。&lt;/p&gt;
&lt;p&gt;学习氛围好，组内技术沉淀氛围好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;让我深刻体会到了，越是优秀的人，越努力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、环境越来越好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;办公环境越来越好，听说每年会有各种&lt;strong&gt;兴趣协会&lt;/strong&gt;、&lt;strong&gt;运动培训班&lt;/strong&gt;、&lt;strong&gt;嘉年华活动&lt;/strong&gt;，走到哪里都有的班车，各种便利的OA等等。&lt;/p&gt;
&lt;p&gt;腾讯的HR、行政一直以“&lt;strong&gt;用户体验&lt;/strong&gt;”作为目标提升工作。&lt;/p&gt;
&lt;p&gt;腾讯的食堂很不错，好吃又便宜。这些都让我觉得，外界条件在往越来越好的地方发展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、上下级，同事之间都很平等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里没有很强烈的上下级概念，都是喊昵称或者xxx哥。&lt;/p&gt;
&lt;p&gt;交流问题的时候，给我感觉，大家都是平等的，一视同仁。&lt;/p&gt;
&lt;p&gt;对于我这个新人来说，初期让我负责一个项目，大家会相信我，放心让我去做。&lt;/p&gt;
&lt;p&gt;这点我觉得挺舒服的！！！&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果你是应届生，&lt;strong&gt;腾讯是值得来的&lt;/strong&gt;。优秀的同事以及完善的新人培养机制会在职业生涯的初期让你&lt;strong&gt;更快成长&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总之，不去诋毁腾讯，也不是希望你盲目乐观的看待腾讯的工作，里面有快乐也有不快乐，&lt;strong&gt;兼听则明&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于团队：&lt;a href="http://www.alloyteam.com/"&gt;AlloyTeam 腾讯文档前端团队&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果喜欢，双击点赞~~&lt;/strong&gt;&lt;/p&gt;</description><author>TianTianUp</author><pubDate>Wed, 23 Jun 2021 00:02:50 GMT</pubDate></item><item><title>「前端性能」避免回流和重绘的必要性</title><link>https://juejin.cn/post/6953029989306466317</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: condensed-night-purple&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本文会介绍浏览器中帧（Frame）的概念，它的流程是怎么样的。&lt;/p&gt;
&lt;p&gt;至于写这个文章的出发点在于，我好奇浏览器中像素工作流程是怎么样的，什么时候开始的，最后的结果是什么。&lt;/p&gt;
&lt;p&gt;基于这些好奇，查阅了些外文资料，本文提供了些参考，参考链接在文末。&lt;/p&gt;
&lt;p&gt;最近搞了性能优化思维导图，还在持续输出中，&lt;a href="https://docs.qq.com/mind/DWnljWm52eEVjWWNE"&gt;点击这里&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;缘由&lt;/h2&gt;
&lt;p&gt;在讲帧的概念前，我们得从背景开始看起，也就是渲染页面的这个过程，有哪些关键性的路径呢。&lt;/p&gt;
&lt;h3&gt;五大关键渲染路径&lt;/h3&gt;
&lt;p&gt;像素输出到页面，肯定经历了很多的过程，那我们作为前端工程师，工作中需要注意的点是哪些呢，这里给出参考:&lt;/p&gt;
&lt;p&gt;&lt;img alt="渲染关键路径" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b04e38ce457a4940af9446daf6fcb6fd~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这五个主要的部分，应该是我们值得去关注的，因为我们拥有最大控制权的部分。至于每一个过程具体是怎么样的呢，不清楚的可以参考下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="详细的工作" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e25e5314ce947e8859820a36680f59c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;所以在这么一个像素的管道里，每部分都有可能造成卡顿，所以我们需要额外的关注这些，毕竟那一部分不当，都会开了不必要的性能开销。&lt;/p&gt;
&lt;h3&gt;三种输出方式&lt;/h3&gt;
&lt;p&gt;当时我的疑问是: 难道每一帧都总是会经过管道每个部分的处理嘛，其实不是这样子的，从视觉的角度来说，管道针对指定帧的运行通常有三种方式:&lt;/p&gt;
&lt;p&gt;&lt;img alt="指定帧的运行通常有三种方式" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03fd70517789475c9d2e4ed50af7736c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果我们以第三种方式来更新视图，也就是更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。&lt;/p&gt;
&lt;h3&gt;跑个demo&lt;/h3&gt;
&lt;p&gt;为了更加具体的验证上述的过程，可以动手跑一个demo，来验证一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;demo地址:https://googlechrome.github.io/devtools-samples/jank/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="主线程-火焰图" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53d192456b80423cb765fad3b12c2df0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们添加多个dom元素进行动画，效果更佳明显，接着我们打开Performance，Record这个过程，我们需要关注的是Main选项卡，也就是主线程，我们在放大里面的Task，就有了下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="主线程-火焰图-2" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5862ea6557704d998ef91f358b3e845d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;经历的过程，也是很清楚看到，Update Layer Tree --&amp;gt;&amp;gt; Layout --&amp;gt;&amp;gt; Paint --&amp;gt;&amp;gt; Composite Layers。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你不是很清楚Performance中名称的含义,可以参考下面这篇文章，&lt;a href="https://mp.weixin.qq.com/s/iodsGPWgYc97yWLb09Xk6A"&gt;点这里&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;https://mp.weixin.qq.com/s/iodsGPWgYc97yWLb09Xk6A&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着，我们按下，Optimize按钮，按照之前的流程走，Record后，发现不对劲，还是这样子步骤，难道是哪里存在问题嘛，好奇的我，打开了Sources面板，然后就发现了:&lt;/p&gt;
&lt;p&gt;&lt;img alt="优化后的动画" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acc257718a5f4c109dc783f6408a3165~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;它的源码优化动画，使用的是rAF,了解过的人一定不会陌生，你可以简单的理解就是:按帧对网页进行重绘。这里就引出了帧的概念，后续会说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rAF的详细介绍，后续会对它进行梳理，可以持续关注。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;如何避免回流与重绘&lt;/h3&gt;
&lt;p&gt;回到前面我们设想的点，我们如何才能保证直接跳到合成过程，避免Layout以及Paint呢，当然有，我们需要对app.js中的uppdate函数进行改造，使用&lt;strong&gt;transform: translateX(0px);&lt;/strong&gt;  做动画，做完update函数的处理逻辑后，我们再次Record一下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="优化后的动画" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73cb710cdf1347a3b4ea52be86664535~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从Task子任务中，我们可以发现，&lt;strong&gt;Layout --&amp;gt;&amp;gt; Paint&lt;/strong&gt;, 布局和绘制的过程跳过了。这也是为什么我们常说的需要避免回流与重绘。从主线程上来看，能够完全的避免这些过程，避免了很多的运算开销。&lt;/p&gt;
&lt;p&gt;这也是为什么经常可以看到这样子的建议:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;坚持使用 transform 和 opacity 属性更改来实现动画。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;will-change&lt;/code&gt; 或 &lt;code&gt;translateZ&lt;/code&gt; 提升移动的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至于使用will-change和translatez来提升图层，这又是另外知识点了，这里就不张开了。&lt;/p&gt;
&lt;p&gt;介绍到这里，我们已经清楚的明白，避免回流和重绘的意义，那么我们提到的&lt;strong&gt;帧&lt;/strong&gt;和&lt;strong&gt;rAF&lt;/strong&gt; 与 渲染路径有啥关系呢。&lt;/p&gt;
&lt;h2&gt;帧&lt;/h2&gt;
&lt;p&gt;我做的第一件事情就是google，然后维基百科给出如下定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在&lt;a href="https://zh.wikipedia.org/wiki/%E8%A7%86%E9%A2%91"&gt;视频&lt;/a&gt;领域，&lt;a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%BD%B1"&gt;电影&lt;/a&gt;、&lt;a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%A7%86"&gt;电视&lt;/a&gt;、&lt;a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%A7%86%E9%A2%91"&gt;数字视频&lt;/a&gt;等可视为随时间连续变换的许多张画面，其中&lt;strong&gt;帧&lt;/strong&gt;是指每一张画面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，不是很好理解，知道我找到了这张图，才解答了我的困惑:&lt;/p&gt;
&lt;p&gt;&lt;img alt="anatomy-of-a-frame.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5780421fc5144028e6b260b36ccb709~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这就真的是&lt;strong&gt;一图胜千言&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个图，你可以理解成就是像素放到屏幕的完整过程。你肯定对里面的一些关键信息很迷惑，这里作出一些解释。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接下来大部分内容都是翻译的，没有更多的总结，感兴趣可以看看原文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;PROCESSES(进程)&lt;/h3&gt;
&lt;p&gt;映入眼帘的就是进程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Renderer Process&lt;/strong&gt;: 渲染进程。
&lt;ul&gt;
&lt;li&gt;一个标签的周围容器。&lt;/li&gt;
&lt;li&gt;它包含了多个线程，这些线程共同负责让你的页面出现在屏幕上的各个环节。&lt;/li&gt;
&lt;li&gt;这些线程是&lt;strong&gt;合成线程&lt;/strong&gt;（Compositor）、&lt;strong&gt;图块栅格化线程&lt;/strong&gt;（Tile Worker）和主线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPU Process&lt;/strong&gt;:  GPU进程。
&lt;ul&gt;
&lt;li&gt;这是服务于所有标签和周围浏览器进程的单一进程。&lt;/li&gt;
&lt;li&gt;当帧被提交时，GPU进程将上传任何磁贴和其他数据（如四维顶点和矩阵）到GPU，以便实际将像素推送到屏幕上。&lt;/li&gt;
&lt;li&gt;GPU进程包含一个单一的线程，称为GPU线程，实际完成工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;RENDERER PROCESS THREADS（渲染进程中的线程）&lt;/h3&gt;
&lt;p&gt;现在我们来看看Renderer Process中的线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Compositor Thread&lt;/strong&gt;(合成线程):
&lt;ul&gt;
&lt;li&gt;这是第一个被告知vsync事件的线程(这是操作系统告诉浏览器制作新帧的方式)。&lt;/li&gt;
&lt;li&gt;它还将接收任何输入事件。&lt;/li&gt;
&lt;li&gt;如果可以的话，合成器线程将避免进入主线程，并将尝试将输入（比如说--滚动甩动）转换为屏幕上的运动。它将通过更新图层位置并通过GPU线程直接将帧提交给GPU来实现。&lt;/li&gt;
&lt;li&gt;如果因为输入事件处理程序或其他视觉工作而无法做到这一点，那么就需要使用主线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Main Thread&lt;/strong&gt;(&lt;strong&gt;主线程&lt;/strong&gt;)：
&lt;ul&gt;
&lt;li&gt;这是浏览器执行我们都知道和喜欢的任务的地方。JavaScript、样式、布局和绘画。(在未来的&lt;a href="https://surma.link/things/houdini-intro/"&gt;Houdini&lt;/a&gt;中，这种情况会有所改变，我们将能够在Compositor线程中运行一些代码。)&lt;/li&gt;
&lt;li&gt;这个线程赢得了 "最有可能导致jank "的奖项，主要是因为这里有很多东西在运行。(jank值得是&lt;strong&gt;页面抖动&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Compositor Tile Worker(s) (&lt;strong&gt;合成图块栅格化线程&lt;/strong&gt;):
&lt;ul&gt;
&lt;li&gt;由合成线程派生的一个或多个线程，用于处理栅格化任务。我们稍后再讨论。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在很多方面，你应该把Compositor线程视为 "大老板"。虽然它不运行JavaScript、Layout、Paint或其他任何东西，但它是完全负责启动主线程工作的线程，然后将帧运送到屏幕上。如果它不需要等待输入事件处理程序，它就可以在等待主线程完成工作的同时运送帧。&lt;/p&gt;
&lt;p&gt;你也可以想象Service Workers和Web Workers生活在这个过程中，不过我没有把他们包括在内，因为这让事情变得更加复杂。&lt;/p&gt;
&lt;h3&gt;THE FLOW OF THINGS(主线程流程)&lt;/h3&gt;
&lt;p&gt;让我们成主线程开始吧。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a7ef1a216604eb282954c9673a1e5e9~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;让我们一步步走过这个流程，从vsync到像素，并谈谈在事件的 "全胖 "版本中事情是如何进行的。值得记住的是，浏览器不需要执行所有这些步骤，这取决于什么是必要的。例如，如果没有新的HTML要解析，那么解析HTML就不会启动。事实上，很多时候，提高性能的最好方法就是简单地消除部分流程被启动的必要性!&lt;/p&gt;
&lt;p&gt;同样值得注意的是，样式和布局下的红色箭头似乎指向了 &lt;strong&gt;requestAnimationFrame&lt;/strong&gt;。在你的代码中完全有可能意外地触发这两者。这就是所谓的强制同步布局（或样式，视情况而定），它通常对性能不利。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Frame Start&lt;/strong&gt;（&lt;strong&gt;开始新的一帧&lt;/strong&gt;）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;垂直同步信号触发，开始渲染新的一帧图像。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Input event handlers&lt;/strong&gt; （&lt;strong&gt;输入事件的处理&lt;/strong&gt;）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-输入数据从合成器线程传递给主线程上的任何输入事件处理程序。&lt;/li&gt;
&lt;li&gt;所有的输入事件处理程序（触摸移动、滚动、点击）都应该首先启动，每帧一次，但情况不一定如此。&lt;/li&gt;
&lt;li&gt;调度器会做出最大努力的尝试，其成功率在不同的操作系统中有所不同。在用户交互和事件进入主线程处理之间也有一些延迟。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是对屏幕进行视觉更新的理想位置，因为你有新鲜的输入数据，而且这是你要得到的最接近vsync的地方。&lt;/li&gt;
&lt;li&gt;其他的视觉任务，比如样式计算，都是在这个任务之后进行的，所以它的理想位置是突变元素。&lt;/li&gt;
&lt;li&gt;如果你突变--比如说--100个类，这不会导致100个样式计算；它们将被分批处理，并在后面处理。唯一需要注意的是，你不要查询任何计算过的样式或布局属性（比如el.style.backgroundImage或el.style.offsetWidth）。&lt;/li&gt;
&lt;li&gt;如果你这样做，你会把重新计算的样式、布局或两者都向前带，导致强制的同步布局，或者更糟糕的是，布局打乱。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Parse HTML&lt;/strong&gt; (&lt;strong&gt;解析 HTML&lt;/strong&gt;):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任何新添加的HTML都会被处理，并创建DOM元素。&lt;/li&gt;
&lt;li&gt;在页面加载过程中或appendChild等操作后，你可能会看到更多的这种情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Recalc Styles&lt;/strong&gt;（&lt;strong&gt;重新计算样式&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;样式是为任何新添加或突变的东西计算的，这可能是整个树，也可能是范围，这取决于改变了什么。&lt;/li&gt;
&lt;li&gt;这可能是整个树，也可能是范围缩小，这取决于改变了什么。&lt;/li&gt;
&lt;li&gt;例如，改变主体上的类可能影响深远，但值得注意的是，浏览器已经非常聪明地自动限制了样式计算的范围。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Layout&lt;/strong&gt;（绘制）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算每个可见元素的几何信息（每个元素的位置和大小）。它通常对整个文档进行计算，通常使计算成本与DOM大小成正比。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Update Layer Tree&lt;/strong&gt;（&lt;strong&gt;更新图层树&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建叠加上下文和深度排序元素的过程。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Paint&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是两部分过程中的第一部分：绘制是记录任何新元素或视觉上有变化的元素的绘制调用（在这里填充一个矩形，在那里写文字）。&lt;/li&gt;
&lt;li&gt;第二部分是光栅化（见下文），在这里执行绘图调用，并填充纹理。这一部分是对绘制调用的记录，通常比光栅化快得多，但这两部分通常统称为 "绘画"。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Composite&lt;/strong&gt;（&lt;strong&gt;合成&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算出图层和瓷砖的信息，并传回给合成器线程来处理。&lt;/li&gt;
&lt;li&gt;这将会考虑到，除其他事项外，像will-change，重叠元素，以及任何硬件加速的canvases。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Raster Scheduled&lt;/strong&gt; （&lt;strong&gt;栅格化规划&lt;/strong&gt;）and &lt;strong&gt;Rasterize&lt;/strong&gt;（&lt;strong&gt;栅格化&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;现在会执行在Paint任务中记录的绘制调用。这是在Compositor Tile Workers中完成的，其数量取决于平台和设备能力。&lt;/li&gt;
&lt;li&gt;例如，在Android上，你通常会发现一个Worker，在桌面上，你有时可以找到四个。栅格化是以图层为单位进行的，每个图层都是由瓷砖组成的。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Frame End（帧结束）:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当各个图层的磁贴都栅格化后，任何新的磁贴都会和输入数据（可能在事件处理程序中被改变）一起提交给GPU线程。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Frame Ships&lt;/strong&gt;（&lt;strong&gt;发送帧&lt;/strong&gt;）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最后，但绝不是最不重要的，磁贴由GPU线程上传至GPU。GPU使用四边形和矩阵（所有常见的GL好东西）将磁贴绘制到屏幕上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大致上，整个的过程就是上述。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;requestIdleCallback&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;要说这个的话，我们得拿&lt;strong&gt;requestAnimationFrame&lt;/strong&gt;来类比，requestAnimationFrame是在重新渲染屏幕&lt;strong&gt;之前&lt;/strong&gt;执行的，上面提到的rAF，当时做的就是优化动画，所以很适合做动画。&lt;/p&gt;
&lt;p&gt;requestIdleCallback你通过主线程里面中的Task去查找的话，会发现它是在渲染屏幕&lt;strong&gt;之后&lt;/strong&gt;执行，通过查阅文章发现，一般会看浏览器是否空闲。&lt;/p&gt;
&lt;p&gt;这里篇幅有限，想要了解这个的话，推荐&lt;a href="https://juejin.cn/post/6844904196345430023"&gt;一篇文章&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://juejin.cn/post/6844904165462769678&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;最近查阅外文文献，发现要学的东西太多了，如果这篇文章有写的不对，或者翻译不佳的地方，欢迎小伙伴指出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文首发地址&lt;a href="https://mp.weixin.qq.com/s/nMp8j2VnwllLzS8PVJnecQ"&gt;点这里&lt;/a&gt;,欢迎大家关注公众号「TianTianUp」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我是TianTian，我们下一期见！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;[1] &lt;strong&gt;w3c-longTasks:&lt;/strong&gt; https://github.com/w3c/longtasks&lt;/p&gt;
&lt;p&gt;[2] &lt;strong&gt;chrome-fps-meter:&lt;/strong&gt; https://developer.chrome.com/docs/devtools/evaluate-performance/reference/#fps-meter&lt;/p&gt;
&lt;p&gt;[3] &lt;strong&gt;devtools-samples:&lt;/strong&gt; https://googlechrome.github.io/devtools-samples/jank/&lt;/p&gt;
&lt;p&gt;[4] &lt;strong&gt;Analyze runtime performance:&lt;/strong&gt; https://developer.chrome.com/docs/devtools/evaluate-performance/&lt;/p&gt;
&lt;p&gt;[5] &lt;strong&gt;Timeline Event Reference:&lt;/strong&gt; https://developer.chrome.com/docs/devtools/evaluate-performance/performance-reference/&lt;/p&gt;
&lt;p&gt;[6] &lt;strong&gt;The Anatomy of a Frame:&lt;/strong&gt; https://aerotwist.com/blog/the-anatomy-of-a-frame/&lt;/p&gt;
&lt;p&gt;[7] &lt;strong&gt;performance-rendering:&lt;/strong&gt; https://developers.google.com/web/fundamentals/performance/rendering&lt;/p&gt;
&lt;p&gt;[8] &lt;strong&gt;维基百科:&lt;/strong&gt; https://zh.wikipedia.org/wiki/&lt;/p&gt;</description><author>TianTianUp</author><pubDate>Mon, 19 Apr 2021 16:33:16 GMT</pubDate></item><item><title>如何使用Lighthouse性能检测工具</title><link>https://juejin.cn/post/6950855971379871757</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: fancy&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近做性能检测工具，很多知识点不清楚，打算查缺补漏，补一补。&lt;/p&gt;
&lt;p&gt;接下来从官方提供的性能检测工具Lighthouse(灯塔)开始我们的学习，简单介绍了下Lighthouse的一些点。&lt;/p&gt;
&lt;p&gt;阅读完本文，你可以了解到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lighthouse 是什么。&lt;/li&gt;
&lt;li&gt;如何快速上手Lighthouse (使用入门)。&lt;/li&gt;
&lt;li&gt;Lighthouse中的一些Metrics指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能相关的总结准备搞个思维导图，可以&lt;a href="https://docs.qq.com/mind/DWnljWm52eEVjWWNE"&gt;点这里&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://docs.qq.com/mind/DWnljWm52eEVjWWNE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Lighthouse 是什么&lt;/h2&gt;
&lt;p&gt;官方对它的解读:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/GoogleChrome/lighthouse"&gt;Lighthouse&lt;/a&gt; 是一个开源的自动化工具，用于改进网络应用的质量。 您可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 您为 Lighthouse 提供一个您要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它是如何工作的呢？&lt;/p&gt;
&lt;p&gt;如果你跟我一样，翻过它的代码，看过它的介绍肯定很懵逼，它的代码依赖性如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse内部模块依赖.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134180f910bf46019ceb8e71e57c1c54~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;感兴趣的可以看看它的仓库，参考链接已经给出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://github.com/GoogleChrome/lighthouse&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;使用入门&lt;/h2&gt;
&lt;p&gt;运行 Lighthouse 的方式有两种: 作为 Chrome 扩展程序运行，或作为命令行工具运行。 Chrome 扩展程序提供了一个对用户更友好的界面，方便读取报告。 命令行工具允许您将 Lighthouse 集成到持续集成系统。&lt;/p&gt;
&lt;h3&gt;Chrome 扩展程序&lt;/h3&gt;
&lt;p&gt;下载 Google Chrome 52 或更高版本。&lt;/p&gt;
&lt;p&gt;安装 &lt;a href="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk"&gt;Lighthouse Chrome 扩展程序&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;地址:https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;点击 &lt;strong&gt;Generate report&lt;/strong&gt; 按钮以针对当前打开的页面运行 Lighthouse 测试。&lt;/p&gt;
&lt;h3&gt;命令行工具&lt;/h3&gt;
&lt;p&gt;Node CLI在配置和报告Lighthouse运行情况方面提供了最大的灵活性。如果用户需要更多的高级功能，或者想自动运行Lighthouse，可以使用Node CLI。安装 Lighthouse 作为一个全局节点模块。&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm install -g lighthouse
# or use yarn:
# yarn global add lighthouse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;针对一个页面运行 Lighthouse 审查。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;lighthouse https://www.example.com --view
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传递 &lt;code&gt;--help&lt;/code&gt; 标志以查看可用的输入和输出选项。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;lighthouse --help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于一些options不清楚的，可以点击这个链接:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://github.com/GoogleChrome/lighthouse#cli-options&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设我们审查后，就会有这么一个结果:&lt;/p&gt;
&lt;p&gt;&lt;img alt="light-metrics.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb85726649d34805a36742eeeb88d8d8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到一共6个Metrics，Lighthouse 6.0在报告中引入了三个新指标。其中两个新的指标--最大内容画（LCP）和累积布局偏移（CLS）--是Core Web Vitals的实验室实现。&lt;/p&gt;
&lt;p&gt;那么接下来，我们看看这些Metrics指标的含义。&lt;/p&gt;
&lt;h2&gt;几个Metrics指标&lt;/h2&gt;
&lt;h3&gt;First Contentful Paint (FCP)&lt;/h3&gt;
&lt;p&gt;第一次内容丰富的绘画(FCP)指标衡量了从页面开始加载到页面内容的任何部分呈现在屏幕上的时间。对于该指标，"内容 "指的是文本、图像（包括背景图像）、&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;元素或非白色&lt;canvas&gt;元素。&lt;/canvas&gt;&lt;/svg&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse-fcp.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8401aa9ee484d7186f5de6ea3308f57~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在上面的负载时间线中，FCP发生在第二帧中，就像呈现给屏幕的第一文本和图像元素时一样。&lt;/p&gt;
&lt;p&gt;你会注意到，虽然部分内容已经呈现，但并非所有内容都已呈现。这是First Contentful Paint (FCP)和Largest Contentful Paint (LCP)之间的一个重要区别--LCP的目的是衡量页面的主要内容何时完成加载。&lt;/p&gt;
&lt;p&gt;知道了概念，如何衡量FCP呢，我们可以接触的有&lt;strong&gt;Field tools&lt;/strong&gt;和&lt;strong&gt;Lab tools&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要在JavaScript中测量FCP，你可以使用Paint Timing API。下面的例子展示了如何创建一个PerformanceObserver，该PerformanceObserver监听名称为first-contentful-paint的油漆条目，并将其记录到控制台。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;new PerformanceObserver((entryList) =&amp;gt; {
  for (const entry of entryList.getEntriesByName('first-contentful-paint')) {
    console.log('FCP candidate:', entry.startTime, entry);
  }
}).observe({type: 'paint', buffered: true});

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Speed Index&lt;/h3&gt;
&lt;p&gt;速度指数是Lighthouse报告中性能部分跟踪的六个指标之一。每项指标都能反映出页面加载速度的某些方面。&lt;/p&gt;
&lt;p&gt;那么它是如何检测的呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;速度指数衡量的是内容在页面加载过程中的视觉显示速度。Lighthouse首先会在浏览器中捕获一段页面加载的视频，并计算出各帧之间的视觉进度。然后，Lighthouse使用Speedline Node.js模块来生成速度指数得分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于具体的计算，可以参考GitHub里面的代码，这里就不展开了。&lt;/p&gt;
&lt;p&gt;那么我们有机会提升它的性能吗？&lt;/p&gt;
&lt;p&gt;利用Lighthouse报告中的 "&lt;strong&gt;Opportunities&lt;/strong&gt; "部分来确定哪些改进对你的页面最有价值。机会越重要，对性能评分的影响就越大。例如，下面的Lighthouse截图显示，消除渲染阻塞资源将带来最大的改善。&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse-speedindex.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5279e1bb4643f9aec3b9e13f6605bb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;Largest Contentful Paint (LCP)&lt;/h3&gt;
&lt;p&gt;最大内容画（LCP）指标报告了在视口中可见的最大图像或文本块的渲染时间，相对于页面首次开始加载的时间。&lt;/p&gt;
&lt;p&gt;&lt;img alt="light-lcp.svg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fe34160f7344500b6527912c2d5723b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从图上也能看出来，为了提供良好的用户体验，网站应该努力使最大内容画幅达到2.5秒或更少。&lt;/p&gt;
&lt;p&gt;更多信息，请观看Paul Irish对LCP的深度剖析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://www.youtube.com/watch?v=diAc65p15ag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Cumulative Layout Shift (CLS)&lt;/h3&gt;
&lt;p&gt;官方对它的解释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cumulative Layout Shift (CLS)是一种视觉稳定性的测量方法，它量化了页面内容在视觉上的移动程度。它量化了一个页面的内容在视觉上移动的程度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单理解就是:&lt;/p&gt;
&lt;p&gt;CLS测量的是整个页面生命周期内发生的每一次意外布局转变的所有单个布局转变得分的总和。&lt;/p&gt;
&lt;p&gt;布局偏移发生在可见元素从一个渲染帧到下一个渲染帧改变其位置的任何时候。关于如何计算单个布局偏移分数，请参见下文）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://web.dev/cls/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="lighthouse-cls.svg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f428f403b344e69baabcef5434adb18~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从上面的图来看，CLS得分低是给开发者的一个信号，表明他们的用户没有经历不必要的内容移动；CLS得分低于0.10被认为是 "好"。&lt;/p&gt;
&lt;h3&gt;Total Blocking Time (TBT)&lt;/h3&gt;
&lt;p&gt;我们看看官方对它的解读：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总阻塞时间（Total Blocking Time，TBT）量化了负载响应能力，测量了主线程被阻塞的时间长到足以阻止输入响应的总时间。TBT衡量的是第一次有内容的绘画（FCP）和交互时间（TTI）之间的总时间。它是TTI的配套指标，它为量化主线程活动带来了更多的细微差别，这些活动阻碍了用户与您的页面进行交互的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，TBT与核心网络生命力的现场指标First Input Delay（FID）有很好的相关性。&lt;/p&gt;
&lt;p&gt;需要更多的了解，可以参考链接:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://web.dev/tbt/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;最新评分标准&lt;/h3&gt;
&lt;p&gt;Lighthouse中的性能得分是由多个指标加权混合计算出来的，总结出一个页面的速度。6.0的性能得分公式如下。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;Phase&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;Metric Name&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;Metric Weight&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Early (15%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;First Contentful Paint (FCP)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;15%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Mid (40%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Speed Index (SI)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;15%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Largest Contentful Paint (LCP)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;25%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Late (15%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Time To Interactive (TTI)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;15%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Main Thread (25%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Total Blocking Time (TBT)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;25%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Predictability (5%)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Cumulative Layout Shift (CLS)&lt;/td&gt;
&lt;td style="text-align: left;"&gt;5%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;那么你是不是会跟我一样，有疑问，我们不能修改这个权重嘛，当然可以试一试:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://googlechrome.github.io/lighthouse/scorecalc/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;点击上面的链接，会展示这个一个画面:&lt;/p&gt;
&lt;p&gt;&lt;img alt="lighthouse-Scoring-calculator.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5272b1ec14c44293ba2537b660c23e0f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这个网站发布了一个评分计算器，帮助你了解性能评分。同时，该计算器还能为你提供Lighthouse 5版和6版的评分比较。当你使用Lighthouse 6.0版本进行审计时，报告中会有一个链接，链接到计算工具，并将结果填入其中。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;到这里，其实Lighthouse如何使用，以及一些关键的指标也做了说明，你一定会有疑问:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我如何通过计算他们具体的值呢，有对应的JavaScript API？&lt;/li&gt;
&lt;li&gt;既然可以通过Lighthouse来衡量性能并找到加快页面加载的机会，那么我们如何优化呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;想必看到这里，你遇到的疑惑跟之前一样，那么如何解决呢。&lt;/p&gt;
&lt;p&gt;嗯，上面说的部分并没有详细的展开，剩下的部分，尝试去翻一翻官方文档，查一查资料，收获一定很大。&lt;/p&gt;
&lt;p&gt;使用入门，很简单，没有难度，后续会继续梳理，思维导图在&lt;a href="https://docs.qq.com/mind/DWnljWm52eEVjWWNE"&gt;这里&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://docs.qq.com/mind/DWnljWm52eEVjWWNE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我是TianTianUp，我们下一期见！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;[1] &lt;strong&gt;Lighthouse performance scoring&lt;/strong&gt;: https://web.dev/performance-scoring/&lt;/p&gt;
&lt;p&gt;[2] &lt;strong&gt;GoogleChrome-lighthouse&lt;/strong&gt;: https://github.com/GoogleChrome/lighthouse&lt;/p&gt;
&lt;p&gt;[3] &lt;strong&gt;What's New in Lighthouse 6.0&lt;/strong&gt;: https://web.dev/lighthouse-whats-new-6.0/&lt;/p&gt;
&lt;p&gt;[4] &lt;strong&gt;Measure:&lt;/strong&gt; https://web.dev/measure/&lt;/p&gt;
&lt;p&gt;[5] &lt;strong&gt;How does Lighthouse work?&lt;/strong&gt;: https://github.com/GoogleChrome/lighthouse/blob/master/docs/architecture.md&lt;/p&gt;
&lt;p&gt;[6] &lt;strong&gt;Largest Contentful Paint (LCP)&lt;/strong&gt;: https://web.dev/lcp/&lt;/p&gt;
&lt;p&gt;[7] &lt;strong&gt;Total Blocking Time (TBT):&lt;/strong&gt; https://web.dev/tbt/&lt;/p&gt;
&lt;p&gt;[8] &lt;strong&gt;Cumulative Layout Shift (CLS):&lt;/strong&gt; https://web.dev/cls/&lt;/p&gt;
&lt;p&gt;[9] &lt;strong&gt;First Contentful Paint (FCP):&lt;/strong&gt; https://web.dev/fcp/&lt;/p&gt;
&lt;p&gt;[10] &lt;strong&gt;Speed Index:&lt;/strong&gt; https://web.dev/speed-index/&lt;/p&gt;</description><author>TianTianUp</author><pubDate>Tue, 13 Apr 2021 19:51:39 GMT</pubDate></item><item><title>阿里腾讯面试梳理&amp;个人成长经历分享</title><link>https://juejin.cn/post/6945625394154307592</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: condensed-night-purple&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;好久没有更新了，最近忙着面试，写毕业设计和论文。&lt;/p&gt;
&lt;p&gt;不过不想停下记笔记的习惯，所以偷偷的发面经，然后"惊艳"老铁们。&lt;/p&gt;
&lt;p&gt;校招面经，面试难度中等，看官老爷们看个热闹就行。&lt;/p&gt;
&lt;p&gt;历经一个月战线，投了阿里和腾讯，具体部门这里不展开了，都是核心部门，提供的舞台很大，至于最后选择去哪一家公司，可以关注文末。&lt;/p&gt;
&lt;p&gt;接下来复盘一下这一个月来的面试感受吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文不会泄题，只是根据我的简历，来展开谈一谈，可能会被问到的题目。&lt;/p&gt;
&lt;p&gt;最后以下都是个人观点，个人能力有限，&lt;strong&gt;如果有错误，希望能纠正我。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;简单介绍&lt;/h2&gt;
&lt;p&gt;2021届毕业生，掘金里面的TianTianUp，双非本科院校(江西师大)，没有听错，那个彩礼“天价”的省份。&lt;/p&gt;
&lt;p&gt;21届里面，应该算起步比较晚的了。2020年暑假7月份，才开始认认真真“复习”前端，当时连js作用域，闭包，浏览器缓存都不清楚。因为起步晚，所以后续错过了秋招。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在我才深刻意识到，视野的重要性。&lt;/p&gt;
&lt;p&gt;当时大三学了点vue，做了点看起来牛逼的东西，就觉得很牛了，于是春招投了阿里，结果惨不忍睹。&lt;/p&gt;
&lt;p&gt;重点当时没有放心上，还是继续玩，继续打游戏。&lt;/p&gt;
&lt;p&gt;还好之后觉悟过来，才有了后面网易的故事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，也导致后续很多环节跟不上其他同届大佬。&lt;/p&gt;
&lt;p&gt;秋招的时候，jack，三元同学，林不渡，单哥，承和等大佬都是offer收割机，各种腾讯，快手，字节ssp，无不冲击着我这个萌新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;暗自下决心: 我也要去大厂核心部门，去做有意思的事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了规划，接下来就是看技术博客，动手实践，总结梳理，写博客。&lt;/p&gt;
&lt;p&gt;熬了无数的夜，无数个周末在社区徘徊，这个知识点不懂，查文档，看不明白就换一篇文章，争取做到一遍过。&lt;/p&gt;
&lt;p&gt;这么坚持了半年，2021年的春招，结果让我满意，但结果还是有些遗憾的。&lt;/p&gt;
&lt;p&gt;满意的地方: 借面试机会，跟着大佬交流学习了一波。&lt;/p&gt;
&lt;p&gt;遗憾的地方: 其他大厂没有去尝试，没有趁着面试机会去接触其他领域的大佬。我觉得原因可以归咎于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找不到大厂核心部门的内推，希望去核心部门。&lt;/li&gt;
&lt;li&gt;需要笔试，觉得流程很慢，没有人跟进。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以后面提到了面试机会。&lt;/p&gt;
&lt;p&gt;整个春招的过程中，聊一聊心态发生的改变吧，迷茫--紧张--坦然--自信，最后到意向书，到拿到offer。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小tips&lt;/strong&gt;⬇️&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你是在校生，推荐你阅读三元同学博客，干货满满。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;面试机会&lt;/h2&gt;
&lt;p&gt;基本上我是靠内推的，腾讯文档，是一位校招大佬帮忙推的，觉得履历还行，给了个面试机会，才勉强给我通过的。真的是勉强给的机会，因为学校确实跟985比起来，差距很大，还好有网易实习经历buff，加上写了点博客笔记等笔记输出，才有这个面试机会。&lt;/p&gt;
&lt;p&gt;内推，内推，内推，这是最快，最有效的方式，可以第一时间知道面试结果，面评，以及后续的面试流程。&lt;/p&gt;
&lt;p&gt;至于其他的，美团，百度，shopee走的都是官网流程，需要笔试。腾讯这边到四面总监面的时候，我基本上都放弃了。&lt;/p&gt;
&lt;p&gt;最好的方式就是找靠谱的内推吧，比如秋风大佬，字节找ssh（昊神），很靠谱的。&lt;/p&gt;
&lt;p&gt;好的履历也很重要:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学校985，211。&lt;/li&gt;
&lt;li&gt;大厂实习经历，众多offer。&lt;/li&gt;
&lt;li&gt;扎实的基础，读过源码，理解框架设计思想。&lt;/li&gt;
&lt;li&gt;社区有一定影响力，坚持做博客产出。&lt;/li&gt;
&lt;li&gt;开源贡献，开源项目维护者，热爱前端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上，我会把握其中的一两个点，争取做好，才会有后续的面试机会。&lt;/p&gt;
&lt;p&gt;有了面试机会后，剩下的就是如何去做好一场面试的准备工作了。&lt;/p&gt;
&lt;h2&gt;如何准备&lt;/h2&gt;
&lt;p&gt;这个链接里面总结的特别好，我基本上看它复习的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://bitable.feishu.cn/app8Ok6k9qafpMkgyRbfgxeEnet?from=logout&amp;amp;table=tblEnSV2PNAajtWE&amp;amp;view=vewJHSwJVd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过面完，给我感觉，重在平时的积累，基本上都是围绕项目展开的，之前做的项目得好好准备一下，比如项目难点，项目如何做优化的，项目的亮点。&lt;/p&gt;
&lt;p&gt;这里推荐一个链接：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;面试被问项目经验不用慌，按这个步骤回答绝对惊艳&lt;/p&gt;
&lt;p&gt;https://juejin.cn/post/6844904102795706375&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于其他的部分，更多的是向面试官展示自己的优点，闪光点。&lt;/p&gt;
&lt;h2&gt;面经心得&lt;/h2&gt;
&lt;p&gt;基本上都是围绕我的简历来的，有兴趣的话，可以联系我要pdf，可以给你参考下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="简历-技能部分.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e339408f918434e8c76e2c823db257f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简历上技能写的不多，基本上能保证的是我写的都能聊上两句。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从我简历部分来看，主要涉及几个点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React部分，这里面可以问的内容也很多。&lt;/li&gt;
&lt;li&gt;浏览器相关的。&lt;/li&gt;
&lt;li&gt;计算机网络部分。&lt;/li&gt;
&lt;li&gt;算法与数据结构，基本上这算是我的一个杀手锏吧。&lt;/li&gt;
&lt;li&gt;webpack相关的，同时会涉及到babel。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我现在回顾我的面试部分，都是围绕这些点张开的。可能我是应届生校招的原因，很多时候，考察的是我学习能力，理解能力，对前端热爱的程度这些方面。&lt;/p&gt;
&lt;p&gt;基于这几点，展开聊聊我面试过程中会注意的点，以及围绕我写的专业技能，会聊到的一些话题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;自我介绍&lt;/h3&gt;
&lt;p&gt;很重要的一个环节，说不定可以奠定本次面试的节奏，会根据你说的内容，来张开问你，同时也会给&lt;strong&gt;给面试官一个缓冲的时间来重新熟悉你的简历&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;面试自我介绍，要：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遵守极简原则，突出重点，忽略细节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小参考:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我是谁。&lt;/li&gt;
&lt;li&gt;我的亮点，可以描述一下几个点，最近的经历。&lt;/li&gt;
&lt;li&gt;我为什么需要这份工作（其实这个我自我介绍都是忽略的）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;围绕上面的点，我会着重突出，我在大学的经历，主要是算法相关的经历，接着就是我在网易实习期间的收获，以及中间会持续更新博客，写总结。&lt;/p&gt;
&lt;p&gt;基本上，面试官对我的掘金博客，以及大学搞算法的经历感兴趣，进入了自己擅长的领域，就会轻松很多。&lt;/p&gt;
&lt;p&gt;记住一个点，&lt;strong&gt;面试是跟人打交道&lt;/strong&gt;，学会去展示自己，以及及时跟面试官做合理的沟通很重要。&lt;/p&gt;
&lt;p&gt;以上是我会注意的一些点，我也是这么去做的，尽量围绕自己的&lt;strong&gt;亮点&lt;/strong&gt;去展开，当然了，有些面试官有自己的风格，&lt;strong&gt;可能一上来就是问你项目&lt;/strong&gt;，那么我们应该如何把握呢。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;项目相关&lt;/h3&gt;
&lt;p&gt;我觉得项目相关的话题，是个挺难的话题，围绕它展开的话，可以延伸出很多话题，我列举了些有意思的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目难点。（如何发现问题，解决思路，最后结果）&lt;/li&gt;
&lt;li&gt;项目考虑过优化吗，你是如何优化的，思路是什么。&lt;/li&gt;
&lt;li&gt;项目的组织架构，你对它的现有架构的理解，哪些优点值得借鉴，哪些缺点需要改进。&lt;/li&gt;
&lt;li&gt;如果让你从0到1建一个项目，你考虑的点是什么，有哪些流程需要注意的。&lt;/li&gt;
&lt;li&gt;项目中代码规范，你们项目有方案吗，你了解的代码规范有哪些方案。&lt;/li&gt;
&lt;li&gt;说一说项目中你们是如何测试的，有哪些单元测试方案，能不能说一说。&lt;/li&gt;
&lt;li&gt;项目中引入TS的原因，为什么这么做。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过对于&lt;strong&gt;应届生&lt;/strong&gt;来说，问项目都是围绕你简历来问的，比如我当时的项目，我觉得没有好的难点，我就&lt;strong&gt;着重说明&lt;/strong&gt;了下，我对项目是如何优化的，优化了哪些点。&lt;/p&gt;
&lt;p&gt;整个面试下来，都会问，你项目写到的优化的地方，能不能具体聊一聊。&lt;/p&gt;
&lt;p&gt;这个时候，真的要把握机会了，问到你会的点，你得有清晰的思路，可以参考STAR法则。&lt;/p&gt;
&lt;p&gt;重新回顾一下 STAR 法则四要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Situation&lt;/strong&gt;：事情是在什么情况下发生，基于一个怎样的背景；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Task&lt;/strong&gt;：你是如何明确你的任务的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Action&lt;/strong&gt;：针对这样的情况分析，你采用了什么行动方式，具体做了哪些工作内容；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Result&lt;/strong&gt;：结果怎样，带来了什么价值，在整个过程中你学到了什么，有什么新的体会。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有段话，我觉得说的很不错:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;往往大部分同学一上来就直接介绍做了什么以及实现的过程，条理也比较清晰，内容也颇具技术含量。但很多同学很容易忽略了 Situation 和 Result 的部分也就是背景和结果。或者是在面试官进一步了解追问细节的时候容易惊慌失措。这些原因往往都是由于面试前对自己的经历没有将来龙去脉讲清楚以及总结不够全面和深入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上，我对项目这块目前能聊的就是这么多，对了，如果你面&lt;strong&gt;大厂核心部门&lt;/strong&gt;，可能还需要关注的点是，&lt;strong&gt;项目的组织架构理解&lt;/strong&gt;，让你实现一个项目，整个流程需要注意考虑哪些点。&lt;/p&gt;
&lt;p&gt;这块真的可以着重准备一下，以我这次春招经验来谈，是重点。&lt;/p&gt;
&lt;p&gt;聊完项目，接下来就围绕我&lt;strong&gt;简历写到的专业技能&lt;/strong&gt;，依此来梳理一下。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;JS基础&lt;/h3&gt;
&lt;p&gt;考察的是一些基础问题，这里最好过一遍，切记不要丢大分。&lt;/p&gt;
&lt;p&gt;比如我写了对异步编程有理解，所以得看一下，异步编程的解决方案，它的发展过程，每种解决方案的优缺点，得了得，最后我会&lt;strong&gt;拓展一下async方案存在的缺陷&lt;/strong&gt;，对错误的捕获，聊到&lt;strong&gt;babel相关&lt;/strong&gt;的，现有的babel社区是否实现了对async语法做错误捕获处理，以及谈了下，社区里面的这个插件存在的缺陷。&lt;/p&gt;
&lt;p&gt;总结的话，我会围绕&lt;strong&gt;面试官问的基础点展开&lt;/strong&gt;，把相关连的部分描述一下， 面试官有兴趣的话，会顺着你的思路往下问。&lt;/p&gt;
&lt;p&gt;至于面试过程中问到&lt;strong&gt;JS基础&lt;/strong&gt;相关的题，这里就不列举了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;React相关&lt;/h3&gt;
&lt;p&gt;第二部分，简历上写了React相关的，那我总结了些可以会问到内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React框架的原理，聊一聊它是如何执行的。&lt;/li&gt;
&lt;li&gt;React更新流程，主要经历了哪些步骤。&lt;/li&gt;
&lt;li&gt;React中setState的理解，需要注意哪些。&lt;/li&gt;
&lt;li&gt;vue和React区别，如何从项目的选型上区分它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;React框架的理解，vdom，patch，批量更新，渲染的过程，经历了啥。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你对React源码很感兴趣，可以关注一下&lt;strong&gt;卡颂大佬&lt;/strong&gt;，他的&lt;a href="https://ke.sifou.com/course/1650000023864436"&gt;自顶向下学 React 源码&lt;/a&gt;值得推荐学习一下。&lt;/p&gt;
&lt;p&gt;当然了，React真的要问，太多可以问你的啦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如让你手写一个Hoc组件，实现类似怎么样的功能，思路是怎么样的。&lt;/li&gt;
&lt;li&gt;比如Hook你对它的理解，当时面试问到了Hook实现原理，还好看平时喜欢折腾，看了下大致流程。&lt;/li&gt;
&lt;li&gt;React-fiber机制引入，解决了什么问题，具体的流程是怎么样的，数据结构上发生了哪些变化。&lt;/li&gt;
&lt;li&gt;React中的时间切片了解嘛，如何实现的，流程能不能说一说。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这次问到好几个React相关的问题，更关注的点是你对原理的过程，有关注嘛，大致是一个怎么样的过程，最后又从中学到了哪些点。简历上写看过React原理相关的，得慎重啊！！！&lt;/p&gt;
&lt;p&gt;快进到浏览器部分。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;浏览器相关&lt;/h3&gt;
&lt;p&gt;这也是我简历上专业技能写到的一个点，这里也写了几个点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入URL到页面渲染。&lt;/li&gt;
&lt;li&gt;DNS解析的端口号是多少，为什么采用UDP协议。&lt;/li&gt;
&lt;li&gt;你渲染流程知道的这么详细，图层，分层，绘制，栅格化线程池，GPU加速，能不能说一下，对你开发有啥影响呢。(其实这个时候，被无情打脸了，知道这个有什么用，当时反问我)&lt;/li&gt;
&lt;li&gt;浏览器缓存。(可以拓展一下，结合webpack如何命中缓存，然后就到你熟悉的webpack领域了)&lt;/li&gt;
&lt;li&gt;浏览器进程架构历史。&lt;/li&gt;
&lt;li&gt;浏览器内核。（这个可以了解）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浏览器的垃圾回收机制&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经典八股文了，不过其实我感觉也是可以拓展的，问到浏览器缓存的时候，结合webpack谈一谈如何命中缓存的。比如讲到浏览器的渲染流程时，我们都知道里面的一些具体流程，比如分层，绘制，栅格化操作，然后其实可以结合实际去思考一下，有哪些具体的用途呢，这里我们需要借助浏览器中的performance来看看。&lt;/p&gt;
&lt;p&gt;&lt;img alt="浏览器中的performance相关.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0579d17015b145a88dd93992c6447d7d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;里面有很多关键性指标，比如 Long  Task执行的细节，跟面试官交流了下，&lt;strong&gt;排查性能问题&lt;/strong&gt;，我是如何通过这个Performance相关的细节去把握的，当然了，里面的内存使用情况，是否出现&lt;strong&gt;内存泄露&lt;/strong&gt;问题，都可以借助它。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非要我总结的话，我觉得哪怕是八股文，我们也要尽可能的展示出亮点来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近也在学习性能优化相关的部分，发现Performance相关的部分，还是有很多地方可以学习的，&lt;strong&gt;可以持续关注我&lt;/strong&gt;噢～&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;webpack相关&lt;/h3&gt;
&lt;p&gt;基本上，看我简历上写了这部分的，会问到，部分问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;webpack打包原理。&lt;/li&gt;
&lt;li&gt;import最终被webpack编译打包成什么。&lt;/li&gt;
&lt;li&gt;路由懒加载的原理是啥，能不能结合webpack说一说。&lt;/li&gt;
&lt;li&gt;写过webpack loader 或者插件吗。&lt;/li&gt;
&lt;li&gt;webpack 如何做性能优化。&lt;/li&gt;
&lt;li&gt;babel的原理了解吗，babel是用来干嘛的。&lt;/li&gt;
&lt;li&gt;说一说常见的babel库，你有使用过哪些。&lt;/li&gt;
&lt;li&gt;写过 babel 插件吗？用来干啥的？怎么写的 babel 插件&lt;/li&gt;
&lt;li&gt;知道怎么转化成 AST 的吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上考察，你是否实践过，因为自己简历上写了这方面的，可能问的比较多。&lt;/p&gt;
&lt;p&gt;比如问到babel原理可以这么答:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;babel的转译过程分为三个阶段：&lt;strong&gt;parsing、transforming、generating&lt;/strong&gt;，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ES6代码输入&lt;/li&gt;
&lt;li&gt;babylon 进行解析得到 AST&lt;/li&gt;
&lt;li&gt;plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树&lt;/li&gt;
&lt;li&gt;用 babel-generator 通过 AST 树生成 ES5 代码&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上至少得知道它大致的原理，平时如果有积累的话，其实问题不大。&lt;/p&gt;
&lt;p&gt;比如babel的话，推荐可以看看babel是如何处理async错误捕获转换的，这个有点意思，正好借这个机会跟面试官交流一下这块的知识点，个人觉得还是很有意思。&lt;/p&gt;
&lt;p&gt;学的时候，&lt;strong&gt;多折腾一下&lt;/strong&gt;，应该就问题不大了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;算法与数据结构相关&lt;/h3&gt;
&lt;p&gt;其实这块，我希望面试官问我多一些，因为大学期间，更多的精力放在算法。有幸碰到过面试官也是打过ICPC，CCPC等比赛的，曾经都是热血青年，最后因为生活，选择了向生活低头。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;聊得过程还是很愉快的～ 也是第一次，跟面试官聊到了，线段树，主席树，最小费用流，二分图匹配（匈牙利）算法，差分约束，Graham扫描法，有限状态自动机，AC自动机。&lt;/p&gt;
&lt;p&gt;似乎找回了大二的那份对算法对热情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记得退役的时候，在QQ个签上，写过这么一句话:&lt;strong&gt;我永远热爱算法，无论它虐我千百遍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能是真的熬了无数的夜，才会有这样子的感慨吧。有点跑题了，感兴趣的话，后续会更新，我是如何走上算法这条路的，最后给我的成长收获又是哪些。&lt;/p&gt;
&lt;p&gt;回到正题，至于这部分的话，我觉得没有一个很明确的范围吧，毕竟算法太广了，过一遍吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向图判断是否有环。&lt;/li&gt;
&lt;li&gt;给定一个数组，如何拆分，保证两个数组的和接近。(想到的是贪心，正解应该是dp)&lt;/li&gt;
&lt;li&gt;Json.parse()实现。&lt;/li&gt;
&lt;li&gt;常见的数据结构。&lt;/li&gt;
&lt;li&gt;数组和链表区别。&lt;/li&gt;
&lt;li&gt;时间复杂度和空间复杂度计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排序算法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;你是如何看待算法的，给你的收获是什么。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法很重要的，对你未来的发展，我觉得还是很有必要去学习的。至于怎么学，我没有能力回答这个问题，要我给建议的话，&lt;strong&gt;看书是一个选择&lt;/strong&gt;，如果要临时应对面试，刷一刷leetcode来说，只能说短期有效果。&lt;/p&gt;
&lt;p&gt;个人建议：&lt;/p&gt;
&lt;p&gt;可以结合书的内容，分专题去刷，比如动态规划dp专题很难，我记得我当时看完书后，对它的理解就很清晰了，当然做题是另外一回事，通过题目不断巩固你对一个算法知识点的理解，我觉得是没有问题的，但是至于完完全全刷leetcode，应付面试，不从最基础的开始，这样子“超车”，觉得意义不大。&lt;/p&gt;
&lt;p&gt;以上是我个人理解，&lt;strong&gt;能力有限&lt;/strong&gt;，说的不对，您就当看个笑话。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;个人经历&lt;/h3&gt;
&lt;p&gt;问到这部分的话，可能是总监面你的时候会问，也可能是hr会问，到hr环节的话，基本十拿九稳了。不过也不能大意，说不定一不留神，卡你学历啥的，一个月的面试付诸东流，还是要认真对待的，罗列了几个点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整个经历自我介绍，越详细越好，什么时候接触计算机，什么时候接触前端。&lt;/li&gt;
&lt;li&gt;整个经历中，你认为最值得骄傲的事情，最难的事情是什么。&lt;/li&gt;
&lt;li&gt;什么事情让你自豪，什么事情让你有挫败感。&lt;/li&gt;
&lt;li&gt;未来的发展，自己的规划。&lt;/li&gt;
&lt;li&gt;为什么现在才来秋招，不选择秋招。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拿我来说，我&lt;strong&gt;双非本科&lt;/strong&gt;，最担心的就是卡学历。当时hr明确问了我，你对现在的学校满意嘛，师范类的院校，怎么选择走软件工程呀，诸如此类的问题很多，无不困扰着我。&lt;/p&gt;
&lt;p&gt;不过我也不搞虚的。实话实话，为什么高中成绩差，又为什么选择软件工程，争取做到坦诚相待的态度，表达出自己最真实的想法吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;看到这里的话，可能对你来说，没有具体说明白，哪些知识点会考，哪些不会考察。&lt;/p&gt;
&lt;p&gt;我面腾讯和阿里的时候，也没有看到我这个部门具体的面试题。&lt;/p&gt;
&lt;p&gt;我觉得更重要的是，把握好&lt;strong&gt;专业技能和项目经历&lt;/strong&gt;的表达，引导面试官去往你所知道的领域交流问题，最后在这个领域拿出自己的&lt;strong&gt;杀手锏&lt;/strong&gt;，这样子面试官会更有好感，接下来的交流会更加愉快。&lt;/p&gt;
&lt;p&gt;对简历感兴趣的话，可以参考下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="个人简历模版.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/453bf44bb9864947bf318974e997f129~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;需要获取简历模板pdf的话，私信我（文末有联系方式），或者&lt;strong&gt;公众号: TianTianUp&lt;/strong&gt;回复，&lt;strong&gt;个人简历&lt;/strong&gt;，即可获取。&lt;/p&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;作为一个即将毕业的我来说，第一份工作很重要。在我面临选择的时候，慎重考虑以及找前辈交流过后，最后选择了&lt;strong&gt;腾讯&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在即将毕业的最后阶段，我应该算交上了一份满意的答卷，未来的路还很长，让我们拭目以待吧！&lt;/p&gt;
&lt;p&gt;有想交流的问题，欢迎联系我⬇️&lt;/p&gt;
&lt;p&gt;微信:DayDay2021&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后做一个简单，自由，有爱的技术人吧。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>TianTianUp</author><pubDate>Tue, 30 Mar 2021 17:34:05 GMT</pubDate></item><item><title>2020的TianTianUp在掘金| 掘金年度征文</title><link>https://juejin.cn/post/6911095991986814989</link><description>&lt;section id="nice"&gt;&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;2020个人总结，基本上是对今年的絮絮叨叨，不是啥干活，感兴趣可以看看。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020即将结束，简单回顾一下，做了哪些事情，收获了什么，哪些不足的地方，做个小结。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;2020年，我大四，似乎才刚刚开始。&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;2021年，我大四，似乎又快结束了。&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;经常这么鼓励自己➡️  为什么要进大厂呢⬇️&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;年轻时候去大厂的目标，是为了避免，【你得顿悟，是别人的基本功】&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;PS: 挤牙膏一样，还是挤不出啥东西。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;前端之旅&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020这一年，真的是波折的一年吧，一直在&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;考研和工作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;之间徘徊，不知道如何选择，想了好久，综合很多方面，于是就走上前端这条曲折又难走的道路。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我，就读于一所本科院校，没有学历光环，没有任何加分项，作为一个Acmer爱好者，跌跌撞撞的搞了算法，奈何实属菜鸡，没有拿到所谓的荣誉证明，一块icpc的奖牌都不从拥有，似乎我的大学将以失败告终！&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;那个时候是最沮丧的时候，算法组成员，很多都已经捧杯无数，似乎只有我，没有一块奖牌来证明自己。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;那个灰暗的时光，似乎过了好久。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可能是因为累了，疲倦了，大三的时候，选择遗憾的退役了，现在想一想，还是很遗憾。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020这一年春天，在前女友的鼓励下，我尝试向互联网公司投了简历，很显然，前端基础不扎实，阿里直接拒绝。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可能是太压抑了，加上之前的失意，似乎我一直都在逃避，一直到今年6🈷️。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;身边的朋友，开始陆陆续续准备考研，工作，而我，机缘巧合下，与一位学长的沟通，坚定了我的前端之路。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我的直系学长，秋招拿到美图offer，春招拿到Shopee的offer，跟他沟通后，发现很多东西都冲刷了我对前端的认知。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;6月底，开始疯狂补前端基础知识，刷题，写博客，特意翻了翻GitHub的提交记录。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="2020-掘金截图" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad013c9ab50b42018cc6f9cb80086f8e~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;2020-掘金截图&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，持续学习，持续总结，希望能赶上同届的大佬们，三元，Jack，曹佬，甘佬，林佬，现在的人太猛了，抓紧时间吧。&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;掘金&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;简单介绍一下，自己是如何知道掘金社区，并且是如何开始写作的吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;2020-06-24,我在大学宿舍，注册了掘金账号。百无聊赖的翻了几篇文章后，才发现，这里面有很多的文章特别如何我的胃口，总结梳理的很棒，说实话，当时看得很投入，于是乎，我跟它的故事便悄悄开始了。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;第一篇文章&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;在写这篇文章时，我特意去翻了翻我在掘金的第一篇文章，到底是哪一篇“水文”。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de92cbfc576b407d8baf4a67d172d20a~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;注册的当天，我似乎就下定了决心，希望接下来有个&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;不平凡&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的2020。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;立个flag：希望在2020秋招前完成对前端知识点的回顾总结。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这是我当时的Flag，似乎我已经完成了一些，至于多少，也许最清楚的人就是我了。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我依稀记得那个时候，JavaScript基础乃至前端基础，都十分的薄弱，与其说这么说，还不如说啥都不会，这是对我最中肯的评价了，我确实没有花时间在前端领域。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;持续写作&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;为了夯实基础，看书籍，这里推荐的就是&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;红宝石&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; ⬇️&lt;/p&gt;
&lt;img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e1b5a98123d4f74b828571e8dd61c77~tplv-k3u1fbpfcp-watermark.image" /&gt;
![个人总结-2020-红宝石](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1f168663eb748b8a8e855dc964ba4c3~tplv-k3u1fbpfcp-watermark.image)
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;啃完这本书，我觉得至少大厂的第一轮技术面试，完全是可以过的。对这本书籍的评价，绝对是一本值得你花时间去品味的书籍。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，在这里的话，我除了看书籍外，会结合很多博客，比如&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;若川&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;冴羽&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;等很多前辈的博客，很多点，看完他们对知识点的解读，完全可以get到重点。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;于是，我会把易错的点，通过笔记的方式记录下来，然后发在掘金上，很显然，一开始是没有人阅读的，这个也是我的预期，懂得都明白，我也没有把它放在心上。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;慢慢的，开始有了一些阅读量，一些人关注，给我点赞，当时对我是莫大的肯定，也一直坚定了我坚持记笔记的决心。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6846687590540640263" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「浏览器工作原理」写给女友的秘籍-浏览器组成&amp;amp;网络请求篇（1.2W字)&lt;/a&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当时看了极客的专栏，对于浏览器这块，我前所未有的对它了解的这么清楚，我记得那几天，我彻夜难眠，似乎它真的解开了我很多的心结，让我对前端体系有了更深的理解，于是我准备梳理一遍，也就是这篇文章，让我开始点赞UpUp，关注UpUp。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;很显然，学东西就是模仿，参考，借鉴创新的过程，我也勘误了原作者，还是有很多人来撕逼，其实你可以完全不去搭理他们，知识不就是如此吗，自己加深了理解，对他人有所帮助，这就够了，说明你理解到位了。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;如何坚持写，如何鼓励自己&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;上篇讲到，很多时间，你会受到很多的质疑，我举个例子：&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="Git命令" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c919f55501aa496b9b2c163de630d2d8~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;Git命令&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;就拿这个来说，Git命令很简单，为啥这样子的文章，有1800+👍，4W万阅读呢？&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;如果我现在看来，根本不需要记那么多命令行，直接用SourceTree这个工具托管，不香吗，它真的香！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;这个时间点，我真好刚刚入职网易，当时开发流程上，有很多不清楚地方，每次更同事合并分支的时候，会遇到些问题，当然了，操作了两遍，就会了，难道这么简单的东西，不是实践几遍就会吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;我写这个初衷是因为有些时候，比如版本回退，有些很难记的东西，需要查资料，还不如，我总结出来，做个脑图，方便以后工作需要。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可是工作不久，等我接触了SourceTree时，我觉得我这篇文章，其实没有必要了，太香了，基本上能满足你日常的开发需求。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;很多时候，你会受到质疑，为啥这么简单的内容，你都要做笔记，你应该这么对自己说，不同的阶段，你会遇到不同阶段的事情，可能过不了多久，你就会觉得之前写的东西很傻，但这不影响你成长，这更是一种对自我的对比，知道接下来如何梳理总结出更加满意的内容。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，有点跑题，我希望传达的意思就是：做自己认为对的事情，写作分享是一件有意义的事情，至于内容的好坏，取决于不同读者对它的解读，我们需要的保持初心，坚持写下去。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;算法&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;本着作为半个Acmer出身，虽然退役了，但是依旧热爱算法，所以把算法给梳理了一遍，花了两个月时间吧，写作不易，也比较用心的去梳理一遍，每个点难理解地方，如何利用技巧去解读它，这里就列一下吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6900698814093459463" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」你可能需要的一份前端算法总结&lt;/a&gt;（910+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6888451657504391181" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」Trie树之美&lt;/a&gt;（200+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6885104477297344525" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」分治算法之美&lt;/a&gt;（190+👍）&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://juejin.cn/post/6882394656148045838" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这是部分链接，当然了，你需要每个专题的题集的话，我这边也有一份不错的leetcode题集PDF，可以来找我领取噢～&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;贵人相助&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;在这最艰难的7，8月内，是最难熬的一段时间了，在掘金这个社区，认识一堆人，我们虽然隔着屏幕，分享着一些囧事，分享着前端领域中遇到的难题，有时候，会在各自坚持不下去的时候，互相鼓励，有时候，你需要的可能就是能倾诉的朋友吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;太多小伙伴了，这里就不提及了，我可能最要感激的一个人，就是&lt;a href="https://juejin.cn/user/764915822103079" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;@阿宝哥&lt;/a&gt; 。有时候，有人给你引导如何去规划，如何做出做得更好，如何规划接下来的路，宝哥就是这么一个人，帮我找工作，帮我安排其他一些事情，教我如何做好一个公众号等等。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;希望下次去厦门的生活，能跟宝哥搓一顿饭。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;小结&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;写的再多，都无法描述，我在2020这一年夏天，7月，8月所发生的事情，可能这两个月，对我的意义非凡吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;希望这份简简单单的描述，对现在的你，有那么一点点帮助的话，也许它就有存在的意义了吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;坚持+运气+拼命，似乎一切都来了。&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;网易&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当时投的公司就三家左右吧，匆匆忙忙的投递，嗯，网易的流程很快，算下来，两天的时间就走完了，基本上就敲定了它。&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;面试回顾&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我印象中，可能是四轮技术面吧，应该没有记错的话。&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;一面技术电话面，记得是一个周五的上午，是个声音非常nice的小哥哥。基本上大厂的电话面都属于简历评估环节吧，简单的聊了30分钟，问的都是前端基础，没有问算法。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;二面技术视频面，全程高冷，基本上抛出问题，让我回答，当时很紧张吧，有些地方回答不是很好，手写一些常见api，接着写了两道算法题，感觉写的一般，整体下来，只能说面评一般。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;三面技术，还是视频面。也就是我现在的导师，可能就是她的微笑吧，看我问题答错了，也是通过微笑来缓解，整体来说，问的难度还能接受，目前看来，导师非常nice。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;四面技术面，依旧是视频面，目前团队的leader，全程70分钟，问了三个大的场景题，嗯，还有些课程相关的问题。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;五面+hr面，几分钟结束战斗。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这里是面经，感兴趣可以看看。&lt;/p&gt;
&lt;h6 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 16px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;a href="https://juejin.cn/post/6862855292577644552" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「面经」你可能需要的三轮网易面经&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h6&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;翻了翻朋友圈，当时感觉整个团队偏年轻化，字里行间可以看得出有多高兴～&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/973a117409a645fa9469901df05a2756~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;转眼间，4个月过去了，收获也是巨大的～，这里离不开导师mentor对我的帮助，还是很幸运遇到非常nice的导师。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;从产品提需求，到需求定稿，开会评估工期，跟UI同事沟通好，以及和测试说好提测时间，接着就是bugfix，正常上线。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;看着自己负责的板块，如期上线，原来，我写的东西也被数以万计的用户使用～&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，项目上线后，也会出现bug，嗯，定位bug原因，bugfix，然后提测，一般而言，遇到小bug跟随下一个版本发，重大的bug话，通常采用hotfix热更新办法，嗯，基本上整个流程都走了一遍了吧。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;还记得当时debug的时候，定位问题，到解决问题的过程⬇️&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="个人总结-2020-bugfix.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30d165f916f64507a70b4a4c3d3d30a1~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;个人总结-2020-bugfix&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那是一个难熬的夜晚，现在想一想，确实很”程序员“。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;谈起网易，很多人都会想到🐷厂伙食，没错，几个月下来，都胖了一圈了。&lt;/p&gt;
&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66b678dee2f249978347cab885ac7161~tplv-k3u1fbpfcp-watermark.image" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;2021新期待&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;希望能合理把生活，工作，学习，公众号，这几方面安排妥当。&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;React源码系列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;前端工程化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;node&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;最后期待粉丝**10000+**吧，能认识更多有趣的人。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，留个联系方式，微信: &lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;DayDay2021&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;, 期待我们能有交流。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;目前我的文章都会发在公众号「&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;前端UpUp&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;」上，感兴趣的朋友可以关注一下&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Sun, 27 Dec 2020 16:22:38 GMT</pubDate></item><item><title>「算法与数据结构」你可能需要的一份前端算法总结</title><link>https://juejin.cn/post/6900698814093459463</link><description>&lt;hr /&gt;
&lt;h1&gt;主题列表：juejin, github, smartblue, cyanosis, channing-cyan, fancy, hydrogen, condensed-night-purple, greenwillow, v-green, vue-pro&lt;/h1&gt;
&lt;h1&gt;贡献主题：https://github.com/xitu/juejin-markdown-themes&lt;/h1&gt;
&lt;h2&gt;theme: juejin
highlight:smartblue&lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近好多事情，最近前端分享会也如期而至，有幸这次分享会，正好周末有时间，做个总结吧。&lt;/p&gt;
&lt;p&gt;这次想分享的就是&lt;strong&gt;算法与数据结构&lt;/strong&gt;，刷了一段时间题目，逛了逛LeetCode，看了很多关于这个方面的文章，有所感悟，准备做个记录吧。&lt;/p&gt;
&lt;p&gt;当你想花时间去了解学习一件对你来说，很苦难的事情的时候，我们需要明确目标，学习它的意义，它有什么用，对你有哪方面帮助。&lt;/p&gt;
&lt;p&gt;升职加薪必备，对以后成长有所帮助，嗯，加薪，加薪，加薪。&lt;/p&gt;
&lt;p&gt;那么问题来了，为什么要进大厂呢⬇️&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;年轻时候去大厂的目标，是为了避免，【你得顿悟，是别人的基本功】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，闲聊就止步于此，接下来开始吧～&lt;/p&gt;
&lt;p&gt;站在巨人肩膀上，学起来就很轻松了， 这里我是参考网上的算法刷题路线，可以参考一下～&lt;/p&gt;
&lt;p&gt;公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，回复&lt;strong&gt;算法&lt;/strong&gt;，即可获取脑图，以及文末的题目汇总pdf。&lt;/p&gt;
&lt;p&gt;&lt;img alt="算法与数据结构" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cabe509f34e40a28ea46191b72689ec~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们就根据这个脑图来梳理一遍吧~&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;数据结构&lt;/h2&gt;
&lt;p&gt;数据结构可以说是算法的基石，如果没有扎实的数据结构基础，想要把算法学好甚至融会贯通是非常困难的，而优秀的算法又往往取决于你采用哪种数据结构。学好这个专题也是很有必要的，那么我们可以稍微的做个分类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常用数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组，字符串&lt;/li&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高级数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图&lt;/li&gt;
&lt;li&gt;前缀树&lt;/li&gt;
&lt;li&gt;线段树&lt;/li&gt;
&lt;li&gt;树状数组&lt;/li&gt;
&lt;li&gt;主席树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么显然，最常见的数据结构一定是需要掌握的，对于高级的数据结构而言，如果你有时间，对它有所热爱的话，可以深入了解，比如这个&lt;strong&gt;主席树&lt;/strong&gt;在解决一些问题 的时候，算法复杂度是log级别的，某些场景下很有帮助。&lt;/p&gt;
&lt;p&gt;这里想提及的就是&lt;strong&gt;树&lt;/strong&gt;。它的结构很显然是很直观的，树当然有很多的性质，这里也列举不完，比如面试中常考的树：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于它而言的话，我们需要到哪些程度呢？&lt;/p&gt;
&lt;p&gt;对于常见树的遍历，从树的前序遍历，到中序遍历，后续遍历，以至于层次遍历，掌握好这四种遍历的递归写法和非递归写法是非常重要的，接下来需要懂得分析各种写法的时间复杂度和空间复杂度。&lt;/p&gt;
&lt;p&gt;面试准备阶段，把树这个结构花时间去准备的话，对于你理解递归还是很有帮助的，同时也能帮助你学习一些图论的知识，更加准确的说，树是面试考察的热门考点，尤其是二叉树！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;掌握好这些数据结构是基础，绝大部分的算法面试题都得靠它们来帮忙，因此，一定要花功夫勤练题目来深入理解它们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;排序算法&lt;/h2&gt;
&lt;p&gt;这应该是面试最常考，最核心的算法。如果你能把排序算法理解的很透彻的话，接下来的其他算法也是一样的旁敲侧击。&lt;/p&gt;
&lt;p&gt;当时我梳理得是常见的6个排序算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-1"&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-5"&gt;计数排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-9"&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-13"&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-17"&gt;插入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006#heading-21"&gt;选择排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在此之前，我也写过一篇排序算法的文章，个人觉得言简意赅，可以看看&lt;a href="https://juejin.cn/post/6856546833025237006"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有时候，面试官喜欢会问冒泡排序和插入排序，基本上这些都是考察你的基础知识，并且看看你能不能快速地写出没有bug的代码。&lt;/p&gt;
&lt;p&gt;又比如，当面试官问你归并排序、快速排序和拓扑排序等的时候，这个时候考察的是你平时对算法得积累，所以有必要做个总结。&lt;/p&gt;
&lt;p&gt;我们拿&lt;strong&gt;归并排序&lt;/strong&gt;来举例子，我们应该如何表达清楚呢？首先，我们应该把这个它的思路说清楚：&lt;/p&gt;
&lt;p&gt;归并排序的核心思想就是分治，它将一个复杂的问题分成两个或者多个相同或相似的子问题，然后把子问题分成更小的子问题，直到子问题可以简单的直接求解，最原问题的解就是子问题解的合并。&lt;strong&gt;归并排序&lt;/strong&gt;将分治的思想体现得淋漓尽致。&lt;/p&gt;
&lt;p&gt;当你向面试官理清楚这个思路时，面试官心里就有底了，他会想，嘿，这个小伙子不错！那你接下来都有底气了！&lt;/p&gt;
&lt;p&gt;有了思想，那么实现起来就不难了:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一开始先把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，才开始排序。&lt;/p&gt;
&lt;p&gt;排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;贴一份之前的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const merge = (left, right) =&amp;gt; { // 合并数组

    let result = []
    // 使用shift()方法偷个懒,删除第一个元素,并且返回该值
    while (left.length &amp;amp;&amp;amp; right.length) {
        if (left[0] &amp;lt;= right[0]) {
            result.push(left.shift())
        } else {
            result.push(right.shift())
        }
    }
    while (left.length) {
        result.push(left.shift())
    }

    while (right.length) {
        result.push(right.shift())
    }
    return result
}

let mergeSort = function (arr) {
    if (arr.length &amp;lt;= 1)
        return arr
    let mid = Math.floor(arr.length / 2)
    // 拆分数组
    let left = arr.slice(0, mid),
        right = arr.slice(mid);
    let mergeLeftArray = mergeSort(left),
        mergeRightArray = mergeSort(right)
    return merge(mergeLeftArray, mergeRightArray)
}

// let arr = [2, 9, 6, 7, 4, 3, 1, 7, 0, -1, -2]
// console.log(mergeSort(arr))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于这部分的算法而言，可以围绕从&lt;strong&gt;解题思路&lt;/strong&gt;--&amp;gt;&amp;gt;&lt;strong&gt;实现过程&lt;/strong&gt;--&amp;gt;&amp;gt;&lt;strong&gt;代码实现&lt;/strong&gt;。 基本上以这三步来实现的话，掌握常见的排序算法完成是没有问题的。&lt;/p&gt;
&lt;p&gt;那么这部分就暂时梳理到这里吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;动态规划&lt;/h2&gt;
&lt;p&gt;动态规划难，可以说是很多面试者也是我最怕的部分，尤其是面试的时候，怕面试官考这个算法了。遇到没有做过的题目，这个时候，能否写出状态转移方程是十分重要的。接下来我们聊一聊这个专题吧。&lt;/p&gt;
&lt;p&gt;首先，强烈推荐我之前分析这个专题如何准备的： &lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果从点赞角度来看，可以说，是我写算法以来，得到大家肯定最多的一次了，可以看看，不过这里也会涵盖部分。&lt;/p&gt;
&lt;p&gt;如何学动态规划，从哪里入手，应该这么去做，这么去刷题，肯定是很多初学者一开始就会遇到的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;动态规划解决了什么问题&lt;/li&gt;
&lt;li&gt;动态规划解题的步骤&lt;/li&gt;
&lt;li&gt;如何高效率刷dp专题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，你得了解动态规划是什么，它的思想是什么，定义又是啥。这里引入维基百科对它的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Wikipedia 定义：它既是一种数学优化的方法，同时也是编程的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然了，看完这段话，我们肯定对它不了解的，我们可以翻译一下，首先它可以算是一种优化的手段，优化一些重复子问题的操作，将很多重叠子问题通过编程的方式来解决，比如&lt;strong&gt;记忆划搜索&lt;/strong&gt;。 又比如，如果一个原问题，可以拆分成很多子问题，它们之间没有任何后续性，当前的决策对后续没有影响的话，每个子问题的最优解，就可以组合成原问题的最优解了。&lt;/p&gt;
&lt;p&gt;当然了，对于动态规划每个人理解是不同的，对于应用到具体的场景中，需要我们都去用多维度的状态去表述它的含义，这里也就是状态转移方程的含义所在。&lt;/p&gt;
&lt;p&gt;嗯，那么动态规划解决了什么问题呢，很显然，对于重复性问题来说，它可以很好的解决，那么从某个维度上来看，它可以优化一个算法的时间复杂度，也就是通常意义上的，拿空间来换取时间的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态规划解题步骤&lt;/strong&gt;： 这个应该就是实际落地的操作，需要我们去通过大量的题目来完成，具体我们需要怎么做呢？&lt;/p&gt;
&lt;p&gt;解题思路，三大步骤👇&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;状态定义&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列出状态转移方程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;强烈推荐这篇问题，里面讲的很清楚了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何高效率刷dp专题&lt;/strong&gt;：首先，你得找到对应的dp专题，这里的话，我帮你准备好了，接下来我说一下我是怎么刷leetcode上面的题目的。&lt;/p&gt;
&lt;p&gt;一般而言，刷完中等的leetcode上的dp专题，基本上可以满足要求了。那么对于中等的dp题目，很多时候，我是写不吃来的，那我应该如何去做呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，我先看题解，把它的状态转移方程写下来，仔细的品味一下，它这么定义，解决了我之前的什么难点，为啥我是没有想到的。&lt;/li&gt;
&lt;li&gt;然后，看完之后，尝试按照这个题解思路，我自己能不能单独实现呢？&lt;/li&gt;
&lt;li&gt;如果不能的话，就照着它的代码，写一遍，多看看状态转移方程是如何写的，把这个题目收藏起来。&lt;/li&gt;
&lt;li&gt;等到下次，或者是隔天，再来看一遍题目，然后看看能不能单独完成，如果不能，第三天再这么操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有，我个人建议，刷dp的话，最好从易到难，这样子自己也会有信心，也不会再去畏惧它。&lt;/p&gt;
&lt;h3&gt;进阶题目汇总&lt;/h3&gt;
&lt;p&gt;以下是我收集的部分题目，希望对你们有帮助。&lt;/p&gt;
&lt;h4&gt;简单&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/climbing-stairs/"&gt;爬楼梯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/house-robber/"&gt;打家劫舍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/"&gt;使用最小花费爬楼梯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/contiguous-sequence-lcci/"&gt;连续数列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/"&gt;三步问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;中等&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/house-robber-ii/"&gt;打家劫舍 II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/"&gt;最佳买卖股票时机含冷冻期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/house-robber-iii/"&gt;打家劫舍 III&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/unique-paths/"&gt;不同路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/unique-paths-ii/"&gt;不同路径 II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/"&gt;最长上升子序列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;困难&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/"&gt;买卖股票的最佳时机 III&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/"&gt;买卖股票的最佳时机 IV&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/frog-jump/"&gt;青蛙过河&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/word-break-ii/"&gt;单词拆分 II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/max-submatrix-lcci/"&gt;最大子矩阵&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;搜索算法&lt;/h2&gt;
&lt;p&gt;这部分也是尤其重要的，那么重点学习深度优先搜索算法（简称为 DFS）和广度优先搜索算法（简称为 BFS）。&lt;/p&gt;
&lt;p&gt;我翻了翻我的博客，恰好有一篇类似的问题，大家可以看看**「算法与数据结构」DFS和BFS算法之美**。&lt;/p&gt;
&lt;p&gt;不过，我看了一下，我当时写得时候，有点粗糙，很多基本的概念都没有讲明白，所以可能适合一些对这部分有基础的小伙伴。&lt;/p&gt;
&lt;p&gt;在这里推荐一个有趣的题目：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-with-rotations/"&gt;穿过迷宫的最少移动次数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你也遇到过迷宫类似的问题，就可以考虑搜索算法了，从我个人的角度来说，它的思路其实就是模拟人的思路，每次走到一个路口的时候，我可以走哪里，我之前走过的路，怎么确保，接下来是不能走的，这里需要在编程的角度，如何去实现呢？&lt;/p&gt;
&lt;p&gt;这里说一说我的经验，对于刚刚提到的题目而言，我盲猜使用BFS，题目做多了，自然就会有心得，对于BFS和DFS而言，做了两个类似的题目，会发现，原来搜索算法也是有迹可循，也是存在某些套路的。&lt;/p&gt;
&lt;p&gt;给些建议：&lt;/p&gt;
&lt;p&gt;一开始可能做的时候，抓不到头脑，有思路，但是代码很难写清楚，那么如何去做呢？ &lt;strong&gt;看题解&lt;/strong&gt;，了解别人的写法是很不错的，可以多个对比，看看哪一份题解代码是你目前可以理解的，然后抄下来，看一遍。&lt;/p&gt;
&lt;p&gt;最普通的办法就是：先画图，看看思维上跟实际代码需要做哪些改变，如何去优化这个过程。最后结合别人代码，一定不要直接copy，不去思考为什么这么写，不然后期发现，是没有多大效果的，一定要多结合自己的理解。&lt;/p&gt;
&lt;p&gt;嗯，不会就看题解，多思考为什么这么写！！！&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;写到这里的时候，已经凌晨1点了，算法与数据结构这个方向太大了，一篇文章不可能写得完，我更希望这篇文章对你，有那么一点点的帮助，对我，或你都些许有所帮助，那么它得存在就有那么一点点意义。&lt;/p&gt;
&lt;p&gt;以下是我刷的题集，需者自取，公众号：&lt;strong&gt;前端UpUp&lt;/strong&gt;，关注它，找我领pdf文档也可以。&lt;/p&gt;
&lt;h3&gt;进阶题目汇总&lt;/h3&gt;
&lt;p&gt;这个专题想进阶，就刷我下面提供的题目吧👇&lt;/p&gt;
&lt;h3&gt;DFS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/"&gt;二叉树的最大深度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/"&gt;二叉树的最小深度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/friend-circles/"&gt;朋友圈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/find-eventual-safe-states/"&gt;找到最终的安全状态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/"&gt;矩阵中的最长递增路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minesweeper/"&gt;扫雷游戏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/word-ladder/"&gt;单词接龙&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;BFS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/"&gt;N叉树的层序遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/"&gt;二叉树的层序遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-height-trees/"&gt;最小高度树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minesweeper/"&gt;扫雷游戏&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;题目汇总&lt;/h2&gt;
&lt;p&gt;我之前刷题历程是根据这套题来的，我觉得里面题目梯度还是质量都是很不错的。&lt;/p&gt;
&lt;p&gt;拿到这个pdf有段时间了，所以不清楚具体作者是谁，有侵权的话，可删。&lt;/p&gt;
&lt;h3&gt;数组&amp;amp;链表&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/rotate-array/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/merge-two-sorted-lists/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/merge-sorted-array/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/swap-nodes-in-pairs/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/3sum/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Map &amp;amp; Set&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/valid-anagram/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/group-anagrams/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;堆栈&amp;amp;队列&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/remove-outermost-parentheses/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/largest-rectangle-in-histogram/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/trapping-rain-water/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二分查找&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/arranging-coins/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/powx-n/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/dungeon-game/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;递归&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/symmetric-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-paths/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/range-sum-of-bst/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;哈希表&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/two-sum/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/valid-anagram/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/top-k-frequent-words&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/number-of-atoms/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二叉树&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/symmetric-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二叉搜索树&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/validate-binary-search-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/range-sum-of-bst/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/contains-duplicate-iii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;图&lt;/h3&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/number-of-islands/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/course-schedule-ii&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;堆和排序&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/find-median-from-data-stream/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DFS&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/friend-circles/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/find-eventual-safe-states/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minesweeper/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/word-ladder/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;BFS&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/binary-tree-level-order-traversal-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minesweeper/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/minimum-height-trees/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Trie树&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/longest-word-in-dictionary/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/implement-trie-prefix-tree/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/word-search-ii/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;分治算法&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/majority-element/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/maximum-subarray/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/search-a-2d-matrix-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;回溯算法&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/letter-case-permutation/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/subsets/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/permutations/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/combinations/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/n-queens/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;贪心算法&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/assign-cookies/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;动态规划&lt;/h3&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/climbing-stairs/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/house-robber/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/house-robber-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/house-robber-iii/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/unique-paths/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.com/problems/unique-paths-ii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;❤️ 感谢大家&lt;/h2&gt;
&lt;p&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/li&gt;
&lt;li&gt;关注公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，联系作者👉 &lt;strong&gt;DayDay2021&lt;/strong&gt; ，我们一起学习一起进步。&lt;/li&gt;
&lt;li&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6888451657504391181"&gt;「算法与数据结构」Trie树之美&lt;/a&gt;（200+👍）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6885104477297344525"&gt;「算法与数据结构」分治算法之美&lt;/a&gt;（190+👍）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6861376131615227912"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6856546833025237006"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6874708801208254478"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6882394656148045838"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description><author>TianTianUp</author><pubDate>Sun, 29 Nov 2020 16:06:46 GMT</pubDate></item><item><title>「算法与数据结构」二叉树之美</title><link>https://juejin.cn/post/6890680584033533960</link><description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这次梳理的内容是数据结构专题中的&lt;strong&gt;树&lt;/strong&gt;，如果你看到&lt;code&gt;树&lt;/code&gt;这类数据结构时，满脑子头疼，觉得它很难理解，如果是这样子的话，那么本文可能对你或许有点帮助。&lt;/p&gt;
&lt;p&gt;俗话说得好，要想掌握理解的话，我们得先了解它的概念，性质等内容。&lt;/p&gt;
&lt;p&gt;围绕以下几个点来展开介绍树👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树的基本概念&lt;/li&gt;
&lt;li&gt;基本术语&lt;/li&gt;
&lt;li&gt;树的种类&lt;/li&gt;
&lt;li&gt;二叉树概念&lt;/li&gt;
&lt;li&gt;二叉树的遍历&lt;/li&gt;
&lt;li&gt;二叉树题目汇总&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，回复&lt;strong&gt;二叉树&lt;/strong&gt;，即可获取脑图。&lt;/p&gt;
&lt;p&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;p&gt;脑图👇&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/345ae35ff7c040cf893fc9b0f06dbb52~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;树的基本概念&lt;/h2&gt;
&lt;p&gt;树是用来模拟具有树状结构性质的数据集合。或者你可以把它认为是一种&lt;strong&gt;抽象数据结构&lt;/strong&gt;或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。&lt;/p&gt;
&lt;p&gt;那么根据维基百科给出的定义，我们似乎可以这么理解：&lt;/p&gt;
&lt;p&gt;它是由n（n&amp;gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;每个节点都只有有限个子节点或无子节点；&lt;/li&gt;
&lt;li&gt;没有父节点的节点称为根节点；&lt;/li&gt;
&lt;li&gt;每一个非根节点有且只有一个父节点；&lt;/li&gt;
&lt;li&gt;除了根节点外，每个子节点可以分为多个不相交的子树；&lt;/li&gt;
&lt;li&gt;树里面没有环路(cycle)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个时候，我们就需要拿出一张图来看👇&lt;/p&gt;
&lt;p&gt;&lt;img alt="树的概念" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a797132557334101a5af5631068d230b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;从图中来看，以上的五个特点都可以很好的总结出来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A节点作为根节点，没有父节点，所以是根节点。&lt;/li&gt;
&lt;li&gt;除根节点（A）外，其他的节点都有父节点，并且每个节点只有有限个子节点或无子节点。&lt;/li&gt;
&lt;li&gt;从某个节点开始，可以分为很多个子树，举个例子，从B节点开始，即是如此。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然对树有一定认识后，我们需要了解它的一些术语。&lt;/p&gt;
&lt;h2&gt;基本术语&lt;/h2&gt;
&lt;p&gt;&lt;img alt="树的基本术语" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffe6a7a99096480c8077c53912a1ccc8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为了更加规范的总结，这里给出的描述来自于维基百科：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;节点的度&lt;/strong&gt;：一个节点含有的子树的个数称为该节点的度；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的度&lt;/strong&gt;：一棵树中，最大的节点度称为树的度；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;叶节点&lt;/strong&gt;或&lt;strong&gt;终端节点&lt;/strong&gt;：度为零的节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非终端节点&lt;/strong&gt;或&lt;strong&gt;分支节点&lt;/strong&gt;：度不为零的节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;父亲节点&lt;/strong&gt;或&lt;strong&gt;父节点&lt;/strong&gt;：若一个节点含有子节点，则这个节点称为其子节点的父节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;孩子节点&lt;/strong&gt;或&lt;strong&gt;子节点&lt;/strong&gt;：一个节点含有的子树的根节点称为该节点的子节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兄弟节点&lt;/strong&gt;：具有相同父节点的节点互称为兄弟节点；&lt;/li&gt;
&lt;li&gt;节点的&lt;strong&gt;层次&lt;/strong&gt;：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;深度&lt;/strong&gt;：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高度&lt;/strong&gt;：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堂兄弟节点&lt;/strong&gt;：父节点在同一层的节点互为堂兄弟；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点的祖先&lt;/strong&gt;：从根到该节点所经分支上的所有节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子孙&lt;/strong&gt;：以某节点为根的子树中任一节点都称为该节点的子孙；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;森林&lt;/strong&gt;：由m（m&amp;gt;=0）棵互不相交的树的集合称为森林。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以结合上述的图来理解这些概念，通过两者的结合，你一定会对树有进一步的了解的。&lt;/p&gt;
&lt;p&gt;有以上基本概念，以及一些专业术语的掌握，接下来我们需要对树进行一个分类，看看树有哪些种类。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;树的种类&lt;/h2&gt;
&lt;p&gt;理解了树的概念以及基本术语，接下来，我们需要拓展的内容就是树的种类。&lt;/p&gt;
&lt;p&gt;我们可以根据维基百科的依据来作为分类的标准👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为&lt;a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E6%A0%91"&gt;自由树&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；
&lt;ul&gt;
&lt;li&gt;二叉树：每个节点最多含有两个子树的树称为二叉树；
&lt;ul&gt;
&lt;li&gt;完全二叉树：对于一颗二叉树，假设其深度为d（d&amp;gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"&gt;满二叉树&lt;/a&gt;：所有叶节点都在最底层的完全二叉树；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"&gt;平衡二叉树&lt;/a&gt;（&lt;a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91"&gt;AVL树&lt;/a&gt;）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；&lt;/li&gt;
&lt;li&gt;排序二叉树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91"&gt;霍夫曼树&lt;/a&gt;：&lt;a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84&amp;amp;action=edit&amp;amp;redlink=1"&gt;带权路径&lt;/a&gt;最短的二叉树称为哈夫曼树或最优二叉树；&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/B%E6%A0%91"&gt;B树&lt;/a&gt;：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然树的分类有这么多的话，那么我们是不是都需要一一掌握呢，我个人觉得，掌握二叉树这种结构就足够了，它也是树最简单、应用最广泛的种类。&lt;/p&gt;
&lt;p&gt;那么接下来，我们就来介绍一下二叉树吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;二叉树的概念&lt;/h2&gt;
&lt;p&gt;二叉树是一种典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。&lt;/p&gt;
&lt;p&gt;&lt;img alt="二叉树" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928edb599f30491c8f62935da572a0eb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;图片来自网络，具体出处不明。&lt;/p&gt;
&lt;p&gt;从这个图片的内容来看，应该很清楚的展示了二叉树的结构。&lt;/p&gt;
&lt;p&gt;至于二叉树的性质的话，可以参考下图，作为补充知识吧，个人觉得这个不是重点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="二叉树的性质" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a977e2da02a847ad92c68adcbfd05a27~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;重点的话，我们需要掌握的应该是它的遍历方式。&lt;/p&gt;
&lt;h2&gt;二叉树的遍历&lt;/h2&gt;
&lt;p&gt;我们知道对于二叉树的遍历而言，有常见得三种遍历方式，分别是以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历&lt;/li&gt;
&lt;li&gt;中序遍历&lt;/li&gt;
&lt;li&gt;后序遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于任何一种遍历方式而言，我们不仅需要掌握它的非递归版本，同时对于它的递归版本来说，更是考察一个人的算法基本功，那么接下来，我们来看看吧。&lt;/p&gt;
&lt;h3&gt;前序遍历&lt;/h3&gt;
&lt;p&gt;点击这里，练习&lt;a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/"&gt;二叉树的前序遍历&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给你二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回它节点值的 &lt;strong&gt;前序&lt;/strong&gt; 遍历。&lt;/p&gt;
&lt;p&gt;假设我们mock一下假数据👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;输入: [1,null,2,3]
   1
    \
     2
    /
   3
输出: [1,3,2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么根据我们对前序遍历的理解，我们可以写出解题伪代码👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;//   TianTianUp
//   * function TreeNode(val, left, right) {
//   *     this.val = (val===undefined ? 0 : val)
//   *     this.left = (left===undefined ? null : left)
//   *     this.right = (right===undefined ? null : right)
//   * }
let preorderTraversal  = (root, arr = []) =&amp;gt; {
    if(root) {
      arr.push(root.val)
      preorderTraversal(root.left, arr)
      preorderTraversal(root.right, arr)
    }
    return arr
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本👇&lt;/p&gt;
&lt;p&gt;对于非递归的话，我们需要借助一个数据结构去存储它的节点，需要使用的就是栈，它的思路可以借鉴👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点为目标节点，开始向它子节点遍历&lt;/li&gt;
&lt;li&gt;1.访问目标节点&lt;/li&gt;
&lt;li&gt;2.左孩子入栈 -&amp;gt; 直至左孩子为空的节点&lt;/li&gt;
&lt;li&gt;3.节点出栈，以右孩子为目标节点，再依次执行1、2、3&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;  let preorderTraversal = (root, arr = []) =&amp;gt; {
    const stack = [], res = []
    let current = root
    while(current || stack.length &amp;gt; 0) {
      while (current) {
        res.push(current.val)
        stack.push(current)
        current = current.left
      }
      current = stack.pop()
      current = current.right
    }
    return res
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;中序遍历&lt;/h3&gt;
&lt;p&gt;给定一个二叉树，返回它的中序 遍历。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [1,null,2,3]
1
&lt;br /&gt;
2
/
3&lt;/p&gt;
&lt;p&gt;输出: [1,3,2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进阶: 递归算法很简单，你可以通过迭代算法完成吗？&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;递归版本👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const inorderTraversal  = (root, arr = []) =&amp;gt; {
  if(root) {
    inorderTraversal(root.left, arr)
    arr.push(root.val)
    inorderTraversal(root.right, arr)
  }
  return arr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本，这里就不解释了，跟前序遍历一样，思路一样，用栈维护节点信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const inorderTraversal = (root, arr = []) =&amp;gt; {
  const stack = [], res = []
  let current = root
  while(current || stack.length &amp;gt; 0) {
    while (current) {
      stack.push(current)
      current = current.left
    }
    current = stack.pop()
    res.push(current.val)
    current = current.right
  }
  return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;后续遍历&lt;/h3&gt;
&lt;p&gt;给定一个二叉树，返回它的 后序 遍历。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [1,null,2,3]&lt;br /&gt;
1
&lt;br /&gt;
2
/
3&lt;/p&gt;
&lt;p&gt;输出: [3,2,1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进阶: 递归算法很简单，你可以通过迭代算法完成吗？&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;递归版本👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const postorderTraversal  = (root, arr = []) =&amp;gt; {
  if(root) {
    postorderTraversal(root.left, arr)
    postorderTraversal(root.right, arr)
    arr.push(root.val)
  }
  return arr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本👇&lt;/p&gt;
&lt;p&gt;其实，嗯，做完前面两个后，会发现都是有套路滴~&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const postorderTraversal = (root, arr = []) =&amp;gt; {
  const stack = [], res = []
  let current = root, last = null  // last指针记录上一个节点
  while(current || stack.length &amp;gt; 0) {
    while (current) {
      stack.push(current)
      current = current.left
    }
    current = stack[stack.length - 1]
    if (!current.right || current.right == last) {
      current = stack.pop()
      res.push(current.val)
      last = current
      current = null              // 继续弹栈
    } else {
      current = current.right
    }
  }
  return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/"&gt;二叉树的层次遍历 ⭐⭐&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/"&gt;二叉树的层序遍历&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给你一个二叉树，请你返回其按 &lt;strong&gt;层序遍历&lt;/strong&gt; 得到的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;p&gt;示例：
二叉树：[3,9,20,null,null,15,7],&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;/ &lt;br /&gt;
9  20
/  &lt;br /&gt;
15   7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回其层次遍历结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[
[3],
[9,20],
[15,7]
]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;递归版本👇&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const levelOrder = function(root) {
  if(!root) return []
  let res = []
  dfs(root, 0, res)
  return res
}

function dfs(root, step, res){
  if(root){
      if(!res[step]) res[step] = []
      res[step].push(root.val)
      dfs(root.left, step + 1, res)
      dfs(root.right, step + 1, res)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非递归版本👇&lt;/p&gt;
&lt;p&gt;这里借助的就是队列这个数据结构，先进先出的机制。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const levelOrder = (root) =&amp;gt; {
  let queue = [], res = []
  if (root) queue.push(root);
  while (queue.length) {
      let next_queue = [],
          now_res = []
      while (queue.length) {
          root = queue.shift()
          now_res.push(root.val)
          root.left &amp;amp;&amp;amp; next_queue.push(root.left)
          root.right &amp;amp;&amp;amp; next_queue.push(root.right)
      }
      queue = next_queue
      res.push(now_res)
  }
  return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;题目汇总&lt;/h2&gt;
&lt;p&gt;还是那句话，题目做不完的，剩下的就靠刷leetcode了，我还准备了一些常见的二叉树题集，题目的质量还是不错的👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/"&gt;二叉树的最小深度⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/"&gt;二叉树的最大深度⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/same-tree/"&gt;相同的树⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/range-sum-of-bst/"&gt;二叉搜索树的范围和⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/symmetric-tree/"&gt; 对称二叉树⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/"&gt;将有序数组转换为二叉搜索树⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/"&gt;二叉树的层次遍历 II⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/"&gt;二叉树的最近公共祖先⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/validate-binary-search-tree/"&gt;验证二叉搜索树⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/path-sum-iii/"&gt;路径总和 III⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/contains-duplicate-iii/"&gt;存在重复元素 III⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/"&gt;计算右侧小于当前元素的个数⭐⭐⭐&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;❤️ 感谢大家&lt;/h2&gt;
&lt;p&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关注公众号&lt;strong&gt;前端UpUp&lt;/strong&gt;，联系作者👉 &lt;strong&gt;DayDay2021&lt;/strong&gt; ，我们一起学习一起进步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6872115031501340679"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6888451657504391181"&gt;「算法与数据结构」Trie树之美&lt;/a&gt;（200+👍）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6885104477297344525"&gt;「算法与数据结构」分治算法之美&lt;/a&gt;（190+👍）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6861376131615227912"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6856546833025237006"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6874708801208254478"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6882394656148045838"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6850418120755494925"&gt;「算法与数据结构」链表的9个基本操作(190+👍)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description><author>TianTianUp</author><pubDate>Mon, 02 Nov 2020 16:06:16 GMT</pubDate></item><item><title>「算法与数据结构」Trie树之美</title><link>https://juejin.cn/post/6888451657504391181</link><description>&lt;section id="nice" style="padding: 0 10px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px;"&gt;&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这次分享的Trie字典树，是数据结构专题中的一个分支，认识了解Trie这种树型数据结构，对构建算法与数据结构知识体系有一定的帮助。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;我对Trie树的理解：把字符串都串接起来，消灭不必要的存储，利用的就是字符串的公共前缀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;其实对于它的理解，你理解了这句话即可👇&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高。&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;如果你还不了解什么是Trie数据结构的话，或者知道一些，但是对于它具体是如何实现一个简单Trie树时，那么这篇文章可能适合你阅读。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么围绕以下几个点来展开介绍Trie树👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;基本概念&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;基本性质&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;应用场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;2个例题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;基本概念&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;首先，我们对Trie树得做一些基本的了解。Trie树中文名叫字典树，前缀树等，接下来我就以字典树称呼。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;我们来看下维基百科对它的描述吧⬇️&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;在&lt;a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;计算机科学&lt;/a&gt;中，&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;trie&lt;/strong&gt;，又称&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;前缀树&lt;/strong&gt;或&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;字典树&lt;/strong&gt;，是一种有序&lt;a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;树&lt;/a&gt;，用于保存&lt;a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;关联数组&lt;/a&gt;，其中的键通常是&lt;a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;字符串&lt;/a&gt;。与&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;二叉查找树&lt;/a&gt;不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的&lt;a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;前缀&lt;/a&gt;，也就是这个节点对应的字符串，而根节点对应&lt;a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;空字符串&lt;/a&gt;。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;朴实无华的描述，其实我们看一张图就能看明白了~，我在网上找了一张不错的图，具体的出处，这里就不补充了，因为实在找不到原作者~&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="字典树图解1" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80d94807ec494830b8d7945a153883e9~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;字典树图解1&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这里需要说明的内容就是，一般而言，&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;应该是用一个点来表示一个字符&lt;/strong&gt;，这里为了更好的说明，所以我就是&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;用边来描述字符&lt;/strong&gt;。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;可以发现，这棵字典树用边来代表字母，而&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;从根结点到树上某一结点的路径就代表了一个字符串&lt;/strong&gt;。举个例子， 1→2→6表示的就是字符串 &lt;code&gt;aba&lt;/code&gt; 。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;再比如，&lt;code&gt;1→4→8&lt;/code&gt;构成的字符串是&lt;code&gt;ca&lt;/code&gt;，那么如果在往下拓展的话，我们是不是有 &lt;code&gt;caa&lt;/code&gt;,&lt;code&gt;cab&lt;/code&gt;，那么他们都会经过&lt;code&gt;1→4→8&lt;/code&gt;，这些路径，说明他们是有一段公共的前缀，这个前缀的内容就是&lt;code&gt;ca&lt;/code&gt;，说道这里，我们就知道字典树利用的就是字符串的前缀来解决问题。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么具体它有哪些性质的话，我们下文介绍一下~&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;基本性质&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;对于上述概念有了一定的理解后，我们接下来就看下Trie树的基本性质。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;可以根据这个，大体上分成三个点来说👇&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;根节点不包含字符，除根节点外，每个节点只包含一个字符。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;每个节点的所有子节点包含的字符串不相同。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;接下来我们可以稍微分析一下，可以结合一个图来看看👇&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;我们通过拿how,hi,her,hello,so,see这6个字符串构造出来的就是下面图这个样子。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="图解Trie树" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a834aa9e63ff47248f6fe0ec5f03bc4d~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;图解Trie树&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;（图片出处不明，网上引用处太多~）&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;第一个性质：&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;从图中也可以看出，根节点是&lt;code&gt;/&lt;/code&gt;, 代表的内容也就是空，其他的节点比如，根节点下一个层级，有 &lt;code&gt;h&lt;/code&gt;和&lt;code&gt;s&lt;/code&gt;，分别代表的是两个字符。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;第二个性质：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;比如&lt;code&gt;how&lt;/code&gt;表示的就是一个字符串，&lt;code&gt;hi&lt;/code&gt;,也表示的是一个字符串，可是你会不会好奇，&lt;code&gt;he&lt;/code&gt;和&lt;code&gt;hel&lt;/code&gt;为什么不能表示一个字符串呢？&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;当你想到这里的话，说明你已经看得很仔细，马上就要掌握它了，确实，从图中看，我们会发现有些节点颜色不同，这是因为，我们预定好以这个深色的节点代表当前是一个字符串的结尾，想一想，这样子的作用是啥？&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么实际代码中，我们应该如何去约定或者做个标记呢，其实只要设置一个标记位即可。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;比如下面这样子👇&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;const&lt;/span&gt; TrieNode = &lt;span class="hljs-function" style="line-height: 26px;"&gt;&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;function&lt;/span&gt; (&lt;span class="hljs-params" style="line-height: 26px;"&gt;&lt;/span&gt;) &lt;/span&gt;{
&lt;span&gt;  &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;this&lt;/span&gt;.next = &lt;span class="hljs-built_in" style="color: #e6c07b; line-height: 26px;"&gt;Object&lt;/span&gt;.create(&lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;null&lt;/span&gt;)
&lt;span&gt;  &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;this&lt;/span&gt;.isEnd = &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;false&lt;/span&gt;
&lt;span&gt;};
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;当前的isEnd变量就表示当前的节点是不是结束串，当isEnd为True时，表示从根节点开始，到这个字符，所构成的字符串是存在的，是一个完整的字符串。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;第三个性质：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;每个节点的所有子节点包含的字符串不相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;很明显，我们从根节点开始，依次往下走，会发现，每个节点下面的节点是不相同的，所以依次组成的字符串不可能相同。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;应用场景&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;对Trie树，有一定了解后，我们就可以看看它有哪些的实际应用场景了。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这里参考的是网上所提供的几个点👇&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;在搜索引擎中关键词提示，引擎会自动弹出匹配关键词的下拉框，这种应用场景大家应该都很熟悉。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="下拉框" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d770fe23422402bb052c28d083535d7~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;下拉框&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;那么应该如何利用一种高效的数据结构存储呢，这里就符合字典树的性质，所以可以利用字典树来构造特定的数据，达到一种更加快速检索的效果。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;字符串检索&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率，可以举例子说明情况👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;词频统计&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;给定很长的一个串，统计频数出现次数最多情况，举个例子👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;字符串最长公共前缀&lt;/strong&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;到现在，我们应该知道，Trie树利用多个字符串的公共前缀来节省存储空间，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀，所以可以利用这个特点来解决一些前缀问题。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;非要举个例子的话，有个例子👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;应用场景还是有很多的，剩下的可以自行去探索，接下来，我们通过实际的题目来看看，如何构造字典树吧~&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;2个例子&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;接下来，我们通过二个题目作为例子，来看看字典树在实际应用可以解决哪些问题👇&lt;/p&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 16px; font-weight: bold; display: inline-block; margin-left: 8px; color: rgb(60,112,198);"&gt;&lt;a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;词典中最长的单词⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;词典中最长的单词&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;若无答案，则返回空字符串。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;示例 1：&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;输入：
&lt;span&gt;words = [&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"w"&lt;/span&gt;,&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wo"&lt;/span&gt;,&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wor"&lt;/span&gt;,&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"worl"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"world"&lt;/span&gt;]
&lt;span&gt;输出：&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"world"&lt;/span&gt;
&lt;span&gt;解释： 
&lt;span&gt;单词&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"world"&lt;/span&gt;可由&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"w"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wo"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"wor"&lt;/span&gt;, 和 &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"worl"&lt;/span&gt;添加一个字母组成。
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;示例 2：&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;输入：
&lt;span&gt;words = [&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"a"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"banana"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"appl"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"ap"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apply"&lt;/span&gt;, &lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;]
&lt;span&gt;输出：&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;
&lt;span&gt;解释：
&lt;span&gt;&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apply"&lt;/span&gt;和&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;都能由词典中的单词组成。但是&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;的字典序小于&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apply"&lt;/span&gt;。
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;提示：&lt;/p&gt;
&lt;span class="span-block-equation" style="cursor: pointer;"&gt;&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" class="equation" src="https://juejin.cn/equation?tex=%E6%89%80%E6%9C%89%E8%BE%93%E5%85%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E5%8F%AA%E5%8C%85%E5%90%AB%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E3%80%82words%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E8%8C%83%E5%9B%B4%E4%B8%BA[1,1000]%E3%80%82words[i]%E7%9A%84%E9%95%BF%E5%BA%A6%E8%8C%83%E5%9B%B4%E4%B8%BA[1,30]%E3%80%82" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;/figure&gt;&lt;/span&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-word-in-dictionary
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这题无非就是找到一个最长的单词，可以拆分成words数组中某一部分，最暴力的思路就是去枚举每一项，但是这样子的时间复杂度是巨大的， 这个时候，我们是不是可以思考一下，这个问题有哪些地方是共性的呢？&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;没错，就是前缀是相同的，从这点来看，是不是就可以利用这个前缀树，把它数据存储下来&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;然后遍历一遍这课树，只要这颗树只有一个分支，则表示它有解，如果存在两个分支以上的话，则无答案。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;复杂度分析&lt;/p&gt;
&lt;span class="span-block-equation" style="cursor: pointer;"&gt;&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" class="equation" src="https://juejin.cn/equation?tex=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9AO(\sum%20w_i)%E3%80%82w_i%20%E6%8C%87%E7%9A%84%E6%98%AF%20words[i]%E7%9A%84%E9%95%BF%E5%BA%A6%E3%80%82" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;/figure&gt;&lt;/span&gt;
&lt;span class="span-block-equation" style="cursor: pointer;"&gt;&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="" class="equation" src="https://juejin.cn/equation?tex=%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9AO(\sum%20w_i)%EF%BC%8C%E5%89%8D%E7%BC%80%E6%A0%91%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E3%80%82" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;/figure&gt;&lt;/span&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这点应该很好理解，这里就跳过了。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这里的话，我的解法构造字典树，当然了，也有其他的解法，这里就不展开了，可以看下我得代码噢～&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="最长的串" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7376b352a77643f7b988899f6fa070a8~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;最长的串&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/Tire%E6%A0%91/leetcode-%E5%AD%97%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D.js" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;代码点这里&lt;/a&gt;☑️&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;其实你会发现，构造一个Trie树的话，是很消耗空间的，有点空间换时间的意思，所以具体得根据实际的题目来解决问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 16px; font-weight: bold; display: inline-block; margin-left: 8px; color: rgb(60,112,198);"&gt;&lt;a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;实现Trie（前缀树）⭐⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;
&lt;p style="padding-bottom: 8px; padding-top: 23px; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;实现 Trie (前缀树)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;示例:&lt;/p&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;Trie trie = new Trie();
&lt;span&gt;trie.insert(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;);
&lt;span&gt;trie.search(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"apple"&lt;/span&gt;);   // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;true&lt;/span&gt;
&lt;span&gt;trie.search(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;);     // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;false&lt;/span&gt;
&lt;span&gt;trie.startsWith(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;); // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;true&lt;/span&gt;
&lt;span&gt;trie.insert(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;);   
&lt;span&gt;trie.search(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;"app"&lt;/span&gt;);     // 返回 &lt;span class="hljs-literal" style="color: #56b6c2; line-height: 26px;"&gt;true&lt;/span&gt;
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;说明:&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;你可以假设所有的输入都是由小写字母 a-z 构成的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;保证所有输入均为非空字符串。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr /&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;这个题目就是典型的写Trie树，对于第一次写这个题目的话，如果没有思路的话，可以尝试先看看别人的代码，看看基本的&lt;code&gt;套路&lt;/code&gt;在哪里。&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;话不多说，可以参考这份代码，可以看看如何构造一颗字典树👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="leetcode-实现Trie树" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c61a33b0a184bc1984e1452916d0b4d~tplv-k3u1fbpfcp-watermark.image" style="display: block; margin: 0 auto; border-radius: 4px; margin-bottom: 25px;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;"&gt;leetcode-实现Trie树&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/Tire%E6%A0%91/leetcode-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AATrie%E6%A0%91.js" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;剩下的删除操作，还有统计字符串出现的频率，可以自己来实现一下，这个基本上不难，画个图，就知道如何实现啦～&lt;/p&gt;
&lt;hr /&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;题目是做不完的，做完这些题目后，希望你能对Trie字典树有所认识，能对它有更加深入的理解~，接下来准备了四道题集，希望对你们有帮助~&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;词典中最长的单词&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;实现 Trie (前缀树)&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/word-search-ii/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;单词搜索 II&lt;/a&gt;&lt;/p&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;&lt;a href="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;Loading question&lt;/a&gt;&lt;/p&gt;
&lt;h2 style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-position: center center; background-size: 63px; margin-top: 38px; margin-bottom: 10px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: rgb(60, 112, 198); background-position: left center; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;"&gt;❤️ 感谢大家&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em;"&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;关注公众号&lt;strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);"&gt;前端UpUp&lt;/strong&gt;，联系作者，遇到问题的话，欢迎打扰我，我们一起探讨一起进步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6885104477297344525" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」回溯算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;「算法与数据结构」分治算法之美(180+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p class="nice-suffix-juejin-container" id="nice-suffix-juejin-container" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 23px; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;"&gt;本文使用 &lt;a href="https://mdnice.com/?from=juejin" style="font-weight: bold; color: rgb(60, 112, 198); text-decoration: none; border-bottom: 1px solid rgb(60, 112, 198);"&gt;mdnice&lt;/a&gt; 排版&lt;/p&gt;&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Tue, 27 Oct 2020 15:53:48 GMT</pubDate></item><item><title>「算法与数据结构」分治算法之美</title><link>https://juejin.cn/post/6885104477297344525</link><description>&lt;section id="nice"&gt;&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这次分享的内容是，经典算法思想-分治，你可以把它称之为一种思想，也可以叫它分治算法，为了更好的区分，接下来我们以&lt;strong style="color: #595959; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;分治法&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;来称呼它。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你还不了解什么是分治法，或者知道一些，但是对于它具体是如何实现&lt;code&gt;回溯&lt;/code&gt;，那么这篇文章可能适合你阅读。&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;我对分治算法的理解：&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;它的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;求出子问题的解，就可得到原问题的解，可以理解成一种分目标完成程序的算法。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;二分法很多时候，就是一种分治的思想。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么围绕以下几个点来展开介绍分治算法👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;基本思路&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;适用情况以及求解哪些经典问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;经典例题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;分治法基本思想&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;一句话，对分治法概括它的话👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;将原问题划分成n个规模较小而结构与原问题相似的子问题，递归去解决这些子问题，然后依次再合并其结果，最后得到原问题的解。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么具体的来说，我们似乎可以分成三个步骤👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;分解：将要解决的问题划分成若干规模较小的同类问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;解决：当子问题划分得足够小时，用较简单的方法解决。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;其实思想还是不变的，将一个难以直接解决的大问题，分割成一些小规模的相同问题，以便各个击破，分而治之。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;分治法适用情况&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;利用分治法求解一个问题，在于我们能否掌握分治法的几个特征：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;把一个问题可以缩小到一定程度，变成更小的问题来解决。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;分解成若干个小问题后，规模更小且是同类问题，这样子的话，该问题应该就是最优子结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;利用该问题分解出来的子问题的解，合并为该问题的解。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;分解出来的各个子问题是相互独立的，即子问题之间不包含公共的子问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那我们来说一说这几个特征吧~&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第一条特征：一个问题的计算复杂性一般是随问题的规模增加而增加的，所以绝大多数问题都满足。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第二条特征：应用分治法的前提是得满足它，你可以理解成它某种程度上反映了递归思想的应用。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第三条特征：这个应该就是分治法的关键了吧，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;了解分治法的特征，我们来看看有哪些经典的问题是利用这个思想来解决问题的👇&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;分治法求解经典问题&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;什么情况下，可以用该思路来求解呢，以下来自网上搜集的内容👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（1）二分搜索&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（2）大整数乘法&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（3）Strassen矩阵乘法&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（4）棋盘覆盖&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（5）合并排序&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（6）快速排序&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（7）线性时间选择&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（8）最接近点对问题&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（9）循环赛日程表&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;（10）汉诺塔&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我想提起的是合并（归并）排序，它完成照应分治法的思想，&lt;code&gt;分解大问题，解决各个规模小问题，最后合并&lt;/code&gt;，那我们来看看合并（归并）排序代码👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="归并排序" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05eb4f8501584bb494ac0029249ba9fd~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;归并排序&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于归并排序的思路，是如何实现的，之前的排序一章以及提及过，采用的是分治思路，可以看看是如何实现的，这里就不具体展开了。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;2个例子&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;接下来，我们通过三个题目作为例子，来看看怎么利用分治的思想来解决问题👇&lt;/p&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-subarray/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;最大子序和⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/maximum-subarray/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;最大子序和&lt;/a&gt;&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;示例:&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;进阶:&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先，我们看看能不能以O(n)复杂度解决这个问题，其实仔细想一想的话，我们可以通过一个简单&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;更多得是，我们这题尝试一下用分治法来解决这题。对于一个数组的最大子序和，它对答案的贡献，只能是以下几种情况👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;出现在左半边&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;出现在右半边&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;出现在中间，穿过中间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么我们是不是可以递归处理呢，对于出现在左边和出现在右边的答案，我们可以把它们当作是一种情况，然后递归去处理，当然了递归的出口，很显然，当递归的数组的长度为1时，我们需要递归结束。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于出现在中间答案的情况，我们可以通过计算来算出答案，所以思路理清楚， 接下来，我们看如何写👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="分治法求最大和" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72e2c3430d264166b61cc8f7fa66be8e~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;分治法求最大和&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，这题用动态规划思路更好求解，也更加得好理解👇&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;//dp[i]表示nums中以nums[i]结尾的最大子序和&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;
&lt;p&gt;&lt;img alt="动态规划求连续和" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167f14786b934fbf95201d6d8b8d4f48~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/p&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;动态规划求连续和&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/leetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%82%E8%A7%A3%E8%BF%9E%E7%BB%AD%E6%9C%80%E5%A4%A7%E5%92%8C.js" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;h3 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;搜索二维矩阵 II⭐⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;搜索二维矩阵 II&lt;/a&gt;&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
示例:&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;现有矩阵 matrix 如下：&lt;/p&gt;
&lt;blockquote class="multiquote-1" style="display: block; font-size: 0.9em; overflow: auto; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; border-left: none;"&gt;&lt;span style="color: #DEC6FB; font-size: 34px; line-height: 1; font-weight: 700;"&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;[
[1,   4,  7, 11, 15],
[2,   5,  8, 12, 19],
[3,   6,  9, 16, 22],
[10, 13, 14, 17, 24],
[18, 21, 23, 26, 30]
]&lt;/p&gt;
&lt;span style="float: right; color: #DEC6FB;"&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定 target = &lt;code&gt;5&lt;/code&gt;，返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定 target = &lt;code&gt;20&lt;/code&gt;，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/search-a-2d-matrix-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这题的题目很清晰👉矩阵的每行从左到右是升序， 每列从上到下也是升序，在矩阵中查找某个数。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当然了，我们有一个简单的思路👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;维护两个指针（row,col),找到目标元素时，我们就放回true&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;当指向当前的元素值小于target时，我们就col++，向上移动一行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;如果当前的值大于当前的target，我们就row--，向左移动一列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;知道col &amp;gt; 矩阵的行，或者row &amp;lt; 0时，我们直接return false，表示不存在。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;时间复杂度：O(n+m)&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;时间复杂度分析的关键是注意到在每次迭代（我们不返回 true）时，行或列都会精确地递减/递增一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;由于行只能减少 m 次，而列只能增加 n次，因此在导致 while 循环终止之前，循环不能运行超过 n+m 次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;因为所有其他的工作都是常数，所以总的时间复杂度在矩阵维数之和中是线性的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;根据以上的伪代码，我们基本上就能解出这个题目👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="二维矩阵求值" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5a9a8aa6a847ddaf57a6faf7e01e94~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #595959;"&gt;二维矩阵求值&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这样子的解法，简单且容易理解，其实这并不是真正意义上的二分，只是根据数据的特殊性，使用特定的搜索方式完成对矩阵的查找。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;既然一维数组查某个值时，我们可以将复杂度降为&lt;code&gt;log&lt;/code&gt;级别的时间复杂度，那么在二维的情况下，我们是不是也可以这么考虑呢?&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这个思路，可以借鉴一下👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;我们可以迭代矩阵对角线，二分搜索这些行和列，对它们进行切片。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;在对角线上迭代，二分搜索行和列，知道对角线上的迭代元素用完为止（这个时候，就可以放回true或者是false）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;说得更加简单一些，二分查找的思想是沿着对角线，行查找一下，列查找一下。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可以借鉴一下代码，就会明白如何利用矩阵的对角线去分治。&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/175cd11798554cf3b23d1b0371430230~tplv-k3u1fbpfcp-watermark.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/leetcode-%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%B1%82%E5%80%BC.js" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none; border-top: 2px solid #d9b8fa;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;理清楚分治法思路，对它的特征有了一定的了解，明白何如利用它解决实际的问题，那或许这就是这篇文章的意义所在吧~&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;题目汇总&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;题目不多，但是对于基本的入门分治法，应该还是不错的选择👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://leetcode-cn.com/problems/maximum-subarray/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;最大子序和&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://leetcode-cn.com/problems/contiguous-sequence-lcci/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;连续数列&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://leetcode-cn.com/problems/qie-fen-shu-zu/" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;切分数组&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; color: #595959;"&gt;❤️ 感谢大家&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;关注公众号&lt;strong style="color: #595959; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;前端UpUp&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，联系作者👉 &lt;strong style="color: #595959; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;DayDay2021&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; ，我们一起学习一起进步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;「算法与数据结构」带你看回溯算法之美(190+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p class="nice-suffix-juejin-container" id="nice-suffix-juejin-container" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #595959; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; margin-top: 20px !important;"&gt;本文使用 &lt;a href="https://mdnice.com/?from=juejin" style="text-decoration: none; color: #664D9D; font-weight: normal;"&gt;mdnice&lt;/a&gt; 排版&lt;/p&gt;&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Sun, 18 Oct 2020 15:24:24 GMT</pubDate></item><item><title>「算法与数据结构」带你看回溯算法之美</title><link>https://juejin.cn/post/6882394656148045838</link><description>&lt;section id="nice"&gt;&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;前言&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;这次梳理的是回溯算法，掌握它的解决问题思路，对很多搜索尝试问题，都会在日后学习工作中有所帮助。&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;我对回溯算法有一定理解：回溯算法建立在DFS基础之上的，但不同的是在搜索的过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索，因此我们可以这样子理解，回溯算法与DFS的区别就是有无状态重置。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你还不了解什么是回溯算法，或者知道一些，但是对于它具体是如何实现&lt;code&gt;回溯&lt;/code&gt;，那么这篇文章可能适合你阅读。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;那么围绕以下几个点来展开介绍回溯算法👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;来源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;基本思路&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;算法框架&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;经典例题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一起探讨问题。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;回溯算法的来源&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先，我们得明白啥叫回溯算法，它的由来是什么。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;根据维基百科给出的定义👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;用回溯算法解决问题的一般步骤：&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;1、 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;2 、确定易于搜索的解空间结构,使得能用&lt;code&gt;回溯法&lt;/code&gt;方便地搜索整个解空间 。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;3 、以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;用更加简单的话术来解释的话👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;回溯法可以理解成为通过选择不同的岔路口，来寻找目的地，一个岔路口一个岔路口的去尝试找到目的地，如果走错了路的话，继续返回到上一个岔路口的另外一条路，直到找到目的地。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;基本思路&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先，我们得明确这个回溯算法的思路是什么，有了思路，我们才可以根据这个思路写出伪代码，有了伪代码之后，根据实际的问题，写出相应的解决方案。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我们可以把这类回溯问题，看成是解决一个决策树的遍历过程，这样子也方便我们接下来的解释👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;基本思路：&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;从决策树的一条路开始走，能进则进，不能进则退回来，换一条路试一试。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;举个例子来说，还是拿八皇后问题来解释：&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;第一步按照顺利，也就是在第一行，我们放置第一个皇后。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;第二步，我们需要在第二行放置一个皇后，我们需要遍历，将符合要求的位置放置皇后。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;第三步，也就是在第三行，我们需要去遍历，找到符合的位置，如果都没有符合要求，我们就需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销第二步操作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，那么需要改变第二个皇后位置，重新放置第二个皇后位置，直到满足第三个皇后放置的位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;当你改变第二个皇后位置后，都无法满足第三个皇后位置的时候，我们就需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销第一步操作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，重新去放置第一个皇后位置，然后按照顺序完成后续操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我们可以通过另外一个例子来看，也就是回溯在迷宫搜索中也很常见，简单来说，就是这条路走不通的话，我们就需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销上个操作&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，返回前一个路口，继续下一条路。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;似乎你已经发现了，回溯说到底就是&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;穷举法&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，但是如果你只是单纯的穷举的话，不剪枝的话，时间复杂度是巨大的，那么如何剪枝呢？&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我们将回溯优化的方法可以称之为剪枝，或者是剪枝函数，通过这个函数，我们可以减去一些状态，剪去一些不可能到达（&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;最终状态&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;），这里说的最终状态，可以认为是答案状态，这样子的话，就减少了部分空间树节点的生成，具体如何剪枝的话，可以根据做题经验多加练习，这里就不张开了。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;算法框架&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;其实刷了一定的题量，你会发现，对于这种回溯思路而言，都是有一定的套路的，那么接下来就给出伪代码👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;接下来是自己的一点理解，觉得按照这个步骤来的话，也好理解一些👇&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;可以按照3个步骤来思考这类的问题：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;路径&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：记录做出的选择。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;选择列表&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：通常而言，用数组存储可以选择的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;结束条件&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：一般而言，就是递归的结束点，也就是搜索的结束点。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;pre class="custom"&gt;&lt;span&gt;&lt;/span&gt;&lt;code class="hljs"&gt;result = []
&lt;span&gt;
&lt;span&gt;&lt;span class="hljs-function" style="line-height: 26px;"&gt;&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;function&lt;/span&gt; &lt;span class="hljs-title" style="color: #61aeee; line-height: 26px;"&gt;backtrack&lt;/span&gt;(&lt;span class="hljs-params" style="line-height: 26px;"&gt;路径, 选择列表&lt;/span&gt;) &lt;/span&gt;{
&lt;span&gt;    &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;if&lt;/span&gt;(&lt;span class="hljs-string" style="color: #98c379; line-height: 26px;"&gt;'满足结束条件'&lt;/span&gt;) {
&lt;span&gt;        &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 这里就是对答案做更新,依据实际题目出发&lt;/span&gt;
&lt;span&gt;        result.push(路径)
&lt;span&gt;        &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;return&lt;/span&gt;
&lt;span&gt;    } &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;else&lt;/span&gt; {
&lt;span&gt;        &lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;for&lt;/span&gt;(&lt;span class="hljs-keyword" style="color: #c678dd; line-height: 26px;"&gt;let&lt;/span&gt; i = &lt;span class="hljs-number" style="color: #d19a66; line-height: 26px;"&gt;0&lt;/span&gt;; i &amp;lt; 选择列表.length; i++) {
&lt;span&gt;            &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 对一个选择列表做相应的选择&lt;/span&gt;
&lt;span&gt;            
&lt;span&gt;            做选择
&lt;span&gt;            
&lt;span&gt;            backtrack(路径, 选择列表)
&lt;span&gt;            
&lt;span&gt;            &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 既然是回溯算法,那么在一次分岔路做完选择后&lt;/span&gt;
&lt;span&gt;            &lt;span class="hljs-comment" style="color: #5c6370; font-style: italic; line-height: 26px;"&gt;// 需要回退我们之前做的操作&lt;/span&gt;
&lt;span&gt;            
&lt;span&gt;            撤销选择
&lt;span&gt;        }
&lt;span&gt;    }
&lt;span&gt;}
&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;做过类似的题目都知道，核心的处理就是for循环里面的递归操作，每次在递归之前，&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;做选择&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，在这种方案结束后，我们需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;撤销选择&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，这样子的话，就不会影响同一层决策树的其他选择。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;举个例子，在走迷宫这类题型中，我们需要不断的去搜索，去试探答案，这个过程就是一个回溯算法的过程，每次要走下一个格子的时候，我们需要先将这个格子&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;做个标记&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，代表这个格子已经走过，然后在往后继续搜索...&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;当这个方案不合理的时候，我们是不是需要将之前标记的格子清除标记呢？仔细想一想的话，这样子是非常合理的，在当前方案行不通的时候，我们要将这个&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;步骤撤销掉&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于以上的基础知识，有了一定了解，接下来我们就通过这么基础知识来解决问题。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;怎么样写回溯&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;做一些题目后，对回溯算法有初步认识后，我觉得可以参考下面的步骤来刻意练习👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;首先画出递归树，找到状态变量（这里可以理解成回溯函数参数）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;确定递归出口，一般根据具体题目条件而言。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;找准选择列表（一般而言与函数参数有关）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;剪枝，对于一些情况而言，可以适当剪枝。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;做出选择，递归调用，进入下一层。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;撤销选择。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;我觉得这个对回溯算法的总结，是挺不错的，可以借鉴下。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;2个例子&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;接下来，我们通过三个题目作为例子，来看看怎么根据我们之前提及的&lt;code&gt;算法框架&lt;/code&gt;来解决问题👇&lt;/p&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;&lt;a href="https://leetcode-cn.com/problems/letter-case-permutation/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字母大小写全排列⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/letter-case-permutation/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字母大小写全排列&lt;/a&gt;&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;示例：&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入：S = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入：S = "3z4"
输出：["3z4", "3Z4"]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入：S = "12345"
输出：["12345"]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;提示：&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;S 的长度不超过12。
S 仅由数字和字母组成。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/letter-case-permutation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;嗯，这题的话，可以通过画图举个例子来说，我这里就借鉴网上的图了👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="字母全排列" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93b6631eb83447609f909fea94d63c9f~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;字母全排列&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;对于数字而言的话，我们直接跳过，字母的话，无非就是两种状态，大小写字母，那么我们就有接下来的思路👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;遇到数字的话，不会涉及新的分支，我们就直接往后搜，这样子的话，对于数字就只需要搜索一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;对于单个字母而言，我们需要&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;搜索2次&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，小写字母搜索一次，大写字母搜索一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;我们可以去维护一个index，遇到数字的话，index+1，继续递归，遇到字母的话，需要递归两次，假设当字母是小写时，我们递归一次(index+1),然后回溯时将字母转为大写，又去递归一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;递归尽头：即搜索完整个字符串为止，我们前面维护的index，这个时候就可以作为条件判断。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;按照这个思路走的话，我们就可以写出完整的解题代码&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;代码👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="回溯算法代码-1" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05057b7c673b46ae9956fddcf4b0e900~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;回溯算法代码-1&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-%E5%AD%97%E6%AF%8D%E5%85%A8%E6%8E%92%E5%88%97.js" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h3 style="padding: 0px; color: black; font-size: 17px; font-weight: bold; text-align: center; margin-top: 20px; margin-bottom: 20px;"&gt;&lt;span class="prefix" style="display: none;"&gt;&lt;/span&gt;&lt;span class="content"&gt;&lt;span&gt;&lt;/span&gt;&lt;a href="https://leetcode-cn.com/problems/subsets/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集🐍⭐⭐&lt;/a&gt;&lt;/span&gt;&lt;span class="suffix" style="display: none;"&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;链接：&lt;a href="https://leetcode-cn.com/problems/subsets/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集&lt;/a&gt;&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;说明：解集不能包含重复的子集。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;示例:&lt;/p&gt;
&lt;blockquote class="multiquote-1"&gt;&lt;span&gt;❝&lt;/span&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; margin: 0px; line-height: 26px; color: #595959;"&gt;输入: nums = [1,2,3]
输出:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/subsets
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;做这类题目的时候，不太懂的话，可以先画图，从上面的题来看，我们可以画类似一个树的结构，然后看看如何去遍历这个决策树，看看能不能剪枝，直接借鉴一下网上的图👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="子集的递归树" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5f58298bf1f4f8d859b368d39fdcf60~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;子集的递归树&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;其实把这个图画出来，你应该就成功一半了，从这个图来看，我们似乎又可以去遍历这颗树。&lt;/p&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;首先我们得把我们思路整理一下👇&lt;/p&gt;
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;这题肯定是求树的所有节点！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;对这颗树而言，我们可以遍历它的分支，选择其中一个分支，然后继续向下操作，不选这个分支的话，选择另外一个分支又是另外一个情况，所以每次枚举下一个数字的时候,也就是两种选择：选或不选。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;可以考虑使用一个index指针来记录&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;节点&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的状态,即当前递归考察的数字&lt;code&gt;nums[index]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;递归结束的条件： index === nums.length, 这个时候代表考察完所有的数字，把当前的子集加入题解，结束当前递归分支。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;每次结束一个分支，即结束递归，需要撤销当前的选择，（从list中删除），回到选择前的状态，做另外一个选择，即不选择当前的数字，往下递归，继续生成子集。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;根据以上的伪代码，我们基本上就能解出这个题目👇&lt;/p&gt;
&lt;figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex;"&gt;&lt;img alt="回溯算法题解-2" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6a5cbcfe7eb465a802faccea3ef20ab~tplv-k3u1fbpfcp-zoom-1.image" style="border-radius: 6px; display: block; margin: 20px auto;" /&gt;&lt;figcaption style="margin-top: 5px; text-align: center; display: block; font-size: 13px; color: #2b2b2b;"&gt;&lt;span&gt;&lt;/span&gt;回溯算法题解-2&lt;/figcaption&gt;&lt;/figure&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;&lt;a href="https://github.com/daydaylee1227/Blog/blob/master/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-%E5%AD%90%E9%9B%86.js" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;代码点这里☑️&lt;/a&gt;&lt;/p&gt;
&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;题目是做不完的，做完这些题目后，希望你能找出回溯算法的规律，能对它有更加深入的理解~，接下来准备了些题集，希望对你们有帮助~&lt;/p&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;进阶题目汇总&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;以下是我在网上看到一套不错的回溯算法题集，如果你还在刻意找的话，可以看看这里。&lt;/p&gt;
&lt;section class="table-container"&gt;&lt;table style="display: table; text-align: left;"&gt;
&lt;thead&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"&gt;
&lt;th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; color: #595959;"&gt;类型&lt;/th&gt;
&lt;th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; color: #595959;"&gt;题目链接&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody style="border: 0;"&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;子集，组合&lt;/td&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/subsets/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/subsets-ii/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;子集 II&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/combinations/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;组合&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/combination-sum/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;组合总和&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/combination-sum-ii/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;组合总和 II&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;"&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;全排列&lt;/td&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/permutations/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;全排列&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/permutations-ii/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;全排列 II&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字符串的全排列&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/letter-case-permutation/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;字母大小写全排列&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style="border: 0; border-top: 1px solid #ccc; background-color: white;"&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;搜索&lt;/td&gt;
&lt;td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959;"&gt;&lt;a href="https://leetcode-cn.com/problems/sudoku-solver/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;解数独&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/word-search/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;单词搜索&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/eight-queens-lcci/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;N皇后&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/palindrome-partitioning/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;分割回文串&lt;/a&gt;、&lt;a href="https://leetcode-cn.com/problems/binary-watch/" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;二进制手表&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/section&gt;&lt;hr style="margin: 0; margin-top: 10px; margin-bottom: 10px; height: 1px; padding: 0; border: none;" /&gt;
&lt;h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block;"&gt;&lt;span class="prefix"&gt;&lt;/span&gt;&lt;span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;"&gt;❤️ 感谢大家&lt;/span&gt;&lt;span class="suffix"&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px;"&gt;如果你觉得这篇内容对你挺有有帮助的话：&lt;/p&gt;
&lt;ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;点赞支持下吧，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;关注公众号&lt;strong style="color: #3594F7; font-weight: bold;"&gt;&lt;span&gt;「&lt;/span&gt;前端UpUp&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，联系作者，我们一起学习一起进步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;觉得不错的话，也可以阅读TianTian近期梳理的文章（感谢掘友的鼓励与支持🌹🌹🌹）：
&lt;ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959;"&gt;
&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6872115031501340679" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」一张脑图带你看动态规划算法之美&lt;/a&gt;（370+👍）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6861376131615227912" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」DFS和BFS算法之美&lt;/a&gt;(240+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6856546833025237006" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」梳理6大排序算法&lt;/a&gt;(220+👍)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"&gt;&lt;a href="https://juejin.cn/post/6874708801208254478" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;「算法与数据结构」带你看哈希算法之美(210+👍)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;
&lt;p class="nice-suffix-juejin-container" id="nice-suffix-juejin-container" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; margin-top: 20px !important;"&gt;本文使用 &lt;a href="https://mdnice.com/?from=juejin" style="text-decoration: none; color: #40B8FA; font-weight: normal;"&gt;mdnice&lt;/a&gt; 排版&lt;/p&gt;&lt;/section&gt;</description><author>TianTianUp</author><pubDate>Sun, 11 Oct 2020 08:11:57 GMT</pubDate></item><item><title>所见即所得 —— HTML转图片组件开发</title><link>https://juejin.cn/post/7153410606673395725</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="伟豪.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6546c8b2768040829a7667de22ff7830~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 160 篇不掺水的原创，想获取更多原创好文，请搜索公众号【政采云前端团队】关注我们吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在我们日常开发中一定会遇到&lt;code&gt;"所见即所得"&lt;/code&gt;的需求，如导出查询表格中的内容为Excel表格——&lt;a href="https://juejin.cn/post/7030291455243452429"&gt;《前端导出Excel，让后端刮目相看》&lt;/a&gt;、通过后台网页配置实现配置预览页与实际页面展示的统一——&lt;a href="https://juejin.cn/post/6937257727106220040"&gt;《从零开发一款可视化大屏制作平台》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;今天我们也来实现一个"所见即所得"的需求：将用户所见网页提取为图片。&lt;/p&gt;
&lt;p&gt;&lt;img alt="2C0714D1-BBEB-4810-8C64-F66963489F9D.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/946b0753eb2c4e87ad73f3fbeafa1034~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;方案1：最短步骤实现结果&lt;/h2&gt;
&lt;p&gt;第一个想到的方案就是通过浏览器自带的网页另存为图片去实现。&lt;/p&gt;
&lt;p&gt;&lt;img alt="68630441-5C95-4594-AFB1-CDE4C6F1B348.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c060bfc087148f397b0db5013012234~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;但这种方法显然是不可行的。第一需要提示用户操作进行繁琐的操作，第二无法达到局部提取为图片的效果。&lt;/p&gt;
&lt;h2&gt;方案2：达成初步可行方案&lt;/h2&gt;
&lt;p&gt;通过调研发现，可以使用 &lt;a href="http://html2canvas.hertzen.com/"&gt;html2canvas&lt;/a&gt; 将网页先转换为 &lt;code&gt;canvas&lt;/code&gt;数据。再将其转换为图片的方法，最终实现我们想要的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20221011134318.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a77d7bf291740349a16c0cca4e30ade~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;引入html2canvas&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cnpm install --save html2canvas
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;div class="box"&amp;gt;
    &amp;lt;!-- 将可保存为图片的内容 通过一个 标签 框起来 --&amp;gt;
    &amp;lt;div id="screenshot-box"&amp;gt;
      &amp;lt;!-- 内容可以随意 --&amp;gt;
      &amp;lt;p&amp;gt;名称：&amp;lt;a-input v-model="formState.name" /&amp;gt;&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;年龄：&amp;lt;a-input v-model="formState.age" /&amp;gt;&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        班级：
        &amp;lt;a-radio-group v-model="formState.class"&amp;gt;
          &amp;lt;a-radio value="1"&amp;gt;班级1&amp;lt;/a-radio&amp;gt;
          &amp;lt;a-radio value="2"&amp;gt;班级2&amp;lt;/a-radio&amp;gt;
        &amp;lt;/a-radio-group&amp;gt;
      &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;a-button  @click="onSaveCanvas"&amp;gt;保存为图片&amp;lt;/a-button&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 点击保存为Canvas
    onSaveCanvas(){
       // 这里的类名要与点击事件里的一样
        const canvas = document.querySelector('#screenshot-box');
        let that = this;
        html2canvas(canvas,{scale:2,logging:false,useCORS:true}).then(function(canvas) {
          const type = 'png';
          let imgData = canvas.toDataURL(type);
          // 图片格式处理
          let _fixType = function(type) {
          type = type.toLowerCase().replace(/jpg/i, 'jpeg');
          let r = type.match(/png|jpeg|bmp|gif/)[0];
          return 'image/' + r;
        };
            imgData = imgData.replace(_fixType(type),'image/octet-stream');
            let filename = "htmlImg" + '.' + type;
            // 保存为文件
            //  以bolb文件下载
 that.downFileToLocal(filename,that.convertBase64ToBlob(imgData))
        });
    },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此我们便实现了初步的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="1.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dec5e02062c74cba8d889df06ca8c900~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;当然，我们也可以设置一个预览图片来预览我们将要导出的图片。&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;img :src="previewPic" alt="预览图片"&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;this.previewPic = URL.createObjectURL(that.convertBase64ToBlob(imgData));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;展示效果&lt;/p&gt;
&lt;p&gt;&lt;img alt="A9A4712D-B30C-452E-A610-9F5ACF492162.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02bbb33f4bef4f5cbe2929f51b8bbbad~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;将方案进行拓展并升级&lt;/h2&gt;
&lt;p&gt;需求止步于此，但秉承着"将事情做的更好"的我们岂能止步于此。&lt;/p&gt;
&lt;h3&gt;实现HTML导出为Word&lt;/h3&gt;
&lt;p&gt;我们需要通过 html-docx 来实现导出为Word（&lt;strong&gt;导出Word目前只支持原生HTML + CSS&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;引入html-docx&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cnpm install --save html-docx-js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;div id="export-word"&amp;gt;
      &amp;lt;table border &amp;gt;
        &amp;lt;tr&amp;gt;
          &amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;
          &amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
          &amp;lt;td&amp;gt;贾维斯&amp;lt;/td&amp;gt;
          &amp;lt;td&amp;gt;2&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
      &amp;lt;/table&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;a-button  @click="onWordExport"&amp;gt;导出为word&amp;lt;/a-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;onWordExport(){
        var contentHtml = document.getElementById("export-word").innerHTML;
        const cssHTML = `table {
                          width: 200px;
                          border: 1px solid #ccc;
                          color:red;
                        }`
        var content = `&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;
            &amp;lt;head&amp;gt;
                &amp;lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&amp;gt;
                &amp;lt;style&amp;gt;
                    ${cssHTML}
                &amp;lt;/style&amp;gt;
            &amp;lt;/head&amp;gt;
            &amp;lt;body&amp;gt;
                ${contentHtml}
            &amp;lt;/body&amp;gt;
            &amp;lt;/html&amp;gt;`
        var converted = htmlDocx.asBlob(content,{orientation:"landscape"});
        this.downFileToLocal('word文件名.docx',converted)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;展示效果&lt;/p&gt;
&lt;p&gt;&lt;img alt="2.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c25207348094464b8aed24cfdb0cbd05~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;如此我们便实现了导出 HTML 为 Word。&lt;/p&gt;
&lt;h3&gt;实现HTML导出为PDF&lt;/h3&gt;
&lt;p&gt;目前市面上 HTML 导出 PDF 的实现方式有多种，如&lt;a href="https://github.com/parallax/jsPDF"&gt;jsPDF&lt;/a&gt;、&lt;a href="https://blog.csdn.net/weixin_43897590/article/details/124729389"&gt;iText&lt;/a&gt;、&lt;a href="https://github.com/wkhtmltopdf/wkhtmltopdf"&gt;wkhtmltopdf&lt;/a&gt;等。在不同情况下我们应该使用不同的解决方案：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方案&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;th&gt;分页&lt;/th&gt;
&lt;th&gt;图片&lt;/th&gt;
&lt;th&gt;表格&lt;/th&gt;
&lt;th&gt;链接&lt;/th&gt;
&lt;th&gt;中文&lt;/th&gt;
&lt;th&gt;特殊字符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;jsPDF&lt;/td&gt;
&lt;td&gt;1、整个过程在客户端执行(不需要服务器参与)，调用简单&lt;/td&gt;
&lt;td&gt;1、生成的pdf为图片形式，且内容失真&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iText&lt;/td&gt;
&lt;td&gt;1、功能基本可以实现，比较灵活 2、生成pdf质量较高&lt;/td&gt;
&lt;td&gt;1、对html标签严格，少一个结束标签就会报错；2、后端实现复杂，服务器需要安装字体；3、图片渲染比较复杂&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wkhtmltopdf&lt;/td&gt;
&lt;td&gt;1、调用方式简单；2、生成pdf质量较高&lt;/td&gt;
&lt;td&gt;1、服务器需要安装wkhtmltopdf环境；2、根据网址生成pdf，对于有权限控制的页面需要在拦截器进行处理&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;今天我们使用在&lt;strong&gt;客户端执行&lt;/strong&gt;(不需要服务器参与)的方式——jsPDF。&lt;/p&gt;
&lt;p&gt;导入jsPDF&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install --save jspdf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt; &amp;lt;a-button  @click="onPDFExport"&amp;gt;导出为PDF&amp;lt;/a-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 导出为PDF
    onPDFExport(){
      const canvas = document.querySelector('#screenshot-box');
      html2canvas(canvas).then(function(canvas) {
        let contentWidth = canvas.width;
            let contentHeight = canvas.height;
            //一页pdf显示html页面生成的canvas高度;
            let pageHeight = contentWidth / 592.28 * 841.89;
            //未生成pdf的html页面高度
            let leftHeight = contentHeight;
            //页面偏移
            let position = 0;
            //a4纸的尺寸[595.28,841.89]，html页面生成的canvas在pdf中图片的宽高
            let imgWidth = 595.28;
            let imgHeight = 592.28/contentWidth * contentHeight;

            let pageData = canvas.toDataURL('image/jpeg', 1.0);

            let pdf = new jsPDF('', 'pt', 'a4');

            //有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)
            //当内容未超过pdf一页显示的范围，无需分页
            if (leftHeight &amp;lt; pageHeight) {
              pdf.addImage(pageData, 'JPEG', 0, 0, imgWidth, imgHeight );
            } else {
              while(leftHeight &amp;gt; 0) {
                  pdf.addImage(pageData, 'JPEG', 0, position, imgWidth, imgHeight)
                  leftHeight -= pageHeight;
                  position -= 841.89;
                  //避免添加空白页
                  if(leftHeight &amp;gt; 0) {
                    pdf.addPage();
                  }
              }
            }
            pdf.save('content.pdf');
      })
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;展示效果&lt;/p&gt;
&lt;p&gt;&lt;img alt="3.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77defcda66bd45269560301574d7fde8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;如此我们便实现了导出 HTML 为 PDF。&lt;/p&gt;
&lt;h2&gt;将功能封装为组件&lt;/h2&gt;
&lt;p&gt;实现一次HTML导出图片需要写的代码太多，很多参数也需要按需定制。是否能够将其封装成组件呢？&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;a href="https://v2.cn.vuejs.org/v2/api/#v-slot"&gt;Vue的插槽&lt;/a&gt;将我们导出的内容进行插入&lt;/p&gt;
&lt;h3&gt;完整组件&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-HTML"&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class="box"&amp;gt;
    &amp;lt;!-- 将可保存为图片的内容 通过一个 标签 框起来 --&amp;gt;
    &amp;lt;div :id="id"&amp;gt;
        &amp;lt;!-- 需要导出的内容 --&amp;gt;
        &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
//引入html2canvas
import html2canvas from 'html2canvas';
export default {
  name: "Html2Image",
  props: {
    id: { // id
      type: String,
      default: 'export-box',
    },
    filename: { // 导出文件名称
      type: String,
      default: 'htmlPic',
    },
    outType:{ // 导出类型
      type: String,
      default: 'png',
      validator(value) {
        return ['png', 'jpg', 'bmp','jpeg','gif'].includes(value)
      }
    },
    isFile: { // 是否为导出文件
      type: Boolean,
      default: false,
    },
    
  },
  methods: {
    //点击保存为Canvas
    onSaveCanvas(){
       // 这里的类名要与点击事件里的一样
        const canvas = document.querySelector(`#${this.id}`);
        let that = this;
        html2canvas(canvas,{scale:2,logging:false,useCORS:true}).then(function(canvas) {
          const type = that.outType;
          let imgData = canvas.toDataURL(type);
          
          // 图片格式处理
          let _fixType = function(type) {
            type = type.toLowerCase().replace(/jpg/i, 'jpeg');
            let r = type.match(/png|jpeg|bmp|gif/)[0];
            return 'image/' + r;
          };
          imgData = imgData.replace(_fixType(type),'image/octet-stream');
          if(!that.isFile){
              const retn = URL.createObjectURL(that.convertBase64ToBlob(imgData))
              that.$emit('onExport',retn)
              return retn
          }
          //  以bolb文件下载
          that.downFileToLocal(that.filename + '.' + type,that.convertBase64ToBlob(imgData))
        });
    },
    // base64转化为Blob对象
    convertBase64ToBlob(imageEditorBase64) {
      let base64Arr = imageEditorBase64.split(",");
      let imgtype = "";
      let base64String = "";
      if (base64Arr.length &amp;gt; 1) {
        //如果是图片base64，去掉头信息
        base64String = base64Arr[1];
        imgtype = base64Arr[0].substring(
          base64Arr[0].indexOf(":") + 1,
          base64Arr[0].indexOf(";")
        );
      }
      // 将base64解码
      let bytes = atob(base64String);
      //let bytes = base64;
      let bytesCode = new ArrayBuffer(bytes.length);
      // 转换为类型化数组
      let byteArray = new Uint8Array(bytesCode);
 
      // 将base64转换为ascii码
      for (let i = 0; i &amp;lt; bytes.length; i++) {
        byteArray[i] = bytes.charCodeAt(i);
      }
      // 生成Blob对象（文件对象）
      return new Blob([bytesCode], { type: imgtype });
    },
    // 下载Blob流文件
    downFileToLocal(fileName, blob) {
      // 创建用于下载文件的a标签
      const d = document.createElement("a");
      // 设置下载内容
      d.href = URL.createObjectURL(blob);
      // 设置下载文件的名字
      d.download = fileName;
      // 界面上隐藏该按钮
      d.style.display = "none";
      // 放到页面上
      document.body.appendChild(d);
      // 点击下载文件
      d.click();
      // 从页面移除掉
      document.body.removeChild(d);
      // 释放 URL.createObjectURL() 创建的 URL 对象
      window.URL.revokeObjectURL(d.href);
    },
  },
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Attributes&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;唯一ID，盒子内容将作为导出内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;filename&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;导出的文件名称（不带文件类型后缀）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;outType&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;导出文件类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isFile&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;是否导出为文件，true将下载文件，false返回bolb路径&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Methods&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;onSaveCanvas&lt;/td&gt;
&lt;td&gt;执行导出或保存方法&lt;/td&gt;
&lt;td&gt;若isFile为true则保存文件，若isFile为false则返回bolb路径&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Events&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;onExport&lt;/td&gt;
&lt;td&gt;导出方法&lt;/td&gt;
&lt;td&gt;当触发导出/下载时会触发该方法输出 Bolb路径 类型String&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;使用组件&lt;/h3&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;Html2Image ref="html2Image" @onExport="exportPic" &amp;gt;
      &amp;lt;div class="export-content" style="border: 1px solid #F0F;width:200px"&amp;gt;
        &amp;lt;div&amp;gt;1&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;2&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;3&amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/Html2Image&amp;gt;
&amp;lt;a-button  @click="onExportImgByComponent"&amp;gt;组件导出为图片&amp;lt;/a-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 引入组件
import Html2Image from '@/components/Html2Image/Html2Image.vue'
// 使用组件
components: { 
    Html2Image
},

// methods
onExportImgByComponent(){
      this.previewPicComponent =this.$refs.html2Image.onSaveCanvas()
    },
exportPic(baseUrl){
       // 赋值导出图片的blob路径
      this.previewPicComponent = baseUrl;
    },  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Q&amp;amp;A&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Q.为什么外网图片展示不出?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="7BFD5507-2620-4EEB-A4AF-144F63441CD8.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36068e8ea46442fca4e0527ca3fa42f6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A: 设置 html2canvas 方法中 useCORS 为 true 即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="AC53AB9C-170A-4CF8-8F1B-2C7724EDC3F6.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8296ccb966454ebfb835e28d46404673~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;最后要说的&lt;/h2&gt;
&lt;p&gt;项目地址: &lt;a href="https://github.com/FireSmallPanda/vuexDemo.git"&gt;https://github.com/FireSmallPanda/vuexDemo.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTML导出为图片组件地址:&lt;a href="https://github.com/FireSmallPanda/vuexDemo/tree/master/src/components/ImageUpload"&gt;HTML导出为图片组件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据需求目前只封装了HTML导出为图片，相信大家可以依葫芦画瓢将导出Word和PDF也一并封装为组件。&lt;/p&gt;
&lt;h2&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/liuzemtx/article/details/109307540"&gt;《前端实现将页面保存成图片功能》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/xiao970615/article/details/126305092"&gt;《base64字串转Blob文件流，Blob文件流再下载到本地》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gitcode.net/mirrors/linwalker/render-html-to-pdf?utm_source=csdn_github_accelerator"&gt;《render-html-to-pdf》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/lisheng19870305/article/details/124158191"&gt;《HTML页面导出为PDF》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://landscape.tuchong.com/"&gt;外网图片来源——《风光摄影精选》&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7145604963593355277"&gt;探索组件在线预览和调试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7143025612267978760"&gt;规范升级 NPM 包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7140422304920109092"&gt;你想知道的前后端协作规范都在这了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7135217402983235592"&gt;带你了解 Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7132628898453880840"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 11 Oct 2022 16:07:23 GMT</pubDate></item><item><title>探索组件在线预览和调试</title><link>https://juejin.cn/post/7145604963593355277</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="梓安.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0f54a21fcf14baa85523b4ccbba2a52~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 159 篇不掺水的原创，想获取更多原创好文，请搜索公众号【政采云前端团队】关注我们吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;前端人员在开发过程中，如何快速&lt;strong&gt;感知&lt;/strong&gt;到组件的功能和属性？现状是通过阅读组件相关文档，好在基础组件库的文档相对完整和清晰，手动补全示例。业务组件相关文档目前只能在内部 NPM 私库上查看，静态的 API 文档，没有组件的 Demo。对于非前端人员，如何预览和调试组件呢？比如：某一天，产品想提前调研其它业务线的业务组件功能能否满足业务诉求；业务组件开发完成，测试和设计可以介入组件相关功能的验证；运营人员可以在低代码搭建平台，预览和调试相关组件等。&lt;/p&gt;
&lt;p&gt;基于以上痛点问题，我们从需求点出发，逐步探索实现方案。&lt;/p&gt;
&lt;h2&gt;需求&lt;/h2&gt;
&lt;h3&gt;场景分析&lt;/h3&gt;
&lt;h4&gt;功能&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;组件预览&lt;/li&gt;
&lt;li&gt;组件调试 面向不同的用户群体，组件功能调试的交互分为两种，一种是&lt;strong&gt;代码调试&lt;/strong&gt;，即通过代码编辑器修改示例代码，另一种是组件 &lt;strong&gt;schema 调试&lt;/strong&gt;，通过 schema JSON 数据来描述组件的属性，然后 通过 schema 渲染器渲染成组件属性面板，这样非研发人员也可以方便的调试组件功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;分类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基础组件&lt;/li&gt;
&lt;li&gt;业务组件&lt;/li&gt;
&lt;li&gt;低代码组件 大致整理了下：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="组件预览和调试-组件分类-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08984f1dad7d4d50b3ab0a58ccfa16ac~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;这里的&lt;strong&gt;低代码组件&lt;/strong&gt;是指提供给低代码搭建平台使用的自定义组件，目前公司的低代码搭建平台主要有“鲁班”，对此感兴趣的小伙伴可以翻一下往期关于 &lt;strong&gt;“鲁班”&lt;/strong&gt; 的文章。&lt;/p&gt;
&lt;p&gt;针对组件&lt;strong&gt;schema 调试&lt;/strong&gt;，低代码组件本身自带 schema 文件，如：“鲁班”自定义组件会有一份 schema.json 文件，需要开发者去编写和维护这份文件。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
 &amp;nbsp;"props": {
 &amp;nbsp; &amp;nbsp;"linkList": {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;"group": "链接配置",
 &amp;nbsp; &amp;nbsp; &amp;nbsp;"title": "链接列表",
 &amp;nbsp; &amp;nbsp; &amp;nbsp;"type": "array",
 &amp;nbsp; &amp;nbsp; &amp;nbsp;"fields": [
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"name": "imageAddress",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"title": "图链接图片地址",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"type": "string"
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  },
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"name": "imageLink",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"title": "链接跳转地址",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"type": "string"
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  } &amp;nbsp; 
 &amp;nbsp; &amp;nbsp;  ]
 &amp;nbsp;  }
  },
 &amp;nbsp;"models": {
 &amp;nbsp; &amp;nbsp;"linkList": [
 &amp;nbsp; &amp;nbsp;  {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"imageAddress": "",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"imageLink": ""
 &amp;nbsp; &amp;nbsp;  },
 &amp;nbsp; &amp;nbsp;  {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"imageAddress": "",
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"imageLink": ""
 &amp;nbsp; &amp;nbsp; &amp;nbsp; }
 &amp;nbsp;  ]
  } &amp;nbsp; 
}
​
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，业务组件也需要同一份 schema 协议的 JSON 文件，这样就可以动态调试组件的属性。但是，不会让开发组件的同学去手动编写。&lt;/p&gt;
&lt;p&gt;自动生成 schema 文件大致思路：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件在线预览和调试-自动生成 schema 文件-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44db4b0c13c34831872c27bf7ea8b22c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;应用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基础组件的示例在线预览和调试&lt;/li&gt;
&lt;li&gt;业务组件的 Demo 在线预览和调试&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;面向人群&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;研发&lt;/li&gt;
&lt;li&gt;非研发：产品、测试、运营 研发主要用到组件的调试功能，而像运营和产品这样非研发人员，他们的诉求简单快捷，就是直接预览该组件，并且可以通过修改组件的 props 看到实时效果，那么问题来了，如何修改组件当前的 props 属性？玩过低代码的同学应该很清楚，有个组件&lt;strong&gt;属性面板&lt;/strong&gt;。基于以上，我们可能需要代码编辑面板、组件属性面板以及组件功能模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大致画了下页面的结构图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件在线预览和调试-界面图-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd38c6f6cf1449d7a3787312587e0124~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;调研&lt;/h2&gt;
&lt;h3&gt;市面上成熟的产品&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Stackblitz 一款非常优秀的在线 IDE，移植了很多 VS Code 的功能和特性。目前支持了很多框架模版，如：React、Angular、Vue3、Next.js、Nuxt3 及自定义模版等，其中， StackBlitz 提供的 WebContainers 可以在浏览器端运行 Node.js 环境。&lt;/li&gt;
&lt;li&gt;CodeSandbox 为 Web 应用程序而开发而构建的在线编辑器，同样也提供了多种模版方便开发者使用。大部分核心代码也开源了，网上也有相关的原理解析和搭建在线 IDE 方案的资料，有兴趣的同学可以去看看。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;需求和应用场景已经很明确了，考虑到不同的用户群体，交互方式也有差别，重点是组件调试功能的差异性，对于研发人员可通过代码编辑器去修改代码达到调试效果，非研发人员则通过修改属性面板的组件属性值。而市面上的成熟产品会提供一些设计思路，具体实现方案下面会细讲。&lt;/p&gt;
&lt;h2&gt;方案&lt;/h2&gt;
&lt;p&gt;从页面结构图，我们先聊下代码编辑器、组件属性面板、工具栏、预览区的设计方案。&lt;/p&gt;
&lt;h4&gt;代码编辑器&lt;/h4&gt;
&lt;p&gt;目前主流的有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MonacoEditor&lt;/li&gt;
&lt;li&gt;Codemirror MonacoEditor 相对来说功能强大，集成度高，但随之带来的是比较重，而 Codemirror 轻量小巧，核心文件压缩后仅 70+ KB 左右，根据所需要支持的语言按需打包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种代码编辑器都能满足我们的需求，在线修改一些组件 Demo 的部分代码，其实 Codemirror 够用了。&lt;/p&gt;
&lt;h4&gt;组件属性面板&lt;/h4&gt;
&lt;p&gt;了解低代码搭建平台的朋友应该很熟悉了，其实就是通过表单去动态修改组件的属性参数，因此，需要一份通用的 schema 协议，来描述组件的自定义属性。可以由&lt;strong&gt;鲁班&lt;/strong&gt;和大数据搭建平台那边提供 schema 数据，我们负责渲染即可。&lt;/p&gt;
&lt;p&gt;大致列了下组件属性的类型和操作表单类型的对应关系：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件预览和调试-属性面板-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30bc75c06daa4ec1a76c4c17c4617fc2~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;工具栏&lt;/h4&gt;
&lt;p&gt;工具栏包含的主要功能有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;账号登陆&lt;/li&gt;
&lt;li&gt;接口代理 业务组件和低代码组件需要被调试时，比如测试人员需要介入测试组件功能，需要用到&lt;strong&gt;账号登陆&lt;/strong&gt;和&lt;strong&gt;接口代理功能&lt;/strong&gt;。组件内涉及到业务接口的请求头需要携带当前登陆用户的 token 信息，先通过请求 oauth 接口拿到对应的 token，然后塞到请求头的 Authorization 字段上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面实现的前提是需要一个代理服务，在本地开发环境我们可以用 &lt;strong&gt;http-proxy&lt;/strong&gt;插件创建本地代理服务，那么问题来了，在浏览器端如何做代理服务？&lt;/p&gt;
&lt;p&gt;目前主流的方案都是通过 Chrome 插件形式，需要用户手动填写代理接口等信息。在我们的场景下，这个方案对用户体验显然不够友好。还有个方案可以利用浏览器的黑科技 —— &lt;strong&gt;Service Worker&lt;/strong&gt;，它可以拦截网页发出的请求，并能自定义返回内容，相当于在浏览器内部实现了一个反向代理。&lt;/p&gt;
&lt;h4&gt;预览区&lt;/h4&gt;
&lt;p&gt;核心会涉及到两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器&lt;/li&gt;
&lt;li&gt;通信 容器是指页面容器，业界通用做法都是通过 iframe，将编译好的组件代码挂载到 iframe 里一个 root 节点上，主要有环境隔离和动态生成预览页面的访问链接作用。编辑器、核心包、预览区之间的通信可以用 postMessage。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通信时序图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件预览和调试-通信.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d3c6df9ec5e494ebc6559c25d467036~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;核心包&lt;/h4&gt;
&lt;p&gt;设计思路，主要参考了 CodeSandbox 的核心源码，主要涉及到代码转译和代码执行。核心模块有 Manger、Transpiler、Preset、Transpiled-module、Runtime。&lt;/p&gt;
&lt;p&gt;架构图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件预览和调试架构图-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c1842b6b80e446dbe3d62debd4e314a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;大致流程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="组件在线预览和调试-核心包流程图-导出.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4de5229d7f9747138764c3d681c04d13~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;Manger 模块&lt;/h4&gt;
&lt;p&gt;顾名思义“管理者“，即管理其它核心模块，主要负责代码转译和执行的一系列过程。&lt;/p&gt;
&lt;p&gt;核心方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addTranspiledModule&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resolveTranspiledModuleSync&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resolveTranspiledModuleAsync&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;evaluateTranspiledModule&lt;/code&gt; 首先将转译后的模块缓存起来放到 &lt;code&gt;transpiledModules&lt;/code&gt; 对象 ，需要的话可以从缓存里同步或异步加载转译后的模块，如果需要执行转译的模块，可以调用 &lt;code&gt;evaluateTranspiledModule&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;transpiledModules&lt;/code&gt; 的类型定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type IModule = {
 &amp;nbsp;path: string;
 &amp;nbsp;url?: any;
 &amp;nbsp;code: string;
 &amp;nbsp;requires?: Array&amp;lt;string&amp;gt;;
 &amp;nbsp;parent?: Module;
};
​
interface ITranspiledModules {
 &amp;nbsp;  [path: string]: {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;module: IModule;
 &amp;nbsp; &amp;nbsp; &amp;nbsp;tModules: {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  [query: string]: ITranspiledModule; // ITranspiledModule 类型定义放在 Transpiled-module 模块
 &amp;nbsp; &amp;nbsp;  };
 &amp;nbsp;  };
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Transpiler 模块&lt;/h4&gt;
&lt;p&gt;类比 Webpack 的 loader，对指定类型的文件进行编译，如：Babel、Typescript、vue、tsx、jsx 等。&lt;/p&gt;
&lt;p&gt;介绍下部分内置的 Transpiler 模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;babelTranspiler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stylesTranspiler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rawTranspiler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noopTranspiler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vueTranspiler&lt;/code&gt; &lt;code&gt;rawTranspiler&lt;/code&gt; 跟 Webpack 的 raw-loader 作用一样，将模块的内容作为字符串导入，从而实现静态资源内联。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现原理也很简单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = JSON.stringify(sourceCode)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;babelTranspiler&lt;/code&gt; 这里实现了简化版，script 标签引入 bable-standalone.js，拿到全局对象 Babel。&lt;/p&gt;
&lt;p&gt;部分核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import babelPluginRenameImports from './plugins/babel-plugin-rename-imports';
​
const transpiledCode = window.Babel.transform(code, {
 &amp;nbsp;plugins: [babelPluginRenameImports],
 &amp;nbsp;presets: ['es2015', 'es2016', 'es2017'],
}).code;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vueTranspiler&lt;/code&gt; ，这里默认是 vue2.0 版本，核心依赖了 &lt;code&gt;vue-template-compiler&lt;/code&gt;、&lt;code&gt;vue-template-es2015-compiler&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;将 vue 单文件组件转换为 SFC 对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as compiler from 'vue-template-compiler';
import type {SFCDescriptor} from 'vue-template-compiler';
​
const sfc:SFCDescriptor = compiler.parseComponent(content, { pad: 'line' });
​
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解析 Vue template 部分核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import * as compiler from 'vue-template-compiler';
import transpile from 'vue-template-es2015-compiler'; &amp;nbsp; 
 &amp;nbsp;
function vueTemplateCompiler(html, options) {
 &amp;nbsp;const bubleOptions = options.buble;
 &amp;nbsp;const vueOptions = options.vueOptions || {};
 &amp;nbsp;const userModules = vueOptions.compilerModules || options.compilerModules;
 &amp;nbsp;const stripWith = bubleOptions.transforms.stripWith !== false;
 &amp;nbsp;const { stripWithFunctional } = bubleOptions.transforms;
 &amp;nbsp;const staticRenderFns = compiled.staticRenderFns.map((fn) =&amp;gt; 
 &amp;nbsp; &amp;nbsp; toFunction(fn, stripWithFunctional)
  ); // 静态渲染函数放到数组中
 &amp;nbsp;const compilerOptions: compiler.CompilerOptionsWithSourceRange = {
 &amp;nbsp; &amp;nbsp;preserveWhitespace: options.preserveWhitespace, // 是否保留HTML标记之间的所有空白字符
 &amp;nbsp; &amp;nbsp;modules: defaultModules.concat(userModules || []), // 自定义编译模版 
 &amp;nbsp; &amp;nbsp;directives: vueOptions.compilerDirectives || options.compilerDirectives || {}, // 自定义指令 
 &amp;nbsp; &amp;nbsp;comments: options.hasComment, // 是否保留注释
 &amp;nbsp; &amp;nbsp;scopeId: options.hasScoped ? options.id : null, / 
  };
  const compiled = compiler.compile(html, compilerOptions);
  
 &amp;nbsp;// 生成渲染函数和静态子树
  let code = transpile(
 &amp;nbsp;  'var render = ' +
 &amp;nbsp;    toFunction(compiled.render, stripWithFunctional) +
 &amp;nbsp; &amp;nbsp;'\n' +
 &amp;nbsp; &amp;nbsp;'var staticRenderFns = [' + 
      staticRenderFns.join(',') +
 &amp;nbsp; &amp;nbsp; ']') + '\n';
 &amp;nbsp; &amp;nbsp;// mark with stripped (this enables Vue to use correct runtime proxy detection)
 &amp;nbsp; &amp;nbsp;if (stripWith) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp;code += `render._withStripped = true\n`;
 &amp;nbsp;  }
​
 &amp;nbsp; &amp;nbsp;const exports = `{ render: render, staticRenderFns: staticRenderFns }`;
 &amp;nbsp; &amp;nbsp;code += `module.exports = ${exports}`;
 &amp;nbsp;
    return code;
}
​
function toFunction(code, stripWithFunctional) {
 &amp;nbsp;return 'function (' + (stripWithFunctional ? '_h,_vm' : '') + ') {' + code + '}';
}
​
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vue 在渲染阶段将模板编译为 AST，然后根据 AST 生成 render 函数，底层通过调用 render 函数会生成 VNode 创建虚拟 DOM。&lt;/p&gt;
&lt;h4&gt;Preset 模块&lt;/h4&gt;
&lt;p&gt;组件预设构建模版，针对不同组件的框架类型，如：Vue2、React 等，预设默认该类型组件所需的 &lt;code&gt;Transpiler&lt;/code&gt; 模块。类似于 vue-cli、create-react-app。&lt;/p&gt;
&lt;p&gt;核心方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;registerTranspiler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getTranspilers&lt;/code&gt; &lt;code&gt;registerTranspiler&lt;/code&gt; 作用是注册 Transpiler 模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;部分伪代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vuePreset.registerTranspiler(
  (module) =&amp;gt; /.(m|c)?jsx?$/.test(module.path),
  [{ transpiler: babelTranspiler }]
);
vuePreset.registerTranspiler(
  (module) =&amp;gt; /.vue$/.test(module.path),
  [{ transpiler: vueTranspiler }]
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Transpiled-module 模块&lt;/h4&gt;
&lt;p&gt;即转译后的模块，维护转译的结果、代码执行的结果、依赖的模块信息，负责驱动具体模块的转译(调用 Transpiler)和执行。&lt;/p&gt;
&lt;h4&gt;Runtime 模块&lt;/h4&gt;
&lt;p&gt;执行转译后的模块入口，使用 eval 执行入口文件，若遇到 require 函数，加载转译后的依赖模块然后使用 eval 执行执行。&lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export default function (
 &amp;nbsp;code: string,
 &amp;nbsp;require: Function,
 &amp;nbsp;module: { exports: any },
 &amp;nbsp;env: Object = {},
 &amp;nbsp;globals: Object = {},
  { asUMD = false }: { asUMD?: boolean } = {}
) {
 &amp;nbsp;const { exports } = module;
  
 &amp;nbsp;const g = typeof window === 'undefined' ? self : window;
 &amp;nbsp;const global = g;
 &amp;nbsp;g.global = global;
  
 &amp;nbsp;// 兼容 Node.js 环境，列举了一部分
 &amp;nbsp;const process = {
 &amp;nbsp; &amp;nbsp;env: { NODE_ENV: 'development', ...env },
 &amp;nbsp; &amp;nbsp;cwd: () =&amp;gt; { return '/' },
 &amp;nbsp; &amp;nbsp;umask: () =&amp;gt; { return 0 }
  };
 &amp;nbsp;
 &amp;nbsp;// 全局变量
 &amp;nbsp;const allGlobals: { [key: string]: any } = {
 &amp;nbsp; &amp;nbsp;require, // require 函数
 &amp;nbsp; &amp;nbsp;module,
 &amp;nbsp; &amp;nbsp;exports,
 &amp;nbsp; &amp;nbsp;process,
 &amp;nbsp; &amp;nbsp;global,
 &amp;nbsp; &amp;nbsp;...globals,
  };
​
 &amp;nbsp;// 是否 UMD 模块
 &amp;nbsp;if (asUMD) {
 &amp;nbsp; &amp;nbsp;delete allGlobals.module;
 &amp;nbsp; &amp;nbsp;delete allGlobals.exports;
 &amp;nbsp; &amp;nbsp;delete allGlobals.global;
  }
 &amp;nbsp;
 &amp;nbsp;const allGlobalKeys = Object.keys(allGlobals);
 &amp;nbsp;const globalsCode = allGlobalKeys.length ? allGlobalKeys.join(', ') : '';
 &amp;nbsp;const globalsValues = allGlobalKeys.map((k) =&amp;gt; allGlobals[k]);
 &amp;nbsp;
 &amp;nbsp;const newCode = `(function $csb$eval(` + globalsCode + `) {` + code + `\n})`;
  (0, eval)(newCode).apply(allGlobals.global, globalsValues);
​
}
​
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;从页面功能模块到组件的构建核心包设计，相信各位看官已经有了初步的了解。有两点没有提到，在这里简单补充下。&lt;/p&gt;
&lt;p&gt;第一点是依赖包的数据源问题，简单粗暴点就是创建 manifest 文件，事先预存一份底层通用的依赖包数据，如：Babel 插件相关等，如果需要动态添加依赖包，可以使用 import-maps 特性。&lt;/p&gt;
&lt;p&gt;第二点在 Transpiler 模块没有提到针对 react 组件的构建方案，添加相关 Babel 插件就好了，如：&lt;code&gt;transform-runtime&lt;/code&gt; 、&lt;code&gt;@babel/plugin-transform-react-jsx-source&lt;/code&gt; 等。&lt;/p&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;背景、需求、调研、方案这四个层面，其中背景和需求更多是从产品的角度去思考和设计，这样做出来的东西才更符合用户需求和提升用户体验。我们技术人员不仅仅只关心技术层面的设计，更多时候还要从产品的角度去思考。&lt;/p&gt;
&lt;p&gt;组件作为项目开发不可分割的一部分，从基础组件到业务组件，我们前端开发人员每天都在跟组件打交道。围绕着组件我们可以有很多专题，如何打造高质量组件？如何提升组件的复用率？如何提升组件的感知度？等等，贯穿组件的整个生命周期，那么如何治理好组件，需要我们共同努力和思考。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/codesandbox/codesandbox-client/tree/master/packages/sandpack-core"&gt;CodeSandbox 核心源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.yuque.com/wangxiangzhong/aob8up/nb1gp2"&gt;CodeSandbox浏览器端的webpack是如何工作的？&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7143025612267978760"&gt;规范升级 NPM 包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7140422304920109092"&gt;你想知道的前后端协作规范都在这了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7135217402983235592"&gt;带你了解 Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7132628898453880840"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 20 Sep 2022 15:18:36 GMT</pubDate></item><item><title>规范升级 NPM 包</title><link>https://juejin.cn/post/7143025612267978760</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="刘静.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a8a543e7ad456eb573501b05ff9796~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 158 篇不掺水的原创，想获取更多原创好文，请搜索公众号【政采云前端团队】关注我们吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在日常工作中，当组件跨项目使用时，我们往往会选择把组件抽成 npm 包。那么在 npm 开发以及发布的过程中有什么需要注意的事项吗？本文将从我自己的角度，来为大家介绍一下我认为的一些需要大家注意的点。&lt;/p&gt;
&lt;h2&gt;版本号规则&lt;/h2&gt;
&lt;p&gt;从日常的开发中我们可以看到，npm 包的版本号的格式都是 X.Y.Z。那么大家发布的 npm 包为什么都在遵循这个格式呢？这个格式其实是由 Gravatars 创办者兼 GitHub 共同创办者 &lt;a href="http://tom.preston-werner.com/"&gt;Tom Preston-Werner&lt;/a&gt; 所建立。由 GitHub 起草的统一的版本号表示规则，称为 Semantic Versioning(语义化版本表示)。这些规范具体包含的内容大家可以参考&lt;a href="https://semver.org/lang/zh-CN/"&gt;语义化版本 2.0.0&lt;/a&gt;。本文只针对我们开发中容易忽略的地方做一些详述。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;X 代表主版本号，也叫做大版本号&lt;/p&gt;
&lt;p&gt;升级大版本时意味着这个包可能做了颠覆性的改动，和低版本的包已经&lt;strong&gt;无法兼容&lt;/strong&gt;。每当主版本号递增时，次版本号和修订号必须归零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Y 代表次版本号，也叫做小版本号&lt;/p&gt;
&lt;p&gt;当做了&lt;strong&gt;向下兼容&lt;/strong&gt;的功能性新增时，升级小版本号。每当次版本号递增时，修订号必须归零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Z 代表修订号&lt;/p&gt;
&lt;p&gt;当做了&lt;strong&gt;向下兼容&lt;/strong&gt;的问题修正（bugfix）时， 升级修订号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;常见版本格式/引用方式&lt;/h2&gt;
&lt;table&gt;
   &lt;tbody&gt;&lt;tr&gt;
      &lt;td style="width: 130px;"&gt;版本引用方式&lt;/td&gt;
      &lt;td style="width: 90px;"&gt;版本号&lt;/td&gt;
      &lt;td&gt;匹配版本&lt;/td&gt;
      &lt;td&gt;解释&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;直接使用版本号&lt;/td&gt;
      &lt;td&gt;2.3.1&lt;/td&gt;
      &lt;td&gt;2.3.1&lt;/td&gt;
      &lt;td&gt;只可以匹配 2.3.1 这个版本，如果是比较重要的项目，建议用这种方式固定版本。&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td rowspan="3"&gt;^:不能修改版本号最左侧非零数字&lt;/td&gt;
      &lt;td&gt;^2.3.1&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 2.3.1 &amp;amp;&amp;amp; &amp;lt; 3.0.0&lt;/td&gt;
      &lt;td&gt;最左侧非零数字是 2&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;^0.3.1&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 0.3.1 &amp;amp;&amp;amp; &amp;lt; 0.4.0&lt;/td&gt;
      &lt;td&gt;最左侧非零数字是 3&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;^0.0.1&lt;/td&gt;
      &lt;td&gt; &amp;gt;= 0.01 &amp;amp;&amp;amp; &amp;lt; 0.02，即 0.01&lt;/td&gt;
      &lt;td&gt;最左侧非零数字是 1&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td rowspan="2"&gt;~:版本号列出 Y 时兼容 Z 的修改。列出 X 时兼容 Y、Z&lt;/td&gt;
      &lt;td&gt;~2.3.1&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 2.3.1 &amp;amp;&amp;amp; &amp;lt; 2.4.0&lt;/td&gt;
      &lt;td&gt;Y 为 3。～2.3 同理&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;～2&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 2.0.0 &amp;amp;&amp;amp; &amp;lt; 3.0.0&lt;/td&gt;
      &lt;td&gt;X 为 2&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td rowspan="3"&gt;*、X、x，空：表示可以匹配任何版本&lt;/td&gt;
      &lt;td&gt;"2.3.X"、"2.3.x"、"2.3*"、"2.3"&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 2.3.0 &amp;amp;&amp;amp; &amp;lt; 2.4.0&lt;/td&gt;
      &lt;td&gt;Z 可以为任意值&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;"2.X"、"2.x"、"2.*"、"2"&lt;/td&gt;
      &lt;td&gt;&amp;gt;= 2.0.0 &amp;amp;&amp;amp; &amp;lt; 3.0.0&lt;/td&gt;
      &lt;td&gt;Y、Z 为任意值&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;*、X、x，空&lt;/td&gt;
      &lt;td&gt;任意版本&lt;/td&gt;
      &lt;td&gt;任意版本指的是最新的正式版&lt;/td&gt;
   &lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;关于 npm 的版本格式还有许多，此处不再赘述。&lt;/p&gt;
&lt;p&gt;从上边的常用格式介绍可以看出来，在精确版本号的情况下，版本号是完全固定的，在项目发布时不会出现一些实际安装的包和 package.json 中版本号不一致的问题。或者如果使用方有用到 package-lock.json 文件来固定包的版本，也可以避免包的版本号导致的问题。&lt;/p&gt;
&lt;p&gt;但是在实际开发中，我们并不知道我们包的使用方是否使用的固定版本号或者 package-lock.json 文件，我们怎么做才能让使用方不受影响呢？&lt;/p&gt;
&lt;p&gt;这时候就要用到先行版本号了，下面我将为大家具体介绍。&lt;/p&gt;
&lt;h2&gt;先行版本&lt;/h2&gt;
&lt;p&gt;npm 的先行版本号，放到 X.Y.Z 的后边，作为延伸。被标上先行版本号则表示这个版本&lt;strong&gt;并非稳定&lt;/strong&gt;而且&lt;strong&gt;可能无法满足预期&lt;/strong&gt;的兼容性需求。例如：1.0.0-alpha.1，2.0.0-beta.1 等。一般常用的关键词有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;alpha：预览版，或者叫内部测试版；一般不向外部发布，会有很多bug（会不太稳定）；一般只有测试人员使用。&lt;/li&gt;
&lt;li&gt;beta：测试版，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在alpha版之后推出。&lt;/li&gt;
&lt;li&gt;rc(release candidate)：最终测试版本；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;先行版本升级规则&lt;/h4&gt;
&lt;p&gt;我们使用 &lt;code&gt;npm dist-tag ls @zcy/zcy-region-detail-back&lt;/code&gt; 查看 @zcy/zcy-region-detail-back 的 tag，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb7df6aa7692494a8c31d5044c76f1e1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到这个包有一个 beta 版，一个 latest 版。&lt;/p&gt;
&lt;p&gt;对比两个版本的名字可以发现，beta 版本是在 latest 版本的 Z 上加了 1 且添加了一个 beta 作为延伸。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果包只是对现有的问题进行修复，那么只需要对 Z 进行加 1，然后添加延伸。&lt;/li&gt;
&lt;li&gt;如果包本次是做&lt;strong&gt;向下兼容&lt;/strong&gt;的功能性新增，那么需要对 Y 进行加 1，Z 清零，然后添加延伸。&lt;/li&gt;
&lt;li&gt;如果包本次的升级是&lt;strong&gt;无法向下兼容&lt;/strong&gt;的，那么就需要对 X 进行加 1，Y、Z 清零，然后添加延伸。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在加了延伸的版本上需要进行 bugfix 时，只需要将我们延伸的版本继续增加即可。当 bugfix 结束，需要发布正式版本时，只需要去掉延伸版本，发布版本即可。&lt;/p&gt;
&lt;h4&gt;什么时候需要使用先行版本&lt;/h4&gt;
&lt;p&gt;假设 P 项目中引用了 @zcy/zcy-region-detail-back 包，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c620677fe4b2487281a4698d3693f74f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;A 需求改动了项目 P，发布时间为 6.30。&lt;/p&gt;
&lt;p&gt;B 需求改动了 @zcy/zcy-region-detail-back 包，改动的时间是 6.29。&lt;/p&gt;
&lt;p&gt;B 需求的改动没有使用先行版本且包中的 bug 在 6.30 项目 P 发布时没有修改。此时就会导致项目 P 发布时，下载到了有 bug 的 @zcy/zcy-region-detail-back 包，就会导致线上问题。&lt;/p&gt;
&lt;p&gt;这是因为我们在 P 项目中执行 &lt;code&gt;npm i @zcy/zcy-region-detail-back&lt;/code&gt; 后，下载出来的 &lt;code&gt;@zcy/zcy-region-detail-back&lt;/code&gt;  的版本号为 1.0.0。因为在执行 &lt;code&gt;npm i @zcy/zcy-region-detail-back&lt;/code&gt; 时会默认下载 tag 为 latest 下的最新包。相当于执行了 &lt;code&gt;npm i @zcy/zcy-region-detail-back@latest&lt;/code&gt;。&lt;strong&gt;注&lt;/strong&gt;：这里的 tag 指的是 npm 中的 tag。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43e162b9ea54b90849d9f5b6cdce364~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;所以 npm 的 tag 到底有什么用呢？其实 tag 就相当于是 git 的分支管理中的标签，不同的 tag 之间的包互不影响。可以使我们发布先行版本时不影响正式版本。&lt;/p&gt;
&lt;p&gt;一般常用的有三种类型的 tag：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;latest：最后的稳定版，npm install 时就是下载的这个&lt;/li&gt;
&lt;li&gt;beta：测试版本，需要指定版本或者使用 &lt;code&gt;npm install packageName@beta&lt;/code&gt;  来下载。例如：1.0.0-beta.0&lt;/li&gt;
&lt;li&gt;next：先行版本，使用 &lt;code&gt;npm install packageName@next&lt;/code&gt; 安装&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;版本发布&lt;/h2&gt;
&lt;p&gt;那么我们如何发布先行版本的包呢？首先需要升级 A 包的版本号，此处介绍两种升级方式&lt;/p&gt;
&lt;p&gt;方式一：简单粗暴，手动修改 package.json 中的 version：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20220313200823440" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bd766dbef3647f2bbe02428b8399165~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;这种方式需要我们自己手动执行 &lt;code&gt;git commit -am 'XXXX'&lt;/code&gt; 提交代码，如果需要在此版本的 git 仓库打上 tag 时，需要我们自己手动触发&lt;code&gt;git tag v2.3.2-beta.1&lt;/code&gt; ，&lt;code&gt;git push origin v2.3.2-beta.1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;方式二：借助 &lt;code&gt;npm version&lt;/code&gt; 命令&lt;/p&gt;
&lt;p&gt;A 包中所有的改动都 commit 后，可以根据以下命令更新版本&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm version [&amp;lt;newversion&amp;gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]
// newversion：指定更新的版本号
// major：大版本并且不向下兼容时，使用 major
// minor：有新功能且向下兼容时，使用 minor
// patch：修复一些问题、优化等，使用 patch
// 以 A：2.3.1 为例
npm version premajor // 版本号会成为 3.0.0-0，即 3.0.0 的预发版本
npm version preminor // 版本号为成为 2.4.0-0，即 2.4.0 的预发版本
npm version prepatch // 版本号成为 2.3.2-0，即 2.3.2 的预发版本
/**
* 版本号会成为 2.3.2-0。
* 执行此命令时，如果没有预发布版本号，则增加 Z，增加预发布号为 0
* 如果有预发步号，增加预发步号
*/
npm version prerelease
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据上边的 API 可以看到我们能通过 &lt;code&gt;npm version 2.3.2-beta.1&lt;/code&gt; 将 A 的版本升为 2.3.2-beta.1 的形式，除此之外，在 &lt;code&gt;npm 6.4.0&lt;/code&gt; 之后，我们也可以使用 &lt;code&gt;--preid&lt;/code&gt; 参数来添加前缀：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm version prerelease --preid=beta
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此种方式需要注意，必须要 commit 本地的修改之后才可以执行。&lt;code&gt;npm version&lt;/code&gt; 修改版本号，会默认执行 &lt;code&gt;git add&lt;/code&gt; -&amp;gt; &lt;code&gt;git commit&lt;/code&gt; -&amp;gt; &lt;code&gt;git tag&lt;/code&gt; 操作，此时的版本号看起来有 beta，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20220703204725616" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0adbc7e25294507bc20cf51b92ae97a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;但是这个 beta 是 git 仓库的 tag，并不是 npm 的 tag。如果不想默认给 git 添加 tag 的话，可以使用以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm --no-git-tag-version version xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么 &lt;code&gt;npm version &lt;/code&gt; 执行时具体发生了什么呢？简要流程图如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1079bc8d179d49c8ae78feae23bca45e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;执行完 &lt;code&gt;npm version 2.3.2-beta.1&lt;/code&gt; 之后，如果直接使用 &lt;code&gt;npm publish&lt;/code&gt; 来发布的话，发布出来的包的 tag 是 latest，但是我们其实是想发布一个测试包。如果其他人 &lt;code&gt;npm i&lt;/code&gt; 下载时就会下载 version 为 2.3.2-beta.1 的包。只有使用 &lt;code&gt;npm publish --tag XXX&lt;/code&gt; 才是给 npm 包上打了 tag 标签。&lt;/p&gt;
&lt;p&gt;执行以下命令就可以生成一个 tag 为 beta 的包：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm run build // 打包
npm publish --tag beta // 发布 beta 包
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b99153d765a4a7ba2621049c0042273~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果不小心直接使用 &lt;code&gt;npm publish&lt;/code&gt; 发错了也没有关系，可以使用以下命令来添加 tag：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;npm dist-tag add &amp;lt;pkg&amp;gt;@2.3.2-beta.1 &amp;lt;tag&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当需要删除多余的 tag 时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm dist-tag rm &amp;lt;pkg&amp;gt; &amp;lt;tag&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给大家提供一条指令完成 beta 版本的发布：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;"scripts": {
    "publish:beta": npm version prerelease --preid=beta &amp;amp;&amp;amp; npm run build &amp;amp;&amp;amp; npm publish --tag=beta"
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码开发完毕，提交之后，只需要 &lt;code&gt;npm run publish:beta&lt;/code&gt; 就可以发布一个测试版本啦～&lt;/p&gt;
&lt;p&gt;以上就是我本次分享的所有内容啦，如果有不足的地方，还望指正。&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://semver.org/lang/zh-CN/spec/v2.0.0.html"&gt;语义化版本 2.0.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/6844903870578032647"&gt;前端工程化（5）：你所需要的npm知识储备都在这了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.npmjs.com/cli/v6/commands/npm-version"&gt;npm version&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7140422304920109092"&gt;你想知道的前后端协作规范都在这了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7135217402983235592"&gt;带你了解 Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7132628898453880840"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 13 Sep 2022 16:28:07 GMT</pubDate></item><item><title>你想知道的前后端协作规范都在这了</title><link>https://juejin.cn/post/7140422304920109092</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="商陆.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19edac65d0f24d80b2d945ceb06a339a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 157 篇不掺水的原创，想获取更多原创好文，请搜索公众号【政采云前端团队】关注我们吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;一. 前言&lt;/h4&gt;
&lt;p&gt;你是否在为如何制定前后端协作规范而发愁？干货来啦，一文带你了解我们团队内部沉淀并践行已久的前后端协作规范，读完本文，回去大胆拒绝你后端的不合理设计！&lt;/p&gt;
&lt;h4&gt;二. 为什么需要协作规范？&lt;/h4&gt;
&lt;p&gt;假如你要在团队内部推一套规范，那么首先你得知道为什么需要制定协作规范呢？有规范会带来什么好处呢？&lt;/p&gt;
&lt;p&gt;随着前后端分离开发模式大行其道，前端和后端已经在两个方向上渐行渐远，各自深耕细作、术业专攻。前端更加关注交互视觉体验，而后端对高并发、高性能、高扩展上要求更高。这就导致大部分的前端和后端之间会存在所谓的"代沟"，我不知道你的数据如何存储，你不知道我的页面如何渲染。&lt;/p&gt;
&lt;p&gt;因此，很有必要制定前后端开发上的规范来抹平代沟，有了协作规范，便有了前后端开发默契，也因此达到了提高开发效率、降低沟通成本的作用。&lt;/p&gt;
&lt;h4&gt;三. 协作流程规范&lt;/h4&gt;
&lt;p&gt;首先是协作的流程规范，相信每个团队在前后端协作中都有各自的开发模式和开发流程来保障效率和质量，我们团队的前后端协作大致流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20220825230352601.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/204e6803eaf44d7aac2267fc6f351f72~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需求导入、交互视觉导入分析 ：对产品导出的需求，参会各方包括产品、前端、后端、测试、UED，在对需求的认知上要达成一致，这是开发的第一步。&lt;/li&gt;
&lt;li&gt;接口设计、前后端对接接口：后端给出接口，前后端要在接口字段设计上达成大致方向上的一致。&lt;/li&gt;
&lt;li&gt;技术方案评审 ：在开发之前进行技术方案评审，再次确保各方在需求的认知上统一，并且双方就接口字段可行性上再次确认。&lt;/li&gt;
&lt;li&gt;并行开发 、前后端自测：前后端并行开发，在此阶段前端可以 mock 数据进行页面渲染。&lt;/li&gt;
&lt;li&gt;开发环境联调：前后端自测完成之后在开发环境上完成接口联调。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;四. 如何做接口规范？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;前置约定：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;后端接口定义 URL、出入参之前，&lt;strong&gt;前后端需达成一致&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;文档规范：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接口注释需要写清楚：模块、枚举、必填/非必填、出参是否可能为 null&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口需要向下兼容，如果不兼容需要评估并且通知相应的业务方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口文档上面有变更需及时同步前端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后端需保证文档上定义的参数，可以正常请求接口且功能正常稳定&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="3"&gt;
&lt;li&gt;计量单位约定：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;时间：统一使用 13 位时间戳&lt;/li&gt;
&lt;li&gt;金额：统一为分，可根据业务情况选择&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="4"&gt;
&lt;li&gt;请求接口 URL &amp;amp; 请求方式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Post 接口不允许使用 Get 传参方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Post 接口必须使用 &lt;code&gt;application/json&lt;/code&gt; 模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口命名应尽量符合语义，接口命名不要过于相似，难区分，易混淆&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="5"&gt;
&lt;li&gt;入参&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;保证同一应用领域内，相同含义的字段，命名保持一致&lt;/li&gt;
&lt;li&gt;业务编号 / ID 必须为&lt;strong&gt;字符串类型&lt;/strong&gt;，JS 对最大数字有限制&lt;/li&gt;
&lt;li&gt;同一个页面不同 Tab，接口尽量保证一致&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="6"&gt;
&lt;li&gt;出参&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;接口出参格式要统一&lt;/li&gt;
&lt;li&gt;接口不要返回类似 "服务器内部异常"、"网络异常" 这种无法理解的错误信息，非线上环境可以返回错误堆栈，方便排查问题&lt;/li&gt;
&lt;li&gt;前后端数据列表相关的接口，如果返回为空，则返回空数组 &lt;code&gt;[]&lt;/code&gt; 或空集合 &lt;code&gt;{}&lt;/code&gt;，有利于数据层面上的协作更加高效，减少前端很多琐碎的 null 值判断，特殊情况特殊分析&lt;/li&gt;
&lt;li&gt;接口出参根据页面需求返回有效字段，避免吐出过多无用字段&lt;/li&gt;
&lt;li&gt;枚举值尽量返回中文和英文描述&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;五. 协作中的Bad Case&lt;/h4&gt;
&lt;p&gt;以下总结了我们团队内部在协作中遇到的比较典型的 Bad Case 以及解决方案，我相信大家在开发过程中也遇到过类似的痛点经历：&lt;/p&gt;
&lt;h5&gt;类型 1：前端过多的条件逻辑判断&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按钮、组件显示与否，前端要通过大量的字段进行条件逻辑判断；同一页面不同场景前端调用的接口不一样&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 按钮文案、显示逻辑
{((record.state === 'RESULT_CONFIRM' &amp;amp;&amp;amp; isCurrentUserCreate) ||(record.state === 'RESULT_CHECK' &amp;amp;&amp;amp; isCurrentUserCreate &amp;amp;&amp;amp; currentUserCanCheck )) &amp;amp;&amp;amp; &amp;lt;Button&amp;gt;确认&amp;lt;/Button&amp;gt;}

 {['DREFT', 'AUDIT_FAILD', 'REVOKE'].includes(record.state) &amp;amp;&amp;amp; isCurrentUserCreate &amp;amp;&amp;amp; &amp;lt;Button&amp;gt;修改&amp;lt;/Button&amp;gt;}
 
// A 场景调用接口 1，B 场景调用接口 2，C 场景调用接口 3 和 4
if (id) {
  this.operation = '修改';
  const res = await this.fetchInfo(id);
  ...
} else if (source) {
  const res = await this.fetchSourceInfo(id: source);
  ...
} else {
  const res = await this.fetchBasicInfo();
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="image-20220823234007383.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3451fc4eb7b443fc8d62e63fcbf71588~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;控制前端显示逻辑判定都放在后端去做处理，前端尽可能减少字段判定。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注：如果功能简单，前端也可以做判断&lt;/strong&gt;，如何鉴定是否简单？从代码层面比如 If 判断中超过 2 个条件，按钮显示超过 2 个条件，可视作复杂逻辑，逻辑移到后端处理。建议一开始就视作复杂去处理，这样后期就不用再调整。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// 按钮展示
前后端约定好 按钮的显示返回一个数组，数组具体返回哪些逻辑写在后端。
[
  { name:'确认'，type:'resultConfirm'},
  { name:'修改'，type:'edit' },
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【好处】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将逻辑收敛到后端，&lt;strong&gt;出现问题或者更改逻辑时只需一方排查或修改&lt;/strong&gt;。即能一端完成的，绝不让两个端干， 两个就可能会出现不一致的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 2：前端二次数据加工过多&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;页面上同一个表格展示的数据是两个接口拼接而成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="image-20220824174620804.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ecfd5abd9a4f80931504fc2e322b5c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;接口数据返回格式不符合前端渲染逻辑，需要二次加工&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;p&gt;1、后端做好数据的整合，避免数据在前端的重组。&lt;/p&gt;
&lt;p&gt;2、Tree 数据展示的场景，如果数据不大后端全量返回，如果数据量过大异步返回，但异步返回存在后续的回显和搜索展示方面问题。&lt;/p&gt;
&lt;p&gt;3、同一个业务功能，一个接口搞定，不要分接口进行，后端业务考虑复用可包装新接口或原接口加参数兼容。&lt;/p&gt;
&lt;p&gt;【好处】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少前后端数据处理的成本，提高性能和用户体验&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 3：枚举值、下拉框数据由前端维护&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;列表页单据状态由前端维护枚举值，如果新增枚举都需要前后端更改，可能导致最终显示状态不统一&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 状态值映射
const getStatusName = (status) =&amp;gt; {
  switch(status) {
    case 0:
      return '草稿'；
    case 1:
      return '待部门审批';
    case 2: 
      return '待财务审核';
    case 3: 
      return '待单位审核';
    case 4: 
      return '审核中';
    ...
    default:
      break;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;确保状态可扩展，后端已经做了枚举的情况下，前端不需维护状态值，以后端提供接口为准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果是状态定死的情况下譬如：选项为【是、否】可无需后端返回。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 由后端接口返回下拉框选项
{
  result: [{
    code: string
    name: string
  }]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【好处】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;枚举值变动时，只需后端更新，也避免了迭代过程中出现的前后端不一致的情况&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 4：PC 端数据结构不适用 App 端&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;App 端的布局样式 是较 PC 端略复杂的，如果 App 端一味采用 PC 端的接口数据，是需要前端做特殊处理的。比如，同一时间的单据 App 端放在同一张卡片内，卡片内部的标题、内容、按钮展示也做了情况区分。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断前端处理工作量，后端需新增接口实现 App 不同的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【好处】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少前端处理逻辑的成本，提高 App 上的用户体验&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 5：同一业务领域同一含义的接口字段命名不统一&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关于返回结果： &lt;code&gt;response.data&lt;/code&gt;、 &lt;code&gt;response.result&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关于时间：&lt;code&gt;createAt&lt;/code&gt;、&lt;code&gt;queryEffectStartingBeginTime&lt;/code&gt;、&lt;code&gt;penaltyBeginTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关于名称：&lt;code&gt;punishedInstitutionName&lt;/code&gt;、&lt;code&gt;responderName&lt;/code&gt;、&lt;code&gt;penaltyObjectName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关于 Id: &lt;code&gt;punishedOrganizationId&lt;/code&gt;，&lt;code&gt;penaltyObjectId&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前后端共同维护一份字段词典，保持同一业务领域下命名一致，避免不必要的字段转换。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 6：金额计算结果由前端提交给后端并入库&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前端页面中，输入支付金额并除以总额，然后计算出支付比例，最后点击保存按钮将数据提交给后端接口；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于金额的计算：以是否入库为界限，非入库纯展示可前端计算，&lt;strong&gt;入库的统一由后端计算&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 7：前端维护业务配置类型的代码&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由多个表单项（下拉框、输入框、单选框等）的值作为条件判断某一表单项（附件、单选框、输入框等）是否必填、显示或隐藏。因此，前端需要写很多动态校验逻辑，并且涉及到每个区划的动态校验逻辑还不一样，有的校验条件还是写死的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置校验规则的页面可根据区划配置后生成标识码，然后后端可提供一个通用的校验接口，前端把值传给后端，然后返回校验结果是否通过。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 入参：
{
  code: '99900', // 区划代码
  identity: '11111', // 标识码
  datas:[ // 数据
   {
     key: 'catalog',
     value: 'A07',
   },
   {
     key: 'assetApproval',
     value: 0,
   }
 ]
}

// 返回值：
{
  result: true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 8：前端直接调用其它业务线后端的接口&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;业务线 A 列表&lt;/strong&gt;页面，点击新建按钮，弹框调用**业务线 B **那边的接口。&lt;/p&gt;
&lt;p&gt;由于 A 和 B 是不同业务线后端，接口对接以及后期的沟通维护成本会比较高。例如该接口发生改动，需要跨业务线通知到对应的前端（该后端还不一定知道前端是哪位）；并且接口返回的大量字段前端都用不到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;后台业务耦合的情况下需要自己业务线后端整合数据；如果只是为了展示非自己业务的数据后端不处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 9：后端分页接口的数据返回格式不统一&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;目前分页接口的数据返回格式不统一，已有如下几种形式：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 形式一：
{
  result: {
    data: [],
      total: 0,
  }
}
// 形式二：
{
  result: {
    data: [],
    pagination: {
      total: 0,
      pageSize: 10,
      pageNo: 1
    }，
  }
}
// 形式三：
{
  result: {
    data: [],
    total: 0,
    pageSize: 10,
    pageNo: 1
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建议后端接口统一格式如形式三。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;类型 10：后端一个接口拆分多个&lt;/h5&gt;
&lt;p&gt;【现象】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个表单页，在提交之前调用三个不同的校验接口。三个校验接口入参也不一样，前端需要组装各种类型的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【解决】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个校验接口和提交接口合并成一个提交接口。&lt;/li&gt;
&lt;li&gt;校验不通过时，接口返回值里区分阻塞式和提醒式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阻塞式：弹框告警，用户只能关闭弹框&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提醒式：弹框询问，在用户点击"继续提交"后，继续调用提交接口，此时增加入参标识跳过此步校验&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;六. 效果&lt;/h4&gt;
&lt;p&gt;基于一套合理可行的协作规范，前后端从开发到上线的各个阶段都能够看到诸多成效：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低沟通成本，减少不必要的扯皮， 加快开发进度；&lt;/li&gt;
&lt;li&gt;缩短联调时间，减少联调阶段的代码调整，保证了开发效率；&lt;/li&gt;
&lt;li&gt;减少测试阶段的排查问题归属，加快测试进度，保证质量；&lt;/li&gt;
&lt;li&gt;方便线上问题排查及修复。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;七. 总结&lt;/h4&gt;
&lt;p&gt;一言以蔽之：如果你发现前端在处理大量的逻辑，那么就是协作规范存在问题啦！前端更多的是关注交互、渲染上的逻辑，应尽量避免复杂的业务逻辑处理。万事开头难！推一套规范是需要时间去沉淀的，前端和后端同学都应多些耐心，多些理解。&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7135217402983235592"&gt;带你了解 Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7132628898453880840"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7124839474575441934"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 06 Sep 2022 16:07:23 GMT</pubDate></item><item><title>带你了解 Tree Shaking</title><link>https://juejin.cn/post/7135217402983235592</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="佳民.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4bcf3e8f8294db798dd11c54b597805~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 156 篇不掺水的原创，想获取更多原创好文，请搜索公众号【政采云前端团队】关注我们吧~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;JavaScript 绝大多数情况需要通过网络进行加载再执行，加载的文件越小，整体执行时间更短，所以就有了 Tree Shaking 去除无用代码，从而减小文件体积。&lt;/p&gt;
&lt;h3&gt;什么是 Tree Shaking&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Tree-shaking&lt;/strong&gt; (摇树) 是一个术语，通常指通过打包工具"摇"我们的代码，将未引用代码 (Dead Code) "摇" 掉。在 Webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝，虽然依赖了某些模块，但其实只使用其中的某些方法，通过 Tree Shaking ，将没有使用的方法摇掉，这样来达到删除无用代码的目的。&lt;/p&gt;
&lt;h3&gt;Tree Shaking 具体做了什么&lt;/h3&gt;
&lt;p&gt;我们通过例子来详细了解一下 Webpack 中 Tree Shaking 到底做了什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未使用的函数消除&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// utils.js
export function sum(x, y) {
  return x + y;
}

export function sub(x, y) {
  return x - y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// index.js
import { sum } from "./utils";
// import * as math from "./utils";

console.log(sum(1, 2));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在 utils 中定义了 sum 与 sub 两个方法， 仅使用了 sum 方法，而 sub 方法并没有被使用。我们一起看一下打包后的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;(()=&amp;gt;{"use strict";console.log(3)})();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;未使用的 JSON 数据消除&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;// main.json
{
  "a": "a",
  "b": "b"
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// index.js
import main from "./main.json";

console.log(main.a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到仅使用了 JSON 中的 a 。我们一起看一下打包后的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;(()=&amp;gt;{"use strict";console.log("a")})();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Tree Shaking 的原理&lt;/h3&gt;
&lt;p&gt;Tree Shaking 在去除代码冗余的过程中，程序会从入口文件出发，扫描所有的模块依赖，以及模块的子依赖，然后将它们链接起来形成一个 “抽象语法树” (AST)。随后，运行所有代码，查看哪些代码是用到过的，做好标记。最后，再将“抽象语法树”中没有用到的代码“摇落”。经历这样一个过程后，就去除了没有用到的代码。
&lt;img alt="image-20200729195132323" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bed23d8877d4ddf8ffc249f7cbbf276~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;前提是模块必须采用 ES6 Module 语法，因为 Tree Shaking 依赖 ES6 的静态语法：import 和 export。不同于 ES6 Module，CommonJS 支持动态加载模块，在加载前是无法确定模块是否有被调用，所以并不支持 Tree Shaking 。如果项目中使用了 babel 的话， &lt;code&gt;@babel/preset-env&lt;/code&gt; 默认将模块转换成 CommonJs 语法，因此需要设置 &lt;code&gt;module：false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;CommonJS 与 ES6 Module 模块的依赖的区别在于，CommonJS 是&lt;strong&gt;动态的&lt;/strong&gt;，ES6 Module 是&lt;strong&gt;静态的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CommonJS 导入时，&lt;code&gt;require&lt;/code&gt; 的路径参数是支持表达式的，路径在代码执行时是可以动态改变的，所以如果在代码编译阶段就建立各个模块的依赖关系，那么一定是不准确的，只有在代码运行了以后，才可以真正确认模块的依赖关系，因此说CommonJS 是动态的。&lt;/p&gt;
&lt;p&gt;ES6 模块不是对象，它的对外接口只是一种静态定义，在代码编译，静态解析阶段就会生成，这样我们就可以使用各种工具对JS模块进行依赖分析，优化代码。&lt;/p&gt;
&lt;h4&gt;Development 模式下&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// webpack.config.js

module.exports = {
  // mode: "production",
  mode: "development",
  devtool: false,
  optimization: {
    usedExports: true, // 目的使未被使用的export被标记出来
  },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打包后的 bundle.js&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sum": () =&amp;gt; (/* binding */ sum)
/* harmony export */ });
/* unused harmony export sub */
function sum(x, y) {
  return x + y;
}

function sub(x, y) {
  return x - y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1、可以看到未被使用的 sub 会被标记为 &lt;code&gt;/* unused harmony export sub */&lt;/code&gt;，不会被 &lt;code&gt;__webpack_require__.d&lt;/code&gt; 进行 exports 绑定；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于 &lt;code&gt;__webpack_require__.d&lt;/code&gt; 的含义，可参考 &lt;a href="https://segmentfault.com/a/1190000024457777"&gt;深入了解 webpack 模块加载原理&lt;/a&gt; 一文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、经过压缩工具（UglifyJSPlugin）压缩后，未使用的接口代码会被删除。原理显而易见，未被 &lt;code&gt;__webpack_require__.d&lt;/code&gt; 引用，所以压缩工具可以将其安全移除。&lt;/p&gt;
&lt;h4&gt;Production 模式下&lt;/h4&gt;
&lt;p&gt;由前面的例子可以看出 &lt;code&gt;dist/bundle.js&lt;/code&gt; 中整个 bundle 都已经被 压缩工具 压缩和混淆破坏，但是如果仔细观察，则不会看到引 &lt;code&gt;sub&lt;/code&gt; 函数，但能看到 &lt;code&gt;sum&lt;/code&gt; 函数的混淆破坏版本（&lt;code&gt;function r(e){return e*e*e}n.a=r&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;再看一下两次打包的文件体积会发现，bundle 的体积明显减少了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image-20220721071044241" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c7005dcdb934685a2ee94629944f464~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;Tree Shaking 和 sideEffects&lt;/h3&gt;
&lt;p&gt;提到 Tree Shaking 就要聊一下 sideEffects。什么是 sideEffects ？sideEffects 又是与 Tree Shaking 如何搭配使用的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sideEffect&lt;/strong&gt;(副作用) 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。&lt;/p&gt;
&lt;p&gt;webpack v4 开始新增了一个 &lt;code&gt;sideEffects&lt;/code&gt; 特性，通过给 &lt;code&gt;package.json&lt;/code&gt; 加入 &lt;code&gt;sideEffects: false&lt;/code&gt; 声明该包模块是否包含副作用，从而可以为 Tree Shaking 提供更大的优化空间。&lt;/p&gt;
&lt;p&gt;举例说明&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// a.js
// 无副作用，仅仅是单纯的 export
function a () {
  console.log('a')
}
export default {
  a
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// b.js
function b () {
  console.log('b')
}

// 执行了特殊行为
Array.prototype.fun = () =&amp;gt; {}

export default {
  b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 a 在 import 后未使用，Tree Shaking 完全可以将其优化掉；但是 b 在 import 后未使用，但因为存在他还执行了为数组原型添加了方法，副作用还是会被保留下来。这时就需要使用  &lt;code&gt;sideEffects: false&lt;/code&gt; ，可以强制标识该包模块不存在副作用，那么不管它是否真的有副作用，只要它没有被引用到，整个 模块/包 都会被完整的移除。&lt;/p&gt;
&lt;p&gt;如果你的项目中存在一些副作用代码 b 需要被保留下来，比如 polyfill、css、scss、less 等，可以按下面方法一样配置；保证必要的代码不被 Tree Shaking&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;// package.json
{
  "name": "your-project",
  "sideEffects": ["./src/b.js", "*.css"]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;通过以上讲解，使 Webpack 更精确地检测无效代码，完成 Tree Shaking 操作，需要符合以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 ES6 Module 语法（即 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;确保没有 &lt;code&gt;@babel/preset-env&lt;/code&gt;等工具将 ES6Module 语法转换为 CommonJS 模块。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optimization: { minimize: true, usedExports: true }&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用支持 Tree Shaking 的包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://segmentfault.com/a/1190000040037144"&gt;Tree shaking原理及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://webpack.docschina.org/guides/tree-shaking/"&gt;Tree Shaking&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7132628898453880840"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7124839474575441934"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 23 Aug 2022 15:28:44 GMT</pubDate></item><item><title>厉害！这篇正则表达式竟写的如此详尽</title><link>https://juejin.cn/post/7132628898453880840</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="伟豪.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70253e0ef87045d29397163c2220f829~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 156 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/regexp"&gt;厉害！这篇正则表达式竟写的如此详尽&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;h3&gt;为什么要学正则表达式？&lt;/h3&gt;
&lt;p&gt;作为一个菜鸟程序员，遇到复杂的正则时往往会求助&lt;strong&gt;搜索引擎&lt;/strong&gt;。虽然能够解决燃眉之急，但往往会有&lt;a href="https://blog.csdn.net/weixin_33994444/article/details/93408973"&gt;边界值&lt;/a&gt;和团队正则不统一的问题。而这种问题往往会被细测测出来，造成不必要的麻烦。对于这种情况，最好的解决方式就是去吃透它，最终能将它手写出来。所谓知其然，也要知其所以然。&lt;/p&gt;
&lt;p&gt;&lt;img alt="RegEx.jpeg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b714067b4b6d46fdb57c76c98be5b87e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;什么是正则表达式？&lt;/h3&gt;
&lt;p&gt;1951年,一位名叫史蒂芬·克林（Stephen Kleene）的数学科学家，发表了一篇名叫《神经网事件的表示法》的论文。论文中引入了&lt;code&gt;正则表达式&lt;/code&gt;的概念。直至七十多年后的今天，&lt;code&gt;正则表达式&lt;/code&gt;仍然影响着我们互联网生活的方方面面。&lt;/p&gt;
&lt;p&gt;&lt;img alt="创建密码：.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b167206d89e242f9a661cc59c93ad426~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;比如需要填入&lt;strong&gt;符合特定规则&lt;/strong&gt;的密码、手机号、邮箱等。
&lt;img alt="9f78f90f4fc7eea055079baf1e0b608d.jpg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25e9d40b63f24cd9b212307eb61e0470~tplv-k3u1fbpfcp-watermark.image" /&gt;
&lt;img alt="" src="https://www.zoo.team/images/upload/upload_9fbf19e559132e6fca267dfc8d7d18cf.png" /&gt;&lt;/p&gt;
&lt;p&gt;又比如我们需要对输入框加一个中文、英文或价格等&lt;strong&gt;输入限制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过在我们学习正则表达式之前，我们需要先熟悉下它的&lt;strong&gt;调试工具&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;怎么检测我的正则对不对呢？&lt;/h2&gt;
&lt;h3&gt;编辑器内置的搜索工具&lt;/h3&gt;
&lt;p&gt;我们可以使用&lt;a href="https://code.visualstudio.com/"&gt;Vscode&lt;/a&gt;提供的正则的搜索方法，来使用正则匹配我们需要搜索的内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="2bd784719bc5b6978b666890e9f11b50.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/876967e4bafc402c8bff29f5bcfa53bc~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;函数调用&lt;/h3&gt;
&lt;p&gt;也可以在自己熟悉的编程语言中调用函数去测试。&lt;/p&gt;
&lt;p&gt;&lt;img alt="eba976de552d2f27a5fa4488610a6fd4.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0f190be786b46dfb88707b7295a4232~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;在线测试网站&lt;/h3&gt;
&lt;p&gt;亦或是使用我这边推荐的一个&lt;a href="https://c.runoob.com/front-end/854/"&gt;在线测试网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="9bc0825470062a225ba48862618cef84.jpg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c13d65c761147c5853c768b9f04d61b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;了解了调试工具后我们开始从&lt;strong&gt;基础&lt;/strong&gt;学习吧。&lt;/p&gt;
&lt;h2&gt;基础&lt;/h2&gt;
&lt;h3&gt;限定符(Quantifiers)&lt;/h3&gt;
&lt;h4&gt;?&lt;/h4&gt;
&lt;p&gt;&lt;img alt="782b5df53d9f928c3665e4ad921432d1.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1b3cd91275b4a5286cf7b8a4011362f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;“?”表示前面的字符可以出现&lt;strong&gt;1次或者0次&lt;/strong&gt;。说简单点就是"co"中的"o"这个字母可有可无。&lt;/p&gt;
&lt;h4&gt;+&lt;/h4&gt;
&lt;p&gt;&lt;img alt="5f90add12862e68dac52415793a22110.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14d0f357912546cc84875e3ead58dfd3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;“+”表示前面的字符至少匹配&lt;strong&gt;1次或多次&lt;/strong&gt;。比如上列中”poverty“、“poor”得到了匹配。“premier”却没有匹配。&lt;/p&gt;
&lt;h4&gt;*&lt;/h4&gt;
&lt;p&gt;&lt;img alt="729092bb5629b191be2acc9a44d14cf7.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78bd71544370478786636c99b6e41e24~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;“*”可以匹配&lt;strong&gt;0个或者多个字符&lt;/strong&gt;。可以看到出现 0 次的“pr”和 2 次的“poor”得到了匹配。我们如何匹配&lt;strong&gt;固定次数&lt;/strong&gt;或&lt;strong&gt;一定范围&lt;/strong&gt;的字符呢？&lt;/p&gt;
&lt;h4&gt;{...}&lt;/h4&gt;
&lt;p&gt;&lt;img alt="39a63a55e7025e5452963a83ce2aafed.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f53c57710857488ca85a605edce12172~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;“{...}”可以用来匹配&lt;strong&gt;固定数量&lt;/strong&gt;的字符或&lt;strong&gt;某个范围&lt;/strong&gt;内的字符。&lt;/p&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;“{2}”当只有一个参数时，只匹配固定数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“{2,3}”当有两个参数时，匹配范围内的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“{2,}”当后面的参数为空时，匹配n个及以上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;(...)&lt;/h4&gt;
&lt;p&gt;以上都讲的是匹配单个字符，当我们想匹配&lt;strong&gt;多个字符&lt;/strong&gt;该怎么办呢？&lt;/p&gt;
&lt;p&gt;&lt;img alt="104f053573d0205258cc98118a8b2619.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fca190b218074c41b87664584c161f7e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以将我们需要匹配的字符用“(...)”括起来，可以看到“(...)”搭配我们上文所学的“+“成功匹配了”banana“和”anna“。&lt;/p&gt;
&lt;h3&gt;或运算符(OR Operator)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="c5dae76af93356ac4ed278c7815e1f59.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c76abd55b57e45afab60ff7dd3fda25d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;当我们需要匹配&lt;strong&gt;两个或多个条件&lt;/strong&gt;时我们就需要使用"|"(或运算符)。图中我们匹配了拥有“an”或“na”的单词。值得注意的是这里的“｜”最外层的"()"是必不可少的。&lt;/p&gt;
&lt;h3&gt;字符类(Character class)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="1458bf56eb5d965823ace88ef27a91ec.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb2fdedc07fb495c91e9db088db355cf~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;比如我们要匹配&lt;strong&gt;拥有“123”中任意字符&lt;/strong&gt;的字符串则需要使用“[...]”,需要匹配的字符只能取自方括号中的内容。另外我们也可以使用字符类去匹配指定范围，如[a-z]、[0-9]、[\u4e00-\u9fa5]等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="708c3df8641ef81355556e12cceae373.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87b18c140cf94e26a80dfaa65ff6b7bf~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;另外我们也可以在前面加”^“用来匹配&lt;strong&gt;非此范围&lt;/strong&gt;的字符串，如上我们就匹配了非英文的字符串。&lt;/p&gt;
&lt;p&gt;另外正则表达式也提供了很多&lt;code&gt;元字符&lt;/code&gt;可以让我们简写我们的正则表达式。&lt;/p&gt;
&lt;h3&gt;元字符(Meta character)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="b7f5812a8a3593cb255f3540f0f372bf.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b5339b063a94173acbdf72a7c5be3d7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用“\d”代替我们之前的“[0-9]”,这里还有两个特殊字符“^”会匹配&lt;strong&gt;开始&lt;/strong&gt;(这里要注意与我们前面讲到的&lt;code&gt;字符类&lt;/code&gt;中的运用要区分)，“$“会匹配结束。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;\d,\w,\s - 匹配数字、字符、空格(分别代表着：digit、word、space)。&lt;/li&gt;
&lt;li&gt;\D,\W,\S - 匹配非数字、非字符、非空格。&lt;/li&gt;
&lt;li&gt;. - 除换行符以外的所有字符(句号句子的结束符)。&lt;/li&gt;
&lt;li&gt;^ - 字符串开头。&lt;/li&gt;
&lt;li&gt;$ - 字符串结尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们来学习一下正则表达式的&lt;strong&gt;高级概念&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;高级概念&lt;/h2&gt;
&lt;h3&gt;懒惰匹配和贪婪匹配(Lazy and Greed)&lt;/h3&gt;
&lt;p&gt;当我们想要匹配文本中的HTML时我们会写下如下正则表达式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="b75cdf169ee888acb769c77838b8dd80.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65ddfa578cd241bf8608aaff781c342d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;根据前面的知识我们知道，此正则将会匹配&amp;lt;开头&amp;gt;结尾中间可以有至少1个任意字符。但结果是匹配了“&amp;lt;”和“&amp;gt;” 标签包含的所有内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc5d409da9aa40792ba90e5b537ebb35.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3e6d077fc2b41c18c50e2c5f7c154b3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以在正则表达式中加“?”来开启&lt;code&gt;懒惰匹配&lt;/code&gt;。开启懒惰匹配后，正则会&lt;strong&gt;尽可能少的匹配&lt;/strong&gt;。所以当匹配的时候发现标签 “ &amp;lt;div&amp;gt; ”已经是符合要求的，所以会匹配&amp;lt;div&amp;gt;标签，然后继续向下匹配，发现&amp;lt;/div&amp;gt;标签也是符合要求的，继续向下匹配，发现文字不符合要求，继续向下，发现&amp;lt;span&amp;gt;和&amp;lt;/span&amp;gt;标签都是符合要求的，所以最后会匹配 &amp;lt;div&amp;gt;, &amp;lt;/div&amp;gt;, &amp;lt;span&amp;gt;, &amp;lt;/span&amp;gt;四个标签。&lt;/p&gt;
&lt;h3&gt;分组(Group)&lt;/h3&gt;
&lt;p&gt;前面我们认识了“(...)”的用法，将其结合我们后面所学的知识就是正则的&lt;code&gt;分组&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="a7392ff6dd264803a4452a4df3e8f920.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36f87aae91f14a2fade79b94a66e7ca8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如上图所示第一个分组中我们匹配 4 个数字，第二个分组中我们匹配 7 个数字。中间使用“-”进行连接，便很容易匹配到了文本中出现的座机电话号。&lt;/p&gt;
&lt;h3&gt;非捕获分组(Non-capture Group)&lt;/h3&gt;
&lt;p&gt;非捕获分组：&lt;code&gt;(?:表达式)&lt;/code&gt;，分组匹配之后，不需要的用“?: ”语法过滤子表达式内容。也就是代码匹配，但是不保存。&lt;/p&gt;
&lt;p&gt;在使用非捕获前:&lt;/p&gt;
&lt;p&gt;&lt;img alt="bd7414a425996817887ea8ff34768dec.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a0d0e49c2d4e8f9f4b25638ecca651~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在使用非捕获后:&lt;/p&gt;
&lt;p&gt;&lt;img alt="29711c018bc8d6c196613e0ed930e554.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c95603ad5fd04ac49c0f0f4418ed666a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;.exec&lt;/code&gt;方法并没有捕获到月份。&lt;/p&gt;
&lt;h3&gt;回溯(Flash Back)&lt;/h3&gt;
&lt;p&gt;当我们想匹配一个正确的HTML标签时，使用"&amp;lt;[\w]+&amp;gt;.*&amp;lt;\/[\w]+&amp;gt;"。&lt;/p&gt;
&lt;p&gt;&lt;img alt="d974356d2305441e19234b3de6a402e0.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f03bd385d1374e40bcffde5d39f2a619~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到虽然可以匹配HTML开始和结束标签，但是&lt;strong&gt;却不能校验前后的一致性&lt;/strong&gt;。如“&amp;lt;/span&amp;gt;”并不是“&amp;lt;div&amp;gt;”的结束标签。&lt;/p&gt;
&lt;p&gt;&lt;img alt="38a9b1c3218a7a0642d44772f0e63d90.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c45f27b04bf34b2c8569910a08793ea3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以把后面的部分改成“&amp;lt;\/\1&amp;gt;”其中“\1”就是引用第一个&lt;code&gt;分组&lt;/code&gt;。这样一来我们就可以匹配正确的HTML标签了。&lt;/p&gt;
&lt;h3&gt;断言(Assertion)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;断言&lt;/strong&gt;有些地方也叫&lt;a href="https://blog.csdn.net/lxcnn/article/details/4304754"&gt;环视(Lookaround)&lt;/a&gt;，它只进行子表达式的匹配，不占有字符，匹配到的内容不保存到最终的匹配结果。&lt;/p&gt;
&lt;h4&gt;正向先行断言&lt;/h4&gt;
&lt;p&gt;正向先行断言：&lt;code&gt;(?=表达式)&lt;/code&gt;，指在某个位置往右看，所在的位置右侧必须匹配&lt;code&gt;表达式&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="c16a1e3118f7225c9c5b109c4a1df01f.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2f48fef68a94b02a31e54ed9dd7012a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到“/喜欢(?=你)”正确匹配到了“你”前面有“喜欢”的文本。&lt;/p&gt;
&lt;h5&gt;实现一个密码强度校验&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;至少有一个大写字母。
至少有一个小写字母。
至少有一个数字。
至少有8个字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="3b6d35aa5cefc456ebc5ef02b412f44a.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f1b58d921a4d889f1f48210cf355b3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h4&gt;反向先行断言&lt;/h4&gt;
&lt;p&gt;反向先行断言：&lt;code&gt;(?!表达式)&lt;/code&gt;，指在某个位置往右看，不能存在&lt;code&gt;表达式&lt;/code&gt;中的内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="f324acb154bd9b76c8f3e05f8167e23e.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f07f3125eca34d70ae9a38ec93296c19~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如上就排除了“喜欢”后面有“你”的字符串。&lt;/p&gt;
&lt;h4&gt;正向后行断言&lt;/h4&gt;
&lt;p&gt;正向后行断言：&lt;code&gt;(?&amp;lt;=表达式)&lt;/code&gt;，指在某个位置往左看，存在&lt;code&gt;表达式&lt;/code&gt;中的内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="84cea0dfb73d0222db6baec62fbeb2be.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/280a1be38d1e4b3899bbf31ce39e0001~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如上就匹配了“喜欢”前面有“我”的字符串。&lt;/p&gt;
&lt;h4&gt;反向后行断言&lt;/h4&gt;
&lt;p&gt;反向后行断言：&lt;code&gt;(?&amp;lt;!表达式)&lt;/code&gt;，指在某个位置往左看，不能存在&lt;code&gt;表达式&lt;/code&gt;中的内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="d853e7b39730aa7648879a717647ad66.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd0d2ed15b1f4523893862c63d37dd44~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如上就排除了“喜欢”前面有“我”的字符串。&lt;/p&gt;
&lt;p&gt;至此正则表达式的&lt;strong&gt;高级部分&lt;/strong&gt;学完啦，接下来我们学习正则提供的&lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;方法&lt;/h2&gt;
&lt;p&gt;在JavaScript中，&lt;code&gt;RegExp&lt;/code&gt;对象是一个预定义了属性和方法的正则表达式对象。&lt;/p&gt;
&lt;h3&gt;test()&lt;/h3&gt;
&lt;p&gt;&lt;img alt="640.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67e6e27ea7ba445d9cef33dacc93dbc7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;该方法用于检测一个字符串是否匹配某个正则表达式，&lt;strong&gt;匹配&lt;/strong&gt;返回 true，&lt;strong&gt;不匹配&lt;/strong&gt;返回 false。&lt;/p&gt;
&lt;h3&gt;exec()&lt;/h3&gt;
&lt;p&gt;&lt;img alt="94254b2d0aa9579258f63de420322fd4.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a665ff5356584716808c7a87337a3253~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;该方法用于检测字符串中对正则表达式的匹配。&lt;/p&gt;
&lt;p&gt;该函数返回一个&lt;strong&gt;数组&lt;/strong&gt;，其中存放匹配的结果。如果未找到匹配，则返回值为 null。&lt;/p&gt;
&lt;p&gt;除了正则自身携带的方法，配合 &lt;strong&gt;String 对象&lt;/strong&gt;的方法一起使用也会有额外的效果。&lt;/p&gt;
&lt;h2&gt;配合String提供的方法&lt;/h2&gt;
&lt;h3&gt;match&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;match&lt;/strong&gt; 这个方法主要用来提取数据，它配合分组的（）一起使用，可以很方便的提取数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var str = '2022-04-22'
var reg = /^(\d{4})-(\d{2})-(\d{2})$/
console.log(str.match(reg));
// &amp;nbsp;['2022-04-22', '2022', '04', '22', index: 0, input: '2022-04-22', groups: undefined]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;replace&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;replace&lt;/strong&gt;这个api主要用于替换数据，多用于字符串的处理和转义。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var str = '贾维斯：您今天共产生了8个BUG'
var reg = /\w{3}/g
console.log(str.replace(reg,"Beautiful Code"))
// 贾维斯：您今天共产生了8个Beautiful Code
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;什么是 $1 $2&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;let str = "前端1组-开发部";
console.log(str.replace(/(.{4})-(.{3})/, "$2 $1"));
// 开发部 前端1组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;$1&lt;/strong&gt;,&lt;strong&gt;$2&lt;/strong&gt;上就是按顺序对应小括号里面的&lt;strong&gt;分组&lt;/strong&gt; 捕获到的内容。这里我们将 2组和1组进行内容替换，就得到了替换后的内容。&lt;/p&gt;
&lt;h3&gt;split&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;split&lt;/strong&gt;主要用于来切分字符串为数组，它的第一个参数也可以为正则的形式。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const str1 = '2022-04-21'
const str2 = '2022.04.22'
const str3 = '2022/04/23'
const regsSplit = /[\.\-\/]/
console.log(str1.split(regsSplit))
console.log(str2.split(regsSplit))
console.log(str3.split(regsSplit))
// ['2022', '04', '21']
// ['2022', '04', '22']
// ['2022', '04', '23']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;了解完了结合String用法，我们再来了解一下&lt;strong&gt;兼容性问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;正则表达式兼容性调研&lt;/h2&gt;
&lt;p&gt;在我们日常使用中，一定会遇到兼容性问题。这里主要对一些不完全兼容的方法进行调研。&lt;/p&gt;
&lt;h3&gt;@@split&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@@split&lt;/code&gt;  方法切割String对象为一个其子字符串的数组 。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var re = /-/g;
var str = '2022-01-02';
var result = re[Symbol.split](str);
console.log(result);  // ["2022", "01", "02"]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="5c998fd1bb7ed1f4f1edf47892b674bc.jpg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebb1364abb5d471ebefda975ba67da77~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;@@match&lt;/h3&gt;
&lt;p&gt;对正则表达式匹配字符串时，&lt;code&gt;@@match&lt;/code&gt; 方法用于获取匹配结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var re = /[0-9]+/g;
var str = '2022-01-02';
var result = re[Symbol.match](str);
console.log(result);  // ["2022", "01", "02"]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="fb392fd5814bd1a403776ff6cd3947fe.jpg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ac9f44299564576bfd06a28e5931b78~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;@@search&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@@search&lt;/code&gt; 方法执行了一个在给定字符串中的一个搜索以取得匹配正则模式的项。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var re = /-/g;
var str = '2016-01-02';
var result = re[Symbol.search](str);
console.log(result);  // 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="01a09f895f172c2492ec4c70901e20aa.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f4ec4fecf114dbc88b9eb1c4baf1f6f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;@@replace&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@@replace&lt;/code&gt; 方法会在一个字符串中用给定的替换器，替换所有符合正则模式的匹配项，并返回替换后的新字符串结果。用来替换的参数可以是一个字符串或是一个针对每次匹配的回调函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var re = /-/g; 
var str = '2016-01-01';
var newstr = re[Symbol.replace](str, '.');
console.log(newstr);  // 2016.01.01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="6529acfb1c3fd4665e0bf9ddfe2ce6b6.jpg" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ef1f3c04c554a29b6d53e0d6c93f00e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;flags&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flags&lt;/code&gt; 属性返回一个字符串，由当前正则表达式对象的标志组成。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/foo/ig.flags;   // "gi"
/bar/myu.flags;  // "muy"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="921a751282a73cda11768b842bbbd01b.jpg" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7928bf17b7ab49e9a616641128bb8db6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;dotAll&lt;/h3&gt;
&lt;p&gt;正则中的点匹配就是 &lt;code&gt;dotAll&lt;/code&gt; ，都是匹配任意字符，但是很多字符是无法匹配的。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;四个字节的 &lt;code&gt;UTF-16&lt;/code&gt; 的字符&lt;/li&gt;
&lt;li&gt;行终止符 &lt;code&gt;\n&lt;/code&gt; &lt;code&gt;\r&lt;/code&gt; 换行 回车&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;console.log(/foo.bar/.test('foo\nbar'))
// false
console.log(/foo.bar/.test('fooabar'))
// true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加上 &lt;code&gt;s&lt;/code&gt; 可以匹配换行符&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;console.log(/foo.bar/s.test('foo\nbar'))
// true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容性&lt;/p&gt;
&lt;p&gt;&lt;img alt="cfda85f9c82bb1c904951d7744167fb6.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d182be57ac0d4d8d97bb02f953f57699~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;最后我们让来点&lt;strong&gt;干货&lt;/strong&gt;吧&lt;/p&gt;
&lt;h2&gt;干货&lt;/h2&gt;
&lt;h3&gt;保留两位小数的价格输入框&lt;/h3&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;
// 输入限制
const changePiece = (e) =&amp;gt;{
      e.target.value = e.target.value.replace(/^\D*(\d*(?:\.\d{0,2})?).*$/g, '$1');
  }
  return (
    &amp;lt;div&amp;gt;
       &amp;lt;input type="text" onKeyUp={ (e) =&amp;gt; {changePiece(e)}} /&amp;gt; 
    &amp;lt;/div&amp;gt;
  );

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常用正则表达式&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// 手机号码的校验
const phoneReg = /^[1][3,4,5,6,7,8,9][0-9]{9}$/
// 身份证的校验
const idCardReg = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/
// URL的校验
const urlReg = /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/
// 邮箱的校验
const emailReg = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/
// 日期 YYYY-MM-DD 校验
const dateReg = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上&lt;strong&gt;干货&lt;/strong&gt;大家也可以通过上文所学的知识自己尝试实现，自己实践才会有更深刻的印象和更深度的认知。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://caniuse.com/?search=RegExp"&gt;《Can I Use——正则表达式》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7016871226899431431"&gt;《有了这25个正则表达式，代码效率提高80%》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.bilibili.com/video/BV1da4y1p7iZ?spm_id_from=333.337.search-card.all.click"&gt;《10分钟快速掌握正则表达式》&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7124839474575441934"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7119639489567260686"&gt;表单数据形式配置化设计&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 16 Aug 2022 16:03:02 GMT</pubDate></item><item><title>学习 HTTP Referer</title><link>https://juejin.cn/post/7130033583284027429</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="维尼.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8583065dd4a64c1ca84f3dac99506518~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 155 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/http-referer"&gt;学习 HTTP Referer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;HTTP 中 Referer 字段在工作中或许并不会吸引你的注意，隐藏在 Network 的请求之下，但是却有着非常重要的作用。平常你一定会遇到一些问题需要去排查，假如这个问题在你排查完全部代码后，依然没有解决，这个时候你会怎么办？此时我们就需要将排查问题的角度转换一下，切换到 HTTP 协议上。&lt;/p&gt;
&lt;p&gt;最近工作当中也碰到了与此相关的一些问题，借此机会也同时做个记录和总结。HTTP 协议整体包含内容非常多，本次我们只把其中的 Referer 字段拿出来和大家详细说一下。&lt;/p&gt;
&lt;h1&gt;HTTP Referer&lt;/h1&gt;
&lt;h2&gt;Referer 是什么？&lt;/h2&gt;
&lt;p&gt;HTTP Referer 是 HTTP 表头的一个字段，用来表示当前网页是来源于哪里，采用的格式是 URL。我们通过这个 HTTP Referer，可以查到访客的来源。&lt;/p&gt;
&lt;p&gt;可以通过 Network 面板看到，页面访问及资源请求的 Request Headers 请求头信息里有一个 Referer 字段，用来标记来源的 URL。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af20b28299904394973399bfbbf341a8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;有同学可能会注意到 Referer “似乎”拼写有误，应该是 “Referrer" 才对，这其实是个历史原因，在早期 HTTP 规范当中就存在的拼写错误，后面为了向下兼容，所以将错就错。&lt;/p&gt;
&lt;p&gt;拼写错误只有 Request Headers 的 “Referer”，在其他地方比如General Headers、 JavaScript 及 DOM 上，都是正确的拼写。&lt;/p&gt;
&lt;p&gt;General Headers：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f7bfd870e624641a4ac6eda7b04b4be~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;// javascript
document.referrer

// DOM
&amp;lt;a target="_blank" href="https://edu.zcygov.cn/live" referrerpolicy="no-referrer"&amp;gt;查看链接&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此大家应该对 Referer 有了一个大概的了解，那么 Referer 字段在什么条件下会展示，以及如何去控制 Referer 返回的具体内容呢？答案就在 Referrer-Policy 当中，下面就带大家详细讲一下 Referrer-Policy 策略。&lt;/p&gt;
&lt;h2&gt;Referrer-Policy 策略&lt;/h2&gt;
&lt;h3&gt;有哪些策略？&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;Referrer-Policy: no-referrer&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;顾名思义，这个策略表示不发送 Referer 信息。&lt;/p&gt;
&lt;p&gt;工作中实际使用的场景：&lt;/p&gt;
&lt;p&gt;在双品牌“乐彩云”推广中为降低双域名跳转改造成本，运维层面在Nginx添加了一个规则，若访问链接（例如 news.zcygov.cn）的 Referer 包含 lecaiyun.com 域名，则会强制将访问链接的域名变更为 lecaiyun.com ，实现链接跳转统一。&lt;/p&gt;
&lt;p&gt;若部分域名不需要走这一套逻辑，不携带 Referer 头信息，则需要指定 Referrer-Policy 策略为 no-referrer 。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/903db37bc96443b8992aa7c16c21a907~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: no-referrer-when-downgrade&lt;/h4&gt;
&lt;p&gt;如果从 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，其他情况发送（包括 HTTP 网址链接到 HTTP 网址）。&lt;/p&gt;
&lt;p&gt;此规则原先是大多数浏览器的默认策略，现在随着隐私安全性的要求变高之后，浏览器将默认规则变更成了 strict-origin-when-cross-origin。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: origin&lt;/h4&gt;
&lt;p&gt;Referer字段一律只发送源信息（协议+域名+端口），不管是否跨域。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: origin-when-cross-origin&lt;/h4&gt;
&lt;p&gt;同源时，发送完整的Referer字段，跨域时发送源信息。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: same-origin&lt;/h4&gt;
&lt;p&gt;链接到同源网址（协议+域名+端口 都相同）时发送，否则不发送。注意，https://foo.com 链接到 http://foo.com 也属于跨域，因为两者的协议不同。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: strict-origin&lt;/h4&gt;
&lt;p&gt;如果从 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，其他情况只发送源信息。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: strict-origin-when-cross-origin&lt;/h4&gt;
&lt;p&gt;同源时，发送完整的Referer字段；跨域时，如果 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，否则发送源信息。&lt;/p&gt;
&lt;h4&gt;Referrer-Policy: unsafe-url&lt;/h4&gt;
&lt;p&gt;Referer字段包含源信息、路径和查询字符串，不包含锚点、用户名和密码。&lt;/p&gt;
&lt;p&gt;针对以上策略，可以根据策略及 Referer 携带信息的完整度，可以总结成一个表格，可以按照自己的需求配置不同的策略：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;不携带任何 Referer 信息&lt;/th&gt;
&lt;th style="text-align: left;"&gt;Referer 只携带域名 Origin 信息&lt;/th&gt;
&lt;th style="text-align: left;"&gt;Referer 携带完整 URL 信息&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;no-referrer&lt;/td&gt;
&lt;td style="text-align: left;"&gt;✅&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;origin&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;✅&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;unsafe-url&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;strict-origin&lt;/td&gt;
&lt;td style="text-align: left;"&gt;从 HTTPS 请求到 HTTP 的网址时&lt;/td&gt;
&lt;td style="text-align: left;"&gt;满足以下任意条件：&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;从 HTTPS 请求到 HTTPS 网址时&lt;/li&gt;&lt;li&gt;从 HTTP 请求到 HTTP 的网址时&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;no-referrer-when-downgrade&lt;/td&gt;
&lt;td style="text-align: left;"&gt;从 HTTPS 请求到 HTTP 的网址时&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;满足以下任意条件：&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;从 HTTPS 请求到 HTTPS 网址时&lt;/li&gt;&lt;li&gt;从 HTTP 请求到 HTTP 的网址时&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;origin-when-cross-origin&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;跨域请求&lt;/td&gt;
&lt;td style="text-align: left;"&gt;同源请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;same-origin&lt;/td&gt;
&lt;td style="text-align: left;"&gt;跨域请求&lt;/td&gt;
&lt;td style="text-align: left;"&gt;-&lt;/td&gt;
&lt;td style="text-align: left;"&gt;同源请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;strict-origin-when-cross-origin&lt;/td&gt;
&lt;td style="text-align: left;"&gt;从 HTTPS 请求到 HTTP 的网址时&lt;/td&gt;
&lt;td style="text-align: left;"&gt;满足以下任意条件：&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;跨域请求&lt;/li&gt;&lt;li&gt;从 HTTPS 请求到 HTTPS 网址时&lt;/li&gt;&lt;li&gt;从 HTTP 请求到 HTTP 网址时&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;同源请求&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;浏览器默认的策略&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;浏览器&lt;/th&gt;
&lt;th style="text-align: left;"&gt;默认的策略&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Chrome&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Chrome 85 版本默认策略变更为：strict-origin-when-cross-origin&lt;br /&gt;原策略：no-referrer-when-downgrade&lt;br /&gt;&lt;br /&gt;详细可查看：&lt;a href="https://developer.chrome.com/blog/referrer-policy-new-chrome-default/"&gt;https://developer.chrome.com/blog/referrer-policy-new-chrome-default/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Firefox&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Firefox 87 版本默认策略变更为：strict-origin-when-cross-origin&lt;br /&gt;原策略：strict-origin-when-cross-origin&lt;br /&gt;&lt;br /&gt;详细可查看：&lt;a href="https://blog.mozilla.org/security/2021/03/22/firefox-87-trims-http-referrers-by-default-to-protect-user-privacy/"&gt;https://blog.mozilla.org/security/2021/03/22/firefox-87-trims-http-referrers-by-default-to-protect-user-privacy/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Edge&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Edge 88 版本默认策略变更为：strict-origin-when-cross-origin&lt;br /&gt;原策略：no-referrer-when-downgrade&lt;br /&gt;&lt;br /&gt;详细可查看：&lt;a href="https://docs.microsoft.com/zh-cn/deployedge/microsoft-edge-policies"&gt;https://docs.microsoft.com/zh-cn/deployedge/microsoft-edge-policies&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Safari&lt;/td&gt;
&lt;td style="text-align: left;"&gt;类似于 strict-origin-when-cross-origin&lt;br /&gt;&lt;br /&gt;依赖智能跟踪预防 (ITP)策略，详细可查看：&lt;a href="https://webkit.org/blog/9661/preventing-tracking-prevention-tracking/"&gt;https://webkit.org/blog/9661/preventing-tracking-prevention-tracking/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;设置 Policy 的方法&lt;/h3&gt;
&lt;p&gt;当我们需要变更 Referer 策略的时候，浏览器本身以及W3C规范都给我们提供了路径，有以下几种方式可以操作：&lt;/p&gt;
&lt;h4&gt;rel 属性&lt;/h4&gt;
&lt;p&gt;&amp;lt;a&amp;gt;、&amp;lt;area&amp;gt;标签均支持 rel 属性，最常见的就是在 &amp;lt;a&amp;gt; 标签中对单个链接设置 &lt;code&gt;rel="noreferrer"&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;&amp;lt;a href="xxx" rel="noreferrer" target="_blank"&amp;gt;新地址&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecf32aea34a34a20bd3b464fce113ede~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;设置之后，新开的网页请求头中，将不再携带来源页面的 Referer 信息。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d3159e114dd4a1b92b2f9e9fd8cc127~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;&amp;lt;meta&amp;gt; 标签&lt;/h4&gt;
&lt;p&gt;在HTML的 &amp;lt;head&amp;gt; 标签内，可以新增 &amp;lt;meta&amp;gt; 标签，设置整个网页的 Referer Policy 策略。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;&amp;lt;meta name="referrer" content="no-referrer"&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Headers 请求头&lt;/h4&gt;
&lt;p&gt;更改 HTTP 头信息中的 Referer-Policy 值即可。比如你使用的是 Nginx，则可以设置 add_headers 设置请求头。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;add_header Referrer-Policy "no-referrer";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置完请求头，最终体现在浏览器 Headers 里字段是：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;Referrer-Policy: no-referrer
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;referrerpolicy 属性&lt;/h4&gt;
&lt;p&gt;这个目前看还是实验性功能，并且在 IE 浏览器上也是完全不支持的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;&amp;lt;a href="xxx" referrerpolicy="no-referrer" target="_blank"&amp;gt;新地址&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;支持的标签：&amp;lt;a&amp;gt;、&amp;lt;area&amp;gt;、&amp;lt;img&amp;gt;、&amp;lt;iframe&amp;gt;、&amp;lt;link&amp;gt;&lt;/p&gt;
&lt;h4&gt;优先级&lt;/h4&gt;
&lt;p&gt;以上几种设置方式，有页面级和元素级，当这两者都存在时，优先级按以下方式进行生效：&lt;/p&gt;
&lt;p&gt;1、元素级政策&lt;/p&gt;
&lt;p&gt;2、页面级政策&lt;/p&gt;
&lt;p&gt;3、浏览器默认&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javaScript"&gt;&amp;lt;meta name="referrer" content="strict-origin-when-cross-origin"&amp;gt;

&amp;lt;a href="https://foo.com" rel="no-referrer" target="_blank"&amp;gt;地址一&amp;lt;/a&amp;gt;
&amp;lt;a href="https://bar.com" target="_blank"&amp;gt;地址二&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;页面中地址一，则优先按元素级策略，走 no-referrer，而页面中其他元素（包括但不限于 a 标签）则按 meta 页面级策略执行&lt;/p&gt;
&lt;h1&gt;作用及使用场景&lt;/h1&gt;
&lt;p&gt;以下列举了几个比较常见的作用及使用场景：&lt;/p&gt;
&lt;h3&gt;（1）防盗链&lt;/h3&gt;
&lt;p&gt;以 CDN 加速为例，一般都提供了防盗链配置，其内部实现原理是按照 Referer 来源来判断是否在配置的白名单或者黑名单中，来决定资源能否可被访问。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68641f37f1ef41918d2c780851924e75~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;图片来自&lt;a href="https://help.aliyun.com/document_detail/27134.html"&gt;阿里云CDN的防盗链配置&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;（2）埋点分析&lt;/h3&gt;
&lt;p&gt;埋点分析有一种情况是用于追溯用户的完整访问路径，这个时候可以依赖的就是 HTTP Referer，可以通过 Referer 来源逐步分析用户的来源网址和整体访问链路。&lt;/p&gt;
&lt;h3&gt;（3）错误排查（接口日志）&lt;/h3&gt;
&lt;p&gt;排查接口请求报错时，一般会关注日志系统，而日志系统里如果没有对于接口访问来源的字段，那么想快速精确找到接口访问的页面是比较困难的。这时候 Referer 就提供了一个比较好的帮助，可以看到接口的请求来源。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c75c68d4184927bf5370adcb2cb4cd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;（4）用户隐私保护&lt;/h3&gt;
&lt;p&gt;为什么各浏览器厂商都升级了 Policy 默认策略？&lt;/p&gt;
&lt;p&gt;目的其实是为了保护用户隐私，过于完整的 Referer 信息能够通过日志抓取到完整链路，也就意味着你的访问路径和来源是没有任何隐藏，这样可能会对隐私及网站的安全性带来一定的危害。&lt;/p&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80"&gt;HTTP来源地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ruanyifeng.com/blog/2019/06/http-referer.html"&gt;HTTP Referer 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types"&gt;链接类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.dev/referrer-best-practices/"&gt;引荐来源 (Referer) 和引荐来源政策 (Referrer-Policy) 最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7127440050937151525"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7124839474575441934"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7119639489567260686"&gt;表单数据形式配置化设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7117042614313943070"&gt;如何将传统 Web 框架部署到 Serverless&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 09 Aug 2022 16:12:17 GMT</pubDate></item><item><title>浅谈低代码平台远程组件加载方案</title><link>https://juejin.cn/post/7127440050937151525</link><description>&lt;p&gt;&lt;img alt="政采云技术团队.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfefad3ee3474e3a8a461251aaddceb4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="百里.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6240750d2ff44fe59d99bdb9766d22e7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 154 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/low-code"&gt;浅谈低代码平台远程组件加载方案&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;低代码开发平台（LCDP）是无需编码（0代码）或通过少量代码就可以快速生成应用程序的开发平台。通过可视化进行应用程序开发的方法，使具有不同经验水平的开发人员可以通过图形化的用户界面，使用拖拽组件和模型驱动的逻辑来创建网页和移动应用程序。这两年越来越多的公司和开发人员开始自研低代码平台来达到降本提效的目的。今天和大家分享一下低代码平台开发过程中遇的一个问题和对应的解决思路。&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;低代码平台之所以不需要写代码是因为平台提供了很多可配置的组件，让平台的用户可以通过配置的方式生成自己想要的产物。那么如果想要能配置出更多的效果，就需要保证物料库足够丰富。&lt;/p&gt;
&lt;p&gt;如果物料组件很多，就需要按需加载组件。现有的开发工具如 webpack 也支持代码分割。但是在低代码平台的开发场景中，平台应用是和组件分离的，需要用户在选择某个组件的时候，要加载远程组件代码。&lt;/p&gt;
&lt;h2&gt;加载方案&lt;/h2&gt;
&lt;h3&gt;组件代码&lt;/h3&gt;
&lt;p&gt;我们以 vue 框架为例，假如当前有一个组件 A，代码如下，如何远程加载这个组件呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-vue"&gt;&amp;lt;template&amp;gt;
    &amp;lt;div class="wp"&amp;gt;{{text}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import { defineComponent, ref } from 'vue';
import _ from 'lodash';
  
export default defineComponent({
  setup(props) {
    console.log(_.get(props, 'a'));
    return {
      onAdd,
      option,
      size,
      text: 'hello world',
    };
  },
});
&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
.wp {
    color: pink;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方案一：放在全局对象上&lt;/h3&gt;
&lt;h4&gt;步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打包：组件代码打包为 umd 格式，打包时配置 webpack externals, 使打包产物不包含公共的依赖；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传：打包的组件 js 上传到 cdn；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加载：在需要使用组件时，插入一个 script ，在这个 script 中将组件放在一个全局对象上；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注册：在 script 插入完成后，从全局对象上获取组件，并进行注册；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;组件打包&lt;/h4&gt;
&lt;p&gt;首先需要增加一个入口文件&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;import Component from './index.vue';

if(!window.share) {
  window.share = {};
}

window.share[Component.name] = Component;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上面的入口文件为入口，用 webpack 打包为 umd 格式&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// 组件打包 webpack 配置
const path = require('path');
const { VueLoaderPlugin } = require('vue-loader')

module.exports = {
  mode: 'production',
  entry: path.resolve(__dirname, './comps/index.js'),
  output: {
    filename: 'index.js',
    path: path.resolve(__dirname, 'dist'),
    library: { type: 'umd' }
  },
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: 'vue-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.js$/,
        loader: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [
          'vue-style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new VueLoaderPlugin()
  ],
  externals: {
    vue: 'vue',
    lodash: 'lodash',
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;html 模板&lt;/h4&gt;
&lt;p&gt;组件公共依赖都需要先加入到模板 html 中&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang="en"&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&amp;gt;
    &amp;lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;script src="https://cdn/vue.global.js"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src="https://cdn/lodash@4.17.21.min.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id="root"&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;组件加载逻辑&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;const loadComponent = (name) =&amp;gt; new Promise((resolve) =&amp;gt; {
  const script = document.createElement('script');
  script.src=`http://xxx/${name}.js`;
  script.onload = script.onreadystatechange = function(){
     resolve();
  };
  document.querySelector('head').appendChild(script);
})

const addComp = async (name) =&amp;gt; {
  await loadComponent(name);
  // 注册组件，其中 app 为 Vue 应用实例对象
  app.component(name, window.share[name]);
}

// 动态注册组件
addComp('A');


&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;组件的依赖共享，需要依赖提前先放到全局，html 模板需要较频繁改动；&lt;/li&gt;
&lt;li&gt;全局对象上要挂载的内容越来越多，影响加载性能，没有做到真正的按需加载；&lt;/li&gt;
&lt;li&gt;依赖版本难以管理。如 A 组件依赖了 loadsh 1.0， 而 B 组件依赖了 lodash 2.0，但是全局对象上的 lodash,同时挂载两个版本就必然会有冲突，因此版本必须一致；且后续如果某个组件要升级某个依赖的版本，也势必会影响所以其他组件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;方案二：amd&lt;/h3&gt;
&lt;p&gt;amd 格式也是一种模块化方案，这里我们选择知名度比较高的 require.js 作为 amd 模块加载器。&lt;/p&gt;
&lt;h4&gt;步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;打包：组件代码打包为 umd 或 amd 格式，打包时配置 webpack externals，使打包产物不包含公共的依赖；&lt;/li&gt;
&lt;li&gt;上传：打包的组件 js 上传到 cdn；&lt;/li&gt;
&lt;li&gt;加载&amp;amp;注册：在需要使用组件时，用 requirejs 获取组件，并进行注册。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;组件打包&lt;/h4&gt;
&lt;p&gt;用 amd 格式来做远程加载时不需要像方案一一样，增加额外的入口文件，可以直接将 .vue 文件作为入口。以下是 webpack 打包配置示例&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// 组件打包 webpack 配置
const path = require('path');
const { VueLoaderPlugin } = require('vue-loader')

module.exports = {
  mode: 'production',
  entry: path.resolve(__dirname, './comps/index.vue'),
  output: {
    filename: 'index.js',
    path: path.resolve(__dirname, 'dist'),
    library: { type: 'umd' }  // 输出 amd 或者 umd
  },
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: 'vue-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.js$/,
        loader: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [
          'vue-style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new VueLoaderPlugin()
  ],
  externals: {
    vue: 'vue',
    lodash: 'lodash',
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;html 模板&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang="en"&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8"&amp;gt;
    &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&amp;gt;
    &amp;lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;script src="./require.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id="app"&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;组件加载逻辑&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// main.js
requirejs.config({
  baseUrl: 'https://cdn.xxx.com',
  map: {
    '*': {
      css: 'require-css',
    },
  },
  paths: {
    echarts: 'echarts@5.1.1',
    vueDemo: 'vue-demo',
    vue: 'vue@3.2.37',
    moment: 'https://cdn/moment@2.29.1.min',
  },
  shim: {
    'ant-design-vue': ['css!https://cdn/ant-design-vue@2.1.6.min.css'],
  },
});

requirejs(['vue', 'vue-demo', 'vue-app'], function (vue, vueDemoModule, VueAppModule) {
  const app = Vue.createApp(VueAppModule.default);
  app.component('vue-demo', vueDemoModule.default);
  const vm = app.mount('#app');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;平台代码（上述代码的&lt;code&gt;vue-app&lt;/code&gt;）也需要编译为 amd 格式，然后上传到 cdn 上，开发流程改变，需要定制化的开发平台项目的发布机制。&lt;/li&gt;
&lt;li&gt;有些第三方库没有提供 amd 或 umd 格式，需要开发者自己开发工具去转换（此过程中可能有很多坑要踩）；&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;优点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;相比于方案一，组件的依赖可以有版本差异且互相不影响。&lt;/li&gt;
&lt;li&gt;组件和组件的依赖都可以按需加载，真正做到按需加载。&lt;/li&gt;
&lt;li&gt;有现成的加载 css 文件的机制；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;方案三：ESModule&lt;/h3&gt;
&lt;h4&gt;步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;打包：组件代码打包为 esm 格式，打包时配置webpack externals, 使打包产物不包含公共的依赖；&lt;/li&gt;
&lt;li&gt;上传：打包的组件 js 上传到 cdn；&lt;/li&gt;
&lt;li&gt;加载&amp;amp;注册：在需要使用组件时，用 esm 的动态引入获取组件，并进行注册；&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;组件打包&lt;/h4&gt;
&lt;p&gt;这里需要注意的是，externals 配置项中直接把公共依赖配置为 cdn 地址；&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;import path from 'path';
import VueLoader from 'vue-loader';

const VueLoaderPlugin = VueLoader.VueLoaderPlugin;

const __dirname = path.resolve();

export default {
  mode: 'development',
  entry: path.resolve(__dirname, './src/vue-demo.vue'),
  output: {
    filename: 'vue-demo.esm.js',
    path: path.resolve(__dirname, 'components'),
    library: { type: 'module' }
  },
  experiments: { outputModule: true },
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: 'vue-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.js$/,
        loader: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [
          'vue-style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new VueLoaderPlugin()
  ],
  externals: {
    vue: 'https://cdn.jsdelivr.net/npm/vue@3.2.37/dist/vue.esm-browser.js',
    'lodash': 'https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.js'
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用上述配置打包后产物，中会把 &lt;code&gt;'vue'&lt;/code&gt; 替换为 externals 中的 cdn 地址&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// 输入
import Vue from 'vue';

// 输出结果
import Vue from 'https://cdn.jsdelivr.net/npm/vue@3.2.37/dist/vue.esm-browser.js';
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;组件加载逻辑&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;const list = ref([]);

const addComp = async () =&amp;gt; {
  const VueDemo = await import(/* @vite-ignore */`http://cdn/components/vue-demo.esm.js`)
  window.app.component('vue-demo', VueDemo.default);
  list.value.push({ key: new Date().valueOf(), name: 'vue-demo' });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;vite 配置&lt;/h4&gt;
&lt;p&gt;需要注意的是要保证本地开发时引入的 &lt;code&gt;vue&lt;/code&gt; 也是远程的，所以需要在 vite 的配置文件中增加 alias 配置。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      'vue': 'https://cdn.jsdelivr.net/npm/vue@3.2.37/dist/vue.esm-browser.js'
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;兼容性问题：很多 Webpack 已经支持很好的功能还没有得到主流浏览器的支持&lt;/li&gt;
&lt;li&gt;对很多第三方依赖的转化处理不完善，缺失完善的解决机制。要将第三方依赖的加载全部交给浏览器本身来接管，那么首先开发工具要做的就是将第三方依赖全部转换为 ESModule 的模块，而现在 npm 上的绝大部分包都是只支持 CommonJS 版本的，因此这里的转换过程通常需要由开发者自己来接管，而这其中有很多底层的问题并没有得到好的解决。同时，在 ESModule 规范推进的过程中，有许多如&lt;code&gt;exports.default&lt;/code&gt;、&lt;code&gt;exports.__esModule&lt;/code&gt;等利用语法来兼容 ESModule 和 CommonJS 的废案往往也都被 babel 实现，而且被许多开发者使用并且发布到了 npm 上，这就导致了现在 npm 上的许多包中有大量的废弃兼容性代码，而这些代码往往会对开发工具的转化造成阻碍。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;优点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;真正的按需加载&lt;/li&gt;
&lt;li&gt;代码上更加优雅&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;关于 webpack 模块联邦&lt;/h3&gt;
&lt;p&gt;基于笔者对模块联邦的了解，笔者认为 Webpack 的模块联邦，目前更加适合微前端的场景，但是不太适用于低代码平台的场景。但是笔者对 webpack 模块联邦了解不够深入，判断不一定准确，欢迎有不同意见的小伙伴在评论区讨论。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;对比上面三个方案，方案一实现起来最简单，但是没有真正实现按需加载，随着项目规模和需要满足的业务场景的扩大，组件的公共依赖会越来越多。方案二 、方案三 都能实现真正的按需加载，其中 require.js 虽然听上去已经是上个世纪的东西了，但是兼容性和坑相对比较少。说到 ESModule， 虽然有兼容性和上面提到的一些格式转化的问题，但随着近些年 Vite 、Snowpack 的发展，在未来 ESModule 一定是大势所趋，目前笔者也正在将负责的我司内部大屏低代码平台改造为 ESModule 方式加载。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.requirejs-cn.cn/"&gt;requirejs 中文文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/0AHmP70HnLUZeJWQlRtUKw"&gt;ESModule 系列 ㈠ ：演进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/lihefei_coder/article/details/81333036"&gt;Require.js加载css依赖&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7124839474575441934"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7119639489567260686"&gt;表单数据形式配置化设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7117042614313943070"&gt;如何将传统 Web 框架部署到 Serverless&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7114450860335169543"&gt;浅谈前端埋点 &amp;amp; 监控&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 02 Aug 2022 16:28:24 GMT</pubDate></item><item><title>政采云 2023 届前端校招提前批来了！！！🎉</title><link>https://juejin.cn/post/7126788456864284709</link><description>&lt;h3&gt;岗位介绍&lt;/h3&gt;
&lt;p&gt;开发-前端&lt;/p&gt;
&lt;h3&gt;面向人群&lt;/h3&gt;
&lt;p&gt;毕业时间在 &lt;strong&gt;2022 年 11 月 - 2023 年 10 月&lt;/strong&gt;的海内外院校应届毕业生&lt;/p&gt;
&lt;h3&gt;工作地点&lt;/h3&gt;
&lt;p&gt;杭州&lt;/p&gt;
&lt;h3&gt;时间起止&lt;/h3&gt;
&lt;p&gt;开始时间：2022 年 8 月 1 日&lt;/p&gt;
&lt;p&gt;截止时间：2022 年 9 月 1 日&lt;/p&gt;
&lt;h3&gt;投递方式&lt;/h3&gt;
&lt;p&gt;扫描下方二维码，投递简历&lt;/p&gt;
&lt;p&gt;&lt;img alt="8256C0A1-D44C-4EE4-9459-5393FA9D8CF9.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5a78136b0e64cac80de563bca6e03de~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;团队介绍&lt;/h3&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。等你扫描下方的二维码。&lt;/p&gt;
&lt;h3&gt;更多问题&lt;/h3&gt;
&lt;p&gt;关于招聘，如果有更多问题，欢迎关注【政采云前端团队】公众号并回复 &lt;strong&gt;交流群&lt;/strong&gt; 获取入群二维码，咨询猴子或其他团队成员了解更多政采云前端团队详情和招聘资讯✌️！&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Sun, 31 Jul 2022 22:19:30 GMT</pubDate></item><item><title>前端富文本基础及实现</title><link>https://juejin.cn/post/7124839474575441934</link><description>&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4eb6a01e6564840817b127265b07edd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="页航.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b0e82e8fb4d4c46ab9360fe96b91c44~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是第 153 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：&lt;a href="https://www.zoo.team/article/rich-text"&gt;前端富文本基础及实现&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在日常生活中我们会经常接触到各种各样的文档格式和形式，其中富文本在文档格式中扮演了重要角色。对于前端而言，富文本产品也层出不穷，其应用也越来越广。&lt;/p&gt;
&lt;p&gt;这篇文章将会为大家介绍前端富文本的一些基础知识以及简单的实现思路。&lt;/p&gt;
&lt;h2&gt;什么是富文本&lt;/h2&gt;
&lt;p&gt;纯文本就是用纯文字编辑器编写，输入什么就是什么的文档，只包含字符。&lt;/p&gt;
&lt;p&gt;富文本对应的是富文本格式（Rich Text Format），即 RTF 格式，又称多文本格式，是由微软公司开发的跨平台文档格式。除字符外还有丰富的样式。doc，docx，rtf，pdf 等都是富文本格式的文件类型。&lt;/p&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (1).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40601a6b7f24488b9f438485655b5503~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;前端中的富文本&lt;/h2&gt;
&lt;p&gt;前端富文本通过 html 的各个元素配合各种样式（一般是内联样式）实现。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (3).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/343f0e7cd7f94cd3adb5babf66951b19~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;富文本编辑器中的富文本，是由红色框中带有语义化标签和内联样式的 html 渲染实现的。通过富文本编辑器，即可实现富文本的编写、展示。&lt;/p&gt;
&lt;p&gt;目前常见的前端富文本编辑器有 tinymce，UEeditor，draft 等。&lt;/p&gt;
&lt;p&gt;文章下文将会讲述实现前端富文本编辑器的一些基础知识和步骤。&lt;/p&gt;
&lt;h2&gt;富文本输入模式实现&lt;/h2&gt;
&lt;p&gt;实现前端富文本编辑器首先要实现文本输入，一般常用两种方式实现。&lt;/p&gt;
&lt;h3&gt;iframe&lt;/h3&gt;
&lt;p&gt;第一种方式是使用 iframe 标签。&lt;/p&gt;
&lt;p&gt;在空白的 HTML 文档中嵌入一个 iframe，并将 designMode 属性设置为 on，文档就会变成可编辑的，实际编辑的则是 iframe 内的 body 元素。文档变成可编辑后，就可以像使用文字处理程序一样编辑文本。&lt;/p&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="QQ20220722-172729.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24586e6aa44f4099881c019b292d50eb~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;元素设置 contenteditable&lt;/h3&gt;
&lt;p&gt;第二种方式是使用 contenteditable 属性指定 HTML 文档中的元素。该方式是 IE 最早实现的。使用方式是在一个元素上添加 contenteditable 属性并设置为 true，然后该元素会立即被用户编辑。&lt;/p&gt;
&lt;p&gt;此种方式通常会和 autocapitalize（首字母自动大写属性）、spellcheck（检查元素的拼写错误，实验功能）等属性共同使用以提升体验。&lt;/p&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="QQ20220722-171453.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a19813363e5c43d08220e3c24f3f75e8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;两者特点&lt;/h3&gt;
&lt;p&gt;两种方式都可以实现编辑模式，并且这种编辑模式与 textarea 不同，其内部会用块级元素（默认为 div 元素）做换行处理，最终体现在 dom 结构中。&lt;/p&gt;
&lt;p&gt;两者不同的是：iframe 方式可做到样式隔离，内部样式与外部样式不存在污染与冲突（ tinymce 实现方式）；元素设置 contentEditable 的方式（ wangEditor 等实现方式）则和其他元素一样受到页面 css 作用。个人认为两者没有优劣之分，开发者根据自身需求选择即可。&lt;/p&gt;
&lt;h2&gt;富文件选区&lt;/h2&gt;
&lt;p&gt;富文本编辑中我们在进行编辑时首先会先选择一块文本区域（即选区），比如选择一段文字并进行字体加粗等操作，那么选区本身包含了哪些信息呢，下面为大家简单介绍一下。&lt;/p&gt;
&lt;p&gt;Selection 对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区，可能横跨多个元素。文本选区由用户拖拽鼠标经过文字而产生。调用  &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getSelection"&gt;window.getSelection()&lt;/a&gt; 可得到此对象，其内部常用属性如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;anchorNode&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回选中区域对应的节点
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;anchorOffset&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回选中区域的起始下标，需要注意起始下标会根据左右方向选择的次序不同来展示不同的下标。如果 anchorNode 是字符串则对应文字下标，anchorNode 是元素，则对应选中区域对应它之前的同级节点的数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;focusNode&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回选中区域终点所在的节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;focusOffset&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与 anchorOffset 类似，如果是 focusNode 是字符串，则对应最后一个选中的字符所在的位置，focusOffset 是元素，则对应选中区域对应同级节点的总数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rangeCount&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回选中的区域所对应的连续的范围内的数量。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回选中区域所对应的类别是连续( Range )，还是同一个位置的( Caret )。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们常通过 anchorNode 与 anchorOffset 属性判断选区起始位置，通过 focusNode 与 focusOffset 属性判断选区终止位置。&lt;/p&gt;
&lt;h3&gt;选区示例&lt;/h3&gt;
&lt;p&gt;如图：anchorNode 为选区起始位置所在节点("政采云"文本节点)，focusNode 为选区结束位置所在节点("ZOO"文本节点)，anchorOffset 与 focusOffset 分别为起始位置的 index，通过此信息可得到选区范围，此时 Selection 对象 type 为 Range 。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (4).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b58237b063924f2f9473b20c24eeb865~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;光标示例（起始位置是同一个位置的选区）&lt;/h3&gt;
&lt;p&gt;如图：anchorNode 与 focusNode 为同一节点("ZOO"文本节点)，anchorOffset 与 focusOffset 指向节点同一处，通过此信息可得到光标位置，此时 Selection 对象 type 为 Caret 。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (5).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a61ef2f6715143e7815e0cdd514cf6b6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;用途&lt;/h3&gt;
&lt;h4&gt;删除、替换选区内容&amp;amp;插入操作&lt;/h4&gt;
&lt;p&gt;Selection 对象有 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection/deleteFromDocument"&gt;deleteFromDocument&lt;/a&gt; 方法，可以在编辑区域删除选区内容。如想删除后插入，可获取新的 Selection 对象，利用此时位置所在 dom 元素的方法插入对应的文字、元素。&lt;/p&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="QQ20220722-175519.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/475bcde68fd54fb5b95fee3ef75ba825~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;插入逻辑代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;  const insert = () =&amp;gt; {
    // 删除所选内容
    window.getSelection().deleteFromDocument()
    const selection = window.getSelection()
    // 删除后选取的起始位置就是插入位置，由 anchorNode 及 anchorOffset 确定
    const { anchorNode, anchorOffset } = selection
    // anchorNode 分为两种情况，一种是文本节点，另一种是其他类型节点，处理逻辑不同
    if (anchorNode.nodeType === 3) {
      const string = anchorNode.nodeValue
      // anchorNode 为文本节点时，需要将内部字符串与索要插入的内容拼接
      anchorNode.nodeValue = (string.substring(0, anchorOffset) + '😄' + string.substring(anchorOffset, Infinity))
    } else {
      const newNode = document.createElement('span')
      newNode.innerText = '😄'
      // anchorNode 为其他类型节点时，需要根据 anchorOffset 在 anchorNode 中插入片元素
      anchorNode.insertBefore(newNode, anchorNode.childNodes[anchorOffset])
    }
  }
  
  //也可根据 Selection 提供的原生方法实现
  const insert2 = () =&amp;gt; {
    lastRange = window.getSelection().getRangeAt(0);
    const newNode = document.createElement('span');
    newNode.textContent = '😄'
    lastRange.deleteContents()
    lastRange.insertNode(newNode)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于选区的更多用途，可参考选区属性和方法进行灵活实现：&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection#methods"&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Selection#methods&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;富文本工具栏实现&lt;/h2&gt;
&lt;p&gt;根据前文介绍的方法实现输入功能后，我们即实现了纯文本编辑的功能，那么如何进一步实现富文本编辑呢？&lt;/p&gt;
&lt;p&gt;document 提供了 execCommand() 方法，该方法会影响使用 designMode 或contentEditable 属性实现可编辑区域的元素。方法说明如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;document.execCommand(*aCommandName*, *aShowDefaultUI*, *aValueArgument*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;aCommandName&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个 &lt;a href="https://developer.mozilla.org/zh-CN/docs/conflicting/Web/JavaScript/Reference/Global_Objects/String_6fa58bba0570d663099f0ae7ae8883ab"&gt;DOMString&lt;/a&gt; ，命令的名称。可用命令列表请参阅 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand#%E5%91%BD%E4%BB%A4"&gt;命令&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;aShowDefaultUI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"&gt;Boolean&lt;/a&gt;， 是否展示用户界面，一般为 false。Mozilla 没有实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;aValueArgument&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一些命令（例如 insertImage）需要额外的参数（insertImage 需要提供插入 image 的 url），默认为 null。&lt;/p&gt;
&lt;p&gt;该方法执行后，会返回 boolean 值，如果是 false，表示操作不被支持或未被启用。&lt;/p&gt;
&lt;p&gt;不同浏览器支持的命令也不一样。下标列出了最常用的命令。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/th&gt;
&lt;th style="text-align: left;"&gt;&lt;strong&gt;可选值&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;backColor&lt;/td&gt;
&lt;td style="text-align: left;"&gt;设置文档背景颜色。在styleWithCss模式下，则只影响容器元素的背景颜色。&lt;/td&gt;
&lt;td style="text-align: left;"&gt;颜色值字符串（IE使用这个命令设置文本背景色）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;bold&lt;/td&gt;
&lt;td style="text-align: left;"&gt;切换选中文本的粗体样式&lt;/td&gt;
&lt;td style="text-align: left;"&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;createLink&lt;/td&gt;
&lt;td style="text-align: left;"&gt;将选中内容转换为指向给定URL的链接&lt;/td&gt;
&lt;td style="text-align: left;"&gt;URL链接值，至少包含一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;fontSize&lt;/td&gt;
&lt;td style="text-align: left;"&gt;将选中文本改为指定字体大小&lt;/td&gt;
&lt;td style="text-align: left;"&gt;提供HTML字体尺寸(1-7)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;foreColor&lt;/td&gt;
&lt;td style="text-align: left;"&gt;将选中文本改为指定颜色&lt;/td&gt;
&lt;td style="text-align: left;"&gt;颜色值字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;formatBlock&lt;/td&gt;
&lt;td style="text-align: left;"&gt;将选中文本包含在指定的HTML标签中&lt;/td&gt;
&lt;td style="text-align: left;"&gt;提供HTML标签，如&lt;h1&gt;&lt;/h1&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;insertImage&lt;/td&gt;
&lt;td style="text-align: left;"&gt;在光标位置插入图片&lt;/td&gt;
&lt;td style="text-align: left;"&gt;图片的URL链接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;insertParagraph&lt;/td&gt;
&lt;td style="text-align: left;"&gt;在光标位置插入&lt;p&gt;元素&lt;/p&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;italic&lt;/td&gt;
&lt;td style="text-align: left;"&gt;切换选中文本的斜体样式&lt;/td&gt;
&lt;td style="text-align: left;"&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;styleWithCSS&lt;/td&gt;
&lt;td style="text-align: left;"&gt;用这个取代useCSS命令。切换使用HTML tags还是CSS来生成标记。&lt;/td&gt;
&lt;td style="text-align: left;"&gt;Boolean值，false使用CSS，true使用HTML&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关于 document.exexCommand 的更多命令，可参考 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand"&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;常用功能（字体样式、插入图片）演示&lt;/h3&gt;
&lt;p&gt;下图挑选了几个常用命令(加粗、斜体、改变字体颜色、插入图片)作为演示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="QQ20220723-184134.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00b6d7e5db5f4ee0aeacb18e36ffe60b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;代码示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;  // 加粗
  const bold = (val) =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('Bold', false, val)
  }
  // 斜体
  const italic = (val) =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('italic', false, val)
  }
  // 改变字体颜色
  const changeColor = (val = '#ff0000') =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('foreColor', false, val)
  }
  // 插入图片
  const insertImage = (val = 'https://avatar-static.segmentfault.com/339/131/3391311562-5d5653daaad5f_huge256') =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('insertImage', false, val)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;富文本数据收集存储与回填&lt;/h2&gt;
&lt;p&gt;富文本容器的 innerHTML 即是富文本数据。&lt;/p&gt;
&lt;p&gt;编辑区域可通过获取编辑元素的 innerHTML拿到对应富文本数据，存入数据库。&lt;/p&gt;
&lt;p&gt;网络请求的富文本数据设置为富文本容器的 innerHTML，即可展示富文本内容。&lt;/p&gt;
&lt;p&gt;下列图片可简单表明：&lt;/p&gt;
&lt;p&gt;&lt;img alt="QQ20220723-183242.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cbdb9442eda4a2eb07bafe7ec8eaa3a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;结尾（附Demo）&lt;/h2&gt;
&lt;p&gt;根据本文介绍内容我们依次了解了前端富文本的概念、输入模式实现、选区的信息及应用、富文本工具栏的实现和富文本数据收集回填。将这些内容汇总即可实现一个简单的前端富文本编辑器。&lt;/p&gt;
&lt;p&gt;下方附上本文内容汇总的代码 demo ，内含基于 iframe 和 div 元素分别实现的富文本编辑器，功能简单，供读者参考。读者可根据文章内容进行拓展实现自己的前端富文本编辑器。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;html lang="en"&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset="UTF-8"&amp;gt;
  &amp;lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&amp;gt;
  &amp;lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;style&amp;gt;
  .rt-container {
    height: 200px;
    width: 500px;
    padding: 10px;
    overflow: auto;
  }
&amp;lt;/style&amp;gt;

&amp;lt;body&amp;gt;
  --------------------------------------------------------------&amp;lt;br /&amp;gt;
  &amp;lt;button onclick="bold()"&amp;gt;粗体&amp;lt;/button&amp;gt;
  &amp;lt;button onclick="italic()"&amp;gt;斜体&amp;lt;/button&amp;gt;
  &amp;lt;button onclick="changeColor()"&amp;gt;改变颜色&amp;lt;/button&amp;gt;
  &amp;lt;button onclick="insertImage()"&amp;gt;插入图片&amp;lt;/button&amp;gt;
  &amp;lt;button onclick="insert()"&amp;gt;插入字符(表情)&amp;lt;/button&amp;gt;&amp;lt;br /&amp;gt;
  元素设置contenteditable&amp;lt;br /&amp;gt;
  --------------------------------------------------------------&amp;lt;br /&amp;gt;
  // 元素设置 contenteditable 方式
  &amp;lt;div class="rt-container" contenteditable="true"&amp;gt;政采云前端团队&amp;lt;/div&amp;gt;
  ------------------------------------------------------------------&amp;lt;br /&amp;gt;

  &amp;lt;button onclick="boldIframe()"&amp;gt;iframe粗体&amp;lt;/button&amp;gt;&amp;lt;br /&amp;gt;
  iframe设置designMode&amp;lt;br /&amp;gt;
  // iframe 设置 designMode 方式
  &amp;lt;iframe class="rt-container" name="editor"&amp;gt;&amp;lt;/iframe&amp;gt;&amp;lt;br /&amp;gt;

  ------------------------------------------------------------------
  &amp;lt;div&amp;gt;政采云&amp;lt;span&amp;gt;前端&amp;lt;/span&amp;gt;团队&amp;lt;img src="https://avatar-static.segmentfault.com/339/131/3391311562-5d5653daaad5f_huge256"
      width="32" height="32"&amp;gt;
    &amp;lt;div&amp;gt;ZOO&amp;lt;/div&amp;gt;TEAM
  &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
  window.addEventListener("load", () =&amp;gt; {
    frames["editor"].document.designMode = "on";
  });
  const bold = (val) =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('Bold', false, val)
  }
  const italic = (val) =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('italic', false, val)
  }
  const changeColor = (val = '#ff0000') =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('foreColor', false, val)
  }
  const insertImage = (val = 'https://avatar-static.segmentfault.com/339/131/3391311562-5d5653daaad5f_huge256') =&amp;gt; {
    document.execCommand('StyleWithCSS', true, true)
    document.execCommand('insertImage', false, val)
  }

  const boldIframe = (val) =&amp;gt; {
    frames["editor"].document.execCommand('StyleWithCSS', true, true)
    frames["editor"].document.execCommand('Bold', false, val)
  }
  const insert = () =&amp;gt; {
    window.getSelection().deleteFromDocument()
    const selection = window.getSelection()
    const { anchorNode, anchorOffset } = selection
    if (anchorNode.nodeType === 3) {
      const string = anchorNode.nodeValue
      anchorNode.nodeValue = (string.substring(0, anchorOffset) + '😄' + string.substring(anchorOffset, Infinity))
    } else {
      const newNode = document.createElement('span')
      newNode.innerText = '😄'
      anchorNode.insertBefore(newNode, anchorNode.childNodes[anchorOffset])
    }
  }
  const insert2 = () =&amp;gt; {
    lastRange = window.getSelection().getRangeAt(0);
    const newNode = document.createElement('span');
    newNode.textContent = '😄'
    lastRange.deleteContents()
    lastRange.insertNode(newNode)
  }
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image (6).png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/115dadd7cf8a464089b39b4e205d98db~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h2&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7122240814108901406"&gt;可视化搭建系统之数据源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7119639489567260686"&gt;表单数据形式配置化设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7117042614313943070"&gt;如何将传统 Web 框架部署到 Serverless&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7114450860335169543"&gt;浅谈前端埋点 &amp;amp; 监控&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7111848825232293918"&gt;如何让 x == 1 &amp;amp;&amp;amp; x == 2 &amp;amp;&amp;amp; x == 3 等式成立&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;开源作品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;政采云前端小报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://www.zoo.team/openweekly/"&gt;www.zoo.team/openweekly/&lt;/a&gt;&lt;/strong&gt; (小报官网首页有微信交流群)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商品选择 sku 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开源地址 &lt;a href="https://github.com/zcy-inc/skuPathFinder-back"&gt;https://github.com/zcy-inc/skuPathFinder-back/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;招贤纳士&lt;/h2&gt;
&lt;p&gt;政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 90 余个前端小伙伴，平均年龄 27 岁，近 4 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。&lt;/p&gt;
&lt;p&gt;如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 &lt;code&gt;ZooTeam@cai-inc.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>政采云前端团队</author><pubDate>Tue, 26 Jul 2022 16:17:49 GMT</pubDate></item><item><title>创建现代npm包的最佳实践</title><link>https://juejin.cn/post/7152302632143421470</link><description>&lt;blockquote&gt;
&lt;p&gt;本文首发于微信公众号：大迁世界, 我的微信：qq449245884，我会第一时间和你分享前端行业趋势，学习途径等等。
更多开源作品请看 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; ，包含一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;技术一直在变化，我们的流程和做法也需要跟上这些变化。因此，虽然npm已经有12年的历史了，但围绕 npm 包创建的做法应该更现代。&lt;/p&gt;
&lt;p&gt;在这节课中，我们使用现代最佳实践（截至2022年）一步一步地创建一个npm包。首先学习如何创建一个npm包，这样你就可以熟悉构建和发布一个包到 npm 注册表。&lt;/p&gt;
&lt;p&gt;然后，再学习如何通过建立测试框架、持续集成和部署管道、安全检查以及发布的自动语义版本管理，来制作一个更健壮、可用于生产的npm包。&lt;/p&gt;
&lt;h2&gt;简单的npm包示例&lt;/h2&gt;
&lt;p&gt;我们先通过一个简单的例子来熟悉创建和发布npm包的过程。&lt;/p&gt;
&lt;h4&gt;创建项目&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建一个 GitHub 仓库: https://github.com/new&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;克隆本地的 repo。
例如：git clone https://github.com/snyk-labs/simple-npm-package.git&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开你的终端,进入到克隆的项目文件夹。
例如：cd simple-npm-package&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;npm init -y&lt;/code&gt; 来创建 &lt;code&gt;package.json&lt;/code&gt; 文件。注意：如果克隆了示例仓库，就不需要做这一步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在package.json 取一个名称，对应 name 字段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为该包编写你的代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;创建 npm 账户&lt;/h4&gt;
&lt;p&gt;为了能够让我们的 npm 包供他人使用，需要一个npm账户。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 https://www.npmjs.com/signup 注册&lt;/li&gt;
&lt;li&gt;为了提高安全性，请在您的npm账户上启用2FA：https://docs.npmjs.com/configuring-two-factor-authentication&lt;/li&gt;
&lt;li&gt;使用 npm login 命令在终端中用你的 npm账户登录，并按照屏幕上的指示操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; npm login
npm notice Log in on https://registry.npmjs.org/
Username: clarkio
Password:
Email: (this IS public) &amp;lt;email address&amp;gt;
npm notice Please use the one-time password (OTP) from your authenticator application
Enter one-time password from our authenticator app: &amp;lt;OTP&amp;gt;
Logged in as clarkio on https://registry.npmjs.org/.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;如何发布 npm 包&lt;/h2&gt;
&lt;p&gt;一旦你有了一个npm项目和一个npm账户，你就可以把你的npm包发布到公开的官方&lt;code&gt;npmjs&lt;/code&gt;注册表上，让其他人可以使用。以下是你要遵循的步骤，在执行之前检查将发布的内容，然后运行实际的发布过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在终端，运行 &lt;code&gt;npx npm-packlist&lt;/code&gt; 来查看将被包含在发布版本的软件包中的内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这可以确保我们没有遗漏任何源代码文件，这些文件是软件包正常运行所需要的。这也是一个好的做法，以确保我们不会意外地将敏感信息泄露给公众，如带有数据库凭证或API密钥的本地配置文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; npx npm-packlist
LICENSE
index.js
package.json
README.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在终端，运行&lt;code&gt;npm publish --dry-run&lt;/code&gt;，看看实际运行命令时将会做什么。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; npm publish --dry-run
npm notice
npm notice 📦@clarkio/simple-npm-package@0.0.1
npm notice === Tarball Contents ===
npm notice 1.1kB LICENSE
npm notice 1.2kB README.md
npm notice 95B index.js
npm notice 690B package.json
npm notice === Tarball Details===
npm notice name: @clarkio/simple-npm-package
npm notice version: 0.0.1
npm notice filename:@clarkio/simple-npm-package-0.0.1.tgz
npm notice package size:1.7 kB
npm notice unpacked size: 3.1 kB
npm notice shasum:40ede3ed630fa8857c0c9b8d4c81664374aa811c
npm notice integrity:sha512-QZCyWZTspkcUXL... ]L60ZKBOOBRLTg==
npm notice total files:4
npm notice
+ @clarkio/simple-npm-package@0.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="3"&gt;
&lt;li&gt;在终端，运行 &lt;code&gt;npm publish --access=public&lt;/code&gt; 来发布软件包到npm。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：&lt;strong&gt;--access=public&lt;/strong&gt;对于作用哉内的包（&lt;code&gt;@clarkio/modern-npm-package&lt;/code&gt;）是需要的，因为它们默认是私有的。如果它不是作用哉内的，并且在你的 &lt;code&gt;package.json&lt;/code&gt; 中没有将&lt;code&gt;private&lt;/code&gt; 字段设置为 &lt;code&gt;true&lt;/code&gt;，它也将是公开的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; npm publish --access=public
npm notice
npm notice 📦@clarkio/simple-npm-package@0.0.1
npm notice === Tarball Contents ===
npm notice 1.1kB LICENSE
npm notice 1.2kB README.md
npm notice 95B index.js
npm notice 690B package.json
npm notice === Tarball Details===
npm notice name: @clarkio/simple-npm-package
npm notice version: 0.0.1
npm notice filename:@clarkio/simple-npm-package-0.0.1.tgz
npm notice package size:2.1 kB
npm notice unpacked size: 4.1 kB
npm notice shasum:6f335d6254ebb77a5a24ee729650052a69994594
npm notice integrity:sha512-VZ1K1eMFOKeJW[...]7ZjKFVAxLcpdQ==
npm notice total files:4
npm notice
This operation requires a one-time password.
Enter OTP: &amp;lt;OTP&amp;gt;
+ @clarkio/simple-npm-package@0.0.1

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们已经完成了构建和部署自己的npm包。接下来，我们来看一下如何制作一个更强大的包，为生产环境做好准备，并得到更广泛的使用。&lt;/p&gt;
&lt;h2&gt;生产就绪的npm包&lt;/h2&gt;
&lt;p&gt;虽然前面的例子的包可以在生产中使用，但它涉及到人工成本来保持其长期的维护。使用工具和自动化以及适当的测试和安全检查将有助于最大限度地减少保持软件包顺利运行的总工作量。让我们深入了解一下这其中的内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建CommonJS（CJS）和ECMAScript（ESM）模块&lt;/li&gt;
&lt;li&gt;设置和编写单元测试&lt;/li&gt;
&lt;li&gt;实施安全检查&lt;/li&gt;
&lt;li&gt;实现版本管理和发布的自动化&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;构建 CommonJS（CJS）和ECMAScript（ESM）模块&lt;/h4&gt;
&lt;p&gt;虽然ECMAScript模块格式现在在Node.js的12+版本中被原生支持，但它还没有被社区广泛采用。为了面向未来并支持这两种格式，我们来看下使用 TypeScript怎么来配置。&lt;/p&gt;
&lt;p&gt;首先，创建一个基本的 TypeScript 配置文件 &lt;code&gt;tsconfig.base.json&lt;/code&gt;。这是通用的编译设置，无论你的目标是哪种模块格式，都可以使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "checkJs": true,
    "allowJs": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true
  },
  "files": ["../src/index.ts"]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后为 CommonJS 格式创建一个TypeScript配置文件，命名为&lt;code&gt;tsconfig.cjs.json&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;lib&lt;/code&gt; 属性向TypeScript指出它应该参考哪些类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;target&lt;/code&gt; 属性向TypeScript指出要编译的项目代码的JavaScript版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;module&lt;/code&gt; 属性向 TypeScript 指出在编译的项目代码时应该使用哪种JavaScript模块格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;moduleResolution&lt;/code&gt; 属性帮助 TypeScript 弄清 "import"语句应该如何被提及。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;outDir&lt;/code&gt; 和 &lt;code&gt;declarationDir&lt;/code&gt; 属性向TypeScript指出了将编译的代码和定义其中使用的类型的结果放在哪里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "lib": ["ES6", "DOM"],
    "target": "ES6",
    "module": "CommonJS",
    "moduleResolution": "Node",
    "outDir": "../lib/cjs",
    "declarationDir": "../lib/cjs/types"
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后，为 ECMAScript 格式创建一个TypeScript配置文件，命名为&lt;code&gt;tsconfig.esm.json&lt;/code&gt;。这里的属性与你在 CommonJS 配置中看到的相同，但现在针对现代ECMAScript模块格式作为其输出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "lib": ["ES2022", "DOM"],
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "NodeNext",
    "outDir": "../lib/esm",
    "declarationDir": "../lib/esm/types"
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新 &lt;code&gt;package.json&lt;/code&gt; 文件，增加一个 &lt;code&gt;files&lt;/code&gt; 字段，指向&lt;code&gt;lib&lt;/code&gt;文件夹，里面有 TypeScript为你构建软件包的结果。&lt;/p&gt;
&lt;p&gt;更新 &lt;code&gt;package.json&lt;/code&gt; 文件中的 &lt;code&gt;exports&lt;/code&gt; 字段，以定义如何根据使用的模块加载器（CJS vs. ESM）查找源文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;"exports": {
    ".": {
      "import": {
        "types": "./lib/esm/types/index.d.ts",
        "default": "./lib/esm/index.mjs"
      },
      "require": {
        "types": "./lib/cjs/types/index.d.ts",
        "default": "./lib/cjs/index.js"
      }
    }
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新 &lt;code&gt;package.json&lt;/code&gt; 文件的 &lt;code&gt;main&lt;/code&gt;和 &lt;code&gt;types&lt;/code&gt; 字段，以指向软件包的CJS版本。这将作为一个默认的、后备的选项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“types": "./lib/cjs/types/index.d.ts",
"main": "./lib/cjs/index.js",
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;package.json&lt;/code&gt; 文件中添加一个 &lt;code&gt;files&lt;/code&gt; 字段，以表明当 &lt;code&gt;npm&lt;/code&gt; 打包你的代码进行发布时，应该包括哪些文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;"files": [
   "lib/**/*"
],
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;package.json&lt;/code&gt; 中的 &lt;code&gt;scripts&lt;/code&gt; 字段创建命令，使用 &lt;code&gt;tsc&lt;/code&gt; 并编译包的 CJS 和 ESM 格式，并生成 &lt;code&gt;lib&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clean&lt;/code&gt; 命令是用来删除过去构建的输出，并从一个干净的地方开始。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;build:esm&lt;/code&gt;命令末尾的 &lt;code&gt;mv lib/esm/index.js lib/esm/index.mjs&lt;/code&gt; 重命名了文件扩展名，这样Node.js模块加载器就知道它是一个ESM模块。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;prepack&lt;/code&gt;命令是npm在打包npm包准备发布到注册表之前使用的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    "clean": "rm -rf ./lib",
    "build": "npm run clean &amp;amp;&amp;amp; npm run build:esm &amp;amp;&amp;amp; npm run build:cjs",
    "build:esm": "tsc -p ./configs/tsconfig.esm.json &amp;amp;&amp;amp; mv lib/esm/index.js lib/esm/index.mjs",
    "build:cjs": "tsc -p ./configs/tsconfig.cjs.json",
    "prepack": "npm run build"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在可以在终端运行 &lt;code&gt;npm run build&lt;/code&gt;，让TypeScript构建你的项目，为使用和发布做准备&lt;/p&gt;
&lt;p&gt;这就是使用 TypeScript 构建 npm 包所需要做的所有设置，它同时支持 CommonJS 和ECMAScript模块格式。&lt;/p&gt;
&lt;h2&gt;设置和添加测试&lt;/h2&gt;
&lt;p&gt;为了对代码的行为和结果有信心，我们需要有一个测试过程。测试迫使在第一次创建代码时，在happy-path 之外，以不同的方式思考代码的功能。举个例子，可以想办法打破一个函数，使它抛出一个错误或产生一个非预期的结果。这样做将使你的应用程序更有弹性和可持续性，并确保在添加更多内容时不会出现问题。&lt;/p&gt;
&lt;h4&gt;单元测试&lt;/h4&gt;
&lt;p&gt;要确保库以我们想要的方式运行，需要针对代码编写测试。我们需要一些工具来帮助设置我们项目来运行单元测试并显示结果。&lt;/p&gt;
&lt;p&gt;这些工具有 &lt;code&gt;Mocha.js&lt;/code&gt;、&lt;code&gt;Chai.js&lt;/code&gt;和 &lt;code&gt;ts-node&lt;/code&gt;。Mocha.js 是一个测试运行器，Chai.js是一个断言库，帮助确定你是否从你的代码中得到你所期望的结果，而 &lt;code&gt;ts-node&lt;/code&gt; 帮助我们在TypeScript项目中使用这些工具。按照下面的步骤，为 npm包设置和运行测试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在终端中使用以下命令安装开发者的依赖:
&lt;code&gt;npm i -D mocha @type/mocha chai @types/chai ts-node&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在项目的根目录下创建一个新文件 &lt;code&gt;.mocharc.json&lt;/code&gt;，内容如下:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
     "extension": ["ts"],
     "spec": "./**/*.spec.ts",
     "require": "ts-node/register"
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在项目的根目录下创建一个 &lt;code&gt;tests&lt;/code&gt; 文件夹。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;index.spec.ts&lt;/code&gt; 文件中写单元测试来测试 &lt;code&gt;index.ts&lt;/code&gt; 中的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;package.json&lt;/code&gt; 文件的 &lt;code&gt;scripts&lt;/code&gt; 部分添加一个 &lt;code&gt;test&lt;/code&gt; 属性，给它一个 &lt;code&gt;mocha&lt;/code&gt; 的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  "scripts": {
    "clean": "rm -rf ./lib",
    "build": "npm run clean &amp;amp;&amp;amp; npm run build:esm &amp;amp;&amp;amp; npm run build:cjs",
    "build:esm": "tsc -p ./configs/tsconfig.esm.json &amp;amp;&amp;amp; mv lib/esm/index.js lib/esm/index.mjs",
    "build:cjs": "tsc -p ./configs/tsconfig.cjs.json",
    "prepack": "npm run build",
    "test": "mocha"
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;最后，在终端运行 &lt;code&gt;npm test&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bc@mbp-snyk modern-npm-package % npm test

&amp;gt; @clarkio/modern-npm-package@0.0.0-development test
&amp;gt; mocha

  NPM Package
    ✔️ should be an object
    ✔️ should have a helloworld property

  Hello World Function
    ✔️  should be a function
    ✔️ should return the hello world message

4 passing (22ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;管道中的测试&lt;/h2&gt;
&lt;p&gt;按照下面的步骤，创建一个测试工作流，作为项目管道的一部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为仓库创建一个新的GitHub Action ：&lt;code&gt;https://github.com/&amp;lt;your-account-or-organization&amp;gt;/&amp;lt;your-repo-name&amp;gt;/actions/new&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将工作流程重命名为 &lt;code&gt;test.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在工作流程文件中插入以下Snyk动作脚本:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;name: Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:

    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [12.x, 14.x, 16.x, 18.x]

    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm ci
      - run: npm test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个YAML脚本检查出你的最新代码，安装其依赖性，并运行 &lt;code&gt;npm test&lt;/code&gt;命令来执行测试。它对&lt;code&gt;node-version&lt;/code&gt;字段中列出的每一个Node.js版本都会这样做，所以可以确保代码在每次运行时都能按预期工作。&lt;/p&gt;
&lt;p&gt;现在已经完成了对项目的设置，以便对npm包的代码进行运行和评估测试。然而，你可能在想 "我如何在另一个项目中使用我的npm包进行测试？" 让我们来看看。&lt;/p&gt;
&lt;h2&gt;包测试&lt;/h2&gt;
&lt;p&gt;包上传完成后，除了单元测试外，我们还要测试在另一个项目引入我们包使用的情况，看看是否像我们所期望那样。这里有五种可以测试的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 npm pack 输出安装&lt;/li&gt;
&lt;li&gt;通过相对路径安装&lt;/li&gt;
&lt;li&gt;通过npm链接安装&lt;/li&gt;
&lt;li&gt;通过注册表安装（如npmjs.com的npm公共注册表）。&lt;/li&gt;
&lt;li&gt;使用Verdaccio（一个开源的npm私有npm注册项目）来运行端到端的软件包发布和安装步骤，作为你CI的一部分。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;npm pack&lt;/h2&gt;
&lt;p&gt;这种方法将利用&lt;code&gt;npm pack&lt;/code&gt;命令将 npm 包打包并压缩成一个文件（&lt;code&gt;&amp;lt;package-name&amp;gt;.tgz&lt;/code&gt;）。然后你可以到你想使用该包的项目中，通过这个文件安装它。这样做的步骤如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;终端运行 &lt;code&gt;npm pack&lt;/code&gt;。注意它产生的&lt;code&gt;.tgz&lt;/code&gt;文件和它的位置。&lt;/li&gt;
&lt;li&gt;改变目录到你想使用 &lt;code&gt;npm&lt;/code&gt; 包的项目目录。例如：&lt;code&gt;cd /path/to/project&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行&lt;code&gt;npm install /path/to/package.tgz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后就可以在项目中使用该包来测试东西了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;npm link&lt;/h2&gt;
&lt;p&gt;利用 &lt;code&gt;npm link&lt;/code&gt; 命令来安装本地包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在当前包目录中，在终端运行 &lt;code&gt;npm link&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;改变目录到你想使用npm包的项目目录。例如：&lt;code&gt;cd /path/to/project&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在项目中运行 &lt;code&gt;npm link &amp;lt;name-of-your-package&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样在项目中就可以使用我们的包。&lt;/p&gt;
&lt;h2&gt;相对路径&lt;/h2&gt;
&lt;p&gt;这种类似于npm link。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在终端运行 &lt;code&gt;npm install /path/to/your/package&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 &lt;code&gt;npm link&lt;/code&gt; 的方法类似，这允许我们在项目中快速测试包的功能，但不会给你完整的类似生产的体验。这是因为它指向完整的软件包源代码目录，而不是你在npm注册表中找到的软件包的构建版本。&lt;/p&gt;
&lt;h2&gt;npm registry&lt;/h2&gt;
&lt;p&gt;这种方法利用了npm包的公共（或你自己）注册表。它涉及到发布的包，并像你通常对任何其他npm包那样进行安装。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用本文前面概述的步骤，通过 &lt;code&gt;npm publish&lt;/code&gt; 命令发布npm包&lt;/li&gt;
&lt;li&gt;改变目录到想使用npm包的项目目录。例如：&lt;code&gt;cd /path/to/project&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在项目目录中运行 &lt;code&gt;npm install &amp;lt;name-of-your-package&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;实施安全检查&lt;/h2&gt;
&lt;p&gt;就像你不希望在自己的项目中出现安全漏洞一样，你也不希望在其他人的项目中引入漏洞。构建一个预计会在许多其他项目中使用的npm包，这就增加了确保事情安全的责任。你需要有安全检查，以帮助监测、提醒和提供帮助来减少漏洞。这就是像&lt;a href="https://app.snyk.io/login"&gt;Snyk&lt;/a&gt;这样的工具可以简化完成这些需求所需的工作的地方。&lt;/p&gt;
&lt;p&gt;对于这个例子中的npm包，你使用GitHub作为你的源码控制管理工具，所以利用它的GitHub Actions功能将Snyk整合到工作流程中。Snyk 有一个GitHub Actions参考项目，可以帮助启动这方面的工作，并为你的项目可能使用的其他编程语言和工具提供例子。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Snyk是免费的，这里可以进行&lt;a href="https://app.snyk.io/login?redirectUri=L2FjY291bnQ%3D&amp;amp;from=snyk_marketing_site"&gt;注册&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在GitHub上将你的Snyk API令牌添加为仓库秘密： &lt;code&gt;https://github.com/&amp;lt;your-account-or-organization&amp;gt;/&amp;lt;your-repo-name&amp;gt;/settings/secrets/actions/new&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仓库创建一个新的GitHub Action: &lt;code&gt;https://github.com/&amp;lt;your-account-or-organization&amp;gt;/&amp;lt;your-repo-name&amp;gt;/actions/new&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将workflow 重命名为 &lt;code&gt;snyk.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 workflow 文件中插入以下Snyk Action 脚本:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;name: Snyk Security Check
on: [push,pull_request]
jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@main
      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="6"&gt;
&lt;li&gt;提交你的修改。&lt;/li&gt;
&lt;li&gt;验证Action 成功运行: &lt;code&gt;https://github.com/&amp;lt;your-account-or-organization&amp;gt;/&amp;lt;your-repo-name&amp;gt;/actions&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了这个设置，任何时候任何人推送到你的版本库或针对它打开一个拉动请求，都会进行安全检查，以确保它不会在软件包中引入任何漏洞。如果发现了问题，行动将失败，并提醒你发现的安全问题的细节。接下来，你将围绕版本管理和发布你的npm包进行自动化处理。&lt;/p&gt;
&lt;p&gt;关于目前的设置，需要注意的一点是，它只利用了Snyk开源（SCA）产品，而不是Snyk代码（SAST）。Snyk Code是我们的代码安全产品，你需要首先通过你的Snyk账户启用它（免费），然后在这里添加到你的工作流程脚本中，以充分利用它。&lt;/p&gt;
&lt;h2&gt;实现版本管理和发布的自动化&lt;/h2&gt;
&lt;p&gt;每当在主分支中合并变化时，我们不想每次都手动更新npm包的版本并发布它。相反，会想让这个过程自动发生。如果你还记得本篇文章前面那个简单的npm包的例子，用以下命令来更新npm包的版本，然后发布它。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm version &amp;lt;major|minor|patch&amp;gt;
npm publish
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;什么是语义版本管理？&lt;/h4&gt;
&lt;p&gt;语义版本管理规定，版本要用三个占位符进行编号。第一个是主要版本，第二个是次要版本，而最后一个是补丁版本。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://semantic-release.gitbook.io/semantic-release/"&gt;Semantic Release&lt;/a&gt;的工具可以与 GitHub Actions 整合来帮助我们自动修改版本并发布。实现这一过程自动化的关键是，你在向项目提交变更时使用所谓的常规提交。这使得自动化能够相应地更新一切，并知道如何为你准备项目的下一个版本。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;运行：&lt;code&gt;npm i -D semantic-release&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;npx semantic-release-cli setup&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照终端的提示，提供所需的令牌&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;需要一个来自 GitHub 的个人访问令牌。要创建一个，请到 https://github.com///settings/secrets/actions/new&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在创建此令牌时，请使用以下作用域&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d5f102e01154db2ac100e1a13459baf~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;ol start="4"&gt;
&lt;li&gt;还需要一个来自npm的自动化类型的访问令牌，只在CI环境中使用，这样它就能绕过你的账户的2FA。要创建一个，请到https://www.npmjs.com/settings//tokens。请确保选择 "Automation"类型，因为这将用于CI/CD工作流程中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b68b33fe4e3e42ac967d3b763a14a785~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bc@mbp-snyk modern-npm-package % npx semantic-release-cli setup
? What is your npm registry? https://registry.npmjs.org/
? What is vour nom username? clarkio
? What is your pm password? [hidden]
? What is your NPM two-factor authentication code? &amp;lt;2FA code&amp;gt;
Provide a GitHub Personal Access Token (create a token at https://github.com/settings/tokens/new?scopes=repo
&amp;lt;token&amp;gt;
? What CI are you using? Github Actions
bc@mbp-snyk modern-npm-package %
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="5"&gt;
&lt;li&gt;将npm令牌作为仓库秘密添加到GitHub仓库中：&lt;code&gt;https://github.com/&amp;lt;your-name-or-organization/&amp;lt;your-repository&amp;gt;/settings/secrets/actions/new&lt;/code&gt;。将秘密的名称设置为&lt;code&gt;NPM_TOKEN&lt;/code&gt;，其值是你在前面步骤中检索到的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a31451f109e045609eced9eaf1f970e8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;ol start="6"&gt;
&lt;li&gt;回到项目中，进入&lt;code&gt;package.json&lt;/code&gt;文件，像下面这样添加一个&lt;code&gt;release&lt;/code&gt;键。如果你的版本库的主分支仍然叫&lt;code&gt;master&lt;/code&gt;而不是&lt;code&gt;main&lt;/code&gt;，那么就相应地更新上述分支的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;"release": {
    "branches": ["main"]
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="7"&gt;
&lt;li&gt;在 &lt;code&gt;package.json&lt;/code&gt; 文件中也添加一个&lt;code&gt;publishConfig&lt;/code&gt;键。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;"publishConfig": {
    "access": "public"
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="8"&gt;
&lt;li&gt;
&lt;p&gt;通过使用&lt;code&gt;semantic-release npm&lt;/code&gt;脚本进行模拟运行来测试一切。采用以下命令，并将&lt;code&gt;NPM_TOKEN=&lt;/code&gt;和&lt;code&gt;GH_TOKEN=&lt;/code&gt;值设置为使用您各自的令牌值。然后在你的终端中复制并运行完整的命令，看看一切是否运行正常。你会看到进程被记录在终端的输出中。如果出现任何问题，它们会在这里显示出来，并提供解决这些问题的细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在确认试运行成功后，可以为GitHub仓库设置一个新的GitHub动作来为你处理发布过程。转到你在GitHub上的仓库，点击 "Actions"。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击新建工作流程选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将工作流程重命名为release.yml。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在新的工作流程文件中加入以下YAML脚本。这个脚本主要是说，一旦Snyk安全检查工作成功完成，就运行发布工作。发布作业会检查代码，设置Node.js环境，安装你的依赖项，然后使用你的GitHub和npm令牌运行语义发布。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;name: Release
on:
  workflow_run:
    workflows: ['Snyk Security Check', 'Tests']
    branches: [main]
    types:
      - completed

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: 'lts/*'
      - name: Install dependencies
        run: npm ci
      - name: Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: npx semantic-release
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;13.提交你的本地修改并推送到你的GitHub仓库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以通过在终端运行命令 &lt;code&gt;git commit -am '&amp;lt;your commit message&amp;gt;'&lt;/code&gt;，然后&lt;code&gt;git push&lt;/code&gt;来实现。&lt;/li&gt;
&lt;li&gt;也可以在VS Code中通过其版本控制功能做到这一点。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="14"&gt;
&lt;li&gt;在所有这些设置完成后，现在可以使用传统的提交方式将修改推送到你的主分支（或通过合并拉动请求），然后发布工作流就会运行（当然是在Snyk安全检查之后）。你可以在&lt;code&gt;modern-npm-package&lt;/code&gt;版本库工作流程的例子中看到这种情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;我们总结一下在本文中学到的一切。首先，熟悉了设置、创建和部署一个简单的npm包。这对于熟悉首次发布自己的npm包来说是很好的。然而，如果想制作一个供生产使用的npm包，这样做是相当费力的，也是不可持续的。&lt;/p&gt;
&lt;p&gt;为了完成制作一个可用于生产的包，随后学会了如何为CommonJS（CJS）和ECMAScript（ESM）模块格式进行构建，设置和编写单元测试，实现安全检查，并自动进行版本管理和发布。有了这些知识，现在已经准备好制作更多属于你自己的npm包了，这些包很容易被社区或你的公司所使用。&lt;/p&gt;
&lt;p&gt;来源：https://snyk.io/blog/best-practices-create-modern-npm-package/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Sat, 08 Oct 2022 16:27:57 GMT</pubDate></item><item><title>CSS容器查询终于来了</title><link>https://juejin.cn/post/7148962811740160007</link><description>&lt;p&gt;CSS容器查询终于来了! 它们目前在谷歌浏览器（105）中得到了支持，很快就会在Safari 16中得到支持。这对前端来说容器查询与媒体查询一样重要。&lt;/p&gt;
&lt;p&gt;在这节课中，我们介绍一下容器查询是如何工作的，如何使用它们，以及语法是什么样子的，并分享一些现实生活中的例子和用例。&lt;/p&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;在设计一个组件时，我们需要适配不同的变化，并根据CSS类或视口大小来改变它们。这对于我们开发来说不是很理想，会迫使我们根据变化类或视口尺寸来写CSS。&lt;/p&gt;
&lt;p&gt;考虑下面例子：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48dbb5241f354badb6904cf35ff1dd3d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们有一个卡片组件，当视口足够大时，它应该切换到水平样式。乍一看，这可能听起来不错。然而，当你更深入地思考这个问题时，它就有点复杂了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b75c0021c43641aa9e67c31d807765b3~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果我们想在不同的地方使用同一个卡片组件，比如在空间狭小的侧边栏和有更多空间的主区域，我们就需要使用不同的类来适配：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.c-article {
  /* Default stacked style */
}

@media (min-width: 800px) {
  /* Horizontal style. */
  .c-article--horizontal {
    display: flex;
    align-items: center;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们不想用上面的方式，那么会出现下面这样的情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2d248843d024a709328207cffbd4136~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这种从用户界面的角度来看，并不友好。&lt;/p&gt;
&lt;p&gt;通过容器查询，我们可以简单地编写响应父级或容器宽度的CSS。请看下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25348c0242704f57a0acb02ef57080f5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;注意到在媒体查询中，我们是如何根据视口或屏幕宽度来查询一个组件的。在容器查询中，同样的情况发生在父级上。&lt;/p&gt;
&lt;h2&gt;什么是容器查询？&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;container-type&lt;/code&gt; 属性查询一个组件与最接近的父类的关系，该父类有一个定义的包含物。&lt;/p&gt;
&lt;p&gt;我们过去在媒体查询中写CSS的方式，但只是针对组件层面。&lt;/p&gt;
&lt;h4&gt;容器查询语法&lt;/h4&gt;
&lt;p&gt;要根据一个组件的父级宽度查询，我们需要使用 &lt;code&gt;container-type&lt;/code&gt; 属性。看下面的例子"&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.wrapper {
  container-type: inline-size;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这些，我们就可以开始查询一个组件。在下面的例子中，如果&lt;code&gt;.card&lt;/code&gt;元素的容器的宽度等于&lt;code&gt;400px&lt;/code&gt;或更大，我们需要添加一个特定的样式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@container (min-width: 400px) {
  .card {
    display: flex;
    align-items: center;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然上述方法可行，但当有多个容器时，就会造成混乱。为了避免这种情况，最好为一个容器命名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.wrapper {
  container-type: inline-size;
  container-name: card;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们可以在 &lt;code&gt;@container&lt;/code&gt; 旁边加容器名称，如下所示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@container card (min-width: 400px) {
  .card {
    display: flex;
    align-items: center;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.wrapper {
  container-type: inline-size;
  container-name: card;
}

.c-article {
  /* Default stacked style */
}

@container card (min-width: 400px) {
  /* Horizontal style. */
  .c-article {
    display: flex;
    align-items: center;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;浏览器支持&lt;/h2&gt;
&lt;p&gt;容器查询现在在Chrome 105中得到支持，并很快在Safari 16中得到支持。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10774b9679a84f1b8324db8050f7ff77~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h2&gt;事例&lt;/h2&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd09e43911434020b4e7b814d60374d7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这边有10个关于容器查询的事例，地址：https://lab.ishadeed.com/container-queries&lt;/p&gt;
&lt;p&gt;来源：https://ishadeed.com/article/container-queries-are-finally-here/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;</description><author>王大冶</author><pubDate>Thu, 29 Sep 2022 16:30:58 GMT</pubDate></item><item><title>别整一坨 CSS 代码了，试试这几个实用函数</title><link>https://juejin.cn/post/7147849664518160415</link><description>&lt;blockquote&gt;
&lt;p&gt;本文首发于微信公众号：大迁世界, 我的微信：qq449245884，我会第一时间和你分享前端行业趋势，学习途径等等。
更多开源作品请看 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; ，包含一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CSS比较函数从2020年4月就开始支持了，我喜欢使用这些函数，但最喜欢的是 &lt;code&gt;clamp()&lt;/code&gt;，它也是我最常用的一个。在这节课中，我们详细来看下这些比较函数。&lt;/p&gt;
&lt;h2&gt;Clamp(), Max(), 和 Min() 函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;clamp()&lt;/code&gt; 函数的作用是把一个值限制在一个上限和下限之间，当这个值超过最小值和最大值的范围时，在最小值和最大值之间选择一个值使用。它接收三个参数：最小值、首选值、最大值。&lt;/p&gt;
&lt;h4&gt;流体的尺寸和定位&lt;/h4&gt;
&lt;p&gt;在下面这个例子中，有一个手机样式，同时有两张图片放置在上面，如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d7171effbac4cd8986cd64d8d4a9f74~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;当容器的宽度变小时，我们要缩小图片的尺寸，这样才不会变形。一般使用百分比单位来解决，如 &lt;code&gt;width: 20%&lt;/code&gt;，但是这种方式没有给我们太多的控制。&lt;/p&gt;
&lt;p&gt;我们希望能够有一个流体尺寸，要求有最小值和最大值，这就是 &lt;code&gt;clamp&lt;/code&gt; 出场的地方。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section-image {
  width: clamp(70px, 80px + 15%, 180px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58459ffca4f647e59cb803ae4602a4f4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;事例地址：https://codepen.io/shadeed/pen/qBYPdOq?editors=1100&lt;/p&gt;
&lt;h4&gt;装饰性元素&lt;/h4&gt;
&lt;p&gt;有时候，我们需要在页面边角加一些修饰元素，该修饰元素需要具有响应式，比如 PC 端是这样的（黑点部分）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b43794fe70d54116a86d19a2b472ed60~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;然后在移动端是长这样的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/297193c6b7e44d0c861826c9d19c9c90~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为了做到这，我们可以使用媒体查询：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.decorative--1 {
  left: 0;
}

.decorative--2 {
  right: 0;
}

@media (max-width: 600px) {
  .decorative--1 {
    left: -8rem;
  }

  .decorative--2 {
    right: -8rem;
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然这样做可以，但我们可以 &lt;code&gt;clamp()&lt;/code&gt;函数，这样更简洁：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  .decorative--1 {
    left: clamp(-8rem, -10.909rem + 14.55vw, 0rem);
  }

  .decorative--2 {
    right: clamp(-8rem, -10.909rem + 14.55vw, 0rem);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事例地址：https://codepen.io/shadeed/pen/LYmzVZW?editors=1100&lt;/p&gt;
&lt;h4&gt;流体高度&lt;/h4&gt;
&lt;p&gt;有时候，我们页面的主区的高度需要根据视口大小而变化。这种场景，我们倾向于通过媒体查询或使用视口单位来改变这种情况。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4cf1a63ddfd41909a8ca8a5efb88480~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.hero {
  min-height: 250px;
}

@media (min-width: 800px) {
  .hero {
    min-height: 500px;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们也可以混合使用固定值和视口单位:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.hero {
  min-height: calc(350px + 20vh);
}

@media (min-width: 2000px) {
  .hero {
    min-height: 600px;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但需要注意在较大的视口上高度不能太过高，所以我们需要设置一个最大高度,使用CSS &lt;code&gt;clamp()&lt;/code&gt;，我们可以只用一个CSS声明来设置最小、首选和最大高度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.hero {
  min-height: clamp(250px, 50vmax, 500px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当调整屏幕大小时，我们会看到，高度会根据视口宽度逐渐改变。在上面的例子中，&lt;code&gt;50vmax&lt;/code&gt;表示着视口最大尺寸的 &lt;code&gt;50%&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a27cf35cca75407e9fb69801f217b705~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;事例地址：https://codepen.io/shadeed/pen/LYmzVZW?editors=1100&lt;/p&gt;
&lt;h4&gt;Loading Bar&lt;/h4&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43196812e33a4d0e97fe1e05ec4fcc59~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;进度条一般是从左到右一个加载过程，在 CSS 中，我们可以定位在左边：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loading-thumb {
  left: 0%;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了将进度条定位到最右边，我们可以使用 &lt;code&gt;left: 100%&lt;/code&gt;，但这会带来一个问题。进度条会跑到容器外：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca1e003d57624344914d0e9181cd392c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loading-thumb {
  left: 100%;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是正常的情况，100% 是从进度条的末端开始的，而进度条本身也有自己的宽度，所以实际宽度会大于容器的宽度。&lt;/p&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;calc()&lt;/code&gt; 来减去的进度条宽度，这样就可以了，但这并不是100%有效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loading-thumb {
  /* 40px represents the thumb width. */
  left: calc(100% - 40px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们来看下，如何利用CSS变量和比较函数来更好地实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loading-thumb {
  --loading: 0%;
  --loading-thumb-width: 40px;
  position: absolute;
  top: 4px;
  left: clamp(
    0%,
    var(--loading),
    var(--loading) - var(--loading-thumb-width)
  );
  width: var(--loading-thumb-width);
  height: 16px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，我们设定一个最小值为 &lt;code&gt;0%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;首选值是 &lt;code&gt;--loading&lt;/code&gt; CSS变量的当前值&lt;/li&gt;
&lt;li&gt;最大值代表当前的加载量减去进度条件的宽度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里的CSS &lt;code&gt;clamp()&lt;/code&gt;为我们提供了这个组件的三种不同的状态信息，这个方案很 nice:&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69f018a690e3449ebd771e1fff003c4e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;不仅如此，我们还可以以相同的方式来处理不同UI&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86389403f4ac4bcbb643472ce739fc67~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loading-progress {
  width: clamp(10px, var(--loading), var(--loading) - 10px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最小值等于圆圈宽度的一半，首选值是当前的加载百分比，最大值是当前百分比与圆圈一半的减去结果。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0971d8908483a9c41aa30346f02d4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;事例地址：https://codepen.io/shadeed/pen/rNvGVOa?editors=0100&lt;/p&gt;
&lt;h4&gt;动态分割器&lt;/h4&gt;
&lt;p&gt;考虑下图，我们在两个区域之间有一个行分隔符。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d73918b63be54d228cd3deb2e5c043f1~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在移动端上，这个分隔符应该变成水平的，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a35fa0ccdd4f4b7e8e55cc6589a5ee05~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我的解决方案是使用一个边框和flex。思路是，边框作为伪元素，以填补垂直和水平状态的可用空间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.section:before {
  content: "";
  border: 1px solid #d3d3d3;
  align-self: stretch;
}

@media (min-width: 700px) {
  .section {
    align-items: center;
    flex-direction: row;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们也可以使用 &lt;code&gt;clamp&lt;/code&gt; 而不需要媒体查询的解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.section {
  --breakpoint: 400px;
  display: flex;
  flex-wrap: wrap;
}

.section:before {
  content: "";
  border: 2px solid lightgrey;
  width: clamp(0px, (var(--breakpoint) - 100%) * 999, 100%);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来剖析一下上面的CSS:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0px：最小值，用于垂直分隔符。它的值是 &lt;code&gt;0&lt;/code&gt;，因为我们使用的是一个CSS边框&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(var(--breakpoint) - 100%) * 999&lt;/code&gt; 是一个个切换器，根据视口宽度在 &lt;code&gt;0px&lt;/code&gt;或 &lt;code&gt;100%&lt;/code&gt; 之间切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d7259c2e03c494185ff74ee9dfd3ec2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h4&gt;动态 border Radius&lt;/h4&gt;
&lt;p&gt;一年前，发现了一个巧妙的CSS技巧。使用CSS &lt;code&gt;max()&lt;/code&gt;函数，根据视口宽度，将卡片的&lt;code&gt;border-radius&lt;/code&gt; 从 &lt;code&gt;0px&lt;/code&gt; 切换到 &lt;code&gt;8px&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99a42174c2914121933c2e9cb409a797~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.card {
  border-radius: max(
    0px,
    min(8px, calc((100vw - 4px - 100%) * 9999))
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来剖析一下上面的CSS:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们有一个 &lt;code&gt;max()&lt;/code&gt; 函数，在 &lt;code&gt;0px&lt;/code&gt; 和 &lt;code&gt;min()&lt;/code&gt;的计算值之间进行比较，并选择较大的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;min()&lt;/code&gt; 函数在 &lt;code&gt;8px&lt;/code&gt; 和 &lt;code&gt;calc((100vw - 4px - 100%) * 9999&lt;/code&gt; 的计算值之间进行比较,这会得到一个非常大的正数或负数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;9999&lt;/code&gt; 是一个很大的数字，这样 &lt;code&gt;min&lt;/code&gt; 的值都是 &lt;code&gt;8px&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;间距&lt;/h4&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c335542fba744cdfa316d38bcb8a3248~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;有时，我们可能需要根据视口宽度来改变一个组件或一个网格的间距。有了CS函数就不一样了,我们只需要设置一次。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.wrapper {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-gap: min(2vmax, 32px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="1034934887-632fc3decc9d8.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/158413c9ab3f4b3e8cac4bc453dbf17a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来源：https://isdeed.com/article/use-cases-css-comparison-functions/&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Mon, 26 Sep 2022 16:28:28 GMT</pubDate></item><item><title>在 Vue 中，使用 $attrs 构建高级组件</title><link>https://juejin.cn/post/7145626573948469261</link><description>&lt;blockquote&gt;
&lt;p&gt;本文首发于微信公众号：大迁世界, 我的微信：qq449245884，我会第一时间和你分享前端行业趋势，学习途径等等。
更多开源作品请看 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; ，包含一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这节课，我们来看下 Vue3 中的 &lt;code&gt;$attrs&lt;/code&gt; 属性。首先，我们会介绍它的用途以及它的实现与 Vue2 有哪些不两同点，并通过事例来加深对它的理解。&lt;/p&gt;
&lt;p&gt;真正理解了 &lt;code&gt;$attrs&lt;/code&gt; 属性有助于我们构建易于使用和可扩展的高级组件&lt;/p&gt;
&lt;h2&gt;什么是 &lt;code&gt;$attrs&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;对 &lt;code&gt;$attrs&lt;/code&gt; 定义， Vue2 与 Vue3 是不一样的，这里我们主要来介绍 Vue3 的版本：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$attrs 对象包含了除组件所声明的 props 和 emits 之外的所有其他 attribute，例如 class，style，v-on 监听器等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;$attrs &lt;/code&gt;也可以被看作是一个安全网，它可以捕获任何我们没有在组件中声明的东西。我们考虑一个只有一个属性和事件处理程序的组件，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;h1 @click="$emit('custom', '改变标题')"&amp;gt;{{ title }}&amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: 'Example',
  props: ['title'],
  emits: ['custom'],
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在父组件中像下面这样实例化上面的组件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id="app"&amp;gt;
    &amp;lt;SimpleEvent
      id="myId"
      class="myClass"
      data-cy="cypress-testing"
      @blur="onBlur"
      title="测试$attrs"
      description="没有声明 props"
      @custom="onCustom"
    /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import SimpleEvent from './components/Button.vue'

const onBlur = () =&amp;gt; {
  // todo
}
const onCustom = () =&amp;gt; {
  // todo
}

&amp;lt;/script&amp;gt;


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在组件中把 &lt;code&gt;$attrs&lt;/code&gt; 打印出来，我们会得到如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  id: 'myId',
  class: 'myClass',
  'data-cy': 'cypress-testing',
  description: '没有声明 props',
  onBlur: () =&amp;gt; { // todo } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这些信息，感觉没啥用，其实不然，我们下面会介绍如何利用这些信息。&lt;/p&gt;
&lt;h2&gt;attrs V3 vs $attrs V2&lt;/h2&gt;
&lt;p&gt;这小节，我们来看下 Vue2 与 Vue3 中的 &lt;code&gt;attrs&lt;/code&gt; 属性的区别，先来看张图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4014a578b352477a81513941014ef3aa~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;与 Vue2 的区别主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义事件放在 &lt;code&gt;@listerner&lt;/code&gt; 对象中&lt;/li&gt;
&lt;li&gt;不包含 &lt;code&gt;class&lt;/code&gt; 属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而 Vue3 中的 &lt;code&gt;attrs&lt;/code&gt; 对象包含了除组件所声明的 &lt;code&gt;props&lt;/code&gt; 和 &lt;code&gt;emits&lt;/code&gt; 之外的所有其他 &lt;code&gt;attribute&lt;/code&gt;，这有利于我们方便使用这些属性。&lt;/p&gt;
&lt;p&gt;下面我们来看些事例。&lt;/p&gt;
&lt;h2&gt;事例&lt;/h2&gt;
&lt;p&gt;事例地址：https://stackblitz.com/edit/vue-slider-listener-example?file=src/components/Slider.vue&lt;/p&gt;
&lt;p&gt;首先我们创建一个 Slider 组件，内容如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;input 
    type="range"  
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
    class="slider__input" /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  name: "Slider-1",
  props: {
    modelValue: [Number, String],
  }
};
&amp;lt;/script&amp;gt;
&amp;lt;style lang="scss"&amp;gt;
// 这里省略一堆样式，自行看事例
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码我们创建一个 &lt;code&gt;slider&lt;/code&gt;，还实现了一个双向绑定。然后可以像下面这样使用该组件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;Slider-1 v-model="value" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5a15c7252e34248bf58d852009bfe72~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h4&gt;添加一些属性&lt;/h4&gt;
&lt;p&gt;目前我们的 Slier 组件还很简单，不太符合实际情况。所以，我们添加几个属性（&lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;data-cy&lt;/code&gt;, &lt;code&gt;@keydown&lt;/code&gt; 和 &lt;code&gt;aria-label&lt;/code&gt;）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;Slider-1
      v-model="value"
      min="0"
      max="50"
      class="blue_slider"
      id="special_id"
      data-cy="cypress-slider"
      @keydown="() =&amp;gt; true"
      aria-label="Example slider"
    /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行后，通过控制检查元素，我们可以看下，我们新加的属性都被添加到了 HTML 元素上了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/968f923e8ec74f14a8222c720272371b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;看到这里，大家可能有疑问了，既然所有的 "非属性/事件" 属性都已经自动应用于内部的HTML元素，为什么还要对 &lt;code&gt;$attrs&lt;/code&gt; 做这么大的介绍？&lt;/p&gt;
&lt;h4&gt;添加标题和值&lt;/h4&gt;
&lt;p&gt;新增需求：作为一个滑块的使用者，用户希望能够看到一个标题，以及它在屏幕上显示的数字形式的值。&lt;/p&gt;
&lt;p&gt;我们在调整一下 Slider 组件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Slider-2.vue

&amp;lt;template&amp;gt;
  &amp;lt;div class="slider"&amp;gt;
    &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt;
    &amp;lt;input 
      type="range" 
      :value="modelValue"
      @input="$emit('update:modelValue', $event.target.value)"
      class="slider__input" /&amp;gt;
      &amp;lt;div&amp;gt;Value: {{ value }}&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  name: "Slider-2",
  props: {
    modelValue: [Number, String]
    title: [String],
    value: [Number, String],
  }
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9798b8b735644dfa8bafce4f5ef04d4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;乍一看，好像没啥问题，但如果我们仔细观察，可以看到有些东西是不对的&lt;/p&gt;
&lt;p&gt;首先，Slider 不是蓝色的。第二，&lt;code&gt;value&lt;/code&gt; 远远超过了50，最后，检查一下HTML，会看到我们所有的额外属性（&lt;code&gt;min, max, data-cy&lt;/code&gt;）都被分配给了根元素，而不是我们的 &lt;code&gt;input&lt;/code&gt; 元素。&lt;/p&gt;
&lt;p&gt;解决上述问题的最好方法是找到一种方法，将所有的属性、类、参数和事件直接 "应用" 到 input  字段上，而不需我们手动的一个个声明。这就是 &lt;code&gt;$attrs&lt;/code&gt; 出场的地方。&lt;/p&gt;
&lt;h4&gt;$attrs 救场&lt;/h4&gt;
&lt;p&gt;在本文的开头，我们介绍了 &lt;code&gt;$attrs&lt;/code&gt;。它是一个存放所有 "未声明"的属性和事件的地方，而这正是我们需要解决的问题。&lt;/p&gt;
&lt;p&gt;要使用这个功能，我们只需将 &lt;code&gt;$attrs&lt;/code&gt; 属性应用于一个或多个HTML元素，使用 &lt;code&gt;v-bind&lt;/code&gt; 操作符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class="slider"&amp;gt;
    &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt;
    &amp;lt;input 
      type="range"  
      v-bind="$attrs"
      :value="modelValue"
      @input="$emit('update:modelValue', $event.target.value)"
      class="slider__input" /&amp;gt;
      &amp;lt;div&amp;gt;Value: {{ modelValue }}&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在组件中，我们使用 &lt;code&gt;attrs&lt;/code&gt; 充当桥梁，将所有的属性（类、属性、属性和自定义事件）复制到一个或多个元素上。 Slider 组件又回到了正常模式上了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a5c586bdd144adaa9c0d6b567c9add6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;还有一个问题--我们添加的属性不仅被分配给了 &lt;code&gt;input&lt;/code&gt; 元素上，也分配给了 &lt;code&gt;root&lt;/code&gt;元素。&lt;/p&gt;
&lt;p&gt;通常情况下，这可能对界面没啥影响，但有的属性确实会生产一些副作用，下面，我们来解决这个问题。&lt;/p&gt;
&lt;h2&gt;inheritAttrs: false&lt;/h2&gt;
&lt;p&gt;默认情况下，任何被传递给组件的额外参数都会自动应用于根元素（以及所有有 &lt;code&gt;$attrs&lt;/code&gt; 绑定的元素）。&lt;/p&gt;
&lt;p&gt;为了关闭这个功能，并控制哪些元素可接受这个额外的属性，我们可以使用一个名为 &lt;code&gt;inheritAttrs&lt;/code&gt; 的标志，并将其设置为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;经过这样的改变，我们的HTML就变得漂亮且干净了。所有的额外属性都只作用于 &lt;code&gt;input&lt;/code&gt; 元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编辑中可能存在的bug没法实时知道，事后为了解决这些bug,花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Tue, 20 Sep 2022 16:41:47 GMT</pubDate></item><item><title>新指令 v-memo，提高性能的又一利器</title><link>https://juejin.cn/post/7144884293423071268</link><description>&lt;blockquote&gt;
&lt;p&gt;本文首发于微信公众号：大迁世界, 我的微信：qq449245884，我会第一时间和你分享前端行业趋势，学习途径等等。
更多开源作品请看 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; ，包含一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vue3 为我们提供了几项开箱即用的重大性能改进，但也引入了一些额外的手动功能，可以帮助提高我们的应用性能。&lt;/p&gt;
&lt;p&gt;在这节课中，我们介绍一下，在 Vue 3.2 中引入新指令 &lt;code&gt;v-memo&lt;/code&gt;。引入这个指令的目的是帮助我们提高中型/大型 Vue 应用程序的性能，小项目大家根据需要自行决定。&lt;/p&gt;
&lt;h2&gt;v-memo 是做什么的？&lt;/h2&gt;
&lt;p&gt;官网对 &lt;code&gt;v-memo&lt;/code&gt; 定义是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。举例来说：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看起来有点绕，但实际上，很好理解。&lt;code&gt;v-memo&lt;/code&gt; 所做的与我们现有的计算属性一样，只不过 &lt;code&gt;v-memo&lt;/code&gt; 的对象是 DOM。&lt;/p&gt;
&lt;p&gt;这个新指令将缓存它所控制的DOM部分，如果一个特定的值发生变化，只需运行更新并重新渲染。这些值是由我们自己手动设置。&lt;/p&gt;
&lt;h2&gt;事例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    ..the rest of the component
    &amp;lt;div v-memo="[myValue]"&amp;gt;
      &amp;lt;svg &amp;gt;
        &amp;lt;title&amp;gt;{{MyValue}}&amp;lt;/title&amp;gt;
        ...
      &amp;lt;/svg&amp;gt;
      &amp;lt;vue-custom-element :value="myValue"&amp;gt;&amp;lt;/vue-custom-element&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对上面解释一下： &lt;code&gt;v-memo&lt;/code&gt; 通常是作为组件的一部分来使用的，它只是影响组件 dom 的一个子集。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div v-memo="[myValue]"&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着，我们将 &lt;code&gt;v-memo&lt;/code&gt;分配给了一个特定的 &lt;code&gt;DIV&lt;/code&gt; 和它的所有子元素。当调用 &lt;code&gt;v-memo&lt;/code&gt; 时，需要传递一个值数组，以控制子树的渲染。&lt;/p&gt;
&lt;p&gt;数组接受一个或多个值 &lt;code&gt;v-memo="[valueOne, valueTwo]"&lt;/code&gt;，也接受像 &lt;code&gt;v-memo="myValue === true"&lt;/code&gt;这样的表达。&lt;/p&gt;
&lt;p&gt;另外：用一个空数组调用 &lt;code&gt;v-memo&lt;/code&gt;相当于使用&lt;code&gt;v-once&lt;/code&gt;，只会渲染该部分组件一次。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;svg &amp;gt;
  &amp;lt;title&amp;gt;{{MyValue}}&amp;lt;/title&amp;gt;
  ...
&amp;lt;/svg&amp;gt;
&amp;lt;vue-custom-element :value="myValue"&amp;gt;&amp;lt;/vue-custom-element&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同在看下子树的内容。在我们的例子中，使用了一个 svg 元素和一个自定义 Vue 组件 &lt;code&gt;vue-custom-element&lt;/code&gt;。这样做是为了说明一件事：&lt;code&gt;v-memo&lt;/code&gt; 包含任何元素。&lt;/p&gt;
&lt;h4&gt;错误的使用方式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div v-memo="[myValue]"&amp;gt;
  &amp;lt;p&amp;gt;Static content, no vue values here&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的例子中，包含在 &lt;code&gt;v-memo&lt;/code&gt; 中的子树不需要被缓存，因为它是静态的，不会改变（它不包括任何Vue变量）。Vue3 会对静态进行一个提升，以便提高性能。&lt;/p&gt;
&lt;p&gt;在一个静态的HTML上添加 &lt;code&gt;v-memo&lt;/code&gt; 是没啥作用，不管这个HTML有多复杂。&lt;/p&gt;
&lt;h4&gt;管理更新&lt;/h4&gt;
&lt;p&gt;在有些情况下，&lt;code&gt;v-memo&lt;/code&gt;不仅可以用来提高性能，还可以通过控制组件的更新周期，实际改善UX（用户体验）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div v-memo="[allFieldChanged]"&amp;gt;
  &amp;lt;p&amp;gt;{{ field1 }}&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;{{ field2 }}&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;{{ field3 }}&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;{{ field4 }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的例子中，改变一个单独的字段，例如 &lt;code&gt;field1&lt;/code&gt;，并不会导致重新渲染。新的字段将在所有字段都被更新后显示。&lt;/p&gt;
&lt;p&gt;最近遇到一个情况，一个子组件会对一个大的JSON数据集进行更新和响应。在这种情况下，使用 &lt;code&gt;v-memo&lt;/code&gt; 真的很有帮助，当所有的变化都完成后，就可以触发更新。&lt;/p&gt;
&lt;h4&gt;与 v-for 结合使用&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;v-memo&lt;/code&gt; 的一个最常见的用例是在处理使用 &lt;code&gt;v-for&lt;/code&gt; 渲染的非常大的列表时。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div v-for="item in list" :key="item.id" v-memo="[item.id === selected]"&amp;gt;
  &amp;lt;p&amp;gt;ID: {{ item.id }} - selected: {{ item.id === selected }}&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;...more child nodes&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不在上面的代码中使用 &lt;code&gt;v-memo&lt;/code&gt;，&lt;code&gt;selected&lt;/code&gt; 变量的每一次改变都会导致列表的完全重新渲染。新指令提供的缓存，允许只更新表达式 &lt;code&gt;item.id === selected&lt;/code&gt; 发生变化的行，也就是当某个项被选中或者取消时。&lt;/p&gt;
&lt;p&gt;如果我们考虑一个有 1000 条数据的列表。使用上述代码的 &lt;code&gt;v-memo&lt;/code&gt;，可以为每一个变化节省998个条重新渲染。&lt;/p&gt;
&lt;h4&gt;无意中停止了子组件触发的更新&lt;/h4&gt;
&lt;p&gt;我们知道 &lt;code&gt;v-memo&lt;/code&gt; 会停止子树渲染更新，但需要注意的是，使用这个指令实际上会停止任何可能被更新触发的代码的执行，如 watch 函数等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div v-memo="[points &amp;gt; 1000]"&amp;gt;
  &amp;lt;myComponent :points="points" /&amp;gt;
&amp;lt;/div&amp;gt;

//myComponent
&amp;lt;isLevel1 v-if="points &amp;lt;= 1000"&amp;gt;....&amp;lt;/isLevel1&amp;gt;
&amp;lt;isLevel2 v-if="points &amp;gt; 1000"&amp;gt;...&amp;lt;/isLevel2&amp;gt;
&amp;lt;script&amp;gt;
...,
watch: {
  points() {
    logPointChange();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的代码中，如果我们的 &lt;code&gt;points&lt;/code&gt; 值是 1000 以内变化，那么 &lt;code&gt;watch&lt;/code&gt; 函数不会被执行，直到 &lt;code&gt;points&lt;/code&gt; 的值大于 1000 才会触发 watch 函数的执行。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;这个新的指令对于要求性能极高的项目有很在帮助了，一般是在比较大型的项目中使用的，当然小型项目，大家可以根据项目需要进行食用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Sun, 18 Sep 2022 16:41:07 GMT</pubDate></item><item><title>为什么说：JavaScript 模块中的默认导出很糟糕</title><link>https://juejin.cn/post/7143396454366314527</link><description>&lt;blockquote&gt;
&lt;p&gt;本文首发于微信公众号：大迁世界, 我的微信：qq449245884，我会第一时间和你分享前端行业趋势，学习途径等等。
更多开源作品请看 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; ，包含一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道，JavaScript 模块有两种方法来定义导出：默认导出和命名导出。在本节中，我们来看下为什么默认导出是一种糟糕的做法，会导致不好的开发体验。&lt;/p&gt;
&lt;p&gt;下面，我们看下例子，假设，我们有一个模块，它同时包含命名导出和默认导出，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export const add = (a, b) =&amp;gt; a + b;

export default subtract = (a, b) =&amp;gt; a - b;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在导入使用之前，这里有一个问题，它可能会影响到我们的开发体验。为什么 &lt;strong&gt;subtract&lt;/strong&gt;  是默认的，而 &lt;strong&gt;add&lt;/strong&gt;  是一个命名的导出？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps：我举的例子，可能有点刻意，但随着模块的复杂，类似这种情况有常有的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考虑到开发人员使用一个他们不熟悉且复杂的模块。他们可能不知道默认导出的是什么方法，甚至可能也不确定是否有默认导出。这导致开发者需要花更多的时间来阅读文档或源码。如果模块只有命名导出，那么使用起来就更加的方便，可读性也会更好。&lt;/p&gt;
&lt;p&gt;有了命名导出，使用IDE，我们可以很方便的知道一个模块有哪些方法。那么，这个下面的列表中没有展示什么呢？没错，就是默认导出。记住，默认导出不是命名的导出，所以 IDE 不知道改默认导出是干嘛的，也就不会在提示的列表中显示出来：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37277fa48c574e0e8acf74badb2b52c2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;默认导出的开发体验类似于 Node 中的 CommonJS，它的开发体验也不太友好。判断代码是否使用 CommonJS 的一个简单方法，就是看有没有使用 &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;module.exports&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;下面我们再介绍一下，默认导出的一些用法(槽点)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认导出的名称可以随便我们取名。也就是说，减法函数你可以命名成乘法。这会导致混乱，特别是随着代码复杂度的增加。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import multiply from './math.js';
const result = multiply(2, 2);  // results is now 0
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由于默认导出可以用任何名字，并且每个开发者的命名习惯不一样，名称就不一样，这样就没有一致性了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认导出也不利于重构。在命名导出中，如果哪天我们的方法名改了，那么IDE 会提示我们对应的方法不存在，我们可以更好的重构。对于默认导出，IDE 是没有反馈的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到这里，大家可能有一个问题，如果来自不同模块的两个命名导出具有相同的名称，该怎么办？&lt;/p&gt;
&lt;p&gt;我们可以使用重命名的方式来解决这个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { Article } from './types';
import { Article as ArticleComponent } from 'my-design-system';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然这种方式仍然需要为别名想一个名称，但这比为默认导出想一个名称要好得多，因为有命名导出作为参考。&lt;/p&gt;
&lt;p&gt;最后，你可能也在想，"我使用的框架或工具几乎要求我们默认导出一个函数或组件"。如果组件很多，我们可以通过使用 "index.js" 来解决这个问题。就是在目录的根部创建一个&lt;code&gt;index.js&lt;/code&gt;或&lt;code&gt;index.ts&lt;/code&gt;文件，然后使用命名导出这些组件。&lt;/p&gt;
&lt;p&gt;比如我们有一个文件 &lt;code&gt;components&lt;/code&gt;，该文件主要放置我们封装的组件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;src/ 
  components/
   com1/
     index.vue
   com2/
     index.vue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么我们可以在 &lt;code&gt;components&lt;/code&gt; 创建一个 &lt;code&gt;index.js&lt;/code&gt; 文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export { default as Com1 } from './com1'
xport { default as Com2 } from './com2'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样我们在其它文件中使用命名导出的方式引入使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { Com1, Com2 } from '@/components'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在写一个模块，无论是代码库还是开源库，尽量少使用默认导出。&lt;/p&gt;
&lt;p&gt;就这。&lt;/p&gt;
&lt;p&gt;来源：https://www.lloydatkinson.net/posts/2022/default-exports-in-javascript-modules-are-terrible/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Wed, 14 Sep 2022 16:28:37 GMT</pubDate></item><item><title>在 JavaScript 中，什么时候使用 Map 或胜过 Object</title><link>https://juejin.cn/post/7141174031411052581</link><description>&lt;blockquote&gt;
&lt;p&gt;本文首发于微信公众号：大迁世界, 我的微信：qq449245884，我会第一时间和你分享前端行业趋势，学习途径等等。
更多开源作品请看 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; ，包含一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 JavaScript 中，对象是很方便的。它们允许我们轻松地将多个数据块组合在一起。 在ES6之后，又出了一个新的语言补充-- Map。在很多方面，它看起来像是一个功能更强的对象，但接口却有些笨拙。&lt;/p&gt;
&lt;p&gt;然而，大多数开发者在需要 hash map 的时候还是会使用对象，只有当他们意识到键值不能只是字符串的时候才会转而使用 Map。因此，Map 在当今的 JavaScript 社区中仍然没有得到充分的使用。&lt;/p&gt;
&lt;p&gt;在本文本中，我会列举一些应该更多考虑使用 Map 的一些原因。&lt;/p&gt;
&lt;h2&gt;为什么对象不符合 Hash Map 的使用情况&lt;/h2&gt;
&lt;p&gt;在 Hash Map 中使用对象最明显的缺点是，对象只允许键是字符串和 symbol。任何其他类型的键都会通过 &lt;code&gt;toString&lt;/code&gt; 方法被隐含地转换为字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const foo = []
const bar = {}
const obj = {[foo]: 'foo', [bar]: 'bar'}

console.log(obj) // {"": 'foo', [object Object]: 'bar'}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更重要的是，使用对象做 Hash Map 会造成混乱和安全隐患。&lt;/p&gt;
&lt;h2&gt;不必要的继承&lt;/h2&gt;
&lt;p&gt;在ES6之前，获得 hash map 的唯一方法是创建一个空对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const hashMap = {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，在创建时，这个对象不再是空的。尽管 &lt;code&gt;hashMap&lt;/code&gt; 是用一个空的对象字面量创建的，但它自动继承了 &lt;code&gt;Object.prototype&lt;/code&gt;。这就是为什么我们可以在 &lt;code&gt;hashMap&lt;/code&gt; 上调用&lt;code&gt;hasOwnProperty&lt;/code&gt;、&lt;code&gt;toString&lt;/code&gt;、&lt;code&gt;constructor&lt;/code&gt; 等方法，尽管我们从未在该对象上明确定义这些方法。&lt;/p&gt;
&lt;p&gt;由于原型继承，我们现在有两种类型的属性被混淆了：存在于对象本身的属性，即它自己的属性，以及存在于原型链的属性，即继承的属性。&lt;/p&gt;
&lt;p&gt;因此，我们需要一个额外的检查（例如&lt;code&gt;hasOwnProperty&lt;/code&gt;）来确保一个给定的属性确实是用户提供的，而不是从原型继承的。&lt;/p&gt;
&lt;p&gt;除此之外，由于属性解析机制在 JavaScrip t中的工作方式，在运行时对 &lt;code&gt;Object.prototype&lt;/code&gt; 的任何改变都会在所有对象中引起连锁反应。这就为原型污染攻击打开了大门，这对大型的JavaScript 应用程序来说是一个严重的安全问题。&lt;/p&gt;
&lt;p&gt;不过，我们可以通过使用 &lt;code&gt;Object.create(null)&lt;/code&gt; 来解决这个问题，它可以生成一个不继承&lt;code&gt;Object.prototype&lt;/code&gt;的对象。&lt;/p&gt;
&lt;h2&gt;名称冲突&lt;/h2&gt;
&lt;p&gt;当一个对象自己的属性与它的原型上的属性有名称冲突时，它就会打破预期，从而使程序崩溃。&lt;/p&gt;
&lt;p&gt;例如，我们有一个函数 &lt;code&gt;foo&lt;/code&gt;，它接受一个对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo(obj) {
//...
for (const key in obj) {
if (obj.hasOwnProperty(key)) {

}
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;obj.hasOwnProperty(key)&lt;/code&gt;有一个可靠性风险：考虑到属性解析机制在JavaScript中的工作方式，如果 &lt;code&gt;obj&lt;/code&gt; 包含一个开发者提供的具有相同名称的 &lt;code&gt;hasOwnProperty&lt;/code&gt; 属性，那就会对&lt;code&gt;Object.prototype.hasOwnProperty&lt;/code&gt;产生影响。因此，我们不知道哪个方法会在运行时被准确调用。&lt;/p&gt;
&lt;p&gt;可以做一些防御性编程来防止这种情况。例如，我们可以从 &lt;code&gt;Object.prototype&lt;/code&gt; 中 "借用""真正的 &lt;code&gt;hasOwnProperty&lt;/code&gt; 来代替:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo(obj) {
//...
for (const key in obj) {
if (Object.prototype.hasOwnProperty.call(obj, key)) {
// ...
}
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一个更简短的方法就是在一个对象的字面量上调用该方法，如&lt;code&gt;{}.hasOwnProperty.call(key)&lt;/code&gt;，不过这也挺麻烦的。这就是为什么还会新出一个静态方法&lt;code&gt;Object.hasOwn&lt;/code&gt; 的原因了。&lt;/p&gt;
&lt;h2&gt;次优的人机工程学&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Object&lt;/code&gt; 没有提供足够的人机工程学，不能作为 hash map 使用，许多常见的任务不能直观地执行。&lt;/p&gt;
&lt;h4&gt;size&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Object&lt;/code&gt; 并没有提供方便的API来获取 &lt;code&gt;size&lt;/code&gt;，即属性的数量。而且，对于什么是一个对象的 size ，还有一些细微的差别:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果只关心字符串、可枚举的键，那么可以用 &lt;code&gt;Object.keys()&lt;/code&gt; 将键转换为数组，并获得其length&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果k只想要不可枚举的字符串键，那么必须得使用 &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt; 来获得一个键的列表并获得其 length&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果只对 symbol  键感兴趣，可以使用 &lt;code&gt;getOwnPropertySymbols&lt;/code&gt; 来显示 symbol  键。或者可以使用 &lt;code&gt;Reflect.ownKeys&lt;/code&gt; 来一次获得字符串键和 symbol  键，不管它是否是可枚举的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述所有选项的运行时复杂度为&lt;strong&gt;O(n)&lt;/strong&gt;，因为我们必须先构造一个键的数组，然后才能得到其长度。&lt;/p&gt;
&lt;h4&gt;iterate&lt;/h4&gt;
&lt;p&gt;循环遍历对象也有类似的复杂性&lt;/p&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;for...in&lt;/code&gt;循环。但它会读取到继承的可枚举属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.prototype.foo = 'bar'

const obj = {id: 1} 

for (const key in obj) {
console.log(key) // 'id', 'foo'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们不能对一个对象使用 &lt;code&gt;for ... of&lt;/code&gt;，因为默认情况下它不是一个可迭代的对象，除非我们明确定义 &lt;code&gt;Symbol.iterator&lt;/code&gt; 方法在它上面。&lt;/p&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;Object.keys&lt;/code&gt;、&lt;code&gt;Object.values&lt;/code&gt; 和 &lt;code&gt;Object.entry &lt;/code&gt;来获得一个可枚举的字符串键（或/和值）的列表，并通过该列表进行迭代，这引入了一个额外的开销步骤。&lt;/p&gt;
&lt;p&gt;还有一个是 插入对象的键的顺序并不是按我们的顺序来的，这是一个很蛋疼的地方。在大多数浏览器中，整数键是按升序排序的，并优先于字符串键，即使字符串键是在整数键之前插入的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const obj = {}

obj.foo = 'first'
obj[2] = 'second'
obj[1] = 'last'

console.log(obj) // {1: 'last', 2: 'second', foo: 'first'}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;clear&lt;/h3&gt;
&lt;p&gt;没有简单的方法来删除一个对象的所有属性，我们必须用 &lt;code&gt;delete&lt;/code&gt; 操作符一个一个地删除每个属性，这在历史上是众所周知的慢。&lt;/p&gt;
&lt;h4&gt;检查属性是否存在&lt;/h4&gt;
&lt;p&gt;最后，我们不能依靠点/括号符号来检查一个属性的存在，因为值本身可能被设置为 &lt;code&gt;undefined&lt;/code&gt;。相反，得使用 &lt;code&gt;Object.prototype.hasOwnProperty&lt;/code&gt; 或 &lt;code&gt;Object.hasOwn&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const obj = {a: undefined}

Object.hasOwn(obj, 'a') // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Map&lt;/h2&gt;
&lt;p&gt;ES6 为我们带来了 Map，首先，与只允许键值为字符串和 symbols 的 Object 不同，Map 支持任何数据类型的键。&lt;/p&gt;
&lt;p&gt;但更重要的是，Map 在用户定义的和内置的程序数据之间提供了一个干净的分离，代价是需要一个额外的 &lt;code&gt;Map.prototype.get&lt;/code&gt; 来获取对应的项。&lt;/p&gt;
&lt;p&gt;Map 也提供了更好的人机工程学。Map 默认是一个可迭代的对象。这说明可以用 &lt;code&gt;for ... of&lt;/code&gt; 轻松地迭代一个 Map，并做一些事情，比如使用嵌套的解构来从 Map 中取出第一个项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const [[firstKey, firstValue]] = map
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与 Object 相比，Map 为各种常见任务提供了专门的API:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Map.prototype.has&lt;/code&gt; 检查一个给定的项是否存在，与必须在对象上使用&lt;code&gt;Object.prototype.hasOwnProperty/Object.hasOwn&lt;/code&gt; 相比，不那么尴尬了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Map.prototype.get 返回与提供的键相关的值。有的可能会觉得这比对象上的点符号或括号符号更笨重。不过，它提供了一个干净的用户数据和内置方法之间的分离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Map.prototype.size&lt;/code&gt; 返回 Map 中的项的个数，与获取对象大小的操作相比，这明显好太多了。此外，它的速度也更快。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Map.prototype.clear&lt;/code&gt; 可以删除 Map 中的所有项，它比 delete 操作符快得多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;性能差异&lt;/h2&gt;
&lt;p&gt;在 JavaScript 社区中，似乎有一个共同的信念，即在大多数情况下，&lt;code&gt;Map&lt;/code&gt; 要比 &lt;code&gt;Object&lt;/code&gt; 快。有些人声称通过从 Object 切换到 Map 可以看到明显的性能提升。&lt;/p&gt;
&lt;p&gt;我在 LeetCode 上也证实了这种想法，对于数据量大的 Object 会超时，但 Map 上则不会。&lt;/p&gt;
&lt;p&gt;然而，说 "Map 比 Object 快" 可能是算一种归纳性的，这两者一定有一些细微的差别，我们可以通过一些例子，把它找出来。&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;测试用例有一个表格，主要测试 Object 和 Map 在插入、迭代和删除数据的速度。&lt;/p&gt;
&lt;p&gt;插入和迭代的性能是以每秒的操作来衡量的。这里使用了一个实用函数 &lt;code&gt;measureFor&lt;/code&gt;，它重复运行目标函数，直到达到指定的最小时间阈值（即用户界面上的 &lt;code&gt;duration&lt;/code&gt; 输入字段）。它返回这样一个函数每秒钟被执行的平均次数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function measureFor(f, duration) {
  let iterations = 0;
  const now = performance.now();
  let elapsed = 0;
  while (elapsed &amp;lt; duration) {
    f();
    elapsed = performance.now() - now;
    iterations++;
  }

  return ((iterations / elapsed) * 1000).toFixed(4);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至于删除，只是要测量使用 &lt;code&gt;delete&lt;/code&gt;  操作符从一个对象中删除所有属性所需的时间，并与相同大小的 Map 使用&lt;code&gt; Map.prototype.delete&lt;/code&gt; 的时间进行比较。也可以使用&lt;code&gt;Map.prototype.clear&lt;/code&gt;，但这有悖于基准测试的目的，因为我知道它肯定会快得多。&lt;/p&gt;
&lt;p&gt;在这三种操作中，我更关注插入操作，因为它往往是我在日常工作中最常执行的操作。对于迭代性能，很难有一个全面的基准，因为我们可以对一个给定的对象执行许多不同的迭代变体。这里我只测量 &lt;code&gt;for ... in&lt;/code&gt; 循环。&lt;/p&gt;
&lt;p&gt;在这里使用了三种类型的 key。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串，例如：Yekwl7caqejth7aawelo4。&lt;/li&gt;
&lt;li&gt;整数字符串，例如：123&lt;/li&gt;
&lt;li&gt;由 &lt;code&gt;Math.random().toString()&lt;/code&gt; 生成的数字字符串，例如：0.4024025689756525。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的键都是随机生成的，所以我们不会碰到V8实现的内联缓存。我还在将整数和数字键添加到对象之前，使用 &lt;code&gt;toString&lt;/code&gt; 明确地将其转换为字符串，以避免隐式转换的开销。&lt;/p&gt;
&lt;p&gt;最后，在基准测试开始之前，还有一个至少100ms的热身阶段，在这个阶段，我们反复创建新的对象和 Map，并立即丢弃。&lt;/p&gt;
&lt;p&gt;如果你也想玩，代码已经放在 &lt;a href="https://codesandbox.io/s/still-glitter-yuu1dm"&gt;CodeSandbox&lt;/a&gt; 上。&lt;/p&gt;
&lt;p&gt;我从大小为 100 个属性/项的 &lt;code&gt;Object&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 开始，一直到 5000000，并让每种类型的操作持续运行 10000ms，看看它们之间的表现如何。下面是测试结果：&lt;/p&gt;
&lt;h4&gt;string keys&lt;/h4&gt;
&lt;p&gt;一般来说，当键为（非数字）字符串时，&lt;code&gt;Map&lt;/code&gt; 在所有操作上都优于 &lt;code&gt;Object&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/472157e58f124b0b8e43be73dbcf05fc~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;但细微之处在于，当数量并不真正多时（低于&lt;code&gt;100000&lt;/code&gt;），Map 在插入速度上 是Object 的两倍，但当规模超过 &lt;code&gt;100000&lt;/code&gt; 时，性能差距开始缩小。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce39a09496694a22983724c0c288970e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;上图显示了随着条目数的增加（x轴），插入率如何下降（y轴）。然而，由于X轴扩展得太宽（从100 到 1000000），很难分辨这两条线之间的差距。&lt;/p&gt;
&lt;p&gt;然后用对数比例来处理数据，做出了下面的图表。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/744305a20140479aaa24dcb3791762bd~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;可以清楚地看出这两条线正在重合。&lt;/p&gt;
&lt;p&gt;这里又做了一张图，画出了在插入速度上 Map 比 Object 快多少。你可以看到 Map 开始时比 Object 快 2 倍左右。然后随着时间的推移，性能差距开始缩小。最终，当大小增长到 &lt;code&gt;5000000时&lt;/code&gt;，Map 只快了 30%。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4d9ba1916134528862e1ea74fe7a9b6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;虽然我们中的大多数人永远不会在一个 Object 或 Map 中拥有超过1 00 万的条数据。对于几百或几千个数据的规模，Map 的性能至少是 Object 的两倍。因此，我们是否应该就此打住，并开始重构我们的代码库，全部采用 Map？&lt;/p&gt;
&lt;p&gt;这不太靠谱......或者至少不能期望我们的应用程序变得快 2 倍。记住我们还没有探索其他类型的键。下面我们看一下整数键。&lt;/p&gt;
&lt;h4&gt;integer keys&lt;/h4&gt;
&lt;p&gt;我之所以特别想在有整数键的对象上运行基准，是因为V8在内部优化了整数索引的属性，并将它们存储在一个单独的数组中，可以线性和连续地访问。但我找不到任何资源来证实它对 Map 也采用了同样的优化方式。&lt;/p&gt;
&lt;p&gt;我们首先尝试在 &lt;code&gt;[0, 1000]&lt;/code&gt; 范围内的整数键。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b738ad3b1d4347a6b530ee0c28ce73~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如我所料，Object 这次的表现超过了 Map。它们的插入速度比 Map 快&lt;code&gt;65%&lt;/code&gt;，迭代速度快&lt;code&gt;16%&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接着， 扩大范围，使键中的最大整数为 1200。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e4a77d0c9824744bf608c9e71184e75~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;似乎现在 Map 的插入速度开始比 Object 快一点，迭代速度快 5 倍。&lt;/p&gt;
&lt;p&gt;现在，我们只增加了整数键的范围，而不是 Object 和 Map 的实际大小。让我们加大 size，看看这对性能有什么影响。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51901ba8c9cc4f8aa33217880ab6e79b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;当属性 size 为 1000 时，Object 最终比 Map 的插入速度快 70%，迭代速度慢2倍。&lt;/p&gt;
&lt;p&gt;我玩了一堆&lt;code&gt; Object/Map&lt;/code&gt; size 和整数键范围的不同组合，但没有想出一个明确的模式。但我看到的总体趋势是，随着 size 的增长，以一些相对较小的整数作为键值，&lt;code&gt;Object&lt;/code&gt; &lt;code&gt;在插入方面比Map&lt;/code&gt; 更有性能，在删除方面总是大致相同，迭代速度慢4或5倍。&lt;/p&gt;
&lt;p&gt;Object 在插入时开始变慢的最大整数键的阈值会随着 Object 的大小而增长。例如，当对象只有100个条数据，阈值是1200；当它有 10000 个条目时，阈值似乎是 24000 左右。&lt;/p&gt;
&lt;h4&gt;numeric keys&lt;/h4&gt;
&lt;p&gt;最后，让我们来看看最后一种类型的按键--数字键。&lt;/p&gt;
&lt;p&gt;从技术上讲，之前的整数键也是数字键。这里的数字键特指由 &lt;code&gt;Math.random().toString()&lt;/code&gt; 生成的数字字符串。&lt;/p&gt;
&lt;p&gt;结果与那些字符串键的情况类似。Map 开始时比 Object 快得多（插入和删除快2倍，迭代快4-5倍），但随着我们规模的增加，差距也越来越小。&lt;/p&gt;
&lt;h2&gt;内存使用情况&lt;/h2&gt;
&lt;p&gt;基准测试的另一个重要方面是内存利用率.&lt;/p&gt;
&lt;p&gt;由于我无法控制浏览器环境中的垃圾收集器，这里决定在 Node 中运行基准测试。&lt;/p&gt;
&lt;p&gt;这里创建了一个小脚本来测量它们各自的内存使用情况，并在每次测量中手动触发了完全的垃圾收集。用 &lt;code&gt;node --expose-gc &lt;/code&gt;运行它，就得到了以下结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  object: {
    'string-key': {
      '10000': 3.390625,
      '50000': 19.765625,
      '100000': 16.265625,
      '500000': 71.265625,
      '1000000': 142.015625
    },
    'numeric-key': {
      '10000': 1.65625,
      '50000': 8.265625,
      '100000': 16.765625,
      '500000': 72.265625,
      '1000000': 143.515625
    },
    'integer-key': {
      '10000': 0.25,
      '50000': 2.828125,
      '100000': 4.90625,
      '500000': 25.734375,
      '1000000': 59.203125
    }
  },
  map: {
    'string-key': {
      '10000': 1.703125,
      '50000': 6.765625,
      '100000': 14.015625,
      '500000': 61.765625,
      '1000000': 122.015625
    },
    'numeric-key': {
      '10000': 0.703125,
      '50000': 3.765625,
      '100000': 7.265625,
      '500000': 33.265625,
      '1000000': 67.015625
    },
    'integer-key': {
      '10000': 0.484375,
      '50000': 1.890625,
      '100000': 3.765625,
      '500000': 22.515625,
      '1000000': 43.515625
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很明显，Map 比 Object 消耗的内存少20%到50%，这并不奇怪，因为 Map 不像 Object 那样存储属性描述符，比如 &lt;code&gt;writable&lt;/code&gt;/&lt;code&gt;enumerable&lt;/code&gt;/&lt;code&gt;configurable&lt;/code&gt; 。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;那么，我们能从这一切中得到什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Map 比 Object 快，除非有小的整数、数组索引的键，而且它更节省内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你需要一个频繁更新的 hash map，请使用 Map；如果你想一个固定的键值集合（即记录），请使用Object，并注意原型继承带来的陷阱。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Thu, 08 Sep 2022 16:42:54 GMT</pubDate></item><item><title>为什么Vue（默认情况下）比React性能更好</title><link>https://juejin.cn/post/7140064503600775176</link><description>&lt;blockquote&gt;
&lt;p&gt;本文首发于微信公众号：大迁世界, 我的微信：qq449245884，我会第一时间和你分享前端行业趋势，学习途径等等。
更多开源作品请看 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; ，包含一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文不是要辩论 Vue 好还是 React 好，而是要看看这两个框架在低层次上是如何选择的。&lt;/p&gt;
&lt;p&gt;我知道有些开发者在选择框架之前会倾向于看&lt;a href="https://krausest.github.io/js-framework-benchmark/current.html"&gt;基准&lt;/a&gt;。然而，这并不是最关键的方面，因为99%的性能都来自于你写的代码，而不是你使用的框架。&lt;/p&gt;
&lt;p&gt;那么，我是如何得出这个结论的呢？&lt;/p&gt;
&lt;p&gt;这里选取了三个常见的web应用程序问题，并检查了Vue和React在每个场景中的响应情况。&lt;/p&gt;
&lt;h2&gt;项目&lt;/h2&gt;
&lt;p&gt;这里有一个类似 TODO 的项目，不过这里添加的不是事项而是水果。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/922b0db419af424ea29d27cd4367ad32~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;下面是 React 代码：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72be182feb3b44fd8967e80ac1c722c4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;Vue 代码：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee1ac7b3f895417287423787c3b2dd20~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;测试1： 静态模块&lt;/h3&gt;
&lt;p&gt;在第一个测试中，我们将比较 React 和 Vue 是如何编译静态部分的。&lt;/p&gt;
&lt;p&gt;先来看看React：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fef33e8ee5ef4785b3c29153a070d50c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，在 JSX 中，编译器是非常简单的。所有的 JSX 元素都被替换成 React &lt;code&gt;的createElement&lt;/code&gt; 函数。它将在应用程序的每次状态更新时重新渲染所有静态元素。&lt;/p&gt;
&lt;p&gt;再来看看 Vue 中是怎么做的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a498010432745a891329e3617f3ae02~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;可能看起来有些复杂，但这里注意一下 &lt;code&gt;hoisted_1&lt;/code&gt; 变量和 &lt;code&gt;setup&lt;/code&gt; 方法。正如我们所看到的，&lt;code&gt;hoisted_1&lt;/code&gt;变量包含了我们的静态内容，并被定义在 &lt;code&gt;setup&lt;/code&gt; 函数之外。&lt;/p&gt;
&lt;p&gt;在编译过程中，Vue检测所有不依赖于应用程序状态的静态节点，并将变量提升到组件设置之外，这样它就不必在每次渲染后重新生成这些静态节点。&lt;/p&gt;
&lt;h4&gt;小结&lt;/h4&gt;
&lt;p&gt;React 只将 JSX 编译为JS，而 Vue 通过提升有效地优化了静态块。这种优化对具有许多节点和深层树状结构的大页面是有益的。&lt;/p&gt;
&lt;h2&gt;测试2：重新渲染&lt;/h2&gt;
&lt;p&gt;React 和 Vue 之间的显著差异在这第二个测试中显现出来。&lt;/p&gt;
&lt;p&gt;当我们在文本输入中输入 "TEST "时，React 应用程序的控制台:&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65ff82b1d92748349ea46dd8f3eff074~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，&lt;code&gt;MyFruits&lt;/code&gt;组件被渲染了五次。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在父组件的第一次渲染时一次&lt;/li&gt;
&lt;li&gt;在输入中每按一次键，就有四次（test 的个数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再来看看 Vue 的情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa3d1bfb8b504613a25f2e8c36c4d85a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyFruits&lt;/strong&gt; 组件只渲染了一次。&lt;/p&gt;
&lt;p&gt;默认情况下，Vue中的任何孩子组件都是有缓存。只有当它的 &lt;code&gt;props&lt;/code&gt; 发生变化时，它才会被重新渲染。&lt;/p&gt;
&lt;p&gt;React 中无论 &lt;code&gt;props&lt;/code&gt;是否改变，都会重新渲染。&lt;/p&gt;
&lt;p&gt;因此，Vue 中的同等代码比 React 的性能更强😎。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React 是怎么来解决这个问题的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在React中，开发者可以选择通过使用&lt;code&gt;memo helper&lt;/code&gt;来启用 &lt;code&gt;memoization&lt;/code&gt;。可以通过下面的代码来完成：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12abf14bda4a403887f9a3fcf707d05d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;然而，这需要额外的代码来达到相同的性能。&lt;/p&gt;
&lt;h2&gt;测试 3：计算属性&lt;/h2&gt;
&lt;p&gt;在Vue中，一个计算属性是一个将根据其他属性而被重新计算粜的的值。例如，一个 hashed password 只有在 password 被改变时才会被重新计算。&lt;/p&gt;
&lt;p&gt;在 React 中:&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5da5b6c96cf4f088aa5610e3f01f678~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;每次渲染时都会调用 hash 。&lt;/p&gt;
&lt;p&gt;在Vue中，只有在使用 &lt;code&gt;hashed&lt;/code&gt; 时才会重新执行。如果该值在模板中不是必需的，就不会重新执行。此外，Vue 隐含地检测到了依赖关系，只有在 password  改变时才会进行计算。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45c951864e044c56bc6dad5c38a875de~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;这在 React中也是可行的，也也是需要额外的代码：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image.png" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d249bd416780478e845389b86bff6b9c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;我们需要调用 &lt;code&gt;useMemo&lt;/code&gt; 并提供一个依赖数组。此外，React 无法检测到模板中是否使用了 &lt;code&gt;hashed&lt;/code&gt; 变量，并会在第一次渲染时计算 &lt;code&gt;hash&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这是一个非常简单的例子，但要考虑复杂的操作。这将极大地影响组件的渲染时间，特别是当计算的属性在初始渲染时没有被使用时。&lt;/p&gt;
&lt;h2&gt;所以 Vue &amp;gt; React？&lt;/h2&gt;
&lt;p&gt;不，经过上面所有的例子，你可能认为 Vue 比 Reac t的性能更好。但这是错误的。事实上，这两个库有不同的理念。Vue 是隐式的，而 React 是显式的。&lt;/p&gt;
&lt;p&gt;怎么说？&lt;/p&gt;
&lt;p&gt;Vue 是老好人，倾向于将尽可能多的事情自动化，因此开发者可以专注于业务逻辑。Vue 默认提供更好的性能。&lt;/p&gt;
&lt;p&gt;另一方面，如果我们想开发更复杂的功能，这也会导致缺乏一些灵活性。如果你没有真正掌握 Vue组件的生命周期，你可能会花很多时间来调试一些愚蠢的代码。&lt;/p&gt;
&lt;p&gt;另外，React 比较懒，需要开发者自己动手，不过，这样也给我们带来更多的灵活性。但也会多写些代码，像上面的三个例子一样，才能达到与Vue相同的性能。&lt;/p&gt;
&lt;p&gt;综上，如果是新手，可以先从 vue 上手，比较好入手。相比之下，React 适合那些已经有基于组件的框架工作经验的开发者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;作者：Gui Milon  译者：前端小智 来源：mediun&lt;/p&gt;
&lt;p&gt;https://medium.com/@gui.milon/why-vue-is-by-default-more-performant-than-react-34e1d9bbade6&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Mon, 05 Sep 2022 16:57:22 GMT</pubDate></item><item><title>为什么 async/await 不仅仅是语法糖</title><link>https://juejin.cn/post/7138200786319704078</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开篇观点，&lt;code&gt;async/await&lt;/code&gt; 不仅仅是 Promise 上面的语法糖，因为 &lt;code&gt;async/await&lt;/code&gt; 确实提供了切实的好处。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;async/await&lt;/code&gt; 让异步代码变成同步的方式，从而使代码更具表现力和可读性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;async/await&lt;/code&gt; 统一了异步编程的经验；以及提供了更好的错误堆栈跟踪。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;关于 JS 中异步编程的一点历史&lt;/h2&gt;
&lt;p&gt;异步编程在 JavaScript 中很常见。每当我们需要进行网络服务调用、文件访问或数据库操作时，尽管语言是单线程的，但异步性是我们防止用户界面被阻塞的方法。&lt;/p&gt;
&lt;p&gt;在  ES6 之前，回调是猿们处理异步编程的方式。我们表达时间依赖性（即异步操作的执行顺序）的唯一方法是将一个回调嵌套在另一个回调中，这导致了所谓的&lt;strong&gt;回调地狱&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Es6 中引入了 &lt;code&gt;Promise&lt;/code&gt;，它是一个用于异步操作的一流对象，我们可以轻松地传递、组合、聚合和应用转换。时间上的依赖性通过 &lt;code&gt;then&lt;/code&gt;方法链干净地表达出来。&lt;/p&gt;
&lt;p&gt;有了 &lt;code&gt;Promise&lt;/code&gt; 这个强大的伙伴，听起来异步编程在 JS 中是一个已经解决的问题，对吗？&lt;/p&gt;
&lt;p&gt;恩，还没有，因为有时候 Promise 的级别太低了，不太适合使用。&lt;/p&gt;
&lt;h2&gt;有时 Promise 的级别太低，不适合使用&lt;/h2&gt;
&lt;p&gt;尽管出现了 Promise，但在 JS 中仍然需要一个更高级别的语言结构来进行异步编程。&lt;/p&gt;
&lt;p&gt;我们来看个例子， 假设我们需要某个函数在某个时间间隔轮询一个API。当达到最大重试次数时，它就会解析为 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面是 Promise 的一种解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let count = 0;

function apiCall() {
  return new Promise((resolve) =&amp;gt;
    // a在第6次重试时，它被解析为 "value"。
    count++ === 5 ? resolve('value') : resolve(null)
  );
}

function sleep(interval) {
  return new Promise((resolve) =&amp;gt; setTimeout(resolve, interval));
}

function poll(retry, interval) {
  return new Promise((resolve) =&amp;gt; {
    // 为了简洁起见，跳过错误处理

    if (retry === 0) resolve(null);
    apiCall().then((val) =&amp;gt; {
      if (val !== null) resolve(val);
      else {
        sleep(interval).then(() =&amp;gt; {
          resolve(poll(retry - 1, interval));
        });
      }
    });
  });
}

poll(6, 1000).then(console.log); // 'value'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种解决方案的直观性和可读性取决于人们对Promise的熟悉程度，以及 &lt;code&gt;Promise.resolve&lt;/code&gt; 如何 "平铺" Promise 和递归。对我来说，这不是写这样一个函数的最可读的方式。&lt;/p&gt;
&lt;h2&gt;使用 async/await&lt;/h2&gt;
&lt;p&gt;我们用 &lt;code&gt;async/await&lt;/code&gt; 语法重写上述解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;async function poll(retry, interval) {
  while (retry &amp;gt;= 0) {
    const value = await apiCall().catch((e) =&amp;gt; {}); 
    if (value !== null) return value;
    await sleep(interval);
    retry--;
  }

  return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我想大多数人都会觉得上面的解决方案更有可读性，因为我们能够使用所有正常的语言结构，如循环、异步操作的 &lt;code&gt;try-catch&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;这可能是 &lt;code&gt;async/await&lt;/code&gt; 的最大卖点--使我们能够以同步的方式编写异步代码。另一方面，这可能是对 &lt;code&gt;async/await&lt;/code&gt; 最常见的反对意见的来源，稍后再谈这个问题。&lt;/p&gt;
&lt;p&gt;顺便说一下，&lt;code&gt;await&lt;/code&gt;甚至有正确的操作符优先级，所以&lt;code&gt;await a + await b&lt;/code&gt; 等于&lt;code&gt;(await a) + (await b)&lt;/code&gt;，而不是让我们说&lt;code&gt;await (a + await b)&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;async/await 在同步和异步代码中提供了统一的体验&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async/await&lt;/code&gt;的另一个好处是，&lt;code&gt;await&lt;/code&gt;自动将任何非Promise（non-thenables）包装成 Promises 。&lt;code&gt;await&lt;/code&gt;的语义等同于&lt;code&gt;Promise.resolve&lt;/code&gt;，这意味着可以 &lt;code&gt;await&lt;/code&gt; 任何东西:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fetchValue() {
  return 1;
}

async function fn() {
  const val = await fetchValue();
  console.log(val); // 1
}

// 上面等同于下面

function fn() {
  Promise.resolve(fetchValue()).then((val) =&amp;gt; {
    console.log(val); // 1
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们将 &lt;code&gt;then&lt;/code&gt; 方法附加到从 &lt;code&gt;fetchValue&lt;/code&gt; 返回的数字 &lt;code&gt;1&lt;/code&gt; 上，就会出现以下错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fetchValue() {
  return 1;
}

function fn() {
  fetchValue().then((val) =&amp;gt; {
    console.log(val);
  });
}

fn(); // ❌ Uncaught TypeError: fetchValue(...).then is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后， 从 &lt;code&gt;async&lt;/code&gt; 函数返回的任何东西都是一个 &lt;strong&gt;Promise&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.prototype.toString.call((async function () {})()); // '[object Promise]'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;async/await 提供更好的错误堆栈跟踪&lt;/h2&gt;
&lt;p&gt;V8工程师Mathias写了一篇名为&lt;code&gt;Asynchronous stack traces: why await beats Promise#then()&lt;/code&gt; 的文章，介绍了为什么与 Promise相比，引擎更容易捕捉和存储 &lt;code&gt;async/await&lt;/code&gt; 的堆栈跟踪。事例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;async function foo() {
  await bar();
  return 'value';
}

function bar() {
  throw new Error('BEEP BEEP');
}

foo().catch((error) =&amp;gt; console.log(error.stack));

// Error: BEEP BEEP
//     at bar (&amp;lt;anonymous&amp;gt;:7:9)
//     at foo (&amp;lt;anonymous&amp;gt;:2:9)
//     at &amp;lt;anonymous&amp;gt;:10:1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;async 版本正确地捕获了错误堆栈跟踪。&lt;/p&gt;
&lt;p&gt;我们再来看看 &lt;code&gt;Promise&lt;/code&gt;  版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo() {
  return bar().then(() =&amp;gt; 'value');
}

function bar() {
  return Promise.resolve().then(() =&amp;gt; {
    throw new Error('BEEP BEEP');
  });
}

foo().catch((error) =&amp;gt; console.log(error.stack));

// Error: BEEP BEEP  at &amp;lt;anonymous&amp;gt;:7:11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;堆栈跟踪丢失。从匿名的箭头函数切换到命名的函数声明有一点帮助，但帮助不大:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo() {
  return bar().then(() =&amp;gt; 'value');
}

function bar() {
  return Promise.resolve().then(function thisWillThrow() {
    throw new Error('BEEP BEEP');
  });
}

foo().catch((error) =&amp;gt; console.log(error.stack));

// Error: BEEP BEEP
//    at thisWillThrow (&amp;lt;anonymous&amp;gt;:7:11)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;对 &lt;code&gt;async/await&lt;/code&gt; 常见反对意见&lt;/h2&gt;
&lt;p&gt;对 &lt;code&gt;async/await&lt;/code&gt; 主要有两种常见的反对意见。&lt;/p&gt;
&lt;p&gt;首先，当独立的异步函数调用可以用&lt;code&gt;Promise.all&lt;/code&gt;并发处理时，如果我们还大量使用&lt;code&gt;async/await&lt;/code&gt; 可能会导致滥用，这样会造成开发者不去试图了解 Promise 的幕后是如何工作，而只是一味的使用 &lt;code&gt;async/await&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第二种情况更为微妙。一些函数式编程爱好者认为 &lt;code&gt;async/await&lt;/code&gt; 会招致命令式编程。从 FP 程序员的角度来看，能够使用循环和 &lt;code&gt;try catch&lt;/code&gt; 并不是一件好事，因为这些语言结构意味着副作用，并鼓励使用不那么理想的错误处理。&lt;/p&gt;
&lt;p&gt;我对这种说法待保留意见。FP程序员理所当然地关心他们程序中的确定性。他们希望对自己的代码有绝对的信心。为了达到这个目的，需要一个复杂的类型系统，其中包括&lt;strong&gt;Result&lt;/strong&gt;等类型。但我不认为&lt;code&gt;async/await&lt;/code&gt;本身与FP不相容。&lt;/p&gt;
&lt;p&gt;无论如何，对于大多数人来说，包括我在内，FP仍然是一种后天的味道（尽管我确实认为FP超级酷，而且我正在慢慢学习它）。&lt;code&gt;async/await&lt;/code&gt;提供的正常控制流语句和&lt;code&gt;try catch&lt;/code&gt;错误处理，对于我们在 JavaScript 中协调复杂的异步操作是非常宝贵的。这正是为什么说 "async/await只是一种语法糖" 是一种轻描淡写的说法。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;作者：zhenghao  译者：前端小智 来源：zhenghao&lt;/p&gt;
&lt;p&gt;原文：https://www.zhenghao.io/posts/await-vs-promise&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;、&lt;/p&gt;</description><author>王大冶</author><pubDate>Wed, 31 Aug 2022 16:24:51 GMT</pubDate></item><item><title>验证 Vue Props 类型，你这几种方式你可能还没试用过！</title><link>https://juejin.cn/post/7137458445745143822</link><description>&lt;blockquote&gt;
&lt;p&gt;微信搜索 【大迁世界】, 我会第一时间和你分享前端行业趋势，学习途径等等。
本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;vue 要求任何传递给组件的数据，都要声明为 &lt;code&gt;props&lt;/code&gt;。此外，它还提供了一个强大的内置机制来验证这些数据。这就像组件和消费者之间的契约一样，确保组件按预期使用。&lt;/p&gt;
&lt;p&gt;这节课我们来看下这个验证机制，它可以帮助我们在开发和调试过程中减少 but，增加我们的自信心(摸鱼时间)。&lt;/p&gt;
&lt;h2&gt;基础&lt;/h2&gt;
&lt;h4&gt;原始类型&lt;/h4&gt;
&lt;p&gt;验证基本类型比较简单，这里我们不过多的介绍，直接看下面例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export default {
  props: {
    // Basic type check
    //  ("null "和 "undefined "值允许任何类型)
    propA: Number,
    // 多种可能的类型
    propB: [String, Number],
    // 必传的参数
    propC: {
      type: String,
      required: true
    },
    // 默认值
    propD: {
      type: Number,
      default: 100
    },
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;复杂类型&lt;/h4&gt;
&lt;p&gt;复杂类型也可以用同样的方式进行验证。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export default {
  props: {
    // 默认值的对象
    propE: {
      type: Object,
      // 对象或数组的默认值必须从
      // 一个工厂函数返回。该函数接收原始
      // 元素作为参数。
      default(rawProps) {
        return { message: 'hello' }
      }
    },
    // 数组默认值
    propF: {
      type: Array,
      default() {
        return []
      }
    },
    // 函数默认值
    propG: {
      type: Function,
       // 不像对象或数组的默认值。
      // 这不是一个工厂函数 
      // - 这是一个作为默认值的函数
      default() {
        return 'Default function'
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 可以是以下之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Boolean&lt;/li&gt;
&lt;li&gt;Array&lt;/li&gt;
&lt;li&gt;Object&lt;/li&gt;
&lt;li&gt;Date&lt;/li&gt;
&lt;li&gt;Function&lt;/li&gt;
&lt;li&gt;Symbol&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，&lt;code&gt;type&lt;/code&gt; 也可以是一个自定义的类或构造函数，然后使用 &lt;code&gt;instanceof&lt;/code&gt; 进行检查。例如，给定下面的类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以把 &lt;code&gt;Person&lt;/code&gt; 作为一个类型传递给 &lt;code&gt;prop&lt;/code&gt; 类型:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export default {
  props: {
    author: Person
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;高级验证&lt;/h2&gt;
&lt;h4&gt;validator 方法&lt;/h4&gt;
&lt;p&gt;Props  支持使用一个 &lt;code&gt;validator&lt;/code&gt;  函数。这个函数接受 prop 原始值，并且必须返回一个布尔值来确定这个 prop 是否有效。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   prop: {
      validator(value) {
        // The value must match one of these strings
        return ['success', 'warning', 'danger'].includes(value)
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用枚举&lt;/h4&gt;
&lt;p&gt;有时我们想把值缩小到一个特定的集合，这可以通过枚举来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export const Position = Object.freeze({
  TOP: "top",
  RIGHT: "right",
  BOTTOM: "bottom",
  LEFT: "left"
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它可以导入 &lt;code&gt;validator&lt;/code&gt; 中使用，也可以作为默认值:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;span :class="`arrow-position--${position}`"&amp;gt;
    {{ position }}
  &amp;lt;/span&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import { Position } from "./types";
export default {
  props: {
    position: {
      validator(value) {
        return Object.values(Position).includes(value);
      },
      default: Position.BOTTOM,
    },
  },
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，父级组件也可以导入并使用这个枚举，它消除了我们应用程序中对魔法字符串的使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;DropDownComponent :position="Position.BOTTOM" /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import DropDownComponent from "./components/DropDownComponent.vue";
import { Position } from "./components/types";
export default {
  components: {
    DropDownComponent,
  },
  data() {
    return {
      Position,
    };
  },
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;布尔映射&lt;/h2&gt;
&lt;p&gt;布尔类有独特的行为。属性的存在或不存在可以决定 prop 的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 等价于 :disabled="true" --&amp;gt;
&amp;lt;MyComponent disabled /&amp;gt;

&amp;lt;!-- 价于 :disabled="false" --&amp;gt;
&amp;lt;MyComponent /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;TypeScript&lt;/h2&gt;
&lt;p&gt;将Vue的内置 prop 验证与 TypeScript相结合，可以让我们对这一机制有更多的控制，因为TypeScript原生支持接口和枚举。&lt;/p&gt;
&lt;h4&gt;Interface&lt;/h4&gt;
&lt;p&gt;我们可以使用一个接口和 &lt;code&gt;PropType&lt;/code&gt; 来注解复杂的 prop 类型。这确保了传递的对象将有一个特定的结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script lang="ts"&amp;gt;
import Vue, { PropType } from 'vue'
interface Book {
  title: string
  author: string
  year: number
}
const Component = Vue.extend({
  props: {
    book: {
      type: Object as PropType&amp;lt;Book&amp;gt;,
      required: true,
      validator (book: Book) {
        return !!book.title;
      }
    }
  }
})
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;枚举&lt;/h4&gt;
&lt;p&gt;我们已经探讨了如何在 JS 中伪造一个枚举。这对于TypeScript来说是不需要的，它本向就支持了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script lang="ts"&amp;gt;
import Vue, { PropType } from 'vue'
enum Position {
  TOP = 'top',
  RIGHT = 'right',
  BOTTOM = 'bottom',
  LEFT = 'left',
}
export default {
  props: {
    position: {
      type: String as PropType&amp;lt;Position&amp;gt;,
      default: Position.BOTTOM,
    },
  },
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Vue 3&lt;/h2&gt;
&lt;p&gt;上述所有内容在使用 Vue 3与 选项API 或 组合API 时都有效。区别在于使用 &lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt;时。props 必须使用 &lt;code&gt;defineProps()&lt;/code&gt; 宏来声明，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
const props = defineProps(['foo'])
console.log(props.foo)
&amp;lt;/script&amp;gt;


&amp;lt;script setup&amp;gt;
defineProps({
  title: String,
  likes: Number
})
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者在使用 TypeScript 的 &lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt; 时，可以使用纯类型注解来声明 prop:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;script setup lang="ts"&amp;gt;
defineProps&amp;lt;{
  title?: string
  likes?: number
}&amp;gt;()
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用一个接口:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang="ts"&amp;gt;
interface Props {
  foo: string
  bar?: number
}
const props = defineProps&amp;lt;Props&amp;gt;()
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，在使用基于类型的声明时，声明默认值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup lang="ts"&amp;gt;
interface Props {
  foo: string
  bar?: number
}


const { foo, bar = 100 } = defineProps&amp;lt;Props&amp;gt;()
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 &lt;a href="https://www.fundebug.com/?utm_source=xiaozhi"&gt;Fundebug&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者：Fotis Adamakis  译者：前端小智 来源：mediun&lt;/p&gt;
&lt;p&gt;原文：https://fadamakis.mdium.com/validating-yur-vue-props-like-a-pro-5a2d0ed2b2d6&lt;/p&gt;
&lt;h3&gt;交流&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有梦想，有干货，微信搜索 &lt;strong&gt;【大迁世界】&lt;/strong&gt; 关注这个在凌晨还在刷碗的刷碗智。&lt;/p&gt;
&lt;p&gt;本文 GitHub  &lt;a href="https://github.com/qq449245884/xiaozhi"&gt;https://github.com/qq449245884/xiaozhi&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;</description><author>王大冶</author><pubDate>Mon, 29 Aug 2022 16:25:28 GMT</pubDate></item><item><title>any 和 unknown 傻傻分不清楚？</title><link>https://juejin.cn/post/7108496183298883597</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;13.5W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1WR4y1P7dw"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1WR4y1P7dw/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在你刚学 TypeScript 的时候，是不是遇到了很多令人抓狂的问题，最终你用上 any 大招把问题解决了。如果后期你没有系统的学习 TypeScript 的类型系统，你会发现你可能把 TypeScript 学成了 &lt;strong&gt;AnyScript&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 TypeScript 中，any 类型被称为 top type。所谓的 top type 可以理解为通用父类型，也就是能够包含所有值的类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: any;
​
value = true; // OK
value = 42; // OK
value = "Hello World"; // OK
value = []; // OK
value = {}; // OK
value = Math.random; // OK
value = null; // OK
value = undefined; // OK
value = new TypeError(); // OK
value = Symbol("type"); // OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在 TypeScript 3.0 时，又引入一个新的 top type —— &lt;strong&gt;unknown 类型&lt;/strong&gt;。同样，你也可以把任何值赋给 unknown 类型的变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: unknown;
​
value = true; // OK
value = 42; // OK
value = "Hello World"; // OK
value = []; // OK
value = {}; // OK
value = Math.random; // OK
value = null; // OK
value = undefined; // OK
value = new TypeError(); // OK
value = Symbol("type"); // OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d375fa3373d84f4d8c491166931a3cb5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么现在问题来了，any 类型和 unknown 类型之间有什么区别呢？any 类型可以理解成我不在乎它的类型，而unknown 类型可以理解成我不知道它的类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0823149987214d7698ee39103d52c1d7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其实 any 类型本质上是类型系统的一个逃生舱口，&lt;strong&gt;TypeScript 允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: any;
​
value.foo.bar; // OK
value.trim(); // OK
value(); // OK
new value(); // OK
value[0][1]; // OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会带来什么问题呢？下面我们来举一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function invokeCallback(callback: any) {
 &amp;nbsp; &amp;nbsp;try {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;callback();
 &amp;nbsp;  } catch (err) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.error(err)
 &amp;nbsp;  }
}
​
invokeCallback(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于以上的 TS 代码，在编译期不会提示任何错误，但在运行期将会抛出运行时错误。作为开发人员，any 类型给了我们很大的自由度，但同时也带来了一些隐患。&lt;strong&gt;为了解决 any 类型存在的安全隐患，TypeScript 团队在 3.0 版本时，引入了 unknown 类型，你可以把它理解成类型安全的 any 类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么 unknown 类型是类型安全的体现在哪里呢？这里我们把 invokeCallback 函数参数的类型改为 unknown 类型，之后 TS 编译器就会提示相应的错误信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function invokeCallback(callback: unknown) {
 &amp;nbsp; &amp;nbsp;try {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// Object is of type 'unknown'.(2571)
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;callback(); // Error
 &amp;nbsp;  } catch (err) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.error(err)
 &amp;nbsp;  }
}
​
invokeCallback(1); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相比 any 类型，TypeScript 会对 unknown 类型的变量执行类型检查，从而避免出现 callback 参数非函数类型。要解决上述问题，我们需要缩小 callback 参数的类型，即可以通过 typeof 操作符来确保传入的 callback 参数是函数类型的对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function invokeCallback(callback: unknown) {
 &amp;nbsp; &amp;nbsp;try {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;if (typeof callback === 'function') {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;callback();
 &amp;nbsp; &amp;nbsp; &amp;nbsp;  }
 &amp;nbsp;  } catch (err) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.error(err)
 &amp;nbsp;  }
}
​
invokeCallback(1); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在实际工作中，你还可以通过 instanceof 或用户自定义类型守卫等方式来缩窄变量的类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;declare function isFunction(x: unknown): x is Function;
​
function f20(x: unknown) {
 &amp;nbsp; &amp;nbsp;if (x instanceof Error) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;x; &amp;nbsp;// Error
 &amp;nbsp;  }
 &amp;nbsp; &amp;nbsp;if (isFunction(x)) {
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;x; &amp;nbsp;// Function
 &amp;nbsp;  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与 any 类型不同，因为 TypeScript 会对 unknown 类型的变量执行类型检查，所以当我们把之前代码中 value 变量的类型改成 unknown 类型时，使用 value 变量的多个语句将出现错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: unknown;
​
// Object is of type 'unknown'.(2571)
value.foo.bar; // Error
value.trim(); // Error
value(); // Error
new value(); // Error
value[0][1]; // Error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，需要注意的是，unknown 类型的变量只能赋值给 any 类型和 unknown 类型本身。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;let value: unknown;
​
let value1: unknown = value; // OK
let value2: any = value; // OK
let value3: boolean = value; // Error
let value4: number = value; // Error
let value5: string = value; // Error
let value6: object = value; // Error
let value7: any[] = value; // Error
let value8: Function = value; // Error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/333580eee6664b01aac61a5a43ddf473~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在往期文章中我们已经介绍过了 keyof 操作符和映射类型。any 类型和 unknown 类型在这些场合中的表现也是不一样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T40 = keyof any; &amp;nbsp;// string | number | symbol
type T41 = keyof unknown; &amp;nbsp;// never
​
type T50&amp;lt;T&amp;gt; = { [P in keyof T]: number };
type T51 = T50&amp;lt;any&amp;gt;; &amp;nbsp;// { [x: string]: number }
type T52 = T50&amp;lt;unknown&amp;gt;; &amp;nbsp;// {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，T50 类型被称为映射类型，在映射过程中，如果 key 的类型是 never 类型，则当前 key 将会被过滤掉，所以 T52 的类型是空对象类型。&lt;/p&gt;
&lt;p&gt;关于 any 类型和 unknown 类型的区别就介绍到这里，现在我们来做个总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可以把任何值赋给 any 类型的变量，并对该变量执行任何操作；&lt;/li&gt;
&lt;li&gt;你可以把任何值赋给 unknown 类型的变量，但你必须进行类型检查或类型断言才能对变量进行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2886ef1f92242239a363cfa23685866~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在平时工作中，为了保证类型安全，我们应该尽可能使用 &lt;strong&gt;unknown&lt;/strong&gt; 类型。最后我们来看一下 unknown 类型与不同类型进行类型运算的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T00 = unknown &amp;amp; null; &amp;nbsp;// null
type T01 = unknown &amp;amp; undefined; &amp;nbsp;// undefined
type T02 = unknown &amp;amp; null &amp;amp; undefined; &amp;nbsp;// null &amp;amp; undefined
type T03 = unknown &amp;amp; string; &amp;nbsp;// string
type T04 = unknown &amp;amp; string[]; &amp;nbsp;// string[]
type T05 = unknown &amp;amp; unknown; &amp;nbsp;// unknown
type T06 = unknown &amp;amp; any; &amp;nbsp;// any
​
type T10 = unknown | null; &amp;nbsp;// unknown
type T11 = unknown | undefined; &amp;nbsp;// unknown
type T12 = unknown | null | undefined; &amp;nbsp;// unknown
type T13 = unknown | string; &amp;nbsp;// unknown
type T14 = unknown | string[]; &amp;nbsp;// unknown
type T15 = unknown | unknown; &amp;nbsp;// unknown
type T16 = unknown | any; &amp;nbsp;// any
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a3a896dfbf4435b6f0eb510f2e7c87~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;any 类型比较特殊，该类型与任意类型进行交叉或联合运算时，都会返回 any 类型。阅读完本文之后，相信你已经了解 any 类型和 unknown 类型之间的区别了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你知道如何检测 any 类型和 unknown 类型么？&lt;/strong&gt; 如果知道的话，可以在评论区提交你的答案。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Sun, 12 Jun 2022 15:30:43 GMT</pubDate></item><item><title>用了模板字面量类型，同事直呼太强了！</title><link>https://juejin.cn/post/7106647263321325605</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;12.7W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1B34y1E7tm/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1B34y1E7tm/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你了解过模板字面量类型么？你想知道如何利用模板字面量类型，来减少 TypeScript 项目中的重复代码么？如果想的话，阅读完本文之后，也许你就懂了。假设我们想要定义一种类型来描述 CSS padding 规则，如果你了解 TypeScript 类型别名和联合类型的话，能很容易定义出 CssPadding 类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4e4a1d85bc945f993589d95fb6ab92a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type CssPadding =
 &amp;nbsp;| "padding-left"
 &amp;nbsp;| "padding-right"
 &amp;nbsp;| "padding-top"
 &amp;nbsp;| "padding-bottom";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但如果我们想要继续定义一种新的类型来描述 CSS margin 规则，你是不是立马想到与定义 CssPadding 类型一样的方式。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MarginPadding =
 &amp;nbsp;| "margin-left"
 &amp;nbsp;| "margin-right"
 &amp;nbsp;| "margin-top"
 &amp;nbsp;| "margin-bottom";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30da3e73d57540968784e22187fa6398~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;对于以上定义的两种类型来说，虽然它们都能满足我们的需求。但在定义这两种类型的过程中，仍然存在一些重复的代码。那么如何解决这个问题呢？这时我们可以使用 TypeScript 4.1 版本引入了新的模板字面量类型，具体的使用方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Direction = "left" | "right" | "top" | "bottom";
​
type CssPadding = `padding-${Direction}`;
type MarginPadding = `margin-${Direction}`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/507a39d3df82491f90e14cbb80251a87~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;看完以上代码，是不是觉得简洁很多。与 JavaScript 中的模板字符串类似，模板字面量类型被括在反引号中，同时可以包含 &lt;code&gt;${T}&lt;/code&gt; 形式的占位符，其中类型变量 T 的类型可以是 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt; 或 &lt;code&gt;bigint&lt;/code&gt; 类型。&lt;/p&gt;
&lt;p&gt;模板字面量类型不仅为我们提供了连接字符串字面量的能力，而且还可以把非字符串基本类型的字面量转换为对应的字符串字面量类型。下面我们来举一些具体的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type EventName&amp;lt;T extends string&amp;gt; = `${T}Changed`;
type Concat&amp;lt;S1 extends string, S2 extends string&amp;gt; = `${S1}-${S2}`;
type ToString&amp;lt;T extends string | number | boolean | bigint&amp;gt; = `${T}`;
​
type T0 = EventName&amp;lt;"foo"&amp;gt;; // 'fooChanged'
type T1 = Concat&amp;lt;"Hello", "World"&amp;gt;; // 'Hello-World'
type T2 = ToString&amp;lt;"阿宝哥" | 666 | true | -1234n&amp;gt;; // "阿宝哥" | "true" | "666" | "-1234"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/346480799b014bc7b43094017053916c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;对于上述的例子来说，其实并不复杂。但现在问题来了，如果传入 EventName 或 Concat 工具类型的实际类型是联合类型的话，那么结果又会是怎样呢？接下来，我们来验证一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T3 = EventName&amp;lt;"foo" | "bar" | "baz"&amp;gt;; 
// "fooChanged" | "barChanged" | "bazChanged"
type T4 = Concat&amp;lt;"top" | "bottom", "left" | "right"&amp;gt;;
// "top-left" | "top-right" | "bottom-left" | "bottom-right"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/433d409800344e288edda8a3d0a9cef6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为什么会生成这样的类型呢？这是因为对于模板字面量类型来说，当类型占位符的实际类型是联合类型（A ｜B ｜C）的话，就会被自动展开：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;`[${A|B|C}]` =&amp;gt; `[${A}]` | `[${B}]` | `[${C}]`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da6ad7f256604ebf83914356f244b33f~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;而对于包含多个类型占位符的情形，比如 &lt;code&gt;Concat&lt;/code&gt; 工具类型。多个占位符中的联合类型解析为叉积：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;`${A|B}-${C|D}` =&amp;gt; `${A}-${C}` | `${A}-${D}` | `${B}-${C}` | `${B}-${D}`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23822d8edc648d1b8fb41addcec3014~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;了解完上述的运算规则，你应该就能理解生成的 T3 和 T4 类型了。在使用模板字面量类型的过程中，我们还可以使用 TypeScript 提供的，用于处理字符串类型的内置工具类型，比如 &lt;strong&gt;Uppercase&lt;/strong&gt;、&lt;strong&gt;Lowercase&lt;/strong&gt;、&lt;strong&gt;Capitalize&lt;/strong&gt; 和 &lt;strong&gt;Uncapitalize&lt;/strong&gt;。具体的使用方式是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type GetterName&amp;lt;T extends string&amp;gt; = `get${Capitalize&amp;lt;T&amp;gt;}`;
type Cases&amp;lt;T extends string&amp;gt; = `${Uppercase&amp;lt;T&amp;gt;} ${Lowercase&amp;lt;T&amp;gt;} ${Capitalize&amp;lt;T&amp;gt;} ${Uncapitalize&amp;lt;T&amp;gt;}`;
​
type T5 = GetterName&amp;lt;'foo'&amp;gt;; &amp;nbsp;// "getFoo"
type T6 = Cases&amp;lt;'bar'&amp;gt;; &amp;nbsp;// "BAR bar Bar bar"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实，模板字面量类型的能力是很强大的，结合 TypeScript 的条件类型和 infer 关键字我们还可以实现类型推断。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Direction = "left" | "right" | "top" | "bottom";
type InferRoot&amp;lt;T&amp;gt; = T extends `${infer R}${Capitalize&amp;lt;Direction&amp;gt;}` ? R : T;
​
type T7 = InferRoot&amp;lt;"marginRight"&amp;gt;; // "margin"
type T8 = InferRoot&amp;lt;"paddingLeft"&amp;gt;; // "padding"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，InferRoot 工具类型除了利用模板字面量类型之外，还使用了 TypeScript 条件类型和 infer。如果你对这两个知识点，还不了解的话，可以观看 “用了 TS 条件类型，同事直呼 YYDS” 和 “学会 TS infer，写起泛型真香！” 这两期的视频。&lt;/p&gt;
&lt;p&gt;此外，TypeScript 4.1 版本允许我们使用 as 子句对映射类型中的键进行重新映射。它的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MappedTypeWithNewKeys&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T as NewKeyType]: T[K]
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  ^^^^^^^^^^^^^
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  This is the new syntax!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce1d6a2bbf14c92afb8a938e4b1093b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其中 NewKeyType 的类型必须是 string | number | symbol 联合类型的子类型。在重新映射的过程中，结合模板字面量类型所提供的能力，我们就可以实现一些有用的工具类型。比如，我们可以定义一个 Getters 工具类型，用于为对象类型生成对应的 Getter 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Getters&amp;lt;T&amp;gt; = {
  [K in keyof T as `get${Capitalize&amp;lt;string &amp;amp; K&amp;gt;}`]: () =&amp;gt; T[K]
};
​
interface Person {
 &amp;nbsp; &amp;nbsp;name: string;
 &amp;nbsp; &amp;nbsp;age: number;
 &amp;nbsp; &amp;nbsp;location: string;
}
​
type LazyPerson = Getters&amp;lt;Person&amp;gt;;
// {
// &amp;nbsp; getName: () =&amp;gt; string;
// &amp;nbsp; getAge: () =&amp;gt; number;
// &amp;nbsp; getLocation: () =&amp;gt; string;
// }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2b1d6b3ea74a5c9e96e8c77ff0d38e~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，因为 keyof T 返回的类型可能会包含 symbol 类型，而 Capitalize 工具类型要求处理的类型需要是 string 类型的子类型，所以需要通过交叉运算符进行类型过滤。除了实现简单的工具类型之外，我们还可以实现比较复杂的工具类型。比如，用于获取对象类型中，任意层级属性的类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type PropType&amp;lt;T, Path extends string&amp;gt; = string extends Path
 &amp;nbsp;? unknown
  : Path extends keyof T
 &amp;nbsp;? T[Path]
  : Path extends `${infer K}.${infer R}`
 &amp;nbsp;? K extends keyof T
 &amp;nbsp; &amp;nbsp;? PropType&amp;lt;T[K], R&amp;gt;
 &amp;nbsp;  : unknown
  : unknown;
​
declare function getPropValue&amp;lt;T, P extends string&amp;gt;(
 &amp;nbsp;obj: T,
 &amp;nbsp;path: P
): PropType&amp;lt;T, P&amp;gt;;
​
const obj = { a: { b: { c: 666, d: "阿宝哥" } } };
let a = getPropValue(obj, "a"); // { b: {c: number, d: string } }
let ab = getPropValue(obj, "a.b"); // {c: number, d: string }
let abd = getPropValue(obj, "a.b.d"); // string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/640e69f0eb7647249c27c215528dea1b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，PropType 工具类型涉及 TypeScript 中的多个核心知识点。除了递归类型之外，条件类型、条件链和 infer 类型推断这些知识点，阿宝哥在往期的文章中都已经介绍了。而关于递归类型的知识点，阿宝哥将在后续的文章中介绍，感兴趣的话记得关注阿宝哥。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Tue, 07 Jun 2022 15:42:46 GMT</pubDate></item><item><title>type 和 interface 傻傻分不清楚？</title><link>https://juejin.cn/post/7098491203443752974</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;7.1 W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8776a0d30114fda90da2b96b6560d04~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1HB4y1y7KG"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1HB4y1y7KG&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你简历上的技能有写 TypeScript，那么面试官可能会问你 type 和 interface 之间有什么区别？你知道怎么回答这个问题么？如果不知道的话，那看完本文也许你就懂了。&lt;/p&gt;
&lt;p&gt;类型别名 type 可以用来给一个类型起个新名字，当命名基本类型或联合类型等非对象类型时非常有用：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MyNumber = number;
type StringOrNumber = string | number;
type Text = string | string[];
type Point = [number, number];
type Callback = (data: string) =&amp;gt; void;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95381b09336d425586700d28acfaf093~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在 TypeScript 1.6 版本，类型别名开始支持泛型。我们工作中常用的 Partial、Required、Pick、Record 和 Exclude 等工具类型都是以 type 方式来定义的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;// lib.es5.d.ts
type Partial&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [P in keyof T]?: T[P];
};
​
type Required&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [P in keyof T]-?: T[P];
};
​
type Pick&amp;lt;T, K extends keyof T&amp;gt; = {
 &amp;nbsp;  [P in K]: T[P];
};
​
type Record&amp;lt;K extends keyof any, T&amp;gt; = {
 &amp;nbsp;  [P in K]: T;
};
​
type Exclude&amp;lt;T, U&amp;gt; = T extends U ? never : T;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而接口 interface 只能用于定义对象类型，Vue 3 中的 App 对象就是使用 interface 来定义的：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;// packages/runtime-core/src/apiCreateApp.ts
export interface App&amp;lt;HostElement = any&amp;gt; {
 &amp;nbsp;version: string
 &amp;nbsp;config: AppConfig
 &amp;nbsp;use(plugin: Plugin, ...options: any[]): this
 &amp;nbsp;mixin(mixin: ComponentOptions): this
 &amp;nbsp;component(name: string): Component | undefined // Getter
 &amp;nbsp;component(name: string, component: Component): this // Setter
 &amp;nbsp;directive(name: string): Directive | undefined
 &amp;nbsp;directive(name: string, directive: Directive): this
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上代码可知，在定义接口时，我们可以同时声明对象类型上的属性和方法。了解 type 和 interface 的作用之后，我们先来介绍一下它们的相似之处。&lt;/p&gt;
&lt;p&gt;1、类型别名和接口都可以用来描述对象或函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型别名&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Point = {
 &amp;nbsp;x: number;
 &amp;nbsp;y: number;
};
​
type SetPoint = (x: number, y: number) =&amp;gt; void;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们通过 type 关键字为对象字面量类型和函数类型分别取了一个别名，从而方便在其他地方使用这些类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface Point {
 &amp;nbsp;x: number;
 &amp;nbsp;y: number;
}
​
interface SetPoint {
  (x: number, y: number): void;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、类型别名和接口都支持扩展&lt;/p&gt;
&lt;p&gt;类型别名通过 &amp;amp;（交叉运算符）来扩展，而接口通过 extends 的方式来扩展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型别名扩展&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Animal = {
 &amp;nbsp;name: string
}
​
type Bear = Animal &amp;amp; { 
 &amp;nbsp;honey: boolean 
}
​
const bear: Bear = getBear() 
bear.name
bear.honey
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;接口扩展&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface Animal {
 &amp;nbsp;name: string
}
​
interface Bear extends Animal {
 &amp;nbsp;honey: boolean
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/032e6bb259724d1faf144e70a9f3ea72~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;此外，接口也可以通过 extends 来扩展类型别名定义的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Animal = {
 &amp;nbsp;name: string
}
​
interface Bear extends Animal {
 &amp;nbsp;honey: boolean
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，类型别名也可以通过 &amp;amp;（交叉运算符）来扩展已定义的接口类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface Animal {
 &amp;nbsp;name: string
}
​
type Bear = Animal &amp;amp; { 
 &amp;nbsp;honey: boolean 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3d9ebb1515b4a108a1b96abbbadb641~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;了解完 type 和 interface 的相似之处之后，接下来我们来介绍它们之间的区别。&lt;/p&gt;
&lt;p&gt;1、类型别名可以为基本类型、联合类型或元组类型定义别名，而接口不行&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type MyNumber = number;
type StringOrNumber = string | number;
type Point = [number, number];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、同名接口会自动合并，而类型别名不会&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同名接口合并&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;interface User {
 &amp;nbsp;name: string;
}
​
interface User {
 &amp;nbsp;id: number;
}
​
let user: User = { id: 666, name: "阿宝哥" };
user.id; // 666
user.name; // "阿宝哥"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;同名类型别名会冲突&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type User = {
 &amp;nbsp;name: string;
};
​
// 标识符“User”重复。ts(2300)
type User = {
 &amp;nbsp;id: number;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e3634daa7704b62a8b845ac6c43ee54~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;利用同名接口自动合并的特性，在开发第三方库的时候，我们就可以为使用者提供更好的安全保障。比如 &lt;a href="https://github.com/antfu/webext-bridge"&gt;webext-bridge&lt;/a&gt; 这个库，使用 interface 定义了 ProtocolMap 接口，从而让使用者可自由地扩展 ProtocolMap 接口。之后，在利用该库内部提供的 &lt;code&gt;onMessage&lt;/code&gt; 函数监听自定义消息时，我们就可以推断出不同消息对应的消息体类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展 ProtocolMap 接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;import { ProtocolWithReturn } from 'webext-bridge'
​
declare module 'webext-bridge' {
 &amp;nbsp;export interface ProtocolMap {
 &amp;nbsp; &amp;nbsp;foo: { title: string }
 &amp;nbsp; &amp;nbsp;bar: ProtocolWithReturn&amp;lt;CustomDataType, CustomReturnType&amp;gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;监听自定义消息&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;import { onMessage } from 'webext-bridge'
​
onMessage('foo', ({ data }) =&amp;gt; {
 &amp;nbsp;// type of `data` will be `{ title: string }`
 &amp;nbsp;console.log(data.title)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62f570dafdab4662b32a23c41017b4cd~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你感兴趣的话，可以看一下该项目的源码。若遇到问题，可以跟阿宝哥交流。最后我们来总结一下类型别名和接口的一些使用场景。&lt;/p&gt;
&lt;p&gt;使用类型别名的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义基本类型的别名时，使用 type&lt;/li&gt;
&lt;li&gt;定义元组类型时，使用 type&lt;/li&gt;
&lt;li&gt;定义函数类型时，使用 type&lt;/li&gt;
&lt;li&gt;定义联合类型时，使用 type&lt;/li&gt;
&lt;li&gt;定义映射类型时，使用 type&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用接口的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要利用接口自动合并特性的时候，使用 interface&lt;/li&gt;
&lt;li&gt;定义对象类型且无需使用 type 的时候，使用 interface&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阅读完本文，相信你已经了解 type 和 interface 之间的区别了。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Mon, 16 May 2022 16:12:28 GMT</pubDate></item><item><title>用了 TS 条件类型，同事直呼 YYDS！</title><link>https://juejin.cn/post/7096265620445986823</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://juejin.cn/post/7095547569777934367"&gt;5.2W 播放量的 TS 动画版进阶教程合集来了！&lt;/a&gt;，通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1HR4y1N7ea/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1HR4y1N7ea/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你用过 Exclude、Extract、NonNullable、Parameters 和 ReturnType 这些工具类型吗？&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Exclude&amp;lt;T, U&amp;gt; = T extends U ? never : T;
type Extract&amp;lt;T, U&amp;gt; = T extends U ? T : never;
type NonNullable&amp;lt;T&amp;gt; = T extends null | undefined ? never : T;
type Parameters&amp;lt;T extends (...args: any) =&amp;gt; any&amp;gt; = T extends (...args: infer P) =&amp;gt; any ? P : never;
type ReturnType&amp;lt;T extends (...args: any) =&amp;gt; any&amp;gt; = T extends (...args: any) =&amp;gt; infer R ? R : any;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你知道它们内部是如何工作的吗？&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18becb1cec4f4d63a8ac836a2f093f7a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你想彻底掌握它们且实现自己的工具类型，那么本文千万不要错过。前面看到的那些内置工具类型，它们内部使用了 TypeScript 2.8 版本引入的条件类型（Conditional Types）。该类型的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;T extends U ? X : Y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 T、U、X 和 Y 这些都是类型占位符。你可以这样理解该语法，当类型 T 可以赋值给类型 U 时，那么返回类型 X，否则返回类型 Y。看到这里你是不是也想到了 JavaScript 中的三元表达式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31c4ef5f3a864df4967d552fa22d06d5~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么条件类型有什么用呢？这里我们来举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type IsString&amp;lt;T&amp;gt; = T extends string ? true : false;
​
type I0 = IsString&amp;lt;number&amp;gt;; &amp;nbsp;// false
type I1 = IsString&amp;lt;"abc"&amp;gt;; &amp;nbsp;// true
type I2 = IsString&amp;lt;any&amp;gt;; &amp;nbsp;// boolean
type I3 = IsString&amp;lt;never&amp;gt;; &amp;nbsp;// never
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c121684a93604a3290ee25bd257c1eb8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，我们定义了 IsString 工具类型。使用该工具类型，我们可以判断传给类型参数 T 的实际类型是否为字符串类型。除了判断单一类型之外，利用条件类型和条件链，我们还可以同时判断多种类型。&lt;/p&gt;
&lt;p&gt;接下来，我们来看一下如何实现该功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type TypeName&amp;lt;T&amp;gt; =
 &amp;nbsp; &amp;nbsp;T extends string ? "string" :
 &amp;nbsp; &amp;nbsp;T extends number ? "number" :
 &amp;nbsp; &amp;nbsp;T extends boolean ? "boolean" :
 &amp;nbsp; &amp;nbsp;T extends undefined ? "undefined" :
 &amp;nbsp; &amp;nbsp;T extends Function ? "function" :
 &amp;nbsp; &amp;nbsp;"object";
​
type T0 = TypeName&amp;lt;string&amp;gt;; &amp;nbsp;// "string"
type T1 = TypeName&amp;lt;"a"&amp;gt;; &amp;nbsp;// "string"
type T2 = TypeName&amp;lt;true&amp;gt;; &amp;nbsp;// "boolean"
type T3 = TypeName&amp;lt;() =&amp;gt; void&amp;gt;; &amp;nbsp;// "function"
type T4 = TypeName&amp;lt;string[]&amp;gt;; &amp;nbsp;// "object"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们定义了一个新的 TypeName 工具类型，在该工具类型中，我们使用了条件链。为了便于大家理解条件链，我们以 JavaScript 三元表达式为例，来演示一下它的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;function example(…) {
 &amp;nbsp; &amp;nbsp;return condition1 ? value1
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : condition2 ? value2
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : condition3 ? value3
 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : value4;
}
​
// 等价于
function example(…) {
 &amp;nbsp; &amp;nbsp;if (condition1) { return value1; }
 &amp;nbsp; &amp;nbsp;else if (condition2) { return value2; }
 &amp;nbsp; &amp;nbsp;else if (condition3) { return value3; }
 &amp;nbsp; &amp;nbsp;else { return value4; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在问题来了，对于前面定义的 TypeName 工具类型来说，如果传入的类型是联合类型的话，那么将返回什么结果？下面我们来验证一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type T10 = TypeName&amp;lt;string | (() =&amp;gt; void)&amp;gt;; &amp;nbsp;// "string" | "function"
type T11 = TypeName&amp;lt;string | string[] | undefined&amp;gt;; &amp;nbsp;// "string" | "object" | "undefined"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96ce7f75210f42aea55f3cd2a4266c71~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为什么 T10 和 T11 类型返回的是联合类型呢？这是因为 TypeName 属于分布式条件类型。在条件类型中，如果被检查的类型是一个 “裸” 类型参数，即没有被数组、元组或 Promise 等包装过，则该条件类型被称为分布式条件类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0377755c894548e6b03c9b5ed42b1acb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;对于分布式条件类型来说，当传入的被检查类型是联合类型的话，在运算过程中会被分解成多个分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;T extends U ? X : Y 
T =&amp;gt; A | B | C 
A | B | C extends U ? X : Y &amp;nbsp;=&amp;gt; 
(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dd1ef3fea6f464992e875c18d6d03e6~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;为了便于大家理解，我们来举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Naked&amp;lt;T&amp;gt; = T extends boolean ? "Y" : "N";
​
type WrappedTuple&amp;lt;T&amp;gt; = [T] extends [boolean] ? "Y" : "N";
type WrappedArray&amp;lt;T&amp;gt; = T[] extends boolean[] ? "Y" : "N";
type WrappedPromise&amp;lt;T&amp;gt; = Promise&amp;lt;T&amp;gt; extends Promise&amp;lt;boolean&amp;gt; ? "Y" : "N";
​
type T0 = Naked&amp;lt;number | boolean&amp;gt;; // "N" | "Y"
type T1 = WrappedTuple&amp;lt;number | boolean&amp;gt;; // "N"
type T2 = WrappedArray&amp;lt;number | boolean&amp;gt;; // "N"
type T3 = WrappedPromise&amp;lt;number | boolean&amp;gt;; // "N"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上结果可知，如果条件类型中的类型参数 T 被包装过，该条件类型就不属于分布式条件类型，所以在运算过程中就不会被分解成多个分支。了解完条件类型和分布式条件类型的知识点，我们来举例演示一下 TypeScript 内置工具类型 Exclude 的执行流程。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type Exclude&amp;lt;T, U&amp;gt; = T extends U ? never : T;
type T4 = Exclude&amp;lt;"a" | "b" | "c", "a" | "b"&amp;gt;
​
("a" extends "a" | "b" ? never : "a") // =&amp;gt; never
| ("b" extends "a" | "b" ? never : "b") // =&amp;gt; never
| ("c" extends "a" | "b" ? never : "c") // =&amp;gt; "c"
​
never | never | "c" // =&amp;gt; "c"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/281bb2aff49f4194b7a263e58050b169~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;掌握了条件类型之后，再结合往期文章中介绍的&lt;a href="https://juejin.cn/post/7089943758543781896"&gt;映射类型&lt;/a&gt;，我们就可以实现一些有用的工具类型。比如实现 FunctionProperties 和 NonFunctionProperties 等工具类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9091804aa8fb4f308e2149d01d0e3f6d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17ceace0ab244401b4e9a6afcf9e4906~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;type FunctionPropertyNames&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];
type FunctionProperties&amp;lt;T&amp;gt; = Pick&amp;lt;T, FunctionPropertyNames&amp;lt;T&amp;gt;&amp;gt;;
​
type NonFunctionPropertyNames&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];
type NonFunctionProperties&amp;lt;T&amp;gt; = Pick&amp;lt;T, NonFunctionPropertyNames&amp;lt;T&amp;gt;&amp;gt;;
​
interface User {
 &amp;nbsp; &amp;nbsp;id: number;
 &amp;nbsp; &amp;nbsp;name: string;
 &amp;nbsp; &amp;nbsp;age: number;
 &amp;nbsp; &amp;nbsp;updateName(newName: string): void;
}
​
type T5 = FunctionPropertyNames&amp;lt;User&amp;gt;; // "updateName"
type T6 = FunctionProperties&amp;lt;User&amp;gt;; // { updateName: (newName: string) =&amp;gt; void; }
type T7 = NonFunctionPropertyNames&amp;lt;User&amp;gt;; // "id" | "name" | "age"
type T8 = NonFunctionProperties&amp;lt;User&amp;gt;; // { id: number; name: string; age: number; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，利用上述的工具类型，我们就可以轻松地提取 User 对象类型中函数类型和非函数类型的属性及相关的对象类型。&lt;/p&gt;
&lt;p&gt;阅读完本文之后，相信你已经了解条件类型和分布式条件类型的作用了，也知道 TS 内部一些工具类型是如何实现的。关于在条件类型中如何利用 infer 实现类型推断，阿宝哥将在后续的文章中介绍。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Tue, 10 May 2022 16:18:52 GMT</pubDate></item><item><title>14.4W 播放量的 TS 动画版进阶教程合集来了！</title><link>https://juejin.cn/post/7095547569777934367</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: orange&lt;/h2&gt;
&lt;p&gt;阿宝哥精心准备的 &lt;strong&gt;&lt;a href="https://space.bilibili.com/406258607"&gt;《轻松学 TypeScript》&lt;/a&gt;&lt;/strong&gt; 视频教程来咯，强烈推荐！通过形象生动的动画，让你轻松搞懂 TypeScript 的难点和核心知识点！目前已更新到第 &lt;strong&gt;19&lt;/strong&gt; 期，其中 1 期的观看量已破 2 W，该合集的播放量目前已达 14.4W+🔥🔥🔥。&lt;/p&gt;
&lt;p&gt;👇 新的一期已经发布了，感兴趣的小伙伴一起学起来。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cfbfe60f59748a7884fbeb96e916674~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你已掌握 TS 的话，那就来做做这 &lt;strong&gt;48&lt;/strong&gt; 道 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247495521&amp;amp;idx=1&amp;amp;sn=dd26b5b4f2cd2c78dcbcc9fd15b27df7&amp;amp;scene=21#wechat_redirect"&gt;TS 练习题&lt;/a&gt;。如果还没开始学 TS 的话，可以先看看 &lt;a href="https://juejin.cn/post/6872111128135073806"&gt;「1.8W字」不可多得的 TS 入门教程&lt;/a&gt;（4347个👍）&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk/"&gt;TypeScript 泛型中的 T、K、V 等到底是个啥？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/d5XUpAA_hG4TL8sBTCPlog"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TypeScript 泛型中的 K、T、V 等变量！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1040d61451f4b89b7a18a9267386fee~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1Wr4y1J7x3/"&gt;用了 TS 映射类型，同事直呼内行！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1Wr4y1J7x3/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/uhL9VZuKg1-CtnGlI0YO7A"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过生动形象的动画，让你搞清楚 TS 内置工具类型的工作原理，同时掌握 TS 映射类型相关语法及重要的知识点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f61f13585fc437fa0ee1c9eed159dfb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1JS4y1Y7Jy/"&gt;Vue 3 中使用的函数重载有啥用？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1JS4y1Y7Jy/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/kyOff_lCrKXWhyAamm-Prw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 Vue3 响应式模块 ref 函数所使用的重载技术，同时了解函数重载和方法重载相关的知识点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d192edf3a4fc48cd9ce7d894fa0d4d92~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1HB4y1y7KG/"&gt;type 和 interface 傻傻分不清楚？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1HB4y1y7KG/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/C-n1vkfv2pATT2fjdNLjmQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TypeScript type 和 interface 之间的区别，还有一个开发 TS 库时，值得学习的 “黑科技”。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0ecd507f53448329e2ee6bd7d5fb2e0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1WR4y1P7dw/"&gt;TypeScript 你还只会用 any？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1WR4y1P7dw/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/-83tlUcG2mOm79nVI2pu3g"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让你轻松搞懂 any 类型和 unknown 类型的区别及在不同场景中的表现。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6564211db2e94d83aa56dbfb6cc757f4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1HR4y1N7ea/"&gt;用了 TS 条件类型，同事直呼 YYDS！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1HR4y1N7ea/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/y-N265ULBluzwnmRGNs2Xg"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以后看到 T extends U ? X : Y 再也不怕了。精心设计设计的动画，让你轻松掌握条件类型、分布式条件类型和 TS 内置工具类型的工作原理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72fd06c2e4a94b36b05fb8162c7698fd~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1qv4y1P7D2/"&gt;学了 TS infer，我也会类型推断了！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1qv4y1P7D2/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/3QlkoSWyPrsNj1Sc8DvzJQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看完本期视频，你就可以轻松地使用条件类型和 infer 来开发各种工具类型实现类型推断。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afbbc8d141b9446dbba202105b3d66a4~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1QY411T7Vn"&gt;TS 4.7 版本新特性，让 infer 更简单&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1QY411T7Vn"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/68iX9xt9QbBXzeP4QKF1mQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看完本期视频之后，让你写的 infer 类型推断更加简洁。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44df990ac3fd4be0b9795de230b5ed86~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1B34y1E7tm"&gt;用了模板字面量类型，同事直呼太强了！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1B34y1E7tm"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/Q8MpOTB77SdipwUVrc3Jyw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;模板字面量类型减少重复代码的利器，结合条件类型、映射类型和infer类型推断，你就能轻松应对工作中遇到的问题！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a330e5207c2444e3bbbfa4987d0c28bc~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1RF411T7zu/"&gt;搞懂 TypeScript 交叉类型的多个知识点！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1RF411T7zu/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/OnLXfjpnR9guQbROINIaag"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让你轻松理解交叉类型并掌握其核心知识点，学完后结合映射类型就可以根据工作需要实现一些自定义工具类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34997d985eec49d89dbf44fbea3236ab~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1jY4y1i7Lh/"&gt;搞懂 TypeScript 联合类型的多个知识点！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1jY4y1i7Lh/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/C_sD6oHwngJ-dU4tev5MQw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞懂 TypeScript 联合类型的多个知识点及应用场景！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2150a24e4f040a89c99c085a3cd5733~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1Zq4y1a79K/"&gt;TypeScript 中的类型到底是个啥？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1Zq4y1a79K/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/dL-G-BypnUMHE9e-MAlQwg"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过形象生动的动画，让你搞懂 TypeScript 的类型，打好进阶 TS 的基础！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0358dc1403b9423da920ac054f337a85~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1RY411A7YS/"&gt;仅知道键和值的类型，如何定义 TS 对象类型？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1RY411A7YS/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/L2sIMye6fo5-VnRccMWXqA"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚索引签名、Record 内置工具类型的使用场景和区别。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e6bb3363f84e6ca31651c5e508ac35~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1nT4y1a7AR/"&gt;TS 内置工具类型中的 keyof 操作符有啥用？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1nT4y1a7AR/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/QPAKjiYamib6HPItgqZEsw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TS 内置工具类型中 keyof 操作符的作用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ecd075b0ca44a26be4abb78a3d9733b~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1P94y127pd"&gt;TS typeof 操作符，原来有这五种用途！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1P94y127pd/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/ptqYjU_0CQO-J88LsULcRQ"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过动画的形式，让你搞清楚 TS 内置工具类型中 typeof 操作符的 5 大应用场景。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f89ac4a46634920af534ec42cd39506~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1254y1Z7BL/"&gt;减少 TS 重复代码，Omit 用起来真香！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1254y1Z7BL/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/sty4oaMCCbmjWAcrAOAJmA"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看完之后让你一次搞懂 TS 内置工具类型 Omit 的应用场景和内部实现原理！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8672c2253e3c4df483a79f24b048aa7a~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.bilibili.com/video/BV1Da411J7jj/"&gt;听说你熟悉 Pick，那就来手写一个 MyPick！&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;👉 &lt;a href="https://www.bilibili.com/video/BV1Da411J7jj/"&gt;观看视频&lt;/a&gt; 📚&lt;a href="https://mp.weixin.qq.com/s/fGWen-uWviauRxF0zmseLw"&gt;阅读文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类型体操开始热身了，看完之后让你一次搞懂 TS 内置工具类型 Pick 的内部实现原理！&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eb7eb148f914b9c9b88f6437b33a06d~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;《轻松学 TypeScript》 已发布 &lt;strong&gt;19 期&lt;/strong&gt; ，肝视频不易，如果对你有帮助的话，欢迎&lt;strong&gt;点赞与分享&lt;/strong&gt;，谢谢大家！你对 TS 哪方面比较感兴趣，可以给我留言呀！&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Sun, 08 May 2022 17:48:51 GMT</pubDate></item><item><title>用了 TS 映射类型，同事直呼内行！</title><link>https://juejin.cn/post/7089943758543781896</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1Wr4y1J7x3/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1Wr4y1J7x3/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你用过&amp;nbsp;Partial、Required、Pick 和 Readonly 这些工具类型吗？&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9e45e9defd947fe8d3da222adb9b54c~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;你知道它们内部是如何工作的吗？&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb55806af6834dbe87d7844753821da7~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;如果你想彻底掌握它们且实现自己的工具类型，那么本文介绍的内容千万不要错过。&lt;/p&gt;
&lt;p&gt;在日常工作中，用户注册是一个很常见的场景。这里我们可以使用 TS 定义一个 User 类型，在该类型中所有的键都是必填的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type User = {
 &amp;nbsp;name: string; // 姓名
 &amp;nbsp;password: string; // 密码
 &amp;nbsp;address: string; // 地址
 &amp;nbsp;phone: string; // 联系电话
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常情况下，对于已注册的用户，我们是允许用户只修改部分用户信息。这时我们就可以定义一个新的 UserPartial 类型，表示用于更新的用户对象的类型，在该类型中所有的键都是可选的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type UserPartial = {
 &amp;nbsp;name?: string; // 姓名
 &amp;nbsp;password?: string; // 密码
 &amp;nbsp;address?: string; // 地址
 &amp;nbsp;phone?: string; // 联系电话
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53c621d50d3b4c62a493ab1a67387fb2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;而对于查看用户信息的场景，我们希望该用户对象所对应的对象类型中所有的键都是只读。针对这种需求，我们可以定义 ReadonlyUser 类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type ReadonlyUser = {
 &amp;nbsp;readonly name: string; // 姓名
 &amp;nbsp;readonly password: string; // 密码
 &amp;nbsp;readonly address: string; // 地址
 &amp;nbsp;readonly phone: string; // 联系电话
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d10197e269d54e49a5b1d3856eab1382~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;回顾前面已定义的与用户相关的 3 种类型，你会发现它们中含有很多重复的代码。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21c4f436353d4523bf32379ffcf6f6a2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么如何减少以上类型中的重复代码呢？&lt;/p&gt;
&lt;p&gt;答案是可以使用映射类型，&lt;strong&gt;它是一种泛型类型，可用于把原有的对象类型映射成新的对象类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74cb5f53f5974c8e8216910671f7a446~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a042030efe54889beabc03ec2d55f68~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;映射类型的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;{ [ P in K ] : T }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0f423e206294a7a9d3fb94b16182869~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其中 P in K 类似于 JavaScript 中的 &lt;code&gt;for...in&lt;/code&gt; 语句，用于遍历 K 类型中的所有类型，而 T 类型变量用于表示 TS 中的任意类型。&lt;/p&gt;
&lt;p&gt;在映射的过程中，你还可以使用 &lt;code&gt;readonly&lt;/code&gt; 和问号这两个额外的修饰符。通过添加加号和减号前缀，来增加和移除对应的修饰符。如果没有添加任何前缀的话，默认是使用加号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87caca9a43644334aefadb47adc1a700~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;现在我们就可以总结出常见的映射类型语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;{ [ P in K ] : T }
{ [ P in K ] ?: T }
{ [ P in K ] -?: T }
{ readonly [ P in K ] : T }
{ readonly [ P in K ] ?: T }
{ -readonly [ P in K ] ?: T }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;介绍完映射类型的语法，我们来看一些具体的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type Item = { a: string; b: number; c: boolean };

type T1 = { [P in "x" | "y"]: number }; // { x: number, y: number }
type T2 = { [P in "x" | "y"]: P }; // { x: "x", y: "y" }
type T3 = { [P in "a" | "b"]: Item[P] }; // { a: string, b: number }
type T4 = { [P in keyof Item]: Item[P] }; // { a: string, b: number, c: boolean }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们来看一下如何利用映射类型来重新定义 UserPartial 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type MyPartial&amp;lt;T&amp;gt; = {
  [P in keyof T]?: T[P];
};

type UserPartial = MyPartial&amp;lt;User&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们定义了 MyPartial 映射类型，然后利用该类型把 User 类型映射成 UserPartial 类型。其中 keyof 操作符用于获取某种类型中的所有键，其返回类型是联合类型。而类型变量 P 会随着每次遍历改变成不同的类型，&lt;code&gt;T[P]&lt;/code&gt; 该语法类似于属性访问的语法，用于获取对象类型某个属性对应值的类型。&lt;/p&gt;
&lt;p&gt;下面我们来演示一下 MyPartial 映射类型的完整执行流程，如果不清楚的话，可以多看几遍加深对 TS 映射类型的理解。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f61f13585fc437fa0ee1c9eed159dfb~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;TypeScript 4.1 版本允许我们使用 as 子句对映射类型中的键进行重新映射。它的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type MappedTypeWithNewKeys&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T as NewKeyType]: T[K]
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  ^^^^^^^^^^^^^
 &amp;nbsp; &amp;nbsp;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  这是新的语法！
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b502a3a628ca40a6baef42699d5950b2~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;其中 NewKeyType 的类型必须是 string | number | symbol 联合类型的子类型。使用 as 子句，我们可以定义一个 Getters 工具类型，用于为对象类型生成对应的 Getter 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;type Getters&amp;lt;T&amp;gt; = {
  [K in keyof T as `get${Capitalize&amp;lt;string &amp;amp; K&amp;gt;}`]: () =&amp;gt; T[K]
};

interface Person {
 &amp;nbsp; &amp;nbsp;name: string;
 &amp;nbsp; &amp;nbsp;age: number;
 &amp;nbsp; &amp;nbsp;location: string;
}

type LazyPerson = Getters&amp;lt;Person&amp;gt;;
// {
// &amp;nbsp; getName: () =&amp;gt; string;
// &amp;nbsp; getAge: () =&amp;gt; number;
// &amp;nbsp; getLocation: () =&amp;gt; string;
// }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc4109e65fb4c96ac64975f9884f2c9~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在以上代码中，因为 keyof T 返回的类型可能会包含 symbol 类型，而 Capitalize 工具类型要求处理的类型需要是 string 类型的子类型，所以需要通过交叉运算符进行类型过滤。&lt;/p&gt;
&lt;p&gt;此外，在对键进行重新映射的过程中，我们可以通过返回 never 类型对键进行过滤：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;// Remove the 'kind' property
type RemoveKindField&amp;lt;T&amp;gt; = {
 &amp;nbsp;  [K in keyof T as Exclude&amp;lt;K, "kind"&amp;gt;]: T[K]
};

interface Circle {
 &amp;nbsp; &amp;nbsp;kind: "circle";
 &amp;nbsp; &amp;nbsp;radius: number;
}

type KindlessCircle = RemoveKindField&amp;lt;Circle&amp;gt;;
// &amp;nbsp; type KindlessCircle = {
// &amp;nbsp; &amp;nbsp; &amp;nbsp; radius: number;
// &amp;nbsp; };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8018d739e8a4521b5121d1b7a5a9cea~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;看完本文之后，相信你已经了解映射类型的作用了，也知道 TS 内部一些工具类型是如何实现的。你喜欢以这种形式学 TS 么？喜欢的话，记得点赞与收藏。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c424563ccc6941f7b7c43771e36fe5c0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk"&gt;TypeScript 泛型中的 K、T、V 等到底是个啥？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://space.bilibili.com/406258607"&gt;轻松学 TypeScript&lt;/a&gt; 视频教程已更新了 7 集，本专题将会以形象生动的动画，带你一起学习 TypeScript 核心知识点，感兴趣的小伙伴一起学起来呀！&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Sat, 23 Apr 2022 15:26:03 GMT</pubDate></item><item><title>【动画演示】TypeScript 泛型中的 K、T、V 等到底是个啥？</title><link>https://juejin.cn/post/7084410879223005215</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.bilibili.com/video/BV1sY4y1H7vk/"&gt;不想看文字，那就直接来看视频吧&lt;/a&gt;&lt;/strong&gt;：https://www.bilibili.com/video/BV1sY4y1H7vk/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你首次看到 TypeScript 泛型中的 &lt;strong&gt;T&lt;/strong&gt; 会感到陌生么？&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-1.gif" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdb08f75963b4b53af2973cbc7a29123~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;图中的 T 被称为&lt;strong&gt;泛型变量&lt;/strong&gt;，它是我们希望传递给 identity 函数的&lt;strong&gt;类型占位符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就像传递参数一样，我们把用户指定的实际类型，链式传递给参数类型和返回值类型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-2.gif" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1040d61451f4b89b7a18a9267386fee~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;那么 T 是什么意思呢？图中的泛型变量 T 表示 Type，实际上 T 可以用任何有效的名称代替。除了 T 之外，常见的泛型变量还有 K、V 和 E 等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K 全称 &lt;strong&gt;Key&lt;/strong&gt; 表示对象中键的类型；&lt;/li&gt;
&lt;li&gt;V 全称 &lt;strong&gt;Value&lt;/strong&gt; 表示对象中值的类型；&lt;/li&gt;
&lt;li&gt;E 全称 &lt;strong&gt;Element&lt;/strong&gt; 表示元素类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="泛型变量-3.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/674dbfa8db5144b3ab94df084a2519e8~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;当然你并不是只能定义一个类型变量，你可以引入任何数量的类型变量。这里我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数。&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-4.gif" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dec767a1a264da18b105830d8068714~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;在调用 identity 函数时，我们可以显式指定泛型变量的实际类型。
当然你也可以不指定泛型变量的类型，让 TypeScript 自动帮我们完成类型推断。&lt;/p&gt;
&lt;p&gt;&lt;img alt="泛型变量-5.gif" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05c1a7120f49447f9d90966ae256b469~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;看完以上动画，你是不是已经理解泛型变量了？如果看懂的话，欢迎在评论区留言。看完觉得意犹未尽，那你可以继续阅读阿宝哥之前写的 &lt;a href="https://mp.weixin.qq.com/s/jF0ZEGM9BRQgyKPZ9W9MpA"&gt;你不知道的 TypeScript 泛型&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;p&gt;最后你喜欢以这种形式学 &lt;strong&gt;TS&lt;/strong&gt; 么？喜欢的话，记得点赞与收藏哟。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Fri, 08 Apr 2022 17:32:45 GMT</pubDate></item><item><title>又一个基于 Esbuild 的神器！</title><link>https://juejin.cn/post/7065465955987488776</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 并不支持直接执行 TS 文件，如果要执行 TS 文件的话，我们就可以借助 &lt;a href="https://github.com/TypeStrong/ts-node"&gt;ts-node&lt;/a&gt; 这个库。相信有些小伙伴在工作中也用过这个库，关于 &lt;a href="https://github.com/TypeStrong/ts-node"&gt;ts-node&lt;/a&gt; 这个库的相关内容我就不展开介绍了，因为本文的主角是由 &lt;strong&gt;antfu&lt;/strong&gt; 大佬开源的 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 项目，接下来我将带大家一起来揭开这个项目背后的秘密。&lt;/p&gt;
&lt;p&gt;阅读完本文后，你将了解 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 项目是如何执行 TS 文件。此外，你还会了解如何劫持 Node.js 的 require 函数、如何为 ES Module 的 import 语句添加钩子及如何自定义 https 加载器，以支持 &lt;code&gt;import React from "https://esm.sh/react"&lt;/code&gt; 导入方式。&lt;/p&gt;
&lt;h3&gt;esno 是什么&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 是基于 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 的 TS/ESNext node 运行时。该库会针对不同的模块化标准，采用不同的方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;esno&lt;/code&gt; - Node in CJS mode - by &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;esmo&lt;/code&gt; - Node in ESM mode - by &lt;a href="https://github.com/antfu/esbuild-node-loader"&gt;esbuild-node-loader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 的方式很简单，你可以以全局或局部的方式来安装它：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局安装&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ npm i -g esno
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在安装成功后，你就可以通过以下方式来直接执行 TS 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ esno index.ts
$ esmo index.ts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;局部安装&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ npm i esno
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而对于局部安装的方式来说，一般情况下，我们会以 &lt;strong&gt;npm scripts&lt;/strong&gt; 的方式来使用它：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  "scripts": {
    "start": "esno index.ts"
  },
  "dependencies": {
    "esno": "0.14.0"
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;esno 是如何工作的&lt;/h3&gt;
&lt;p&gt;在开始分析 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 的工作原理之前，我们先来熟悉一下该项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;├── LICENSE
├── README.md
├── esmo.mjs
├── esno.js
├── package.json
├── pnpm-lock.yaml
├── publish.ts
└── tsconfig.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上的项目结构可知，该项目并不会复杂。在项目根目录下的 &lt;strong&gt;package.json&lt;/strong&gt; 文件中，我们看到了前面介绍的 &lt;strong&gt;esno&lt;/strong&gt; 和 &lt;strong&gt;esmo&lt;/strong&gt; 命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  "bin": {
    "esno": "esno.js",
    "esmo": "esmo.mjs"
  },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，在 &lt;strong&gt;package.json&lt;/strong&gt; 的 &lt;strong&gt;scripts&lt;/strong&gt; 字段中，我们发现了 &lt;strong&gt;release&lt;/strong&gt; 命令。顾名思义，该命令用来发布版本。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  "scripts": {
    "release": "npx bumpp --tag --commit --push &amp;amp;&amp;amp; node esmo.mjs publish.ts"
  },
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，在 &lt;code&gt;publish.ts&lt;/code&gt; 文件中，使用到了 2021 年度 Github 上最耀眼的项目 &lt;a href="https://github.com/google/zx"&gt;zx&lt;/a&gt;，利用该项目我们可以轻松地编写命令行脚本。写作本文时，它的 Star 数已经高达 &lt;strong&gt;27.5K&lt;/strong&gt;，强烈推荐感兴趣的小伙伴关注一下该项目。&lt;/p&gt;
&lt;p&gt;简单介绍了 &lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 项目之后，接下来我们来分析 &lt;code&gt;esno.js&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;#!/usr/bin/env node

const spawn = require('cross-spawn')
const spawnSync = spawn.sync

const register = require.resolve('esbuild-register')

const argv = process.argv.slice(2)

process.exit(spawnSync('node', ['-r', register, ...argv], 
  { stdio: 'inherit' }).status)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上代码可知，当执行 &lt;code&gt;esno index.ts&lt;/code&gt; 命令后，会通过 &lt;code&gt;spawnSync&lt;/code&gt; 来启动 &lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 程序执行脚本。需要注意的是，在执行时使用了 &lt;code&gt;-r&lt;/code&gt; 选项，该选项的作用是预加载模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; -r, --require = ... module to preload (option can be repeated)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里预加载的模块是 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt;，该模块就是 &lt;strong&gt;esno&lt;/strong&gt; 命令执行 TS 文件的幕后英雄。&lt;/p&gt;
&lt;h3&gt;esbuild-register 是什么&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 是一个基于 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 来转换 JSX、TS 和 esnext 特性的工具。你可以通过以下多种方式来安装它：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ npm i esbuild esbuild-register -D
# Or Yarn
$ yarn add esbuild esbuild-register --dev
# Or pnpm
$ pnpm add esbuild esbuild-register -D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在成功安装该模块之后，就可以在命令行中，直接通过 &lt;code&gt;node&lt;/code&gt; 应用程序来执行 ts 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node -r esbuild-register file.ts
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;-r, --require  =  ... module to preload (option can be repeated)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-r&lt;/code&gt; 用于指定预加载的文件，即在执行 &lt;code&gt;file.ts&lt;/code&gt; 文件前，提前加载 &lt;code&gt;esbuild-register&lt;/code&gt; 模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它将会使用 &lt;code&gt;tsconfig.json&lt;/code&gt; 中的 &lt;code&gt;jsxFactory&lt;/code&gt;, &lt;code&gt;jsxFragmentFactory&lt;/code&gt; 和 &lt;code&gt;target&lt;/code&gt; 配置项来执行转换操作。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 不仅可以在命令行中使用，而且还可以通过 API 的方式进行使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;const { register } = require('esbuild-register/dist/node')

const { unregister } = register({
  // ...options
})

// Unregister the require hook if you don't need it anymore
unregister()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;了解完 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 的基本使用之后，接下来我们来分析它内部是如何工作的。&lt;/p&gt;
&lt;h3&gt;esbuild-register 是如何工作的&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 内部利用了 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库来劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数，从而让你可以在命令行中，直接执行 &lt;code&gt;ts&lt;/code&gt; 文件。下面我们来看一下 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 模块中定义的 &lt;code&gt;register&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;// esbuild-register/src/node.ts
import { transformSync, TransformOptions } from 'esbuild'
import { addHook } from 'pirates'

export function register(esbuildOptions: RegisterOptions = {}) {
  const {
    extensions = DEFAULT_EXTENSIONS,
    hookIgnoreNodeModules = true,
    hookMatcher,
    ...overrides
  } = esbuildOptions

  // 利用 transformSync 
  const compile: COMPILE = function compile(code, filename, format) {
    const dir = dirname(filename)
    const options = getOptions(dir)
    format = format ?? inferPackageFormat(dir, filename)

    const {
      code: js,
      warnings,
      map: jsSourceMap,
    } = transformSync(code, {
      sourcefile: filename,
      sourcemap: 'both',
      loader: getLoader(filename),
      target: options.target,
      jsxFactory: options.jsxFactory,
      jsxFragment: options.jsxFragment,
      format,
      ...overrides,
    })
// 省略部分代码
  }

  const revert = addHook(compile, {
    exts: extensions,
    ignoreNodeModules: hookIgnoreNodeModules,
    matcher: hookMatcher,
  })

  return {
    unregister() {
      revert()
    },
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上的代码可知，在 &lt;code&gt;register&lt;/code&gt; 函数内部是利用 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 模块提供的 &lt;code&gt;transformSync&lt;/code&gt; API 来实现 &lt;strong&gt;ts -&amp;gt; js&lt;/strong&gt; 代码的转换。其实最关键的环节，还是通过调用 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库提供的 &lt;code&gt;addHook&lt;/code&gt; 函数来注册编译 ts 文件的钩子。
那么 &lt;code&gt;addHook&lt;/code&gt; 函数内部到底做了哪些处理呢？下面我们来看一下它的实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// pirates-4.0.5/src/index.js
export function addHook(hook, opts = {}) {
  let reverted = false;
  const loaders = []; // 存放新的loader
  const oldLoaders = []; // 存放旧的loader
  let exts;

  const originalJSLoader = Module._extensions['.js']; // 原始的JS Loader 
  // 省略部分代码
  exts.forEach((ext) =&amp;gt; {
    // 获取已注册的loader，若未找到，则默认使用JS Loader
    const oldLoader = Module._extensions[ext] || originalJSLoader;
    oldLoaders[ext] = Module._extensions[ext];

    loaders[ext] = Module._extensions[ext] = function newLoader(
  mod, filename) {
      let compile;
      if (!reverted) {
        if (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {
          compile = mod._compile;
          mod._compile = function _compile(code) {
// 这里需要恢复成原来的_compile函数，否则会出现死循环
            mod._compile = compile;
// 在编译前先执行用户自定义的hook函数
            const newCode = hook(code, filename);
            if (typeof newCode !== 'string') {
              throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);
            }

            return mod._compile(newCode, filename);
          };
        }
      }

       oldLoader(mod, filename);
     };
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实 &lt;code&gt;addHook&lt;/code&gt; 函数的实现并不会复杂，该函数内部就是通过替换 &lt;code&gt;mod._compile&lt;/code&gt; 方法来实现钩子的功能。即在调用原始的 &lt;code&gt;mod._compile&lt;/code&gt; 方法进行编译前，会先调用 &lt;code&gt;hook(code, filename)&lt;/code&gt; 函数来执行用户自定义的 &lt;code&gt;hook&lt;/code&gt; 函数，从而对代码进行预处理。&lt;/p&gt;
&lt;p&gt;而对于 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 库中的 &lt;code&gt;register&lt;/code&gt; 函数来说，当 &lt;code&gt;hook&lt;/code&gt; 函数执行时，就会调用该函数内部定义的 &lt;code&gt;compile&lt;/code&gt; 函数来编译 ts 代码，然后再调用 &lt;code&gt;mod._compile&lt;/code&gt; 方法编译生成的 &lt;code&gt;js&lt;/code&gt; 代码。&lt;/p&gt;
&lt;p&gt;关于 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 和 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这两个库的内容就先介绍到这里，如果你想详细了解 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库是如何工作的，可以阅读 &lt;a href="https://mp.weixin.qq.com/s/BFu4SouMdXFYLELRjHhUyg"&gt;如何为 Node.js 的 require 函数添加钩子？&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;p&gt;现在我们已经分析完 &lt;code&gt;esno.js&lt;/code&gt; 文件，接下来我们来分析 &lt;code&gt;esmo.mjs&lt;/code&gt; 文件。&lt;/p&gt;
&lt;h3&gt;esmo 是如何工作的&lt;/h3&gt;
&lt;p&gt;esmo 命令对应的是 esmo.mjs 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;#!/usr/bin/env node

import spawn from 'cross-spawn'
import { resolve } from 'import-meta-resolve'
const spawnSync = spawn.sync

const argv = process.argv.slice(2)
resolve('esbuild-node-loader', import.meta.url).then((path) =&amp;gt; {
  process.exit(spawnSync('node', ['--loader', path, ...argv], 
{ stdio: 'inherit' }).status)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由以上代码可知，当使用 node 应用程序执行 ES Module 文件时，会通过 &lt;code&gt;--loader&lt;/code&gt; 选项来指定自定义的 ES Module 加载器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; --loader, --experimental-loader = ... use the specified module as a custom loader
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，通过 &lt;code&gt;--loader&lt;/code&gt; 选项指定的自定义加载器只适用于 ES Module 的 import 调用，并不适用于 CommonJS 的 require 调用。&lt;/p&gt;
&lt;p&gt;那么自定义加载器有什么作用呢？在当前最新的 Node.js v17.4.0 版本中，还不支持以 &lt;code&gt;https://&lt;/code&gt; 开头的说明符。我们可以在自定义加载器中，利用 Node.js 提供的钩子机制，让 Node.js 可以使用 &lt;code&gt;import&lt;/code&gt; 导入以 &lt;code&gt;https://&lt;/code&gt; 协议开头的 ES 模块。&lt;/p&gt;
&lt;p&gt;在分析如何自定义 &lt;code&gt;https&lt;/code&gt; 资源加载器前，我们需要先介绍一下 import 说明符的概念。&lt;/p&gt;
&lt;h4&gt;import 说明符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 语句的说明符是 &lt;code&gt;from&lt;/code&gt; 关键字之后的字符串，例如 &lt;code&gt;import { sep } from 'path'&lt;/code&gt; 中的 &lt;code&gt;'path'&lt;/code&gt;。 说明符也用于 &lt;code&gt;export from&lt;/code&gt; 语句，并作为 &lt;code&gt;import()&lt;/code&gt; 表达式的参数。&lt;/p&gt;
&lt;p&gt;有三种类型的说明符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相对说明符，如 &lt;code&gt;'./startup.js'&lt;/code&gt; 或 &lt;code&gt;'../config.mjs'&lt;/code&gt;。它们指的是相对于导入文件位置的路径。对于这种类型，文件扩展名是必须的。&lt;/li&gt;
&lt;li&gt;裸说明符，如 &lt;code&gt;'some-package'&lt;/code&gt; 或 &lt;code&gt;'some-package/shuffle'&lt;/code&gt;。它们可以通过包名来引用包的主入口点。当包没有 &lt;code&gt;exports&lt;/code&gt; 字段的时候，才需要包含文件扩展名。&lt;/li&gt;
&lt;li&gt;绝对说明符，如 &lt;code&gt;file:///opt/nodejs/config.js&lt;/code&gt;。它们直接且明确地引用完整路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;裸说明符解析由 &lt;a href="https://nodejs.org/api/esm.html#resolver-algorithm-specification"&gt;Node.js 模块解析算法&lt;/a&gt;处理，所有其他说明符解析始终仅使用标准的相对&lt;a href="https://url.spec.whatwg.org/"&gt;URL&lt;/a&gt; 解析语义进行解析。&lt;/p&gt;
&lt;p&gt;和 CommonJS 一样，包内的模块文件可以通过在包名上添加路径来访问，除非包的 package.json 包含一个 "exports " 字段，在这种情况下，包中的文件只能通过 "exports " 中定义的路径访问。&lt;/p&gt;
&lt;p&gt;介绍完 import 说明符之后，接下来我们来看一下如何自定义 https 加载器。&lt;/p&gt;
&lt;h4&gt;自定义 https 加载器&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;resolve 钩子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resolve&lt;/code&gt; 钩子用于根据模块的说明符和 &lt;code&gt;parentURL&lt;/code&gt; 生成导入目标的绝对路径，调用该钩子后会返回一个包含 &lt;code&gt;format&lt;/code&gt;（可选） 和 &lt;code&gt;url&lt;/code&gt; 属性的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// https-loader.mjs
import { get } from 'https';

export function resolve(specifier, context, defaultResolve) {
  const { parentURL = null } = context;

  if (specifier.startsWith('https://')) {
    return {
      url: specifier
    };
  } else if (parentURL &amp;amp;&amp;amp; parentURL.startsWith('https://')) {
    return {
      url: new URL(specifier, parentURL).href
    };
  }

  // 让 Node.js 处理其它的说明符
  return defaultResolve(specifier, context, defaultResolve);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，会先判断 &lt;code&gt;specifier&lt;/code&gt; 字符串是否以 &lt;code&gt;'https://'&lt;/code&gt; 开头，如果条件满足的话，该字符串的值直接作为 &lt;code&gt;url&lt;/code&gt; 属性的值，直接返回 &lt;code&gt;{ url: specifier }&lt;/code&gt; 对象。否则，会判断 &lt;code&gt;parentURL&lt;/code&gt; 是否以 &lt;code&gt;'https://'&lt;/code&gt; 开头，如果条件满足的话，则会调用 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/URL"&gt;URL&lt;/a&gt; 构造函数，创建 URL 对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;parentURL&lt;/code&gt; 是从 &lt;code&gt;context&lt;/code&gt; 对象上获取的，那它什么时候会有值呢？假设在 ES 模块 A 中，以相对路径的形式导入 ES 模块 B。在导入 ES 模块 B 时，也会调用 &lt;code&gt;resolve&lt;/code&gt; 钩子，此时 &lt;code&gt;context&lt;/code&gt; 对象上的 &lt;code&gt;parentURL&lt;/code&gt; 就会有值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;load 钩子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;load&lt;/code&gt; 钩子用于定义应该如何解释、检索和解析 URL 的方法，调用该方法后，会返回包含 &lt;code&gt;format&lt;/code&gt; 和 &lt;code&gt;source&lt;/code&gt; 属性的对象。其中 &lt;code&gt;format&lt;/code&gt; 属性值只能是 &lt;code&gt;'builtin'&lt;/code&gt;、&lt;code&gt;'commonjs'&lt;/code&gt;、&lt;code&gt;'json'&lt;/code&gt;、&lt;code&gt;'module'&lt;/code&gt; 和 &lt;code&gt;'wasm'&lt;/code&gt; 中的一种。而 &lt;code&gt;source&lt;/code&gt; 属性值的类型可以为 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;ArrayBuffer&lt;/code&gt; 或 &lt;code&gt;TypedArray&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;import { get } from 'https';

export function load(url, context, defaultLoad) {
  if (url.startsWith('https://')) {
    return new Promise((resolve, reject) =&amp;gt; {
      get(url, (res) =&amp;gt; {
        let data = '';
        res.on('data', (chunk) =&amp;gt; data += chunk);
        res.on('end', () =&amp;gt; resolve({
          format: 'module',
          source: data,
        }));
      }).on('error', (err) =&amp;gt; reject(err));
    });
  }

  // 让 Node.js 加载其它类型的文件
  return defaultLoad(url, context, defaultLoad);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，会通过 &lt;code&gt;https&lt;/code&gt; 模块中的 &lt;code&gt;get&lt;/code&gt; 函数来加载 &lt;code&gt;https://&lt;/code&gt; 协议的 ES 模块。如果不是以 &lt;code&gt;'https://'&lt;/code&gt; 开头，则会使用默认的加载器来加载其它类型的文件。&lt;/p&gt;
&lt;p&gt;创建完 &lt;code&gt;https-loader&lt;/code&gt; 之后，我们来测试一下该加载器。首先创建一个 &lt;code&gt;main.mjs&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// main.mjs
import React from "https://esm.sh/react@17.0.2"

console.dir(React);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在命令行输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node --experimental-loader ./https-loader.mjs ./main.mjs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  Fragment: Symbol(react.fragment),
  StrictMode: Symbol(react.strict_mode),
  Profiler: Symbol(react.profiler),
  Suspense: Symbol(react.suspense),
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;了解完以上的内容后，我们回过头来看一下 &lt;code&gt;esmo.mjs&lt;/code&gt; 文件中所使用的 &lt;a href="https://github.com/antfu/esbuild-node-loader"&gt;esbuild-node-loader&lt;/a&gt; 模块。下面我们来简单分析一下 &lt;code&gt;load&lt;/code&gt; 钩子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// loader.mjs（esbuild-node-loader v0.6.4）
export function load(url, context, defaultLoad) {
  if (extensionsRegex.test(new URL(url).pathname)) {
    const { format } = context;

    let filename = url;
    if (!isWindows) filename = fileURLToPath(url);

    const rawSource = fs.readFileSync(new URL(url), { encoding: "utf8" });
    const { js } = esbuildTransformSync(rawSource, filename, url, format);

    return {
      format: "module",
      source: js,
    };
  }

  // Let Node.js handle all other format / sources.
  return defaultLoad(url, context, defaultLoad);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过观察以上代码，我们可知 &lt;code&gt;load&lt;/code&gt; 钩子的核心处理流程，可以分为两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：使用 &lt;code&gt;fs.readFileSync&lt;/code&gt; 方法读取文件资源的内容；&lt;/li&gt;
&lt;li&gt;步骤二：使用 &lt;code&gt;esbuildTransformSync&lt;/code&gt; 函数对源代码进行转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在 &lt;code&gt;esbuildTransformSync&lt;/code&gt; 函数中，使用了 &lt;code&gt;esbuild&lt;/code&gt; 模块提供的 &lt;code&gt;transformSync&lt;/code&gt; 函数来实现代码的转换。该函数的相关代码如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// loader.mjs（esbuild-node-loader v0.6.4）
function esbuildTransformSync(rawSource, filename, url, format) {
  const {
    code: js,
    warnings,
    map: jsSourceMap,
  } = transformSync(rawSource.toString(), {
    sourcefile: filename,
    sourcemap: "both",
    loader: new URL(url).pathname.match(extensionsRegex)[1],
    target: `node${process.versions.node}`, 
    format: format === "module" ? "esm" : "cjs",
  });

  // 省略部分代码
  return { js, jsSourceMap };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于 &lt;code&gt;transformSync&lt;/code&gt; 函数的使用方式，我就不展开介绍了。感兴趣的小伙伴可以自行阅读一下 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 官网上的相关文档。&lt;/p&gt;
&lt;p&gt;好的，&lt;a href="https://github.com/antfu/esno"&gt;esno&lt;/a&gt; 这个项目就介绍到这里。如果你对 Node.js 平台下的 &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; hook 机制感兴趣的话，可以详细阅读一下 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt;、&lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 和 &lt;a href="https://github.com/antfu/esbuild-node-loader"&gt;esbuild-node-loader&lt;/a&gt; 这几个项目的源码。若有遇到问题的话，欢迎跟阿宝哥交流哟。&lt;/p&gt;
&lt;h3&gt;参考资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://esbuild.github.io/"&gt;esbuild 官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://nodejs.org/api/esm.html#loaders"&gt;Node.js 官网 - ESM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/BFu4SouMdXFYLELRjHhUyg"&gt;如何为 Node.js 的 require 函数添加钩子？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><author>阿宝哥</author><pubDate>Wed, 16 Feb 2022 16:22:34 GMT</pubDate></item><item><title>如何为 Node.js 的 require 函数添加钩子？</title><link>https://juejin.cn/post/7062536831664914463</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 是一个基于 &lt;a href="https://v8.dev/"&gt;Chrome V8 引擎&lt;/a&gt;的 JavaScript 运行时环境。早期的 Node.js 采用的是 CommonJS 模块规范，从 &lt;a href="https://nodejs.org/de/blog/release/v13.2.0/"&gt;Node v13.2.0&lt;/a&gt; 版本开始正式支持 ES Modules 特性。直到 v15.3.0 版本 ES Modules 特性才稳定下来并与 NPM 生态相兼容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="nodejs-esm-history.jpg" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b651f355770d4f1db87a30cc6d0c3289~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;（图片来源：https://nodejs.org/api/esm.html）&lt;/p&gt;
&lt;p&gt;本文将介绍 Node.js 中 &lt;code&gt;require&lt;/code&gt; 函数的工作流程、如何让 Node.js 直接执行 ts 文件及如何正确地劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数，从而实现钩子的功能。接下来，我们先来介绍 &lt;code&gt;require&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h3&gt;require 函数&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 应用由模块组成，每个文件就是一个模块。对于 CommonJS 模块规范来说，我们通过 &lt;code&gt;require&lt;/code&gt; 函数来导入模块。那么当我们使用 &lt;code&gt;require&lt;/code&gt; 函数来导入模块的时候，该函数内部发生了什么？这里我们通过调用堆栈来了解一下 &lt;code&gt;require&lt;/code&gt; 的过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="how-node-require-work.jpg" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ac592857e6842ef83f94570238d09e0~tplv-k3u1fbpfcp-watermark.image" /&gt;&lt;/p&gt;
&lt;p&gt;由上图可知，在使用 &lt;code&gt;require&lt;/code&gt; 导入模块时，会调用 &lt;code&gt;Module&lt;/code&gt; 对象的 &lt;code&gt;load&lt;/code&gt; 方法来加载模块，该方法的实现如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module.prototype.load = function(filename) {
  this.filename = filename;
  this.paths = Module._nodeModulePaths(path.dirname(filename));

  const extension = findLongestRegisteredExtension(filename);

  Module._extensions[extension](this, filename);
  this.loaded = true;
  // 省略部分代码
};
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：本文所引用 Node.js 源码所对应的版本是 &lt;strong&gt;v16.13.1&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在以上代码中，重要的两个步骤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：根据文件名找出扩展名；&lt;/li&gt;
&lt;li&gt;步骤二：通过解析后的扩展名，在 &lt;code&gt;Module._extensions&lt;/code&gt; 对象中查找匹配的加载器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &lt;a href="https://nodejs.org/zh-cn/"&gt;Node.js&lt;/a&gt; 中内置了 3 种不同的加载器，用于加载 &lt;code&gt;node&lt;/code&gt;、&lt;code&gt;json&lt;/code&gt; 和 &lt;code&gt;js&lt;/code&gt; 文件。
&lt;strong&gt;node 文件加载器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module._extensions['.node'] = function(module, filename) {
  return process.dlopen(module, path.toNamespacedPath(filename));
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;json 文件加载器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module._extensions['.json'] = function(module, filename) {
 const content = fs.readFileSync(filename, 'utf8');
 try {
    module.exports = JSONParse(stripBOM(content));
 } catch (err) {
   err.message = filename + ': ' + err.message;
   throw err;
 }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;js 文件加载器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module._extensions['.js'] = function(module, filename) {
  // If already analyzed the source, then it will be cached.
  const cached = cjsParseCache.get(module);
  let content;
  if (cached?.source) {
    content = cached.source;
    cached.source = undefined;
  } else {
    content = fs.readFileSync(filename, 'utf8');
  }
  // 省略部分代码
  module._compile(content, filename);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们来分析比较重要的 &lt;strong&gt;js 文件加载器&lt;/strong&gt;。通过观察以上代码，我们可知 &lt;code&gt;js&lt;/code&gt; 加载器的核心处理流程，也可以分为两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤一：使用 &lt;code&gt;fs.readFileSync&lt;/code&gt; 方法加载 &lt;code&gt;js&lt;/code&gt; 文件的内容；&lt;/li&gt;
&lt;li&gt;步骤二：使用 &lt;code&gt;module._compile&lt;/code&gt; 方法编译已加载的 &lt;code&gt;js&lt;/code&gt; 代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么了解以上的知识之后，对我们有什么用处呢？其实在了解 &lt;code&gt;require&lt;/code&gt; 函数的工作流程之后，我们就可以扩展 Node.js 的加载器。比如让 Node.js 能够运行 &lt;code&gt;ts&lt;/code&gt; 文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// register.js
const fs = require("fs");
const Module = require("module");
const { transformSync } = require("esbuild");

Module._extensions[".ts"] = function (module, filename) {
  const content = fs.readFileSync(filename, "utf8");
  const { code } = transformSync(content, {
    sourcefile: filename,
    sourcemap: "both",
    loader: "ts",
    format: "cjs",
  });
  module._compile(code, filename);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，我们引入了内置的 &lt;code&gt;module&lt;/code&gt; 模块，然后利用该模块的 &lt;code&gt;_extensions&lt;/code&gt; 对象来注册我们的自定义 ts 加载器。&lt;/p&gt;
&lt;p&gt;其实，加载器的本质就是一个函数，在该函数内部我们利用 &lt;a href="https://esbuild.github.io/"&gt;esbuild&lt;/a&gt; 模块提供的 &lt;code&gt;transformSync&lt;/code&gt; API 来实现 &lt;strong&gt;ts -&amp;gt; js&lt;/strong&gt; 代码的转换。当完成代码转换之后，会调用 &lt;code&gt;module._compile&lt;/code&gt; 方法对代码进行编译操作。&lt;/p&gt;
&lt;p&gt;看到这里相信有的小伙伴，也想到了 Webpack 中对应的 loader，想深入学习的话，可以阅读 &lt;a href="https://mp.weixin.qq.com/s/2v1uhw2j7yKsb1U5KE2qJA"&gt;多图详解，一次性搞懂Webpack Loader&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;p&gt;篇幅有限，具体的编译过程，我们就不展开介绍了。下面我们来看一下如何让自定义的 ts 加载器生效。要让 Node.js 能够执行 ts 代码，我们就需要在执行 ts 代码前，先完成自定义 ts 加载器的注册操作。庆幸的是，Node.js 为我们提供了模块的预加载机制：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt; $ node --help | grep preload
   -r, --require=... module to preload (option can be repeated)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即利用 &lt;code&gt;-r, --require&lt;/code&gt; 命令行配置项，我们就可以预加载指定的模块。了解完相关知识之后，我们来测试一下自定义 ts 加载器。首先创建一个 &lt;code&gt;index.ts&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ts"&gt;// index.ts
const add = (a: number, b: number) =&amp;gt; a + b;

console.log("add(a, b) = ", add(3, 5));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在命令行输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node -r ./register.js index.ts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;add(a, b) =  8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很明显我们自定义的 ts 文件加载器生效了，这种扩展机制还是值得我们学习的。另外，需要注意的是在 &lt;code&gt;load&lt;/code&gt; 方法中，&lt;code&gt;findLongestRegisteredExtension&lt;/code&gt; 函数会判断文件的扩展名是否已经注册在 &lt;code&gt;Module._extensions&lt;/code&gt; 对象中，若未注册的话，默认会返回 &lt;code&gt;.js&lt;/code&gt; 字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// lib/internal/modules/cjs/loader.js
Module.prototype.load = function(filename) {
  this.filename = filename;
  this.paths = Module._nodeModulePaths(path.dirname(filename));

  const extension = findLongestRegisteredExtension(filename);

  Module._extensions[extension](this, filename);
  this.loaded = true;
  // 省略部分代码
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就意味着只要文件中包含有效的 &lt;code&gt;js&lt;/code&gt; 代码，&lt;code&gt;require&lt;/code&gt; 函数就能正常加载它。比如下面的 &lt;strong&gt;a.txt&lt;/strong&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;  module.exports = "hello world";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到这里相信你已经了解 &lt;code&gt;require&lt;/code&gt; 函数是如何加载模块及如何自定义 Node.js 文件加载器。那么，让 Node.js 支持加载 &lt;code&gt;ts&lt;/code&gt;、&lt;code&gt;png&lt;/code&gt; 或 &lt;code&gt;css&lt;/code&gt; 等其它类型的文件，有更优雅、更简单的方案么？答案是有的，我们可以使用 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个第三方库。&lt;/p&gt;
&lt;h3&gt;pirates 是什么&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库让我们可以正确地劫持 Node.js 的 &lt;code&gt;require&lt;/code&gt; 函数。利用这个库，我们就可以很容易扩展 Node.js 加载器的功能。&lt;/p&gt;
&lt;h4&gt;pirates 的用法&lt;/h4&gt;
&lt;p&gt;你可以使用 npm 来安装 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;npm install --save pirates
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在成功安装 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库之后，就可以利用该模块导出提供的 &lt;code&gt;addHook&lt;/code&gt; 函数来添加钩子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// register.js
const addHook = require("pirates").addHook;

const revert = addHook(
  (code, filename) =&amp;gt; code.replace("@@foo", "console.log('foo');"),
  { exts: [".js"] }
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是调用 &lt;code&gt;addHook&lt;/code&gt; 之后会返回一个 &lt;code&gt;revert&lt;/code&gt; 函数，用于取消对 &lt;code&gt;require&lt;/code&gt; 函数的劫持操作。下面我们来验证一下 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 这个库是否能正常工作，首先新建一个 &lt;code&gt;index.js&lt;/code&gt; 文件并输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// index.js
console.log("@@foo")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在命令行输入以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;$ node -r ./register.js index.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当以上命令成功运行之后，控制台会输出以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;console.log('foo');
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上结果可知，我们通过 &lt;code&gt;addHook&lt;/code&gt; 函数添加的钩子生效了。是不是觉得挺神奇的，接下来我们来分析一下 pirates 的工作原理。&lt;/p&gt;
&lt;h3&gt;pirates 是如何工作的&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 底层是利用 Node.js 内置 &lt;code&gt;module&lt;/code&gt; 模块提供的扩展机制来实现 &lt;code&gt;Hook&lt;/code&gt; 功能。前面我们已经介绍过了，当使用 &lt;code&gt;require&lt;/code&gt; 函数来加载模块时，Node.js 会根据文件的后缀名来匹配对应的加载器。
其实 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 的源码并不会复杂，我们来重点分析 &lt;code&gt;addHook&lt;/code&gt; 函数的核心处理逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;// src/index.js
export function addHook(hook, opts = {}) {
  let reverted = false;
  const loaders = []; // 存放新的loader
  const oldLoaders = []; // 存放旧的loader
  let exts;

  const originalJSLoader = Module._extensions['.js']; // 原始的JS Loader 

  const matcher = opts.matcher || null;
  const ignoreNodeModules = opts.ignoreNodeModules !== false;
  exts = opts.extensions || opts.exts || opts.extension || opts.ext 
    || ['.js'];
  if (!Array.isArray(exts)) {
    exts = [exts];
  }
  exts.forEach((ext) { 
    // ... 
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了提高执行效率，&lt;code&gt;addHook&lt;/code&gt; 函数提供了 &lt;code&gt;matcher&lt;/code&gt; 和 &lt;code&gt;ignoreNodeModules&lt;/code&gt; 配置项来实现文件过滤操作。在获取到 &lt;code&gt;exts&lt;/code&gt; 扩展名列表之后，就会使用新的加载器来替换已有的加载器。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;exts.forEach((ext) =&amp;gt; {
    if (typeof ext !== 'string') {
      throw new TypeError(`Invalid Extension: ${ext}`);
    }
    // 获取已注册的loader，若未找到，则默认使用JS Loader
    const oldLoader = Module._extensions[ext] || originalJSLoader;
    oldLoaders[ext] = Module._extensions[ext];

    loaders[ext] = Module._extensions[ext] = function newLoader(
  mod, filename) {
      let compile;
      if (!reverted) {
        if (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {
          compile = mod._compile;
          mod._compile = function _compile(code) {
// 这里需要恢复成原来的_compile函数，否则会出现死循环
            mod._compile = compile;
// 在编译前先执行用户自定义的hook函数
            const newCode = hook(code, filename);
            if (typeof newCode !== 'string') {
              throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);
            }

            return mod._compile(newCode, filename);
          };
        }
      }

      oldLoader(mod, filename);
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察以上代码可知，在 &lt;code&gt;addHook&lt;/code&gt; 函数内部是通过替换 &lt;code&gt;mod._compile&lt;/code&gt; 方法来实现钩子的功能。即在调用原始的 &lt;code&gt;mod._compile&lt;/code&gt; 方法进行编译前，会先调用 &lt;code&gt;hook(code, filename)&lt;/code&gt; 函数来执行用户自定义的 &lt;code&gt;hook&lt;/code&gt; 函数，从而对代码进行处理。&lt;/p&gt;
&lt;p&gt;好的，至此本文的主要内容都介绍完了，在实际工作中，如果你想让 Node.js 直接执行 ts 文件，可以利用 &lt;a href="https://github.com/TypeStrong/ts-node"&gt;ts-node&lt;/a&gt; 或 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 这两个库。其中 &lt;a href="https://github.com/egoist/esbuild-register"&gt;esbuild-register&lt;/a&gt; 这个库内部就是使用了 &lt;a href="https://github.com/danez/pirates"&gt;pirates&lt;/a&gt; 提供的 Hook 机制来实现对应的功能。&lt;/p&gt;</description><author>阿宝哥</author><pubDate>Tue, 08 Feb 2022 18:50:17 GMT</pubDate></item><item><title>问卷还可以这样开发，效率提升 150%</title><link>https://juejin.cn/post/7028793777875582984</link><description>&lt;hr /&gt;
&lt;h2&gt;theme: awesome-green
highlight: a11y-light&lt;/h2&gt;
&lt;p&gt;工作了一天，终于到了最 “鸡冻” 的时刻，等待下班铃声的响起...&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f4aa77df01e4a9ea039dcf32a0d0b64~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;不过没过多久，就听到了那既熟悉而又抗拒的消息提示声。临近下班前的消息，感觉就不太妙。不过还是硬着头皮打开了公司运营妹纸发的消息 —— “宝哥，帮帮忙，明天下午我们有一个新版的 PC 知识库的推广活动，想在我们的知识库模块中添加一个问卷入口，收集一下用户的使用体验”。&lt;/p&gt;
&lt;p&gt;看完以上的消息之后，当时我的心情是这样的👇&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f0e08a748b34809a993b910d32c4eb7~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;本想装作没看见，奈何消息已变成已读。所以我只能强装镇定，给妹纸回了消息，让她把问卷要收集的信息发给我，过了一会儿妹纸把信息发了过来。看完后，发现表单并不会复杂，松了一口气。&lt;/p&gt;
&lt;p&gt;之后，立马让妹纸去协调一下服务端的资源。没想到妹纸却回我说：“宝哥，这个功能不会太复杂，以你的技术能力，应该一个人就可以搞定吧”。既然妹纸都这样说了，我只能委屈的说没问题。接着，跟妹纸大致沟通了需求，确认说表单的数据，可以不用提交到我们的系统。&lt;/p&gt;
&lt;p&gt;既然需求已经明确了，剩下的就是如何快速开发这个功能了。思考了一会儿，一个便捷的开发方案就涌现在脑海中。刚好之前有了解过在线的表单设计器和朋友公司的 Bass 产品 ——  &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 。我就想利用在线表单设计器来快速生成表单代码，然后利用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的服务来存储数据。大致方案已经有了，为了能早点下班，我立马行动起来。&lt;/p&gt;
&lt;h3&gt;一、拖拽生成表单&lt;/h3&gt;
&lt;p&gt;我司新版的 PC 知识库是基于 Vue 2 开发的，使用了 Element UI 组件库。经过一番搜索，我找到了 &lt;a href="https://github.com/JakHuang/form-generator"&gt;form-generator&lt;/a&gt; 这个开源项目。该项目是一款基于 Element UI 表单设计及代码生成器，目前 Github 上的 Star 数是 5.2K，是一个挺不错的开源项目。&lt;/p&gt;
&lt;p&gt;不得不说以拖拽的方式设计表单，使用起来还是很 “香” 的。一顿操作后，表单就生成了，具体效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee165d6f94e54e5380cdfa7a097298a9~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是，该在线工具还允许我们为表单的每个字段配置正则校验&lt;/strong&gt;。在完成表单设计之后，我通过点击 &lt;strong&gt;导出vue文件&lt;/strong&gt; 的按钮，就下载到对应的 Vue 文件。此时，问卷表单的功能已经完成一大半了，就差对接数据提交的功能。所以接下来我们将利用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的能力，来快速生成 API。&lt;/p&gt;
&lt;h3&gt;二、快速生成 API&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 为应用开发者提供高可用、自动弹性伸缩的后端云服务。前端通过统一的 SDK 和 API 连接后端服务（云数据库、云存储、云函数、用户管理、统计分析等），加速移动/Web/IoT/游戏等应用的开发，并降低运维成本。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d16e33d2fc47409a94f8c1c541dc3311~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;（图片来源：https://docs.memfiredb.com/）&lt;/p&gt;
&lt;p&gt;简单介绍了 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 的功能之后，下面我们来介绍如何使用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台快速生成 API。&lt;/p&gt;
&lt;h4&gt;2.1 创建数据库账号&lt;/h4&gt;
&lt;p&gt;首先要使用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台服务提供的服务，我们需要先注册一个账号。在账号注册成功后，我们就能登录 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台的管理后台。在创建表单应用前，我们需要先创建一个数据库账号，具体的操作方式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bf9d2aabc1c4a19bda4fd6fdf4cb8ff~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;2.2 创建表单应用&lt;/h4&gt;
&lt;p&gt;在创建完账号之后，我们就可以创建表单应用了。首先点击左侧 &lt;strong&gt;我的应用&lt;/strong&gt; 菜单，然后点击 &lt;strong&gt;创建应用&lt;/strong&gt; 按钮，在弹出的对话框中输入应用名称并选择前面新增的数据库账号，最后点击 &lt;strong&gt;创建按钮&lt;/strong&gt; 就会开始创建表单应用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47567b1cbb59430c9be881b553a2290a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h4&gt;2.3 新建数据表&lt;/h4&gt;
&lt;p&gt;在成功创建完表单应用之后，我们就可以新建问卷表了，用于保存表单的数据。首先点击刚新建的表单应用，进入表单应用编辑页面，然后点击左侧 &lt;strong&gt;数据表&lt;/strong&gt; 菜单，接着继续点击 &lt;strong&gt;新建数据表&lt;/strong&gt; 按钮，具体步骤如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea830eea1b84f68a41fa20937aadf0a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;在点击 &lt;strong&gt;新建数据表&lt;/strong&gt; 按钮后，在当前页面右侧会以 Drawer（抽屉）的形式，显示新建数据表的表单。接着我们根据已生成 Vue 表单文件中的字段来创建 &lt;strong&gt;feedbacks&lt;/strong&gt; 数据表的字段，具体的过程如以下动图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c3bcab9c7734af5b5216b0fb93ed07d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;以上动图只演示了添加 &lt;code&gt;name&lt;/code&gt; 字段的过程，通过 &lt;strong&gt;添加字段&lt;/strong&gt; 按钮，我们陆续添加了 &lt;strong&gt;mobile、post、score 和 suggestion&lt;/strong&gt; 等字段。最后每个字段的详细配置信息如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88da9001dfcf49df86dc640652c1e774~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：上图中的 &lt;code&gt;id&lt;/code&gt; 字段是默认生成的，它的值会不断自增。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过一番配置之后，我们问卷的 API 就已经创建好了，整体操作起来还是挺方便的。下面我们只要对接一下客户端 SDK 就可以提交表单数据了。&lt;/p&gt;
&lt;h3&gt;三、集成 JS 客户端 SDK&lt;/h3&gt;
&lt;p&gt;在集成 JS 客户端 SDK 的时候，可以通过 &lt;code&gt;npm&lt;/code&gt; 或 &lt;code&gt;CDN&lt;/code&gt; 的方式来安装 SDK。这里我们使用 &lt;code&gt;npm&lt;/code&gt; 的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;npm install @supabase/supabase-js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在成功安装了 &lt;code&gt;@supabase/supabase-js&lt;/code&gt; 模块之后，我们需要在表单页面中引入该模块，然后使用表单项目总览页面中的信息来创建 JS 客户端对象，需获取的 JS 客户端对象初始化信息如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9210fd811aeb4809a9f5b152d7783fba~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;在获取初始化信息之后，我们就可以创建  JS 客户端对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;import { createClient } from "@supabase/supabase-js";

const supabase = createClient(
  "https://c5s0hnq5g6heb3j9g3gg.baseapi.memfiredb.com", // baseURL
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYW" // 公开的密钥（仅截取部分内容）
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了 &lt;code&gt;supabase&lt;/code&gt; 客户端对象之后，我们就可以利用该对象提供的方法来提交表单数据了，具体的使用方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;// src/components/FeedbackForm.vue
export default {
  data() {
    return {
      // 省略其他属性
      submitting: false
    };
  },
  methods: {
    submitForm() {
      this.$refs["elForm"].validate(async (valid) =&amp;gt; {
        if (!valid || this.submitting) return;
        this.submitting = true; // 避免快速点击，重复提交数据
        const { error } = await supabase
          .from("feedbacks") // 数据表的表名
          .insert(this.formData);  
        const msg = error == null ? "感谢您的反馈!" : "服务器开小差，请稍后再试";
        alert(msg);
        if(!error) this.$refs["elForm"].resetFields(); // 复位表单
        this.submitting = false;
      });
    },
    resetForm() {
      this.$refs["elForm"].resetFields();
    },
  },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在以上代码中，&lt;code&gt;supabase.from&lt;/code&gt; 方法用于指定数据表的表名，而 &lt;code&gt;insert&lt;/code&gt; 方法用来插入新增的数据。需要注意的是，&lt;code&gt;insert&lt;/code&gt; 方法的参数也可以是数组，即可以批量插入多条数据。在插入数据时，也可以配置 &lt;code&gt; { upsert: true }&lt;/code&gt; 选项来执行 &lt;code&gt;upsert&lt;/code&gt; 操作。&lt;/p&gt;
&lt;p&gt;其实除了 &lt;code&gt;insert&lt;/code&gt; 方法之外，该 SDK 也为我们提供了 &lt;code&gt;select（获取数据）&lt;/code&gt;、&lt;code&gt;update（修改数据）&lt;/code&gt;、&lt;code&gt;delete（删除数据）&lt;/code&gt; 等方法。同时，也提供了强大的修改器（limit、order、range 等）和过滤器（filter、or、not、eq 等），感兴趣的小伙伴可以阅读 &lt;a href="https://docs.memfiredb.com/base/javascript/select.html"&gt;MemFire Cloud JS 客户端文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在完成以上三个步骤之后，我们调查问卷功能就已经开发完成了。成功收集的问卷数据，我们可以在 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 云平台管理后台中进行查看：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a70610745e2248fa8b5ce00e9755ea65~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;四、总结&lt;/h3&gt;
&lt;p&gt;利用 &lt;a href="https://github.com/JakHuang/form-generator"&gt;form-generator&lt;/a&gt; 表单设计器和 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的简单易用、功能强大的数据存储功能，我快速完成了公司运营妹纸的调查问卷功能，成功逃过加班的 “厄运”。其实后期还可以考虑对这两个工具做进一步的整合，即可以根据表单设计器生成的字段信息，自动创建对应的表结构，同时自动生成客户端 SDK 的调用代码。&lt;/p&gt;
&lt;p&gt;在日常生活中，利用 &lt;a href="https://memfiredb.com/"&gt;MemFire Cloud&lt;/a&gt; 提供的数据库即服务的功能，我们还可以快速开发一些小的工具。比如网页书签收集器，感兴趣的小伙伴可以参考 &lt;a href="https://github.com/d2-projects/d2-daily-chrome-extension"&gt;d2-daily-chrome-extension&lt;/a&gt; 这个项目，只需把 &lt;code&gt;axios&lt;/code&gt; 替换成 &lt;code&gt;@supabase/supabase-js&lt;/code&gt; 客户端，你就可以快速开发一个网页书签收集器的 Chrome 插件。如果你还有其它更好玩的想法，欢迎给我留言哟。&lt;/p&gt;
&lt;h3&gt;五、参考资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.memfiredb.com/base/javascript/installing.html"&gt;MemFire Cloud 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/JakHuang/form-generator"&gt;Github — form-generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/d2-projects/d2-daily-chrome-extension"&gt;Github — d2-daily-chrome-extension&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><author>阿宝哥</author><pubDate>Tue, 09 Nov 2021 20:30:13 GMT</pubDate></item><item><title>推荐 7 个本周 yyds 的开源项目</title><link>https://juejin.cn/post/7126458144833667108</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. Web 是如何工作的？&lt;/p&gt;
&lt;p&gt;2. 发现好教程&lt;/p&gt;
&lt;p&gt;3. FastAPI&lt;/p&gt;
&lt;p&gt;4. 编程大学&lt;/p&gt;
&lt;p&gt;5. 全栈 Web 框架：Remix&lt;/p&gt;
&lt;p&gt;6. 用户身份访问管理&lt;/p&gt;
&lt;p&gt;7. 科技爱好者周刊&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. Web 是如何工作的？&lt;/h3&gt;
&lt;p&gt;当我们在浏览器中输入 www.google.com 后会发生什么事？&lt;/p&gt;
&lt;p&gt;这个开源项目详细的解释了这一操作背后的原理，从计算机网络、服务器响应、解析渲染，把每一个细节都做了解释。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/vasanthk/how-web-works"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bd0208915f84ee9be202cc3e409e10c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 发现好教程&lt;/h3&gt;
&lt;p&gt;这个开源项目搜集了 YouTube 上优质的机器学习教程，方向包括机器学习、深度学习、计算机视觉、自然语言处理、无监督学习等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/dair-ai/ML-YouTube-Courses"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93b3d40887084214bcc4cf3ae87ce5a3~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee85841541b9473dbe3649cd86a01dd2~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. FastAPI&lt;/h3&gt;
&lt;p&gt;FastAPI 框架：一个快速（高性能）的 Web 框架，是最快的 Python 框架之一。这个开源项目有 47.5K 的 Star。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/tiangolo/fastapi"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc59e43c8ecd44d6acdaf84e28aaf833~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 编程大学&lt;/h3&gt;
&lt;p&gt;这个开源项目记录了一个亚马逊的工程师从零到一学习编程的计划，这位开发者每天学习 8 小时，大约进行了 8 个月的学习，如愿以偿的从零到一，拿到了亚马逊的 Offer！&lt;/p&gt;
&lt;p&gt;这是软件工程的学习计划，而不是 Web 开发。谷歌、亚马逊、Facebook 和微软等大型软件公司将软件工程视为与 Web 开发不同。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/jwasham/coding-interview-university"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eb474e42c8c49049d73f1b4f86f6c1d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;05. 全栈 Web 框架：Remix&lt;/h3&gt;
&lt;p&gt;Remix 是一个全栈 Web 框架，可让你专注于用户界面并通过 Web 基础知识进行工作，以提供快速、流畅且有弹性的用户体验，可部署到任何 Node.js 服务器。该开源项目已经斩获 18.1k 的 Star！&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/remix-run/remix"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86c1a7bf66194bc08672569e0afcb0eb~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;06. 用户身份访问管理&lt;/h3&gt;
&lt;p&gt;Logto 是针对登陆的解决方案，通过多平台 SDK 可将应用程序与 Logto 快速集成，可在几分钟内建立用户身份和不错的登录体验。&lt;/p&gt;
&lt;p&gt;该开源项目提供基于 OIDC 的身份服务，支持集成多社交平台登陆，比如 GitHub、谷歌、微信、支付宝等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/logto-io/logto"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b92bd9330fa49a3ad3e8323e86a73e6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;07. 科技爱好者周刊&lt;/h3&gt;
&lt;p&gt;科技爱好者周刊，记录每周值得分享的科技内容，周五发布。本开源项目由 阮一峰 维护，从 2019 年起，已经持续更新两年多。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ruanyf/weekly"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b97bcb3e15344a4a6db41b4978de977~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/p&gt;
&lt;p&gt;https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/910279204e4f480585c35393872946a7~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 31 Jul 2022 00:59:25 GMT</pubDate></item><item><title>粉丝推荐的 GitHub 项目 yyds</title><link>https://juejin.cn/post/7126456742409568269</link><description>&lt;p&gt;本期盘点的开源项目由逛逛 GitHub 的读者投稿，如果你或者所在的组织开源了高质量的项目，希望被更多人看到，你可以关注逛逛 GitHub 后在底部菜单栏找到投稿入口。&lt;/p&gt;
&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 小游戏收集器&lt;/p&gt;
&lt;p&gt;2. 云原生的开源分布式存储系统&lt;/p&gt;
&lt;p&gt;3. 整理常见的国内镜像&lt;/p&gt;
&lt;p&gt;4. 跨平台跨框架 Web 解决方案&lt;/p&gt;
&lt;p&gt;5. 基于Go+Vue实现的openLDAP后台管理项目&lt;/p&gt;
&lt;p&gt;6. 跨平台的文件搜索引擎&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;小游戏收集器&lt;/p&gt;
&lt;p&gt;小游戏收集器，一键解析下载 Flash 和 Unity3D Web 小游戏，支持进度管理，希望能帮助你收集到来自童年的一份快乐。&lt;/p&gt;
&lt;p&gt;开发者 @Cnotech 今年大四，写毕业论文的时候无聊顺手做的小玩具。零零碎碎写了几个月感觉功能已经基本完善，自测也遇不到新的 bug 了，开发者来逛逛 GitHub 投稿希望有更多人看到，最好能帮忙一起完善。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/Cnotech/flash-collector&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aacf50b21be4dc1b62ce64b23c6b935~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;云原生的开源分布式存储系统&lt;/p&gt;
&lt;p&gt;网易开源的分布式存储系统：Curve ，由云原生计算基金会 (CNCF) 作为沙盒项目托管，对标 Ceph 性能缺陷，主打性能，已经有落地用户。本开源项目累计 Star 有 1.3K，由 @opencurve 开源。&lt;/p&gt;
&lt;p&gt;编程语言：C++&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/opencurve/curve&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/003b843cf84f4f46a20ba7d4d6574be1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;整理常见的国内镜像&lt;/p&gt;
&lt;p&gt;由于国内网络原因，下载依赖包或者软件，对于不少互联网从业者来说，都有不小的挑战，时间浪费在这上边，实在可惜。这个项目介绍了常见依赖，软件的国内镜像，助力大家畅爽编码。&lt;/p&gt;
&lt;p&gt;这是一个归纳梳理类的项目，由开发者 @eryajf 创建，整理了常见的包管理工具，软件，系统的国内镜像，以助力运维同学自建企业私服，开发同学直接上手使用。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/eryajf/Thanks-Mirror&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6148b9a307d421d9d53041ac77de75f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;跨平台跨框架 Web 解决方案&lt;/p&gt;
&lt;p&gt;Elux：基于“微模块”和“模型驱动”的跨平台、跨框架同构方案，由开发者 @hiisea 开源。&lt;/p&gt;
&lt;p&gt;用同一个工程模式开发 Web（浏览器页面）SSR（服务器渲染）Micro（微前端）MP（小程序）APP（手机应用），更可以把 Redux 当 vuex 用，也可以把 vuex 当 redux 用。、&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/hiisea/elux&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d249646840c42aa98672e365d1087e5~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;基于Go+Vue实现的openLDAP后台管理项目&lt;/p&gt;
&lt;p&gt;基于 Go + Vue 实现的 openLDAP 后台管理项目。现代化 openLDAP 管理后台，设计简洁，交互简单，助力运维人员快速简单地应用并管理 openLDAP。本项目由开发者 @eryajf 创建。&lt;/p&gt;
&lt;p&gt;支持钉钉，企业微信，飞书的组织架构，以及员工信息自动同步到平台，一座打通 IM 与常见支持 ldap 认证的应用的桥梁。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/eryajf/go-ldap-admin&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a7edc123e9c423fbe84234eeaedb1b0~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;06&lt;/h1&gt;
&lt;p&gt;跨平台的文件搜索引擎&lt;/p&gt;
&lt;p&gt;Orange是一款跨平台的文件搜索引擎。由开发者 @naaive 创建该项目。使用简单，自带中文简繁体分词、拼音、补全、高亮，支持毫秒级搜索响应。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/naaive/orange&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d83af5e3e864259abb5fc67ca8944d6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55de0f41aa26439fb8e11c00628ffbfd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 31 Jul 2022 00:53:55 GMT</pubDate></item><item><title>盘点 6 月 yyds 的开源项目！</title><link>https://juejin.cn/post/7113563869296984078</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. Nginx 可视化神器&lt;/p&gt;
&lt;p&gt;2. Elastic UI 框架&lt;/p&gt;
&lt;p&gt;3. 新一代建站工具&lt;/p&gt;
&lt;p&gt;4. 前端测试工具&lt;/p&gt;
&lt;p&gt;5. 30 天 JavaScript 编程挑战&lt;/p&gt;
&lt;p&gt;6. 使用 Go + HTML + CSS + JS 构建漂亮的跨平台桌面应用&lt;/p&gt;
&lt;p&gt;7. 适用于 Android 的魔法面具&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;Nginx 可视化神器&lt;/p&gt;
&lt;p&gt;一款可以一键生成 Nginx 配置的神器，相当给力。&lt;/p&gt;
&lt;p&gt;先来看看它都支持什么功能的配置：反向代理、HTTPS、HTTP/2、IPv6, 缓存、WordPress、CDN、Node.js 支持、 Python (Django) 服务器等等。&lt;/p&gt;
&lt;p&gt;如果你想在线进行配置，只需要打开网站：https://nginxconfig.io/，按照自己的需求进行操作就行了。选择你的场景，填写好参数，系统就会自动生成配置文件。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/digitalocean/nginxconfig.io&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eabdb2adf5a40cc91ffcaaad0506c37~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;Elastic UI 框架&lt;/p&gt;
&lt;p&gt;Elastic UI 框架是一组 React UI 组件，用于在 Elastic 中快速构建用户界面。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/elastic/eui&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f4b660824ff41deb212f5d5cf6821e6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;新一代建站工具&lt;/p&gt;
&lt;p&gt;VitePress 是 VuePress 的精神继承者，建立在 vite 之上。VitePress 在写博客网站，技术文档，面试题网站等方面，就有着它先天的优势。&lt;/p&gt;
&lt;p&gt;不仅如此，它还有极易上手、构建速度快等优点。目前，它开箱即用，由于正处于 alpha 阶段，配置和 API 可能可能会在次要版本之间发生变化。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/vuejs/vitepress&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c635ce8627d4210b69e464e1c2cd176~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;前端测试工具&lt;/p&gt;
&lt;p&gt;Cypress 可以对在浏览器中运行的任何东西进行快速、简单和可靠的测试。&lt;/p&gt;
&lt;p&gt;Cypress 是为现代网络而构建的下一代前端测试工具，用于解决开发者和 QA 工程师在测试现代应用程序时面临的关键难题。&lt;/p&gt;
&lt;p&gt;Cypress 简化了设置测试、编写测试、运行测试和调试测试，支持端到端测试、集成测试和单元测试，支持测试在浏览器中运行的任意内容。支持 Mac OS、Linux 和 Windows 平台。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/cypress-io/cypress&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbedef26becd4cada5050bb9133546e5~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;30 天 JavaScript 编程挑战&lt;/p&gt;
&lt;p&gt;30 天 JavaScript 编程挑战是在 30 天内学习 JavaScript 编程语言的分步指南。此挑战可能需要100多天，请按照自己的节奏进行。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/Asabeneh/30-Days-Of-JavaScript&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/128f605dc4e7436c9e98250e98d45eaf~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;06&lt;/h1&gt;
&lt;p&gt;构建漂亮的跨平台桌面应用&lt;/p&gt;
&lt;p&gt;使用 Go 和 Web 技术构建桌面应用程序。为 Go 程序提供 Web 界面的传统方法是通过内置 Web 服务器。&lt;/p&gt;
&lt;p&gt;Wails 提供了一种不同的方法：它提供了将 Go 代码和 Web 前端一起打包成单个二进制文件的能力。通过提供的工具，可以很轻松的完成项目的创建、编译和打包。你所要做的就是发挥想象力！&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/wailsapp/wails&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0bb7f1b9ef4f8d99f6649b8fb0ed06~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;07&lt;/h1&gt;
&lt;p&gt;适用于 Android 的魔法面具&lt;/p&gt;
&lt;p&gt;Magisk 是当前 Android 社区用来获取 root 权限的主流方式。同时，Magisk 特殊的运作机制还赋予了它 systemless 的特质。&lt;/p&gt;
&lt;p&gt;systemless 让 Magisk 一方面可以有针对性地隐藏 root，甚至暂时隐藏 Magisk 本身。另一方面，挂载系统的存在，也让 Magisk 拥有了多样的模块化生态系统。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/topjohnwu/Magisk&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b56f8a0af1b44809003afebcaeb0be6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de1c360b7ec448eab4b45b4261103a1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 26 Jun 2022 07:01:45 GMT</pubDate></item><item><title>盘点最近 火火火火 的 GitHub 项目</title><link>https://juejin.cn/post/7111331196948185101</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 文章同步插件&lt;/p&gt;
&lt;p&gt;2. 读书笔记插件&lt;/p&gt;
&lt;p&gt;3. 在线简历排版工具&lt;/p&gt;
&lt;p&gt;4. 表情包生成器&lt;/p&gt;
&lt;p&gt;5. 开源的在线文档&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;文章同步插件&lt;/p&gt;
&lt;p&gt;还在为一次编辑，N 个平台需多次排版上传脑壳疼吧？为广大自媒体朋友撸了个提高生产力的小工具、可以做到的在多个内容平台无缝同步。&lt;/p&gt;
&lt;p&gt;一键同步文章到多个内容平台，支持今日头条、WordPress、知乎、简书、掘金、CSDN、typecho各大平台，一次发布，多平台同步发布。解放个人生产力。&lt;/p&gt;
&lt;p&gt;编程语言：JavaScript&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/wechatsync/Wechatsync&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e55ad130e20c42deab5f6873b8d00158~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;读书笔记插件&lt;/p&gt;
&lt;p&gt;一个还不错的微信读书笔记工具，方便你导出书本标注等内容，对常使用 Markdown 做笔记的用户比较有帮助，可以 一键导出标注、热门标注、书评、想法、目录。&lt;/p&gt;
&lt;p&gt;编程语言：Typescript&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/Higurashi-kagome/wereader&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10f93edbd294c168a03c818e6806826~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;在线简历排版工具&lt;/p&gt;
&lt;p&gt;这是一个支持 Markdown 和富文本的在线简历排版工具，如下图所示，你可以通过 Markdown 语法或者富文本编辑的方式编辑一个美观的简历。&lt;/p&gt;
&lt;p&gt;编程语言：JavaScript&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/mdnice/markdown-resume&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b8afa14f2145d09d1db77103047d9e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;表情包生成器&lt;/p&gt;
&lt;p&gt;Sorry 是一个很有意思的项目，源自"Sorry，有钱事真的能为所欲为" 这梗 … 而这个开源项目是一个可以将自己的梗生成 GIF 的表情包生成器。&lt;/p&gt;
&lt;p&gt;编程语言：CSS &amp;nbsp;HTML&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/xtyxtyx/sorry&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18f551ba07da4d648f1b16aca3b45e68~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;开源的在线文档&lt;/p&gt;
&lt;p&gt;云策文档是一款开源知识管理工具。通过独立的知识库空间，结构化地组织在线协作文档，实现知识的积累与沉淀，促进知识的复用与流通。该项目基于 next.js、nest.js、MySQL 等技术栈。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/fantasticit/think&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba02f55ed58d40f283ba086662bbac2a~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b18eeaef0f85464693178855cdf9a40c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b802bbd5caa4e1eb61ef76a239392ff~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Mon, 20 Jun 2022 06:37:30 GMT</pubDate></item><item><title>Google 有哪些牛逼的开源项目？</title><link>https://juejin.cn/post/7107144360013398029</link><description>&lt;p&gt;本文盘点 Google 开源项目中 Star 最多的 6 个开源项目。@逛逛GitHub 历史还盘点过百度、阿里、腾讯等互联网大厂的开源成果，可以查看历史文章翻阅。&lt;/p&gt;
&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 核心 Java 库&lt;/p&gt;
&lt;p&gt;2. 使用 Node.js 高效编写脚本&lt;/p&gt;
&lt;p&gt;3. 谷歌开源项目风格指南&lt;/p&gt;
&lt;p&gt;4. 高效的 KV 数据库&lt;/p&gt;
&lt;p&gt;5. Python Fire&lt;/p&gt;
&lt;p&gt;6. Gson&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. 核心 Java 库&lt;/h3&gt;
&lt;p&gt;Guava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、图形库以及用于并发、I/O、缓存、字符串等的实用程序！它广泛用于 Google 内部的大多数 Java 项目，也被许多其他公司广泛使用。&lt;/p&gt;
&lt;p&gt;开源项目：https://github.com/google/guava&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bddd492577e4217bf131d459f18f732~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 使用 Node.js 高效编写脚本&lt;/h3&gt;
&lt;p&gt;如果你尝试编写一个在 Node.js 下运行的 Shell 脚本，你可能会发现它并不像你希望的那样流畅。而Google 的 zx 库有助于使用 Node.js 高效且愉快地编写 Shell 脚本。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/zx&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/034a91a8075b4c44b2af25db83ae5788~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. 谷歌开源项目风格指南&lt;/h3&gt;
&lt;p&gt;每个开源项目都有自己的风格指南：一组关于如何为该项目编写代码的约定。当其中的所有代码都采用一致的样式时，理解大型代码库会容易得多。&lt;/p&gt;
&lt;p&gt;“风格”涵盖了很多方面，从“使用驼峰式命名变量名”到“从不使用全局变量”到“从不使用异常”。这个开源项目是一个索引页，可以帮你快速了解 Google 开源项目的风格规范。&lt;/p&gt;
&lt;p&gt;开源地点：https://github.com/google/styleguide&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/463786f1fafb49f8928f3822a05733ba~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 高效的 KV 数据库&lt;/h3&gt;
&lt;p&gt;Leveldb 是一个 Google 实现的非常高效的 KV 数据库，版本 1.2 能够支持 Billion 级别的数据量了。在这个数量级别下还有着非常高的性能，主要归功于它的良好的设计。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/leveldb&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d4261fc6f7544318472abd6b58bca18~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;05. Python Fire&lt;/h3&gt;
&lt;p&gt;Python Fire 是一个 Python 库，只需对 Fire 进行一次调用即可将任何 Python 组件转变为命令行界面。不需要做任何额外的工作，只需要从主模块中调用 fire.Fire()，它会自动将你的代码转化为 CLI，Fire() 的参数可以说任何的 Python 对象。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/python-fire&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4ce913e648c400c8082189d4e256304~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;06. Gson&lt;/h3&gt;
&lt;p&gt;Google Gson 是一个简单的基于 Java 的库，用于将 Java 对象序列化为 JSON，反之亦然。它是由 Google 开发的一个开源库。&lt;/p&gt;
&lt;p&gt;以下几点说明为什么应该使用这个库，Gson是一个由Google管理的标准化库、这是对 Java 标准库的可靠，快速和高效的扩展、Gson 库经过高度优化、它为泛型提供了广泛的支持、它支持具有深度继承层次结构的复杂对象。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/google/gson&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d975d9217394d77833e83cf60860b1f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a80ced5396314208a49057768d881e16~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;</description><author>逛逛GitHub</author><pubDate>Wed, 08 Jun 2022 23:50:27 GMT</pubDate></item><item><title>推荐 4 个视频自动生成器</title><link>https://juejin.cn/post/7106394465580875784</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 编程生成视频的库&lt;/p&gt;
&lt;p&gt;2. 半佛风格视频生成器&lt;/p&gt;
&lt;p&gt;3. 快速高效的生成短视频&lt;/p&gt;
&lt;p&gt;4. 知乎文章转视频乞丐版&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. 编程生成视频的库&lt;/h3&gt;
&lt;p&gt;Remotion 是一套使用编程生成视频的库，为使用 React 以编程方式创建视频奠定了基础。&lt;/p&gt;
&lt;p&gt;有很多方法可以使用编程的方式创建视频，比如：利用网络技术，使用 CSS、Canvas、SVG、WebGL 等，也可以使用变量、函数、API、数学和算法来创造新的效果。但是利用 React，可重用组件、有强大的组合、快速刷新、包含包生态系统。&lt;/p&gt;
&lt;p&gt;开源地址：开源地址：https://github.com/remotion-dev/remotion&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a75cb81cd11d40e181eb9bc6574f122d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 半佛风格视频生成器&lt;/h3&gt;
&lt;p&gt;半佛在 2020 年凭借众多沙雕表情包视频 + 魔性的文案迅速出圈。这个开源项目会爬取半佛的公众号文案，然后进行断句，将文案根据短句分割，每句作为一条字幕，根据字幕搜索表情包并选择设置。&lt;/p&gt;
&lt;p&gt;利用语音合成手段合成配音，直到所有的字幕均完成表情包设定、字幕设定、配音设定，合成视频并加入背景音乐，就能导出成品了。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/WithHades/banfoStyle&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f82ced5799b14bb2b122c4e2b1f73f4f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. 快速高效的生成短视频&lt;/h3&gt;
&lt;p&gt;一种基于 Python 编写的视频自动生成程序。这个小项目实现了文字转视频和音频转视频的功能。&lt;/p&gt;
&lt;p&gt;任意输入或者利用爬虫爬取一段文字语料，首先将其生成音频，然后将这段音频生成视频并添加字幕。音频中可加入各种声效，视频可换任意背景图。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/qihao123/GenVIdeo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7592045accdb4e929964e6418eef33d4~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 知乎文章转视频乞丐版&lt;/h3&gt;
&lt;p&gt;这个开源项目是开发者写的一个小 Demo，实现文字转视频功能。在实现文章转视频需要解决的几个问题：文字分割、文字生成图片、文字转语言等。&lt;/p&gt;
&lt;p&gt;这个开源项目都是使用的比较基础和简单的手段解决这些问题。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/leoython/text-to-video&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b0c3e66bc6402abcccec0a7ff6219c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;历史盘点：https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22f40a9c3a6845dda8b1066ef06d77dc~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Mon, 06 Jun 2022 23:20:14 GMT</pubDate></item><item><title>推荐 8 个 GitHub 开源项目</title><link>https://juejin.cn/post/7106020139799150629</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. App ideas&lt;/p&gt;
&lt;p&gt;2. 中国程序员容易发音错误的单词&lt;/p&gt;
&lt;p&gt;3. 新型冠状病毒数据库&lt;/p&gt;
&lt;p&gt;4. 全新的构建 &amp;nbsp;Web 界面的方法&lt;/p&gt;
&lt;p&gt;5. Vite &amp;amp; Vue 支持的静态站点生成器。&lt;/p&gt;
&lt;p&gt;6. 视频制作机器人&lt;/p&gt;
&lt;p&gt;7. 50 天 50 个项目&lt;/p&gt;
&lt;p&gt;8. 北京买房攻略&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;01&lt;/h1&gt;
&lt;p&gt;App ideas&lt;/p&gt;
&lt;p&gt;这个项目是一个项目列表，该列表会根据开发者的水平提供一些练手项目，帮助你提升编程技巧。&lt;/p&gt;
&lt;p&gt;这个开源项目可以帮助你：提高编程能力;助你尝试新技术;增加你的项目经验。这个列表中提到的小项目，易于完成，易于扩展。&lt;/p&gt;
&lt;p&gt;这不仅是一个简单的列表，每个项目都描述的足够详细，有明确的描述性目标和应当实施的用户故事列表，以方便你从头开始进行开发。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/florinpop17/app-ideas&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c09b5aa66294178958d78ab804f0e2e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;02&lt;/h1&gt;
&lt;p&gt;中国程序员容易发音错误的单词&lt;/p&gt;
&lt;p&gt;本开源项目收集了技术栈相关的容易发音错误的单词。本着简单的原则，又为了避免程序猿们出现选择困难症， '正确音标'采用了最接近有道词典音频的英式 DJ 音标,，不代表其唯一性。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/shimohq/chinese-programmer-wrong-pronunciation&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c91a47a9bf8040ee97876ae229283ecd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;03&lt;/h1&gt;
&lt;p&gt;新型冠状病毒数据库&lt;/p&gt;
&lt;p&gt;这是由约翰霍普金斯大学系统科学与工程中心 (JHU CSSE) 运营的 2019 年新型冠状病毒可视化仪表板的数据存储库。此外，由 ESRI Living Atlas 团队和约翰霍普金斯大学应用物理实验室 (JHU APL) 提供支持。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/CSSEGISandData/COVID-19&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2bd52588a8c4f5d9709374e93579abe~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;04&lt;/h1&gt;
&lt;p&gt;全新的构建 &amp;nbsp;Web 界面的方法&lt;/p&gt;
&lt;p&gt;Svelte 是一种全新的构建用户界面的方法。传统框架如 React 和 Vue 在浏览器中需要做大量的工作，而 Svelte 将这些工作放到构建应用程序的编译阶段来处理。&lt;/p&gt;
&lt;p&gt;与使用虚拟（virtual）DOM 差异对比不同。Svelte 编写的代码在应用程序的状态更改时就能像做外科手术一样更新 DOM。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/sveltejs/svelte&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1b4d99a2c9249808df7ea4469c49004~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;05&lt;/h1&gt;
&lt;p&gt;Vite &amp;amp; Vue 支持的静态站点生成器。&lt;/p&gt;
&lt;p&gt;Vite 和 Vue 支持的静态站点生成器，简单、强大且高性能。满足您一直想要的现代 SSG 框架。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/vuejs/vitepress&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87872f04c67c4fc581d11139c488c002~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cae6d5c5c0904e4f8beaf6091d9b21a8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;06&lt;/h1&gt;
&lt;p&gt;视频制作机器人&lt;/p&gt;
&lt;p&gt;有些在抖音、快手上的视频获得了数百万的观看次数，你仔细分析他们的视频，他们唯一做的原创事情收集材料、然后拼接在一起。尤其是一些新闻类的视频，本开源项目就是把这个过程自动化了。&lt;/p&gt;
&lt;p&gt;你只需要准备好视频材料，就能自动生成一个视频。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/elebumm/RedditVideoMakerBot&lt;/p&gt;
&lt;h1&gt;07&lt;/h1&gt;
&lt;p&gt;50 天 50 个项目&lt;/p&gt;
&lt;p&gt;50 多个使用 HTML、CSS 和 JS 搭建的迷你 Web 项目。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/bradtraversy/50projects50days&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a5b491e50354aefb7b9d222cbba07a0~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h1&gt;08&lt;/h1&gt;
&lt;p&gt;北京买房攻略&lt;/p&gt;
&lt;p&gt;本文总结了北京买房的一些基础知识与经验，由于市场和房贷政策随时间会发生变化，并不保证所有信息的真实有效性，也不构成任何投资建议。&lt;/p&gt;
&lt;p&gt;开源地址：https://github.com/facert/beijing_house_knowledge&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32f2772167b74cc1a8d8da345036547d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10c2258575141029daab7e4ab11ca0e~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 05 Jun 2022 23:08:06 GMT</pubDate></item><item><title>盘点最近 yyds 的开源项目</title><link>https://juejin.cn/post/7104110370645606430</link><description>&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 一个清新文艺的微社区&lt;/p&gt;
&lt;p&gt;2. 30 天学会 React&lt;/p&gt;
&lt;p&gt;3. 零配置 API 样板&lt;/p&gt;
&lt;p&gt;4. 系统设计资源&lt;/p&gt;
&lt;p&gt;5. Wiki 应用程序&lt;/p&gt;
&lt;p&gt;6. 即时通讯项目&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. 一个清新文艺的微社区&lt;/h3&gt;
&lt;p&gt;一个美观清新的微社区开源项目，整套系统使用 Go + Zinc 的架构，前端由 Vue3 构建，采用小清新风格，布局类似 Twitter 的三栏设计。用 Go 写的后端服务运行内存仅 8MB，在单实例 100QPS 时，内存也能稳定在 20MB 左右，资源占用极低。&lt;/p&gt;
&lt;p&gt;全文检索用 Zinc &amp;nbsp;替代了笨重的ElasticSearch，10 万条数据运行内存在 10MB 左右。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/rocboss/paopao-ce"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/295a34338a214bf3bcd5fe73fced4ce6~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44b3016d0fbc4e6584cf15322244058d~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 30 天学会 React&lt;/h3&gt;
&lt;p&gt;这个项目是《30 天 React 挑战》，是在 30 天内学习 React 的分步指南。它需要你学习 React 之前具备 HTML、CSS 和 JavaScript 知识储备。&lt;/p&gt;
&lt;p&gt;除了 30 天学会 React，开发者还发布过 30 天学会 JavaScript 等项目。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Asabeneh/30-Days-Of-React"&gt;开源地址&lt;/a&gt;
&lt;a href="https://github.com/Asabeneh/30-Days-Of-HTML"&gt;开源地址&lt;/a&gt;
&lt;a href="https://github.com/Asabeneh/30-Days-Of-JavaScript"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afee9b85ab3949bf90336d9593f64e67~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. 零配置 API 样板&lt;/h3&gt;
&lt;p&gt;Hydra 是 Laravel Sanctum 的零配置 API 样板，并带有开箱即用的优秀用户和角色管理 API。使用 Hydra 开始您的下一个大型 API 项目，专注于构建业务逻辑，并节省无数时间一次又一次地编写无聊的用户和角色管理 API。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/hasinhayder/hydra"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d03cbaf82aa349e4835fbe8dfa2118ef~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 系统设计资源&lt;/h3&gt;
&lt;p&gt;开源项目收集了网上优秀的系统设计的资源，包括视频处理、集群、消息队列、系统设计、分布式、数据等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/InterviewReady/system-design-resources"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2dc1e20261742f6815bb47665265a6f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;05. Wiki 应用程序&lt;/h3&gt;
&lt;p&gt;这个 14.7 K Star 的开源项目是基于 Node.js 构建的现代且强大的 wiki 应用程序。使用 Wiki.js 漂亮而直观的界面让编写文档成为一种乐趣！&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/requarks/wiki"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44a1de6d640a470889c9ce1ce09a0dcc~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;06. 即时通讯项目&lt;/h3&gt;
&lt;p&gt;由 IM 技术专家打造的基于 Go 实现的即时通讯（IM）项目。从服务端到客户端 SDK 开源即时通讯（IM）整体解决方案，可以轻松替代第三方 IM 云服务，打造具备聊天、社交功能的 App。&lt;/p&gt;
&lt;p&gt;支持 Andorid、iOS 原生开发，支持 Flutter、uni-app 跨端开发，支持小程序、React 等所有主流 web 前端技术框架， PC 支持 Electron，Flutter、iOS、uni-app 已有成熟 demo 可以体验。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/OpenIMSDK/Open-IM-Server"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/100485c8f2df45fc985f8a9e4be6806f~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1520242baac444e3a80d24a75cbaad66~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Tue, 31 May 2022 19:37:54 GMT</pubDate></item><item><title>两天标星 2K Star！程序员人体系统调优指南</title><link>https://juejin.cn/post/7103378856341405726</link><description>&lt;p&gt;这个 repo 火了，两天在 GitHub 获得了 2000 + Star。这个开源项目教你"如何健康学习到 150 岁”，堪称人体系统调优指南。&lt;/p&gt;
&lt;p&gt;睡眠、饮食、心态与动力、学习等方便给出实操建议，开发者将学习 huberman 斯坦福教师的课程做了详细笔记，形成了这么一篇调优指南。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c30da7f085f943bba1a3d5c6e41dcec7~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;huberman 是斯坦福的神经学教授，看完他的课程感觉像调优软件程序那样来“调优”我们自身的人体系统是有可能的。老逛就将指南中比能落地的部分摘要一下。想弄清楚原因的可以去原文看一看。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;开源项目：HumanSystemOptimization&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;教授网站：https://hubermanlab.com/&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;睡眠&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 起床后应该到外面去接触阳光，持续 2-10 分钟&lt;/p&gt;
&lt;p&gt;2.&amp;nbsp;在晚上要尽量减少光源的接触&lt;/p&gt;
&lt;p&gt;3. 午睡可以缓解一天中的精神状态的低谷&lt;/p&gt;
&lt;p&gt;4. 建议的锻炼时间：醒来后 30 分钟，3 小时和 11 小时这三个时间点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;饮食&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&amp;nbsp;间歇性禁食状态对于身体有非常多的好处&lt;/p&gt;
&lt;p&gt;2.&amp;nbsp;何时进食，与吃什么东西，其实是同等重要的&lt;/p&gt;
&lt;p&gt;3. 起床后至少 1 小时内不要吃东西，同时睡前的 2-3 小时不要吃任何东西。&lt;/p&gt;
&lt;p&gt;4.&amp;nbsp;最理想的进食窗口是 8 小时，保证这个窗口时间的稳定性&lt;/p&gt;
&lt;p&gt;5.&amp;nbsp;摄入发酵类食品有好处&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;心态与动力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;了解人体的多巴胺系统原理，帮助你调节心态和情绪。&lt;/p&gt;
&lt;p&gt;1.&amp;nbsp;当你持续做一件喜欢的事情时，你感受到快乐的阈值也会不断提高&lt;/p&gt;
&lt;p&gt;2.&amp;nbsp;半夜睡不着刷手机是很有害的&lt;/p&gt;
&lt;p&gt;3.&amp;nbsp;间歇性且随机的奖励机制&lt;/p&gt;
&lt;p&gt;4.&amp;nbsp;通过自我暗示，把努力过程本身当作一种“奖励”&lt;/p&gt;
&lt;p&gt;4. 影响多巴胺释放的各类因素&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7352795fd2d946d5b9958b5d6bd12f27~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习与专注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 犯错是我们进入学习状态的重要前提&lt;/p&gt;
&lt;p&gt;2. 心流是一种精神高度集中且接近于自动化的状态，是在做我们已经知道怎么做的事情，而不是在学习新的知识技能。推荐一本书《心流》&lt;/p&gt;
&lt;p&gt;3. 成年人对于小幅度的增量学习是完全可以适应与掌握的&lt;/p&gt;
&lt;p&gt;4. 尽可能广泛的学习各种知识和技能&lt;/p&gt;
&lt;p&gt;4.&amp;nbsp;就是让你的身体有一些“新颖的重力体验”，如倒立，瑜伽，体操，滑板，任何让身体会失去平衡的一些状态等，会快速激发“我犯错了”的信号，进入学习状态，甚至可以在之后去做别的任务的学习&lt;/p&gt;
&lt;p&gt;5.&amp;nbsp;不能太放松以至于有些昏昏欲睡，也不能太紧张激动，无法控制自己拥有清晰的思考&lt;/p&gt;
&lt;p&gt;6. 减少睡眠对长期的学习与记忆效果可能并没有提升作用&lt;/p&gt;
&lt;p&gt;7.&amp;nbsp;限制视野范围，能够提升专注度&lt;/p&gt;
&lt;p&gt;8. 视线往下看会让神经系统偏向镇静，放松，甚至困倦，而视线向上则会让系统提升警惕。工作时一般至少把显示器放置在鼻子位置之上。&lt;/p&gt;
&lt;p&gt;9.&amp;nbsp;17 分钟的冥想，能够对大脑中的神经元做重新连接，永久地改善注意力&lt;/p&gt;
&lt;p&gt;10.&amp;nbsp;对大脑直接帮助最大的是有氧运动&lt;/p&gt;
&lt;p&gt;历史盘点&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：Awesome-GitHub-Repo&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd329a1149f340338a9812a800760a2c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect"&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect"&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect"&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; &lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect"&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;</description><author>逛逛GitHub</author><pubDate>Sun, 29 May 2022 20:20:01 GMT</pubDate></item><item><title>盘点 6 个开源的音乐播放器！</title><link>https://juejin.cn/post/7098919562975903775</link><description>&lt;p&gt;盘点几个开源的音乐播放器，在这些项目中你可以学习到 React、Vue、Kotlin等相关的技术栈。有的是仿当前比较火的音乐应用，而有的是开发者自主开发。&lt;/p&gt;
&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;
&lt;p&gt;1. 仿 QQ 音乐&lt;/p&gt;
&lt;p&gt;2. 网易云音乐&lt;/p&gt;
&lt;p&gt;3. Material 主题音乐播放器&lt;/p&gt;
&lt;p&gt;4. 不太现代的音乐播放器&lt;/p&gt;
&lt;p&gt;5. 专注于免费流媒体资源的桌面音乐播放器&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;01. 仿 QQ 音乐&lt;/h3&gt;
&lt;p&gt;模仿 QQ 音乐网页版界面，采用 flexbox 和 position 布局，支持响应式。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/maomao1996/Vue-mmPlayer"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f664eb72ecfb483b88b16698df0e4068~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;02. 网易云音乐&lt;/h3&gt;
&lt;p&gt;基于 React 的在线音乐播放器，这个开源项目是高仿移动端安卓的网易云音乐。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/maomao1996/react-music"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c808bfea3994db09ce381ed00fe69e8~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;03. Material 主题音乐播放器&lt;/h3&gt;
&lt;p&gt;Material 主题音乐播放器，适用于手机端、穿戴设备端、汽车端等。该项目基于最新的开发工具和设计模式构建，用 Kotlin 编写、Android 架构组件、数据绑定等等。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/naman14/TimberX"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25bd59e0009d4ccabf3d5fe30e2cd77b~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86e3ac78655348bcae8738bc7785769c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff4aded2c0b6432a91b2af3d328299f1~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;04. 不太现代的音乐播放器&lt;/h3&gt;
&lt;p&gt;Clementine 是适用于 Windows、Linux 和 macOS 的现代音乐播放器和库管理器。虽然开发者标榜现代，但是看了它的 UI，发觉没那么现代。&lt;/p&gt;
&lt;p&gt;它的灵感来源于 Amarok 1.4, 致力于开发一个易于使用的界面，令你能够快速地搜索和播放音乐。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/clementine-player/Clementine"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c635d87922a447ad82c1088226cf93fd~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;h3&gt;05. 专注于免费流媒体资源的桌面音乐播放器&lt;/h3&gt;
&lt;p&gt;nuclear 是一个从互联网的各个角落拉取免费的资源的免费流媒体播放器。&lt;/p&gt;
&lt;p&gt;如果你知道 mps-youtube 这个项目,该项目与之类似，但是我们提供了一个美观、强大的图形用户界面。nuclear 更加的专注于音频。想象一下Spotify，你无须为音乐付费，而且你比Spotify有更多的音库来源的选择。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nukeop/nuclear"&gt;开源地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5346034c90864a5d9fcc1cf51385c63c~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;p&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo"&gt;历史盘点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23c5c07805964910bfc5dcf5e4cc1b80~tplv-k3u1fbpfcp-zoom-1.image" /&gt;&lt;/p&gt;
&lt;hr /&gt;</description><author>逛逛GitHub</author><pubDate>Tue, 17 May 2022 19:54:17 GMT</pubDate></item></channel></rss>